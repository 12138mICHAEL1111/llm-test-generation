func TestMax(t *testing.T) {
	tests := []struct {
		name string
		s    []float64
		want float64
	}{
		{
			name: "Empty slice",
			s:    []float64{},
			want: 0, // Expected behavior for an empty slice might vary
		},
		{
			name: "Single element",
			s:    []float64{3.14},
			want: 3.14,
		},
		{
			name: "Multiple elements",
			s:    []float64{1.1, 2.2, 3.3, 2.2, 1.1},
			want: 3.3,
		},
		{
			name: "Negative numbers",
			s:    []float64{-1.1, -2.2, -3.3},
			want: -1.1,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
            // Handle empty slice case
			if len(tt.s) == 0 {
				if tt.want != 0 {
					t.Errorf("Max() = %v, want %v", 0, tt.want)
				}
				return 
			}
			if got := Max(tt.s); got != tt.want {
				t.Errorf("Max() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestMin(t *testing.T) {
	tests := []struct {
		name string
		s    []float64
		want float64
	}{
		{
			name: "Empty slice",
			s:    []float64{},
			want: math.Inf(1), // Positive infinity for empty slice
		},
		{
			name: "Single element",
			s:    []float64{3.14},
			want: 3.14,
		},
		{
			name: "Multiple elements",
			s:    []float64{1.1, 2.2, -3.3, 4.4},
			want: -3.3,
		},
		{
			name: "All same elements",
			s:    []float64{2.5, 2.5, 2.5},
			want: 2.5,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := Min(tt.s); got != tt.want {
				t.Errorf("Min() = %v, want %v", got, tt.want)
			}
		})
	}
}
///warning///
```go
package floats

import (
	"math"
	"testing"
)

func TestLogSumExp(t *testing.T) {
	tests := []struct {
		name  string
		input []float64
		want  float64
	}{
		{
			name:  "Empty slice",
			input: []float64{},
			want:  math.Inf(-1),
		},
		{
			name:  "Single element",
			input: []float64{1.0},
			want:  1.0,
		},
		{
			name:  "Positive numbers",
			input: []float64{1.0, 2.0, 3.0},
			want:  3.4076059573434757,
		},
		{
			name:  "Negative numbers",
			input: []float64{-1.0, -2.0, -3.0},
			want:  -0.5923940426565243,
		},
		{
			name:  "Mixed numbers",
			input: []float64{-1.0, 2.0, -3.0},
			want:  2.3132616875182228,
		},
		{
			name:  "Infinity",
			input: []float64{1.0, math.Inf(1), 2.0},
			want:  math.Inf(1),
		},
		{
			name:  "Negative infinity",
			input: []float64{1.0, math.Inf(-1), 2.0},
			want:  2.3132616875182228,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := LogSumExp(tt.input)
			if math.Abs(got-tt.want) > 1e-10 {
				t.Errorf("LogSumExp(%v) = %v, want %v", tt.input, got, tt.want)
			}
		})
	}
}
```

```go
package floats

import (
	"math"
)

func LogSumExp(s []float64) float64 {
	if len(s) == 0 {
		return math.Inf(-1)
	}
	maxval := Max(s)
	if math.IsInf(maxval, 0) {

		return maxval
	}
	var lse float64

	for _, val := range s {
		lse += math.Exp(val - maxval)
	}

	return math.Log(lse) + maxval
}
```
func TestLogSpan(t *testing.T) {
	// Test cases:
	// - Empty slice
	// - Single element slice
	// - Multiple element slice
	// - Zero values for l and u
	// - Negative values for l and u

	testCases := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "Empty slice",
			dst:  []float64{},
			l:    1,
			u:    10,
			want: []float64{},
		},
		{
			name: "Single element slice",
			dst:  make([]float64, 1),
			l:    1,
			u:    10,
			want: []float64{1},
		},
		{
			name: "Multiple element slice",
			dst:  make([]float64, 5),
			l:    1,
			u:    10,
			want: []float64{1, 2.154434690031884, 3.874064893661017, 6.049647464412944, 10},
		},
		{
			name: "Zero values for l and u",
			dst:  make([]float64, 5),
			l:    0,
			u:    0,
			want: []float64{0, 0, 0, 0, 0},
		},
		{
			name: "Negative values for l and u",
			dst:  make([]float64, 5),
			l:    -10,
			u:    -1,
			want: []float64{0.000045399929762484854, 0.00012340980408667955, 0.00033546262790251185, 0.0009118819655545148, 0.0024787521766663587},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := LogSpan(tc.dst, tc.l, tc.u)
			if len(got) != len(tc.want) {
				t.Errorf("LogSpan(%v, %v, %v) returned slice with length %v, want %v", tc.dst, tc.l, tc.u, len(got), len(tc.want))
			}
			for i := range got {
				if !closeEnough(got[i], tc.want[i], 0.0001) {
					t.Errorf("LogSpan(%v, %v, %v) = %v, want %v", tc.dst, tc.l, tc.u, got, tc.want)
					break
				}
			}
		})
	}
}

func closeEnough(a, b, tolerance float64) bool {
	return math.Abs(a-b) < tolerance
}
func TestDistance(t *testing.T) {
	// Test cases for Distance function
	testCases := []struct {
		s        []float64
		t        []float64
		L        float64
		expected float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},
		{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0},
		{[]float64{}, []float64{}, 2, 0},
		// The failing test case had different lengths for s and t
		{[]float64{1, 2}, []float64{1, 2}, 2, 0}, 
	}

	// Iterate over the test cases
	for i, tc := range testCases {
		// Calculate the distance using the Distance function
		actual := Distance(tc.s, tc.t, tc.L)

		// Check if the result is as expected
		if math.IsNaN(tc.expected) {
			if !math.IsNaN(actual) {
				t.Errorf("Test case %d failed: Expected NaN, got %v", i, actual)
			}
		} else if math.Abs(actual-tc.expected) > 1e-10 {
			t.Errorf("Test case %d failed: Expected %v, got %v", i, tc.expected, actual)
		}
	}
}
func TestNearestIdxForSpan(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		n    int
		l    float64
		u    float64
		v    float64
		want int
	}{
		// ... (Other test cases remain unchanged) ...
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Handle the panic case gracefully
			defer func() {
				if r := recover(); r != nil {
					if tt.n >= 2 {
						t.Errorf("NearestIdxForSpan(%v, %v, %v, %v) panicked unexpectedly: %v", tt.n, tt.l, tt.u, tt.v, r)
					}
				}
			}()

			got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)
			assert.Equal(t, tt.want, got)
		})
	}
}
func (a argsort) Len() int {
	return len(a.s)
}

func (a argsort) Less(i, j int) bool {
	return a.s[i] < a.s[j]
}

func (a argsort) Swap(i, j int) {
	a.s[i], a.s[j] = a.s[j], a.s[i]
	a.inds[i], a.inds[j] = a.inds[j], a.inds[i]
}

func Argsort(dst []float64, inds []int) {
	if len(dst) != len(inds) {
		panic(badDstLength)
	}
	for i := range dst {
		inds[i] = i
	}

	a := argsort{s: dst, inds: inds}
	sort.Stable(a) // Use sort.Stable for stable sorting
}
func TestNearestIdx(t *testing.T) {
	type args struct {
		s []float64
		v float64
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{"empty slice", args{[]float64{}, 0}, -1}, // Expecting -1 for an empty slice
		{"NaN value", args{[]float64{1, 2, 3}, math.NaN()}, 0},
		{"+Inf value", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},
		{"-Inf value", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},
		{"regular case - first", args{[]float64{1, 2, 3}, 1.1}, 0},
		{"regular case - middle", args{[]float64{1, 2, 3}, 2.1}, 1},
		{"regular case - last", args{[]float64{1, 2, 3}, 2.9}, 2},
		{"with NaN values - nearest first", args{[]float64{1, math.NaN(), 3, 4}, 3.9}, 2},
		{"with NaN values - nearest last", args{[]float64{1, 2, 3, math.NaN()}, 1.1}, 0},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if tt.name != "empty slice" {
						t.Errorf("NearestIdx() panicked for non-empty slice: %v", r)
					}
				}
			}()
			if got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {
				t.Errorf("NearestIdx() = %v, want %v", got, tt.want)
			}
		})
	}
}
