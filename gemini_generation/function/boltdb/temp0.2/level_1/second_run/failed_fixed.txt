func TestDB_View(t *testing.T) {
	db, err := bolt.Open("my.db", 0600, nil)
	if err != nil {
		t.Fatal(err)
	}
	defer db.Close()

	t.Run("Successful View", func(t *testing.T) {
		err = db.View(func(tx *bolt.Tx) error {
			// Only perform read-only operations within the View transaction
			_, err := tx.Bucket([]byte("mybucket")) // Retrieve a bucket - read-only
			if err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			t.Errorf("View should not return an error, got: %v", err)
		}
	})

	t.Run("View with Error", func(t *testing.T) {
		err = db.View(func(tx *bolt.Tx) error {
			// Simulate an error within the transaction
			return errors.New("intentional error")
		})
		if err == nil {
			t.Error("View should return an error")
		}
	})
}
func TestStats_Sub(t *testing.T) {
	// Test cases
	testCases := []struct {
		name   string
		s      bolt.Stats
		other  *bolt.Stats
		expect bolt.Stats
	}{
		// ... (other test cases)
		{
			"Subtracting with some matching values",
			bolt.Stats{FreePageN: 1, PendingPageN: 2, FreeAlloc: 3, FreelistInuse: 4, TxN: 5, TxStats: bolt.TxStats{PageCount: 10}},
			&bolt.Stats{FreePageN: 1, FreeAlloc: 3, TxN: 2, TxStats: bolt.TxStats{PageCount: 5}},
			bolt.Stats{FreePageN: 0, PendingPageN: 2, FreeAlloc: 0, FreelistInuse: 4, TxN: 3, TxStats: bolt.TxStats{PageCount: 5}},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := tc.s.Sub(tc.other)
			if result.FreePageN != tc.expect.FreePageN ||
				result.PendingPageN != tc.expect.PendingPageN ||
				result.FreeAlloc != tc.expect.FreeAlloc ||
				result.FreelistInuse != tc.expect.FreelistInuse ||
				result.TxN != tc.expect.TxN ||
				result.TxStats.PageCount != tc.expect.TxStats.PageCount {

				t.Errorf("Expected %v, got %v", tc.expect, result)
			}
		})
	}
}
func TestDB_Stats(t *testing.T) {
	// Open a new in-memory database.
	db, err := bolt.Open("test.db", 0600, nil)
	if err != nil {
		t.Fatal(err)
	}
	defer db.Close()

	// Get the initial stats.
	initialStats := db.Stats()

	// Perform a write operation to modify the database.
	err = db.Update(func(tx *bolt.Tx) error {
		bucket, err := tx.CreateBucketIfNotExists([]byte("myBucket"))
		if err != nil {
			return err
		}
		return bucket.Put([]byte("myKey"), []byte("myValue"))
	})
	if err != nil {
		t.Fatal(err)
	}

	// Get the updated stats.
	updatedStats := db.Stats()

	// Assert that the stats have changed as expected.
	if reflect.DeepEqual(initialStats, updatedStats) {
		t.Error("Stats did not change after database operations")
	}
}
func TestDB_IsReadOnly(t *testing.T) {
	t.Run("Read-only database", func(t *testing.T) {
		db, err := bolt.Open("test_readonly.db", 0600, &bolt.Options{ReadOnly: true})
		if err != nil {
			t.Fatal(err)
		}
		defer os.Remove("test_readonly.db") // Cleanup
		defer db.Close()

		if !db.IsReadOnly() {
			t.Error("Expected database to be read-only")
		}
	})

	t.Run("Read-write database", func(t *testing.T) {
		db, err := bolt.Open("test_readwrite.db", 0600, nil)
		if err != nil {
			t.Fatal(err)
		}
		defer os.Remove("test_readwrite.db") // Cleanup
		defer db.Close()

		if db.IsReadOnly() {
			t.Error("Expected database to be read-write")
		}
	})
}
func TestOpen(t *testing.T) {
	t.Run("open existing database", func(t *testing.T) {
		path := "test.db"
		f, err := os.Create(path)
		if err != nil {
			t.Fatal(err)
		}
		f.Close()
		defer os.Remove(path)

		db, err := bolt.Open(path, 0600, nil)
		if err != nil {
			t.Fatal(err)
		}
		// Close the database immediately as we're just testing opening
		if err := db.Close(); err != nil {
			t.Error("expected database to be open and close successfully")
		}
	})

	t.Run("create new database", func(t *testing.T) {
		path := "test.db"
		defer os.Remove(path)

		db, err := bolt.Open(path, 0600, nil)
		if err != nil {
			t.Fatal(err)
		}
		// Close the database immediately as we're just testing opening
		if err := db.Close(); err != nil {
			t.Error("expected database to be open and close successfully")
		}
	})

	t.Run("open with read only mode", func(t *testing.T) {
		path := "test.db"
		f, err := os.Create(path)
		if err != nil {
			t.Fatal(err)
		}
		f.Close()
		defer os.Remove(path)

		db, err := bolt.Open(path, 0600, &bolt.Options{ReadOnly: true})
		if err != nil {
			t.Fatal(err)
		}

		// Try to perform a write operation, which should fail in read-only mode
		err = db.Update(func(tx *bolt.Tx) error {
			_, err := tx.CreateBucket([]byte("test"))
			return err
		})
		if !errors.Is(err, bolt.ErrDatabaseReadOnly) {
			t.Error("expected read-only database to return ErrDatabaseReadOnly on write")
		}

		// Close the database after the write attempt
		if err := db.Close(); err != nil {
			t.Error("error closing database:", err)
		}
	})
}
func TestBoltDB_Batch(t *testing.T) {
	path := "my.db"
	db, err := bolt.Open(path, 0600, nil)
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(path)
	defer db.Close()

	// Create the bucket before running the batch operations
	db.Update(func(tx *bolt.Tx) error {
		_, err := tx.CreateBucketIfNotExists([]byte("MyBucket"))
		return err
	})

	// Test case 1: Batch operations within MaxBatchSize
	t.Run("Batch within MaxBatchSize", func(t *testing.T) {
		db.MaxBatchSize = 3
		db.MaxBatchDelay = 1 * time.Second

		err := db.Batch(func(tx *bolt.Tx) error {
			return tx.Bucket([]byte("MyBucket")).Put([]byte("key1"), []byte("value1"))
		})
		if err != nil {
			t.Fatal(err)
		}

		err = db.Batch(func(tx *bolt.Tx) error {
			return tx.Bucket([]byte("MyBucket")).Put([]byte("key2"), []byte("value2"))
		})
		if err != nil {
			t.Fatal(err)
		}

		// Sleep to allow batch to execute
		time.Sleep(100 * time.Millisecond)

		err = db.View(func(tx *bolt.Tx) error {
			v := tx.Bucket([]byte("MyBucket")).Get([]byte("key1"))
			if string(v) != "value1" {
				return fmt.Errorf("unexpected value: %s", v)
			}
			v = tx.Bucket([]byte("MyBucket")).Get([]byte("key2"))
			if string(v) != "value2" {
				return fmt.Errorf("unexpected value: %s", v)
			}
			return nil
		})
		if err != nil {
			t.Fatal(err)
		}
	})

	// ... (rest of the test cases)
}
