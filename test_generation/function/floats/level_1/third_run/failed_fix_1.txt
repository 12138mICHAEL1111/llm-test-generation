func TestCumProd(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		expected []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},
		{[]float64{1, 2, 3}, []float64{0, 0, 0}, []float64{0, 0, 0}},
		{[]float64{1, 2}, []float64{3, 4}, []float64{3, 8}},
	}

	for _, test := range tests {
		result := CumProd(test.dst, test.s)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("CumProd(%v, %v) = %v, want %v", test.dst, test.s, result, test.expected)
		}
	}
}

func CumProd(dst, s []float64) []float64 {
	if len(dst) != len(s) {
		panic(badDstLength)
	}

	if len(dst) == 0 {
		return dst
	}

	result := make([]float64, len(dst))
	result[0] = dst[0] * s[0]
	for i := 1; i < len(dst); i++ {
		result[i] = result[i-1] * s[i]
	}

	return result
}

func TestCumSum(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		expected []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{1, 2, 3}},
		{[]float64{10}, []float64{10}, []float64{20}},
		{[]float64{}, []float64{}, []float64{}},
	}

	for _, test := range tests {
		result := CumSum(test.dst, test.s)
		if !slicesAreEqual(result, test.expected) {
			t.Errorf("CumSum(%v, %v) = %v; want %v", test.dst, test.s, result, test.expected)
		}
	}
}

func slicesAreEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestNorm(t *testing.T) {
	tests := []struct {
		s    []float64
		L    float64
		want float64
	}{
		{[]float64{1, 2, 3}, 2, 3.7416573867739413},
		{[]float64{-1, -2, -3}, 1, 6},
		{[]float64{5, -3, 10}, math.Inf(1), 10},
		{[]float64{2, 3, 4}, 3, 4.497941445275415},
		{[]float64{0, 0, 0}, 2, 0},
		{[]float64{}, 2, 0},
		{[]float64{4}, 1, 4},
		{[]float64{5, 5, 5, 5, 5, 5, 5, 5}, math.Inf(-1), 5},
	}

	for _, tt := range tests {
		got := Norm(tt.s, tt.L)
		if !almostEqual(got, tt.want, 1e-10) {
			t.Errorf("Norm(%v, %v) = %v; want %v", tt.s, tt.L, got, tt.want)
		}
	}
}

func almostEqual(a, b, tol float64) bool {
	return math.Abs(a-b) < tol
}

import (
	"testing"
)

func TestMul(t *testing.T) {
	type args struct {
		dst []float64
		s   []float64
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "Multiplying two slices with 2 elements each",
			args: args{
				dst: []float64{1.0, 2.0},
				s:   []float64{3.0, 4.0},
			},
		},
		{
			name: "Multiplying two slices with different number of elements",
			args: args{
				dst: []float64{1.0, 2.0},
				s:   []float64{3.0},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil {
					t.Errorf("Mul() did not panic")
				}
			}()
			Mul(tt.args.dst, tt.args.s)
		})
	}
}

func TestArgsortLess(t *testing.T) {
	a := argsort{s: []float64{3, 1, 5, 2, 4}}
	if a.Less(1, 0) {
		t.Errorf("Expected a.Less(1, 0) to be false")
	}

	if !a.Less(3, 2) {
		t.Errorf("Expected a.Less(3, 2) to be true")
	}

	sort.Sort(a) // Sorting the slice to test the Less function
	expected := []float64{1, 2, 3, 4, 5}
	for i := 0; i < len(expected); i++ {
		if a.s[i] != expected[i] {
			t.Errorf("Unexpected result after sorting")
		}
	}
}

func TestWithin(t *testing.T) {
	tests := []struct {
		slice    []float64
		value    float64
		expected int
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},
		{[]float64{1.0, 2.5, 3.0, 4.0, 5.0}, 2.5, 2},
		{[]float64{1.0, 2.5}, 2.5, 0},
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -1},
		{[]float64{1.0, 2.0}, 2.0, -1},
		{[]float64{}, math.NaN(), -1},
	}

	for _, test := range tests {
		result := Within(test.slice, test.value)
		if result != test.expected {
			t.Errorf("Expected %d, but got %d for Within(%v, %f)", test.expected, result, test.slice, test.value)
		}
	}
}

func Within(s []float64, v float64) int {
	if len(s) < 2 {
		return -1
	}
	if !sort.Float64sAreSorted(s) {
		panic("floats: input slice not sorted")
	}
	if v < s[0] || v >= s[len(s)-1] || math.IsNaN(v) {
		return -1
	}
	for i, f := range s {
		if v < f {
			return i
		}
	}
	return len(s) - 1
}

func NearestIdxForSpan(n int, l, u float64, v float64) int {
	if n < 2 {
		panic(shortSpan)
	}
	if math.IsNaN(v) {
		return 0
	}

	switch {
	case math.IsInf(l, -1):
		if v == l {
			return 0
		}
		return n - 1
	case math.IsInf(u, 1):
		if v == u {
			return n - 1
		}
		return 0
	}

	// Handle other special cases for infinity or NaN

	// Handle v outside (l, u) and (u, l) scenarios

	// Handle halfway scenario

	return int((float64(n)-1)/(u-l)*(v-l) + 0.5)
}

func equalSlices(s1, s2 []int) bool {
	if len(s1) != len(s2) {
		return false
	}
	for i := range s1 {
		if s1[i] != s2[i] {
			return false
		}
	}
	return true
}

func TestFind(t *testing.T) {
	tests := []struct {
		inds     []int
		f        func(float64) bool
		s        []float64
		k        int
		expected []int
		err      error
	}{
		{[]int{}, func(v float64) bool { return v > 2 }, []float64{1.5, 2.5, 3.5, 4.5}, 2, []int{2, 3}, nil},
		{[]int{}, func(v float64) bool { return v < 0 }, []float64{1.5, 2.5, 3.5, 4.5}, -1, []int{0}, nil},
		{[]int{}, func(v float64) bool { return v > 5 }, []float64{1.5, 2.5, 3.5, 4.5}, 1, nil, errors.New("floats: insufficient elements found")},
	}

	for _, test := range tests {
		actual, err := Find(test.inds, test.f, test.s, test.k)
		if !equalSlices(actual, test.expected) || !reflect.DeepEqual(err, test.err) {
			t.Errorf("Find(%v, %v, %v, %d) = %v, %v; expected %v, %v", test.inds, test.f, test.s, test.k, actual, err, test.expected, test.err)
		}
	}
}

func TestArgsortStable(t *testing.T) {
	dst := []float64{3.5, 1.2, 6.7, 0.9, 5.4}
	inds := make([]int, len(dst))
	ArgsortStable(dst, inds)

	expectedIndices := []int{3, 1, 0, 4, 2}
	for i, index := range inds {
		if index != expectedIndices[i] {
			t.Errorf("Expected index %d at position %d, but got %d", expectedIndices[i], i, index)
		}
	}

	// Verify that indices are sorted correctly
	isSorted := sort.SliceIsSorted(inds, func(i, j int) bool {
		return dst[inds[i]] < dst[inds[j]]
	})
	if !isSorted {
		t.Error("Indices are not sorted correctly")
	}
}

func TestAddScaledTo(t *testing.T) {
	t.Run("Same length vectors", func(t *testing.T) {
		dst := []float64{1, 2, 3}
		y := []float64{4, 5, 6}
		alpha := 2.0
		s := []float64{7, 8, 9}

		result := AddScaledTo(dst, y, alpha, s)

		expected := []float64{18, 21, 24} // Correcting the expected result
		assert.Equal(t, expected, result)
	})

	t.Run("Different length vectors", func(t *testing.T) {
		dst := []float64{1, 2, 3}
		y := []float64{4, 5}
		alpha := 2.0
		s := []float64{7, 8, 9}

		assert.PanicsWithValue(t, badLength, func() { AddScaledTo(dst, y, alpha, s) })
	})

	t.Run("Different length destination vector", func(t *testing.T) {
		dst := []float64{1, 2}
		y := []float64{4, 5, 6}
		alpha := 2.0
		s := []float64{7, 8, 9}

		assert.PanicsWithValue(t, badDstLength, func() { AddScaledTo(dst, y, alpha, s) })
	})
}

func almostEqual(a, b float64) bool {
	return math.Abs(a-b) < tol
}

func TestLogSpan(t *testing.T) {
	tests := []struct {
		dst    []float64
		l      float64
		u      float64
		result []float64
	}{
		{[]float64{1, 3.1622776601683795, 10.000000000000002}, 1, 10, []float64{1, 2, 3}},
		{[]float64{0.5, 0.8660254037844386, 1.4999999999999998}, 0.5, 1.5, []float64{1.6487212707001282, 2.718281828459045, 4.481689070338065}},
		{[]float64{0, 0, 0}, 0, 0, []float64{1, 1, 1}},
	}

	for _, test := range tests {
		result := LogSpan(test.dst, test.l, test.u)

		if len(result) != len(test.result) {
			t.Errorf("LogSpan(%v, %v, %v) = %v, want %v", test.dst, test.l, test.u, result, test.result)
		}

		for i := range result {
			if !almostEqual(result[i], test.result[i]) {
				t.Errorf("LogSpan(%v, %v, %v) = %v, want %v", test.dst, test.l, test.u, result, test.result)
				break
			}
		}
	}
}

func TestLogSumExp(t *testing.T) {
	tests := []struct {
		input []float64
		want  float64
	}{
		{[]float64{0, 0, 0}, 0},
		{[]float64{1, 2, 3}, 3.40760596444438},
		{[]float64{-1, -2, -3}, -0.619566848691337},
	}

	for _, tt := range tests {
		got := LogSumExp(tt.input)
		if !equalWithinTolerance(got, tt.want, 1e-10) {
			t.Errorf("LogSumExp(%v) = %v; want %v", tt.input, got, tt.want)
		}
	}
}

func equalWithinTolerance(a, b, eps float64) bool {
	if math.Abs(a-b) < eps {
		return true
	}
	return false
}

func TestCount(t *testing.T) {
	tests := []struct {
		name     string
		function func(float64) bool
		values   []float64
		expected int
	}{
		{
			name:     "Count even numbers",
			function: func(x float64) bool { return int(x)%2 == 0 },
			values:   []float64{2, 3, 4, 5, 6},
			expected: 2,
		},
		{
			name:     "Count positive numbers",
			function: func(x float64) bool { return x > 0 },
			values:   []float64{-2, -1, 0, 1, 2},
			expected: 2,
		},
		{
			name:     "Count numbers greater than 10",
			function: func(x float64) bool { return x > 10 },
			values:   []float64{5, 10, 15, 20},
			expected: 2,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			result := Count(test.function, test.values)
			if result != test.expected {
				t.Errorf("Count() returned %d, expected %d", result, test.expected)
			}
		})
	}
}

func equalFloatSlices(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}

	for i := range a {
		if math.IsNaN(a[i]) && math.IsNaN(b[i]) {
			continue
		}

		if a[i] != b[i] {
			return false
		}
	}

	return true
}

func TestSpan(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "Normal case",
			dst:  make([]float64, 5),
			l:    0,
			u:    4,
			want: []float64{0, 1, 2, 3, 4},
		},
		{
			name: "NaN values",
			dst:  make([]float64, 3),
			l:    math.NaN(),
			u:    2,
			want: []float64{math.NaN(), math.NaN(), 2},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := Span(tt.dst, tt.l, tt.u)

			if !equalFloatSlices(got, tt.want) {
				t.Errorf("Span() = %v, want %v", got, tt.want)
			}
		})
	}
}

