func TestLogSpan(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "normal case",
			dst:  make([]float64, 5),
			l:    1,
			u:    10000,
			want: []float64{1, 10, 100, 1000, 10000},
		},
		{
			name: "edge case with zeros",
			dst:  make([]float64, 5),
			l:    0,
			u:    10,
			want: []float64{0, 0, 0, 0, 0},
		},
		{
			name: "edge case with negatives",
			dst:  make([]float64, 5),
			l:    -10,
			u:    -1,
			want: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := LogSpan(tt.dst, tt.l, tt.u)
			for i := range got {
				if math.Abs(got[i]-tt.want[i]) > epsilon {
					t.Errorf("LogSpan() = %v, want %v", got, tt.want)
					break
				}
			}
		})
	}
}
func TestWithin(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		value    float64
		expected int
	}{
		{
			name:     "value within the provided slice",
			input:    []float64{1, 3, 5, 7, 9},
			value:    4,
			expected: 2,
		},
		{
			name:     "value outside the provided slice",
			input:    []float64{1, 3, 5, 7, 9},
			value:    10,
			expected: -1,
		},
		{
			name:     "empty slice",
			input:    []float64{},
			value:    4,
			expected: -1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					// Test for expected panic
					if r != "floats: input slice not sorted" && r != shortSpan {
						t.Errorf("Unexpected panic: %v", r)
					}
				}
			}()

			result := Within(tt.input, tt.value)

			if result != tt.expected {
				t.Errorf("Expected index %d, but got %d for value %f in slice %v", tt.expected, result, tt.value, tt.input)
			}
		})
	}

	// Additional tests for special cases like NaN
	t.Run("NaN value", func(t *testing.T) {
		input := []float64{1, 3, 5, 7, 9}
		value := math.NaN()
		expected := -1

		result := Within(input, value)

		if result != expected {
			t.Errorf("Expected index %d, but got %d for value NaN in slice %v", expected, result, input)
		}
	})
}
func TestDistance(t *testing.T) {
	tests := []struct {
		name     string
		s        []float64
		t        []float64
		L        float64
		expected float64
	}{
		{"Case 1: L2 norm", []float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152},
		{"Case 2: L1 norm", []float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},
		{"Case 3: Inf norm", []float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},
		{"Case 4: L3 norm", []float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.301927},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Distance(tt.s, tt.t, tt.L)
			if !almostEqual(result, tt.expected, 1e-6) {
				t.Errorf("Distance(%v, %v, %v) = %v; want %v", tt.s, tt.t, tt.L, result, tt.expected)
			}
		})
	}

}

func almostEqual(a, b, epsilon float64) bool {
	return math.Abs(a-b) < epsilon
}
func TestLogSumExp(t *testing.T) {
	tests := []struct {
		name   string
		input  []float64
		output float64
	}{
		{name: "Test Case 1", input: []float64{1.0, 2.0, 3.0}, output: 3.4076059644443803},
		{name: "Test Case 2", input: []float64{-1.0, 0.0, 1.0}, output: 1.3132616875182228},
		{name: "Test Case 3", input: []float64{0.0}, output: 0.0},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := LogSumExp(tc.input)
			if !floatEquals(result, tc.output, 1e-10) {
				t.Errorf("Expected %v, but got %v", tc.output, result)
			}
		})
	}
}

func floatEquals(a, b, eps float64) bool {
	return math.Abs(a-b) < eps
}

func TestLogSumExpEmptySlice(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic when it should have")
		}
	}()

	LogSumExp([]float64{})
}
func TestNearestIdxForSpan(t *testing.T) {
	tests := []struct {
		n    int
		l, u float64
		v    float64
		want int
	}{
		{3, 1.000000, 0.000000, 2.000000, 1},
		{5, 3.000000, 1.000000, 5.000000, 2},
		{10, 5.000000, 1.000000, 10.000000, 5},
		{4, 0.000000, 2.000000, 2.000000, 1},
	}

	for _, test := range tests {
		got := NearestIdxForSpan(test.n, test.l, test.u, test.v)
		if got != test.want {
			t.Errorf("NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d", test.n, test.l, test.u, test.v, got, test.want)
		}
	}
}
func TestSubTo(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		t        []float64
		expected []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},
		{[]float64{1, 2}, []float64{3, 4}, []float64{1, 2, 3}, nil}, // Should panic due to different lengths
	}

	for _, test := range tests {
		if test.expected == nil {
			func() {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("SubTo did not panic for unequal lengths")
					}
				}()
				SubTo(test.dst, test.s, test.t)
			}()
		} else {
			result := SubTo(test.dst, test.s, test.t)
			if !reflect.DeepEqual(result, test.expected) {
				t.Errorf("SubTo(%v, %v, %v) returned %v, expected %v", test.dst, test.s, test.t, result, test.expected)
			}
		}
	}
}
func TestDot(t *testing.T) {
	tests := []struct {
		name   string
		slice1 []float64
		slice2 []float64
		want   float64
	}{
		{"Same length slices", []float64{1, 2, 3}, []float64{4, 5, 6}, 32},
		{"Different length slices", []float64{1, 2}, []float64{4, 5, 6}, -1},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil && tt.want != -1 {
					t.Errorf("The code did not panic")
				}
			}()

			got := Dot(tt.slice1, tt.slice2)
			if got != tt.want {
				t.Errorf("Got %v, want %v", got, tt.want)
			}
		})
	}
}
func TestAddScaledTo(t *testing.T) {
	tests := []struct {
		dst     []float64
		y       []float64
		alpha   float64
		s       []float64
		want    []float64
		wantErr bool
	}{
		{ // Test case 1: successful addition
			dst:     []float64{0, 0, 0},
			y:       []float64{4, 5, 6},
			alpha:   2,
			s:       []float64{7, 8, 9},
			want:    []float64{15, 18, 21},
			wantErr: false,
		},
		{ // Test case 2: y and s slices are of different lengths
			dst:     []float64{1, 2, 3},
			y:       []float64{4, 5},
			alpha:   2,
			s:       []float64{7, 8, 9},
			want:    []float64{},
			wantErr: true,
		},
		{ // Test case 3: dst and y slices are of different lengths
			dst:     []float64{1, 2},
			y:       []float64{4, 5, 6},
			alpha:   2,
			s:       []float64{7, 8, 9},
			want:    []float64{},
			wantErr: true,
		},
	}

	for _, tc := range tests {
		t.Run("", func(t *testing.T) {
			defer func() {
				r := recover()
				if (r != nil && !tc.wantErr) || (r == nil && tc.wantErr) {
					t.Errorf("Expected panic=%v, but got panic=%v", tc.wantErr, r)
				}
			}()

			got := AddScaledTo(tc.dst, tc.y, tc.alpha, tc.s)

			if !tc.wantErr {
				for i := range tc.want {
					if got[i] != tc.want[i] {
						t.Errorf("AddScaledTo(%v, %v, %v, %v)=%v; want %v", tc.dst, tc.y, tc.alpha, tc.s, got, tc.want)
						break
					}
				}
			}
		})
	}
}
func TestEqualApprox(t *testing.T) {
	slice1 := []float64{1.0, 2.0, 3.0}
	slice2 := []float64{1.01, 2.02, 3.03}

	tolerance := 0.1
	assert.True(t, EqualApprox(slice1, slice2, tolerance))
  
	slice3 := []float64{1.0, 2.0, 3.0}
	slice4 := []float64{1.1, 2.2, 3.3}

	assert.False(t, EqualApprox(slice3, slice4, tolerance))

	slice5 := []float64{1.0, 2.0}
	slice6 := []float64{1.01, 2.02}

	assert.False(t, EqualApprox(slice5, slice6, tolerance))
}
func MinIdx(s []float64) int {
	if len(s) == 0 {
		panic(zeroLength)
	}

	min := math.NaN()
	var ind int
	nanFlag := false

	for i, v := range s {
		if math.IsNaN(v) {
			if !nanFlag {
				ind = i
				nanFlag = true
			}
			continue
		}

		if math.IsNaN(min) || v < min {
			min = v
			ind = i
		}
		
	}

	return ind
}
