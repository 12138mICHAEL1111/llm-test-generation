func TestAdd(t *testing.T) {
	tests := []struct {
		dst    []float64
		s      []float64
		result []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},
		{[]float64{10, 20, 30}, []float64{1, 2, 3}, []float64{11, 22, 33}},
	}

	for _, test := range tests {
		Add(test.dst, test.s)
		for i := 0; i < len(test.dst); i++ {
			if test.dst[i] != test.result[i] {
				t.Errorf("For dst %v and s %v, expected %v but got %v", test.dst, test.s, test.result, test.dst)
			}
		}
	}

	// Test for panic when lengths do not match
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("Add did not panic when lengths do not match")
		}
	}()
	Add([]float64{1, 2}, []float64{4, 5, 6})
}

func TestAddTo(t *testing.T) {
	type args struct {
		dst []float64
		s   []float64
		t   []float64
	}
	tests := []struct {
		name string
		args args
		want []float64
	}{
		{
			name: "AddTo test case 1",
			args: args{
				dst: []float64{1.0, 2.0, 3.0},
				s:   []float64{4.0, 5.0, 6.0},
				t:   []float64{7.0, 8.0, 9.0},
			},
			want: []float64{11.0, 13.0, 15.0},
		},
		// Add more test cases as needed
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("AddTo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAddConst(t *testing.T) {
	tests := []struct {
		name   string
		c      float64
		dst    []float64
		result []float64
	}{
		{"Test case 1", 5.0, []float64{1.0, 2.0, 3.0}, []float64{6.0, 7.0, 8.0}},
		{"Test case 2", -2.0, []float64{4.0, 5.0, 6.0}, []float64{2.0, 3.0, 4.0}},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			AddConst(test.c, test.dst)
			assert.Equal(t, test.result, test.dst)
		})
	}
}

func TestAddScaled(t *testing.T) {
	tests := []struct {
		dst    []float64
		alpha  float64
		s      []float64
		result []float64
	}{
		{
			dst:    []float64{1, 2, 3},
			alpha:  2,
			s:      []float64{4, 5, 6},
			result: []float64{9, 12, 15},
		},
		{
			dst:    []float64{1, 2, 3},
			alpha:  0,
			s:      []float64{4, 5, 6},
			result: []float64{1, 2, 3},
		},
		// add more test cases as needed
	}

	for _, test := range tests {
		actualResult := make([]float64, len(test.dst))
		copy(actualResult, test.dst)
		
		AddScaled(actualResult, test.alpha, test.s)
		
		if !floatSlicesEqual(actualResult, test.result) {
			t.Errorf("Expected %v but got %v", test.result, actualResult)
		}
	}
}

func floatSlicesEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestAddScaledTo(t *testing.T) {
	tests := []struct {
		dst     []float64
		y       []float64
		alpha   float64
		s       []float64
		want    []float64
		wantErr bool
	}{
		{ // Test case 1: successful addition
			dst:     []float64{1, 2, 3},
			y:       []float64{4, 5, 6},
			alpha:   2,
			s:       []float64{7, 8, 9},
			want:    []float64{15, 18, 21},
			wantErr: false,
		},
		{ // Test case 2: y and s slices are of different lengths
			dst:     []float64{1, 2, 3},
			y:       []float64{4, 5},
			alpha:   2,
			s:       []float64{7, 8, 9},
			want:    []float64{},
			wantErr: true,
		},
		{ // Test case 3: dst and y slices are of different lengths
			dst:     []float64{1, 2},
			y:       []float64{4, 5, 6},
			alpha:   2,
			s:       []float64{7, 8, 9},
			want:    []float64{},
			wantErr: true,
		},
	}

	for _, tc := range tests {
		t.Run("", func(t *testing.T) {
			defer func() {
				r := recover()
				if (r != nil && !tc.wantErr) || (r == nil && tc.wantErr) {
					t.Errorf("Expected panic=%v, but got panic=%v", tc.wantErr, r)
				}
			}()

			got := AddScaledTo(tc.dst, tc.y, tc.alpha, tc.s)

			if !tc.wantErr {
				for i := range tc.want {
					if got[i] != tc.want[i] {
						t.Errorf("AddScaledTo(%v, %v, %v, %v)=%v; want %v", tc.dst, tc.y, tc.alpha, tc.s, got, tc.want)
						break
					}
				}
			}
		})
	}
}

func TestArgsort_Len(t *testing.T) {
	t.Run("Test with non-empty array", func(t *testing.T) {
		arr := []int{3, 1, 4, 1, 5, 9, 2, 6}
		argsort := argsort{arr}

		actual := argsort.Len()
		expected := len(arr)

		if actual != expected {
			t.Errorf("Length of argsort array is incorrect, got: %d, want: %d", actual, expected)
		}
	})

	t.Run("Test with empty array", func(t *testing.T) {
		arr := []int{}
		argsort := argsort{arr}

		actual := argsort.Len()
		expected := len(arr)

		if actual != expected {
			t.Errorf("Length of argsort array is incorrect, got: %d, want: %d", actual, expected)
		}
	})
}

func TestLess(t *testing.T) {
	a := argsort{s: []int{3, 1, 2}}
	result := a.Less(0, 1)
	if result != false {
		t.Errorf("Expected false but got %v", result)
	}

	result = a.Less(1, 2)
	if result != true {
		t.Errorf("Expected true but got %v", result)
	}
}

func (a argsort) Less(i, j int) bool {
	return a.s[i] < a.s[j]
}

func (a argsort) Swap(i, j int) {
	a.s[i], a.s[j] = a.s[j], a.s[i]
}

func (a argsort) Len() int {
	return len(a.s)
}

func TestArgsort_Swap(t *testing.T) {
	a := argsort{
		s:    []int{1, 2, 3, 4, 5},
		inds: []int{0, 1, 2, 3, 4},
	}

	a.Swap(1, 3)

	expectedS := []int{1, 4, 3, 2, 5}
	expectedInds := []int{0, 3, 2, 1, 4}

	if !reflect.DeepEqual(a.s, expectedS) {
		t.Errorf("Expected s to be %v, but got %v", expectedS, a.s)
	}

	if !reflect.DeepEqual(a.inds, expectedInds) {
		t.Errorf("Expected inds to be %v, but got %v", expectedInds, a.inds)
	}
}

func TestArgsort(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		inds []int
	}{
		{
			name: "Test sorting float64 slice",
			dst:  []float64{3.5, 1.2, 4.7, 2.1},
			inds: []int{0, 1, 2, 3},
		},
		{
			name: "Test sorting float64 slice with negative numbers",
			dst:  []float64{-2.5, 1.8, -4.2, 5.6},
			inds: []int{0, 1, 2, 3},
		},
		{
			name: "Test sorting empty float64 slice",
			dst:  []float64{},
			inds: []int{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			origDst := make([]float64, len(tt.dst))
			copy(origDst, tt.dst)
			origInds := make([]int, len(tt.inds))
			copy(origInds, tt.inds)

			Argsort(tt.dst, tt.inds)

			// Check if dst is sorted
			for i := 0; i < len(tt.dst)-1; i++ {
				if tt.dst[i] > tt.dst[i+1] {
					t.Errorf("Failed to sort dst slice")
				}
			}

			// Check if original elements match sorted elements
			for i := 0; i < len(tt.dst); i++ {
				if tt.dst[i] != origDst[tt.inds[i]] {
					t.Errorf("Failed to track original order")
				}
			}

			// Check if inds are shuffled
			for i := 0; i < len(tt.inds); i++ {
				if tt.inds[i] != origInds[i] {
					return
				}
			}
		})
	}
}

func TestArgsortStable(t *testing.T) {
	dst := []float64{3.2, 1.5, 4.8, 2.1}
	inds := make([]int, len(dst))
	ArgsortStable(dst, inds)

	expectedDst := []float64{1.5, 2.1, 3.2, 4.8}
	expectedInds := []int{1, 3, 0, 2}

	for i := range dst {
		if dst[i] != expectedDst[i] || inds[i] != expectedInds[i] {
			t.Errorf("Expected dst[%d] to be %f with ind %d but got %f with ind %d", i, expectedDst[i], expectedInds[i], dst[i], inds[i])
		}
	}
}

func (a argsort) Len() int {
	return len(a.s)
}

func (a argsort) Less(i, j int) bool {
	return a.s[i] < a.s[j]
}

func (a argsort) Swap(i, j int) {
	a.s[i], a.s[j] = a.s[j], a.s[i]
	a.inds[i], a.inds[j] = a.inds[j], a.inds[i]
}

func TestCount(t *testing.T) {
	tests := []struct {
		name     string
		f        func(float64) bool
		s        []float64
		expected int
	}{
		{
			name: "count positive numbers",
			f: func(x float64) bool {
				return x > 0
			},
			s:        []float64{1.0, -2.0, 3.0, -4.0, 5.0},
			expected: 3,
		},
		{
			name: "count even numbers",
			f: func(x float64) bool {
				return int(x)%2 == 0
			},
			s:        []float64{2.0, 3.0, 4.0, 5.0, 6.0},
			expected: 3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Count(tt.f, tt.s)
			if result != tt.expected {
				t.Errorf("Count() returned %d, expected %d", result, tt.expected)
			}
		})
	}
}

func TestCumProd(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		s        []float64
		expected []float64
	}{
		{
			name:     "Test case 1",
			dst:      []float64{1, 2, 3, 4},
			s:        []float64{1, 2, 3, 4},
			expected: []float64{1, 2, 6, 24},
		},
		{
			name:     "Test case 2",
			dst:      []float64{1, 2, 3},
			s:        []float64{1, 2, 3, 4},
			expected: nil, // panic expected due to length mismatch
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil && tt.expected == nil {
					t.Errorf("expected panic, but got nil")
				}
			}()

			actual := CumProd(tt.dst, tt.s)

			if !reflect.DeepEqual(actual, tt.expected) {
				t.Errorf("CumProd() = %v, want %v", actual, tt.expected)
			}
		})
	}
}

func TestCumSum(t *testing.T) {
	tests := []struct {
		dst []float64
		s   []float64
		want []float64
	}{
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{1, 3, 6}},
		{[]float64{}, []float64{}, []float64{}},
	}

	for _, tt := range tests {
		t.Run("", func(t *testing.T) {
			got := CumSum(tt.dst, tt.s)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("CumSum(%v, %v) = %v; want %v", tt.dst, tt.s, got, tt.want)
			}
		})
	}
}

func TestDistance(t *testing.T) {
	tests := []struct {
		name     string
		s        []float64
		t        []float64
		L        float64
		expected float64
	}{
		{"Case 1: L2 norm", []float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152},
		{"Case 2: L1 norm", []float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},
		{"Case 3: Inf norm", []float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},
		{"Case 4: L3 norm", []float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.301927},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Distance(tt.s, tt.t, tt.L)
			if result != tt.expected {
				t.Errorf("Distance(%v, %v, %v) = %v; want %v", tt.s, tt.t, tt.L, result, tt.expected)
			}
		})
	}

}

func TestDiv(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		expected []float64
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, []float64{1.0, 1.0, 1.0}},
		{[]float64{4.0, 5.0, 6.0}, []float64{2.0, 1.0, 3.0}, []float64{2.0, 5.0, 2.0}},
	}

	for _, test := range tests {
		Div(test.dst, test.s)

		if !floatSlicesAreEqual(test.dst, test.expected) {
			t.Errorf("Div failed, expected: %v, got: %v", test.expected, test.dst)
		}
	}
}

func floatSlicesAreEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func TestDivTo(t *testing.T) {
	tests := []struct {
		dst []float64
		s   []float64
		t   []float64
	}{
		{[]float64{2, 4, 6}, []float64{4, 8, 12}, []float64{2, 2, 2}},
		{[]float64{1, 2, 3}, []float64{3, 6, 9}, []float64{3, 3, 3}},
	}
	
	for _, test := range tests {
		dst := make([]float64, len(test.s))
		DivTo(dst, test.s, test.t)

		for i := 0; i < len(dst); i++ {
			expected := test.s[i] / test.t[i]
			if math.Abs(dst[i]-expected) > 1e-9 || math.IsNaN(dst[i]) {
				t.Errorf("DivTo failed at index %d, got: %v, want: %v", i, dst[i], expected)
			}
		}
	}

	// Test for panic with bad lengths
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("DivTo did not panic with bad lengths")
		}
	}()
	
	DivTo(make([]float64, 2), []float64{1, 2}, []float64{3})
}

func TestDot(t *testing.T) {
	tests := []struct {
		name   string
		slice1 []float64
		slice2 []float64
		want   float64
	}{
		{"Same length slices", []float64{1, 2, 3}, []float64{4, 5, 6}, 32},
		{"Different length slices", []float64{1, 2}, []float64{4, 5, 6}, -1},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil {
					t.Errorf("The code did not panic")
				}
			}()

			got := Dot(tt.slice1, tt.slice2)
			if got != tt.want {
				t.Errorf("Got %v, want %v", got, tt.want)
			}
		})
	}
}

func TestEqual(t *testing.T) {
	tests := []struct {
		s1 []float64
		s2 []float64
		want bool
	}{
		{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},
		{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},
		{[]float64{1, 2}, []float64{1, 2, 3}, false},
		{[]float64{}, []float64{}, true},
	}

	for _, tt := range tests {
		got := Equal(tt.s1, tt.s2)
		if got != tt.want {
			t.Errorf("Equal(%v, %v) = %v; want %v", tt.s1, tt.s2, got, tt.want)
		}
	}
}

func TestEqualApprox(t *testing.T) {
	slice1 := []float64{1.0, 2.0, 3.0}
	slice2 := []float64{1.01, 2.02, 3.03}

	tolerance := 0.1
	assert.True(t, EqualApprox(slice1, slice2, tolerance))

	slice3 := []float64{1.0, 2.0, 3.0}
	slice4 := []float64{1.1, 2.2, 3.3}

	assert.False(t, EqualApprox(slice3, slice4, tolerance))

	slice5 := []float64{1.0, 2.0}
	slice6 := []float64{1.01, 2.02, 3.03}

	assert.False(t, EqualApprox(slice5, slice6, tolerance))
}

func TestEqualFunc(t *testing.T) {
	tests := []struct {
		slice1 []float64
		slice2 []float64
		expected bool
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.1}, false},
		{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},
	}

	for _, test := range tests {
		result := EqualFunc(test.slice1, test.slice2, func(a, b float64) bool {
			return a == b
		})
		if result != test.expected {
			t.Errorf("For %v and %v expected %t, but got %t", test.slice1, test.slice2, test.expected, result)
		}
	}
}

func TestEqualLengths(t *testing.T) {
	tests := []struct {
		name   string
		slices [][]float64
		want   bool
	}{
		{
			name:   "all slices have equal length",
			slices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
			want:   true,
		},
		{
			name:   "some slices have different lengths",
			slices: [][]float64{{1, 2, 3}, {4, 5, 6, 7}, {8, 9}},
			want:   false,
		},
		{
			name:   "empty slices",
			slices: [][]float64{},
			want:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := EqualLengths(tt.slices...)
			if got != tt.want {
				t.Errorf("EqualLengths() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFind(t *testing.T) {
	// Test case 1: k = -1
	inds, err := Find(nil, func(val float64) bool { return val > 5 }, []float64{1, 6, 2, 7, 9}, -1)
	expected := []int{1, 3, 4}
	if err != nil {
		t.Errorf("Expected error to be nil, got: %v", err)
	}
	if !reflect.DeepEqual(inds, expected) {
		t.Errorf("Expected indices to be %v, got: %v", expected, inds)
	}

	// Test case 2: k = 2
	inds, err = Find(nil, func(val float64) bool { return val < 5 }, []float64{1, 6, 2, 7, 9}, 2)
	expected = []int{0, 2}
	if err != nil {
		t.Errorf("Expected error to be nil, got: %v", err)
	}
	if !reflect.DeepEqual(inds, expected) {
		t.Errorf("Expected indices to be %v, got: %v", expected, inds)
	}

	// Test case 3: k = 4 (not enough elements satisfying f)
	inds, err = Find(nil, func(val float64) bool { return val < 5 }, []float64{6, 7, 8, 9}, 4)
	expectedErr := "floats: insufficient elements found"
	if err == nil {
		t.Error("Expected error, got nil")
	}
	if err.Error() != expectedErr {
		t.Errorf("Expected error message to be '%s', got: %v", expectedErr, err)
	}
}

func TestHasNaN(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected bool
	}{
		{"no NaN values", []float64{1.0, 2.0, 3.0}, false},
		{"NaN value present", []float64{1.0, math.NaN(), 3.0}, true},
		{"all NaN values", []float64{math.NaN(), math.NaN(), math.NaN()}, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := HasNaN(tt.input)
			if result != tt.expected {
				t.Errorf("Expected HasNaN(%v) to be %v, but got %v", tt.input, tt.expected, result)
			}
		})
	}
}

func TestLogSpan(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "normal case",
			dst:  make([]float64, 5),
			l:    1,
			u:    100,
			want: []float64{1, 10, 100, 1000, 10000},
		},
		{
			name: "edge case with zeros",
			dst:  make([]float64, 5),
			l:    0,
			u:    10,
			want: []float64{0, 0, 0, 0, 0},
		},
		{
			name: "edge case with negatives",
			dst:  make([]float64, 5),
			l:    -10,
			u:    -1,
			want: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := LogSpan(tt.dst, tt.l, tt.u)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("LogSpan() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestLogSumExp(t *testing.T) {
	tests := []struct {
		name   string
		input  []float64
		output float64
	}{
		{name: "Test Case 1", input: []float64{1.0, 2.0, 3.0}, output: 3.4076059644443803},
		{name: "Test Case 2", input: []float64{-1.0, 0.0, 1.0}, output: 1.3132616875182228},
		{name: "Test Case 3", input: []float64{0.0}, output: 0.0},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := LogSumExp(tc.input)
			if !floatEquals(result, tc.output, 1e-10) {
				t.Errorf("Expected %v, but got %v", tc.output, result)
			}
		})
	}
}

func floatEquals(a, b, eps float64) bool {
	return math.Abs(a-b) < eps
} 

func TestLogSumExpEmptySlice(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic when it should have")
		}
	}()

	LogSumExp([]float64{})
}

func TestMax(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4, 5}, 5},
		{[]float64{10, 20, 30, 40, 50}, 50},
		{[]float64{4.5, 6.7, 8.9, 2.3}, 8.9},
		{[]float64{}, 0}, // This test case will check for panic
	}

	for _, test := range tests {
		func() {
			defer func() {
				if recover() != nil {
					return
				}
			}()
			result := Max(test.input)
			if result != test.expected {
				t.Errorf("Expected %f but got %f for input %v", test.expected, result, test.input)
			}
		}()
	}
}

func TestMaxIdx(t *testing.T) {
	tests := []struct {
		input []float64
		want  int
	}{
		{[]float64{1, 2, 3, 4, 3}, 3},
		{[]float64{0, 0, 0, 0, 0}, 0},
		{[]float64{10, 5, 8, 10, 5}, 0},
		{[]float64{7, 3, 5, 8, 1}, 3},
	}

	for _, test := range tests {
		got := MaxIdx(test.input)
		if got != test.want {
			t.Errorf("MaxIdx(%v) = %d; want %d", test.input, got, test.want)
		}
	}
}

func TestMaxIdxPanic(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic as expected")
		}
	}()

	MaxIdx([]float64{})
}

func TestMin(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4, 5}, 1},
		{[]float64{2.5, 3.7, 1.2, 4.5}, 1.2},
		{[]float64{5, 4, 3, 2, 1}, 1},
	}
	
	for _, test := range tests {
		result := Min(test.input)
		if result != test.expected {
			t.Errorf("Min(%v) = %v; want %v", test.input, result, test.expected)
		}
	}
}

func TestMinEmptySlice(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("Min did not panic for empty slice")
		}
	}()

	Min([]float64{})
}

func TestMinIdx(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected int
	}{
		{"Normal case", []float64{3.0, 1.0, 5.0, 2.0, 4.0}, 1},
		{"No minimum value", []float64{6.0, 8.0, 10.0, 4.0}, 3},
		{"Empty slice", []float64{}, -1},
		{"NaN values", []float64{math.NaN(), math.NaN(), 5.0, 2.0, 4.0}, 2},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := MinIdx(tt.input)
			if got != tt.expected {
				t.Errorf("MinIdx(%v) = %v, want %v", tt.input, got, tt.expected)
			}
		})
	}
}

func TestMul(t *testing.T) {
	tests := []struct {
		dst, s, want []float64
	}{
		{
			dst:  []float64{1, 2, 3},
			s:    []float64{4, 5, 6},
			want: []float64{4, 10, 18},
		},
		{
			dst:  []float64{1, 2, 3},
			s:    []float64{4, 5},
			want: []float64{}, // should panic
		},
	}

	for _, tc := range tests {
		defer func() {
			if r := recover(); r == nil && len(tc.want) == 0 {
				t.Errorf("expected a panic, but got none")
			}
		}()

		Mul(tc.dst, tc.s)

		if !float64SlicesAreEqual(tc.dst, tc.want) {
			t.Errorf("Mul(%v, %v) = %v, want %v", tc.dst, tc.s, tc.dst, tc.want)
		}
	}
}

func float64SlicesAreEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestMulTo(t *testing.T) {
	tests := []struct {
		dst []float64
		s   []float64
		t   []float64
	}{
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}},
		{[]float64{0, 0, 0, 0}, []float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}},
	}

	for _, test := range tests {
		result := MulTo(test.dst, test.s, test.t)

		if !reflect.DeepEqual(result, test.dst) {
			t.Errorf("Expected %v but got %v", test.dst, result)
		}
	}
}

func TestNearestIdx(t *testing.T) {
	tests := []struct {
		name           string
		s              []float64
		v              float64
		expectedOutput int
	}{
		{
			name:           "Test case 1",
			s:              []float64{1, 2, 3, 4, 5},
			v:              3.2,
			expectedOutput: 2,
		},
		{
			name:           "Test case 2",
			s:              []float64{1.2, 2.4, 3.6, 4.8, 5.9},
			v:              6.0,
			expectedOutput: 4,
		},
		{
			name:           "Test case 3",
			s:              []float64{5, 4, 3, 2, 1},
			v:              2.5,
			expectedOutput: 3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output := NearestIdx(tt.s, tt.v)
			if output != tt.expectedOutput {
				t.Errorf("Expected: %d, Got: %d", tt.expectedOutput, output)
			}
		})
	}
}

func TestNearestIdxForSpan(t *testing.T) {
	tests := []struct {
		n, v      int
		l, u, want float64
	}{
		{3, 1, 0, 2, 1},
		{5, 3, 1, 5, 2},
		{10, 5, 1, 10, 5},
		{4, 0, 0, 2, 0},
	}

	for _, test := range tests {
		got := NearestIdxForSpan(test.n, test.l, test.u, test.v)
		if got != test.want {
			t.Errorf("NearestIdxForSpan(%d, %f, %f, %f) = %d; want %f", test.n, test.l, test.u, test.v, got, test.want)
		}
	}
}

func TestNorm(t *testing.T) {
	tests := []struct {
		name     string
		s        []float64
		L        float64
		expected float64
	}{
		{"L2 norm", []float64{1, 2, 3}, 2, 3.7416573867739413},
		{"L1 norm", []float64{1, 2, 3}, 1, 6},
		{"Infinity norm", []float64{1, -5, 3}, math.Inf(1), 5},
		{"Zero norm", []float64{}, 2, 0}, // Add test cases as needed
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual := Norm(test.s, test.L)
			if actual != test.expected {
				t.Errorf("Expected norm value: %v, but got: %v", test.expected, actual)
			}
		})
	}
}

func TestProd(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4}, 24},
		{[]float64{0, 2, 3}, 0},
		{[]float64{}, 1},
	}

	for _, tt := range tests {
		result := Prod(tt.input)
		if result != tt.expected {
			t.Errorf("Prod(%v) = %v, want %v", tt.input, result, tt.expected)
		}
	}
}

func TestReverse(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected []float64
	}{
		{
			name:     "Reverse order of elements in slice",
			input:    []float64{1.0, 2.0, 3.0, 4.0},
			expected: []float64{4.0, 3.0, 2.0, 1.0},
		},
		{
			name:     "Empty slice",
			input:    []float64{},
			expected: []float64{},
		},
		{
			name:     "Single element slice",
			input:    []float64{1.0},
			expected: []float64{1.0},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			Reverse(test.input)
			if !reflect.DeepEqual(test.input, test.expected) {
				t.Errorf("Expected %v, but got %v", test.expected, test.input)
			}
		})
	}
}

func TestSame(t *testing.T) {
	tests := []struct {
		s      []float64
		t      []float64
		result bool
	}{
		{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},
		{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},
		{[]float64{1, math.NaN(), 3}, []float64{1, math.NaN(), 3}, true},
		{[]float64{1, math.NaN(), 3}, []float64{1, 2, 3}, false},
	}

	for _, test := range tests {
		if res := Same(test.s, test.t); res != test.result {
			t.Errorf("Expected Same(%v, %v) to be %t, but got %t", test.s, test.t, test.result, res)
		}
	}
}

func TestScale(t *testing.T) {
	tests := []struct {
		c      float64
		dst    []float64
		result []float64
	}{
		{2.0, []float64{1.0, 2.0, 3.0}, []float64{2.0, 4.0, 6.0}},
		{0.5, []float64{4.0, 5.0, 6.0}, []float64{2.0, 2.5, 3.0}},
		{3.0, []float64{0.5, 1.5, 2.5}, []float64{1.5, 4.5, 7.5}},
		{1.0, []float64{}, []float64{}},
	}

	for _, test := range tests {
		Scale(test.c, test.dst)
		if !reflect.DeepEqual(test.dst, test.result) {
			t.Errorf("Expected %v but got %v", test.result, test.dst)
		}
	}
}

func TestScaleTo(t *testing.T) {
	// Test case 1: Equal length slices
	dst := []float64{1.0, 2.0, 3.0}
	c := 2.0
	s := []float64{4.0, 5.0, 6.0}

	expected := []float64{8.0, 10.0, 12.0}
	result := ScaleTo(dst, c, s)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v but got %v", expected, result)
	}

	// Test case 2: Unequal length slices
	dst = []float64{1.0, 2.0}
	c = 3.0
	s = []float64{4.0, 5.0, 6.0}

	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic")
		}
	}()

	ScaleTo(dst, c, s)
}

func TestSpan(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "Test Case 1",
			dst:  []float64{0, 0},
			l:    0,
			u:    10,
			want: []float64{0, 10},
		},
		{
			name: "Test Case 2",
			dst:  []float64{0, 0, 0},
			l:    1,
			u:    5,
			want: []float64{1, 3, 5},
		},
		// Add more test cases as needed
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := Span(tt.dst, tt.l, tt.u)

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Span() = %v, want %v", got, tt.want)
			}

			// Additional tests for panics can be added here
		})
	}
}

func TestSub(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		s    []float64
		want []float64
	}{
		{
			name: "subtract elements successfully",
			dst:  []float64{1.0, 2.0, 3.0},
			s:    []float64{0.5, 1.0, 1.5},
			want: []float64{0.5, 1.0, 1.5},
		},
		{
			name: "panic if argument lengths do not match",
			dst:  []float64{1.0, 2.0, 3.0},
			s:    []float64{0.5, 1.0},
			want: nil, // Expecting panic
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil && tt.want == nil {
					t.Errorf("Sub() did not panic")
				}
			}()

			Sub(tt.dst, tt.s)

			if !reflect.DeepEqual(tt.dst, tt.want) {
				t.Errorf("Sub() = %v, want %v", tt.dst, tt.want)
			}
		})
	}
}

func TestSubTo(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		t        []float64
		expected []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},
		{[]float64{1, 2}, []float64{3, 4}, []float64{1, 2, 3}, nil}, // Should panic due to different lengths
	}

	for _, test := range tests {
		defer func() {
			if r := recover(); r == nil && test.expected == nil {
				t.Errorf("SubTo did not panic for unequal lengths")
			}
		}()

		result := SubTo(test.dst, test.s, test.t)

		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("SubTo(%v, %v, %v) returned %v, expected %v", test.dst, test.s, test.t, result, test.expected)
		}
	}
}

func TestSum(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected float64
	}{
		{
			name:     "Test case 1",
			input:    []float64{1.5, 2.5, 3.5},
			expected: 7.5,
		},
		{
			name:     "Test case 2",
			input:    []float64{0.0, 0.0, 0.0},
			expected: 0.0,
		},
		{
			name:     "Test case 3",
			input:    []float64{10.5, -5.5, 3.0},
			expected: 8.0,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			result := Sum(test.input)
			if result != test.expected {
				t.Errorf("Expected: %v, but got: %v", test.expected, result)
			}
		})
	}
}

func TestWithin(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		value    float64
		expected int
	}{
		{
			name:     "value within the provided slice",
			input:    []float64{1, 3, 5, 7, 9},
			value:    4,
			expected: 2,
		},
		{
			name:     "value outside the provided slice",
			input:    []float64{1, 3, 5, 7, 9},
			value:    10,
			expected: -1,
		},
		{
			name:     "empty slice",
			input:    []float64{},
			value:    4,
			expected: -1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					// Test for expected panic
					if r != "floats: input slice not sorted" && r != shortSpan {
						t.Errorf("Unexpected panic: %v", r)
					}
				}
			}()

			result := Within(tt.input, tt.value)

			if result != tt.expected {
				t.Errorf("Expected index %d, but got %d for value %f in slice %v", tt.expected, result, tt.value, tt.input)
			}
		})
	}

	// Additional tests for special cases like NaN
	t.Run("NaN value", func(t *testing.T) {
		input := []float64{1, 3, 5, 7, 9}
		value := math.NaN()
		expected := -1

		result := Within(input, value)

		if result != expected {
			t.Errorf("Expected index %d, but got %d for value NaN in slice %v", expected, result, input)
		}
	})
}

func TestSumCompensated(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected float64
	}{
		{
			name:     "Test case 1",
			input:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},
			expected: 15.0,
		},
		{
			name:     "Test case 2",
			input:    []float64{10.0, -5.0, 3.0, 7.0},
			expected: 15.0,
		},
		{
			name:     "Test case 3",
			input:    []float64{-1.0, -2.0, -3.0, -4.0},
			expected: -10.0,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := SumCompensated(tc.input)
			if !almostEqual(result, tc.expected) {
				t.Errorf("Expected %f, but got %f", tc.expected, result)
			}
		})
	}
}

func almostEqual(a, b float64) bool {
	const epsilon = 1e-9
	return math.Abs(a-b) < epsilon
}

