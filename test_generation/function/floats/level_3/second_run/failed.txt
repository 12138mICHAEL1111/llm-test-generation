func TestArgsort(t *testing.T) {
	tests := []struct {
		dst  []float64
		inds []int
	}{
		{[]float64{4, 2, 1, 3}, []int{0, 0, 0, 0}},
		{[]float64{10, 5, 8, 3, 1}, []int{0, 0, 0, 0, 0}},
		{[]float64{100, 50, 25, 75, 10, 5}, []int{0, 0, 0, 0, 0, 0}},
	}

	for _, test := range tests {
		originalInds := make([]int, len(test.inds))
		copy(originalInds, test.inds)

		Argsort(test.dst, test.inds)

		sortedValues := make([]float64, len(test.dst))
		sortedIndices := make([]int, len(test.inds))
		copy(sortedValues, test.dst)
		copy(sortedIndices, test.inds)

		sort.Float64s(sortedValues)
		sort.Ints(sortedIndices)

		for i, index := range sortedIndices {
			if test.dst[index] != sortedValues[i] {
				t.Errorf("Sorting incorrect for input dst: %v, expected inds: %v, got: %v", test.dst, originalInds, test.inds)
				break
			}
		}
	}
}
func TestCumSum(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		s        []float64
		expected []float64
	}{
		{
			name:     "Empty arrays",
			dst:      []float64{},
			s:        []float64{},
			expected: []float64{},
		},
		{
			name:     "Equal length arrays",
			dst:      []float64{0, 0, 0},
			s:        []float64{1, 2, 3},
			expected: []float64{1, 3, 6},
		},
		{
			name:     "Unequal length arrays",
			dst:      []float64{0, 0, 0},
			s:        []float64{1, 2},
			expected: []float64{}, // Expecting panic due to badDstLength
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			if test.name == "Unequal length arrays" {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("Expected panic due to badDstLength, but it didn't occur")
					}
				}()
			}

			result := CumSum(test.dst, test.s)
			if !reflect.DeepEqual(result, test.expected) {
				t.Errorf("Unexpected result - Got: %v, Want: %v", result, test.expected)
			}
		})
	}
}
func TestLogSpan(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "example test case",
			dst:  []float64{1, 2, 3},
			l:    1,
			u:    3,
			want: []float64{1, 2, 3},
		},
		// Add more test cases here
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := LogSpan(tt.dst, tt.l, tt.u)

			// round to handle float comparison
			for i := range got {
				got[i] = math.Round(got[i] * 1e10)
				got[i] /= 1e10
			}

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("LogSpan() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestNearestIdx(t *testing.T) {
	tests := []struct {
		s        []float64
		v        float64
		expected int
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},
		{[]float64{5.0, 3.0, 1.0}, 2.5, 2},
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, math.NaN(), 0},
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, math.Inf(1), 4},
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, math.Inf(-1), 0},
	}

	for _, test := range tests {
		result := NearestIdx(test.s, test.v)
		if result != test.expected {
			t.Errorf("NearestIdx(%v, %v) = %d; want %d", test.s, test.v, result, test.expected)
		}
	}
}
func TestWithin(t *testing.T) {
	tests := []struct {
		s        []float64
		v        float64
		expected int
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 4},
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -1},
		{[]float64{1.0}, 1.0, -1},
	}

	for _, test := range tests {
		defer func() {
			if r := recover(); r != nil {
				t.Errorf("Recovered from panic: %v", r)
			}
		}()
		result := Within(test.s, test.v)
		if result != test.expected {
			t.Errorf("For %v, expected %d, but got %d", test, test.expected, result)
		}
	}
}
func TestLogSumExp(t *testing.T) {
	tests := []struct {
		name string
		s    []float64
		want float64
	}{
		{
			name: "Test Case 1",
			s:    []float64{1, 2, 3, 4},
			want: 4.440189698215903,
		},
		{
			name: "Test Case 2",
			s:    []float64{0.1, 0.5, 0.9},
			want: 1.0516618204973902,
		},
		{
			name: "Test Case 3",
			s:    []float64{-1, -2, -3},
			want: -0.6931471805599453,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := LogSumExp(tt.s)
			if math.Abs(got-tt.want) > 1e-10 {
				t.Errorf("LogSumExp() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestMul(t *testing.T) {
	type args struct {
		dst []float64
		s   []float64
	}
	tests := []struct {
		name string
		args args
		want []float64
	}{
		{
			name: "Test case 1",
			args: args{
				dst: []float64{1, 2, 3},
				s:   []float64{2, 3, 4},
			},
			want: []float64{2, 6, 12},
		},
		{
			name: "Test case 2",
			args: args{
				dst: []float64{4, 5, 6},
				s:   []float64{2, 2, 2},
			},
			want: []float64{8, 10, 12},
		},
		{
			name: "Test case 3",
			args: args{
				dst: []float64{1, 2, 3, 4},
				s:   []float64{2, 3, 4},
			},
			want: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if tt.want == nil {
						return
					}
					t.Errorf("Mul() panic = %v, want %v", r, nil)
				}
			}()
			Mul(tt.args.dst, tt.args.s)
			if !reflect.DeepEqual(tt.args.dst, tt.want) {
				t.Errorf("Mul() = %v, want %v", tt.args.dst, tt.want)
			}
		})
	}
}
func TestNearestIdxForSpan(t *testing.T) {
	tests := []struct {
		n       int
		l, u, v float64
		want    int
	}{
		{5, 1.0, 3.0, 2.0, 2},
		{4, math.Inf(-1), 4.0, 5.0, 0},
		{7, math.NaN(), 8.0, 4.0, 6},
		// Add more test cases as needed
	}

	for _, tt := range tests {
		got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)
		if got != tt.want {
			t.Errorf("NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d", tt.n, tt.l, tt.u, tt.v, got, tt.want)
		}
	}
}

func TestNorm(t *testing.T) {
	testCases := []struct {
		input    []float64
		L        float64
		expected float64
	}{
		{[]float64{1, 2, 3}, 1, 6},                    // sum of absolute values
		{[]float64{1, 2, 3}, 2, 3.74165738677},        // L2-norm
		{[]float64{1, 2, 3}, math.Inf(1), 3},          // max absolute value
		{[]float64{}, 2, 0},                            // empty slice
	}

	// Define a function for float64 approximate equality
	approxEqual := func(a, b, tolerance float64) bool {
		return math.Abs(a-b) < tolerance
	}

	tolerance := 1e-10 // define a tolerance for float64 comparisons

	for _, tc := range testCases {
		output := Norm(tc.input, tc.L)
		if !approxEqual(output, tc.expected, tolerance) {
			t.Errorf("Norm(%v, %v) = %v; want %v", tc.input, tc.L, output, tc.expected)
		}
	}
} 

func TestSumCompensated(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected float64
	}{
		{
			name:     "Test case 1",
			input:    []float64{1.1, 2.2, 3.3},
			expected: 6.6,
		},
		{
			name:     "Test case 2",
			input:    []float64{1, 0, -1, 2, -2},
			expected: 0,
		},
		{
			name:     "Test case 3",
			input:    []float64{1.1, -1.1, 0.0001, -0.0001},
			expected: 0.1,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			result := SumCompensated(test.input)
			
			// Increased tolerance for float comparison
			eps := 1e-6
			
			if math.Abs(result-test.expected) > eps {
				t.Errorf("Expected %v, got %v", test.expected, result)
			}
		})
	}
}
func TestCumProd(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		s        []float64
		expected []float64
	}{
		{
			name:     "Empty arrays",
			dst:      []float64{},
			s:        []float64{},
			expected: []float64{},
		},
		{
			name:     "Arrays with the same length",
			dst:      []float64{1, 2, 3, 4},
			s:        []float64{1, 2, 3, 4},
			expected: []float64{1, 2, 6, 24},
		},
		{
			name:     "Arrays with different lengths",
			dst:      []float64{1, 2, 3, 0},
			s:        []float64{1, 2, 3, 4},
			expected: []float64{1, 2, 6, 0},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := CumProd(tt.dst, tt.s)
			if len(result) != len(tt.expected) {
				t.Errorf("Expected result length %d, but got %d", len(tt.expected), len(result))
			}

			for i := 0; i < len(tt.expected); i++ {
				if result[i] != tt.expected[i] {
					t.Errorf("Expected %f at index %d, but got %f", tt.expected[i], i, result[i])
				}
			}
		})
	}
}
func TestSpan(t *testing.T) {
	tests := []struct {
		dst      []float64
		l, u     float64
		expected []float64
	}{
		{make([]float64, 4), math.NaN(), 10, []float64{math.NaN(), math.NaN(), math.NaN(), 10}},
		{make([]float64, 6), math.Inf(+1), 10, []float64{math.Inf(+1), math.Inf(+1), math.Inf(+1), 10, math.Inf(+1), math.Inf(+1)}},
	}

	for _, test := range tests {
		result := Span(test.dst, test.l, test.u)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("For input dst=%v, l=%v, u=%v, expected %v but got %v", test.dst, test.l, test.u, test.expected, result)
		}
	}
}
func TestDiv(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		s    []float64
		want []float64
	}{
		{
			name: "Test Case 1",
			dst:  []float64{10, 20, 30},
			s:    []float64{2, 2, 3},
			want: []float64{5, 10, 10},
		},
		{
			name: "Test Case 2",
			dst:  []float64{10, 20, 30},
			s:    []float64{0, 2, 3},
			want: []float64{math.Inf(1), 10, 10},
		},
		{
			name: "Test Case 3",
			dst:  []float64{10, 20, 30},
			s:    []float64{2, 0, 3},
			want: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if tt.want != nil {
						t.Errorf("Div panicked, but not expected. want = %v", tt.want)
					}
				}
			}()

			Div(tt.dst, tt.s)

			if tt.want == nil {
				t.Errorf("Div() did not panic as expected. want = %v", tt.want)
			} else if !reflect.DeepEqual(tt.dst, tt.want) {
				t.Errorf("Div() got = %v, want %v", tt.dst, tt.want)
			}
		})
	}
}
func TestMaxIdx(t *testing.T) {
	tests := []struct {
		input    []float64
		expected int
	}{
		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},
		{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},
		{[]float64{5.0, math.NaN(), 3.0, 2.0, 1.0}, 0},
		{[]float64{}, 0}, // test zero-length array
	}

	for _, test := range tests {
		func() {
			defer func() {
				if r := recover(); r != nil {
					t.Errorf("Panic occurred: %v", r)
				}
			}()
			result := MaxIdx(test.input)
			if result != test.expected {
				t.Errorf("For %v, expected %d, but got %d", test.input, test.expected, result)
			}
		}()
	}
}
