func TestGetUint(t *testing.T) {
	// Test case for non-existing keys path
	t.Run("NonExistingKeysPath", func(t *testing.T) {
		// Test logic here
	})

	// Test case for valid uint value
	t.Run("ValidUintValue", func(t *testing.T) {
		// Test logic here
	})

	// Test case for invalid value type
	t.Run("InvalidValueType", func(t *testing.T) {
		// Test logic here
	})
}
func TestParseRawKey(t *testing.T) {
	tests := []struct {
		input    string
		expected struct {
			firstResult string
			secondResult string
			err error
		}
	}{
		// Add your test cases here
	}

	for _, tt := range tests {
		firstResult, secondResult, err := parseRawKey(tt.input)
		if !reflect.DeepEqual(tt.expected.firstResult, firstResult) {
			t.Errorf("Expected first result %v, but got %v", tt.expected.firstResult, firstResult)
		}
		if !reflect.DeepEqual(tt.expected.secondResult, secondResult) {
			t.Errorf("Expected second result %v, but got %v", tt.expected.secondResult, secondResult)
		}
		if !reflect.DeepEqual(tt.expected.err, err) {
			t.Errorf("Expected error %v, but got %v", tt.expected.err, err)
		}
	}
}
func TestParseRawString(t *testing.T) {
	// Test case 1: input string with no escaped quotes
	// expected result: first string should be "hello", remaining string should be ", world!"
	// error should be nil
	s1 := `"hello"," world!"`
	first1, remaining1, err1 := parseRawString(s1)
	if first1 != "hello" || remaining1 != ", world!" || err1 != nil {
		t.Errorf("Test case 1 failed")
	}

	// Test case 2: input string with escaped quotes
	// expected result: first string should be "hello\"world\"", remaining string should be ":)"
	// error should be nil
	s2 := `"hello\"world\"":" :)"`
	first2, remaining2, err2 := parseRawString(s2)
	if first2 != "hello\\\"world\\\"" || remaining2 != ": :)" || err2 != nil {
		t.Errorf("Test case 2 failed")
	}

	// Test case 3: input string missing closing quote
	// expected result: error should indicate missing closing quote
	s3 := `"missing closing quote`
	_, _, err3 := parseRawString(s3)
	if err3 == nil || err3.Error() != `missing closing '"'` {
		t.Errorf("Test case 3 failed")
	}
}
func TestGetKV(t *testing.T) {
	obj := Object{
		kvs: []kv{
			{k: "key1", v: &Value{}},
			{k: "key2", v: &Value{}},
		},
		keysUnescaped: false,
	}

	result := obj.getKV()

	if result == nil {
		t.Error("Expected non-nil result, got nil")
	}
	if result.k != "" || result.v != nil {
		t.Errorf("Expected empty key and nil value, got key: %s and value: %v", result.k, result.v)
	}
}
func TestType(t *testing.T) {
	v := &fastjson.Value{t: fastjson.TypeString}
	expectedType := fastjson.TypeString

	actualType := v.Type()

	if actualType != expectedType {
		t.Errorf("Expected type %v, but got %v", expectedType, actualType)
	}
}
func TestGetInt(t *testing.T) {
	// Test cases for GetInt function
	tests := []struct {
		name     string
		value    *Value
		keys     []string
		expected int
	}{
		{
			name:     "Existing key path - valid value type",
			value:    &Value{s: "42", t: TypeNumber},
			keys:     []string{},
			expected: 42,
		},
		{
			name:     "Existing key path - invalid value type",
			value:    &Value{s: "42", t: TypeString},
			keys:     []string{},
			expected: 0,
		},
		{
			name:     "Non-existing key path",
			value:    nil,
			keys:     []string{"key1", "key2"},
			expected: 0,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			actual := tc.value.GetInt(tc.keys...)
			if actual != tc.expected {
				t.Errorf("Expected: %d, but got: %d", tc.expected, actual)
			}
		})
	}
}
func TestArray(t *testing.T) {
	// create a Value with TypeArray
	v := &Value{
		t: TypeArray,
		a: []*Value{
			&Value{t: TypeNumber},
			&Value{t: TypeString},
			&Value{t: TypeTrue},
		},
	}
	
	// call Array function on Value
	arr, err := v.Array()
	
	// check if error is not returned
	if err != nil {
		t.Errorf("Array function returned error: %v", err)
	}
	
	// check if the length of the returned array is 3
	if len(arr) != 3 {
		t.Errorf("Expected array length of 3, but got %d", len(arr))
	}
	
	// check the types of the elements in the array
	expectedTypes := []Type{TypeNumber, TypeString, TypeTrue}
	for i, val := range arr {
		if val.t != expectedTypes[i] {
			t.Errorf("Expected type %s at index %d, but got %s", expectedTypes[i], i, val.Type())
		}
	}
}
func TestValue_Get(t *testing.T) {
	type fields struct {
		o Object
		a []*Value
		s string
		t Type
	}
	tests := []struct {
		name   string
		fields fields
		keys   []string
		want   *Value
	}{
		// Add your test cases here
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := &Value{
				o: tt.fields.o,
				a: tt.fields.a,
				s: tt.fields.s,
				t: tt.fields.t,
			}
			if got := v.Get(tt.keys...); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Value.Get() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestGetUint64(t *testing.T) {
	// Add test cases for GetUint64 function
}
func TestBool(t *testing.T) {
	// Test case for TypeTrue
	vTrue := &Value{t: TypeTrue}
	bTrue, err := vTrue.Bool()
	if bTrue != true || err != nil {
		t.Errorf("Expected true, got %t with error: %v", bTrue, err)
	}

	// Test case for TypeFalse
	vFalse := &Value{t: TypeFalse}
	bFalse, err := vFalse.Bool()
	if bFalse != false || err != nil {
		t.Errorf("Expected false, got %t with error: %v", bFalse, err)
	}

	// Test case for TypeNull
	vNull := &Value{t: TypeNull}
	bNull, err := vNull.Bool()
	if err == nil {
		t.Error("Expected error for TypeNull, got nil")
	}
}
func TestGetBool(t *testing.T) {
	// Test cases for GetBool function
	tests := []struct {
		name     string
		value    *fastjson.Value
		keys     []string
		expected bool
	}{
		{
			name:     "Existing key with true value",
			value:    &fastjson.Value{t: fastjson.TypeTrue},
			keys:     []string{},
			expected: true,
		},
		{
			name:     "Existing key with false value",
			value:    &fastjson.Value{t: fastjson.TypeFalse},
			keys:     []string{},
			expected: false,
		},
		{
			name:     "Non-existing key",
			value:    nil,
			keys:     []string{"key1", "key2"},
			expected: false,
		},
		{
			name:     "Invalid value type",
			value:    &fastjson.Value{t: fastjson.TypeNumber},
			keys:     []string{},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.value.GetBool(tt.keys...)
			if result != tt.expected {
				t.Errorf("Got %v, expected %v", result, tt.expected)
			}
		})
	}
}
func TestStringBytes(t *testing.T) {
	// Create a sample Value object with TypeString
	v := &Value{s: "Test String", t: TypeString}

	// Call StringBytes on the sample Value object
	bytes, err := v.StringBytes()

	// Check if error is nil
	if err != nil {
		t.Errorf("Error returned: %v", err)
	}

	// Check if the bytes returned match the original string
	expectedBytes := []byte("Test String")
	if !reflect.DeepEqual(bytes, expectedBytes) {
		t.Errorf("Expected bytes %v, but got %v", expectedBytes, bytes)
	}
}
func TestParseBytes(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected *Value
	}{
		// Add your test cases here
	}

	p := &Parser{}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := p.ParseBytes(tt.input)
			if err != nil {
				t.Errorf("ParseBytes error = %v", err)
				return
			}
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("ParseBytes() = %v, want %v", result, tt.expected)
			}
		})
	}
}
func TestReset(t *testing.T) {
	obj := &fastjson.Object{
		kvs:           []fastjson.kv{{k: "key1", v: &fastjson.Value{Type: fastjson.TypeString, Str: "value1"}}},
		keysUnescaped: true,
	}

	obj.reset()

	if len(obj.kvs) != 0 || obj.keysUnescaped {
		t.Error("Object reset failed")
	}
}
func TestHasSpecialChars(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{"hello", false},
		{"world", false},
		{"hello\"world", true},
		{"hello\\world", true},
		{"\x0f", true},
		{"\x10", true},
		{"\x1f", true},
	}

	for _, test := range tests {
		result := hasSpecialChars(test.input)
		if result != test.expected {
			t.Errorf("For input '%s', expected %v but got %v", test.input, test.expected, result)
		}
	}
}
func TestTypeString(t *testing.T) {
	tests := []struct {
		input    Type
		expected string
	}{
		{TypeObject, "object"},
		{TypeArray, "array"},
		{TypeString, "string"},
		{TypeNumber, "number"},
		{TypeTrue, "true"},
		{TypeFalse, "false"},
		{TypeNull, "null"},
	}

	for _, test := range tests {
		result := test.input.String()
		if result != test.expected {
			t.Errorf("Expected %s, but got %s for input %d", test.expected, result, test.input)
		}
	}
}
func TestParseValue(t *testing.T) {
	cache := &cache{}
	depth := 0

	t.Run("ParseObject", func(t *testing.T) {
		jsonStr := `{"key": "value"}`
		v, tail, err := parseValue(jsonStr, cache, depth)
		
		if err != nil {
			t.Errorf("Failed to parse JSON object: %s", err)
		}

		// Add assertions here based on expected output
	})

	t.Run("ParseArray", func(t *testing.T) {
		jsonStr := `["value1", "value2"]`
		v, tail, err := parseValue(jsonStr, cache, depth)

		if err != nil {
			t.Errorf("Failed to parse JSON array: %s", err)
		}

		// Add assertions here based on expected output
	})

	// Add more test cases for other scenarios
}
func TestObject_unescapeKeys(t *testing.T) {
	t.Run("keys already unescaped", func(t *testing.T) {
		// Write test case for keys already unescaped
	})

	t.Run("keys need unescaping", func(t *testing.T) {
		// Write test case for keys that need unescaping
	})
}
func TestFloat64(t *testing.T) {
	// create a new test case
	// test the Float64 function of the Value struct
	t.Run("Float64", func(t *testing.T) {
		// create a new Value object to test
		v := &Value{
			s:   "3.14",
			t:   TypeNumber,
		}

		// call the Float64 function
		result, err := v.Float64()

		// check if there was an error
		if err != nil {
			t.Errorf("Expected 3.14, but got an error: %v", err)
		}

		// check if the result is as expected
		if result != 3.14 {
			t.Errorf("Expected 3.14, but got %v", result)
		}
	})

	// add more test cases here if needed
}
func TestInt64(t *testing.T) {
	// create a Value with int64 data
	v := &fastjson.Value{
		s: "123",
		t: fastjson.TypeNumber,
	}

	// call Int64 method on the Value
	result, err := v.Int64()

	// verify the result and error
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	if result != 123 {
		t.Errorf("expected Int64 value to be 123, but got %d", result)
	}
}
func TestParse(t *testing.T) {
	// Test cases
	tests := []struct {
		name     string
		input    string
		expected *Value
		err      error
	}{
		{
			name:     "Valid JSON object",
			input:    `{"key": "value"}`,
			expected: &Value{t: TypeObject},
			err:      nil,
		},
		{
			name:     "Invalid JSON",
			input:    `{"key": value"}`,
			expected: nil,
			err:      fmt.Errorf("cannot parse JSON"),
		},
		// Add more test cases as needed
	}

	// Initialize the Parser
	parser := &Parser{}

	// Run tests
	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result, err := parser.Parse(tc.input)
			if !reflect.DeepEqual(result, tc.expected) || err != tc.err {
				t.Errorf("Parse(%s) = (%v, %v), expected (%v, %v)", tc.input, result, err, tc.expected, tc.err)
			}
		})
	}
}
func TestParseObject(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
		err      string
	}{
		// Add test cases here
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Initialize cache and depth
			c := &cache{}
			depth := 0

			// Call the parseObject function
			val, remaining, err := parseObject(tt.input, c, depth)

			// Check the parsed value
			if val != nil {
				// Add assertions for the parsed value here
			}

			// Check the remaining string
			if remaining != tt.expected {
				t.Errorf("Expected remaining string: %s, got: %s", tt.expected, remaining)
			}

			// Check the error
			if err != nil && err.Error() != tt.err {
				t.Errorf("Expected error: %s, got: %s", tt.err, err.Error())
			}
		})
	}
}
func TestUnescapeStringBestEffort(t *testing.T) {
	testCases := []struct {
		input  string
		output string
	}{
		{input: `{"key": "value"}`, output: `{"key": "value"}`},
		{input: `{"key": "value\n"}`, output: `{"key": "value\n"}`},
		{input: `{"key": "value\r"}`, output: `{"key": "value\r"}`},
		{input: `{"key": "value\t"}`, output: `{"key": "value\t"}`},
		{input: `{"key": "value\b"}`, output: `{"key": "value\b"}`},
		{input: `{"key": "value\f"}`, output: `{"key": "value\f"}`},
		{input: `{"key": "value\\\\"}`, output: `{"key": "value\\"}`},
		{input: `{"key": "value\\u0041"}`, output: `{"key": "valueA"}`},
		{input: `{"key": "value\\uDBFF\\uDC00"}`, output: `{"key": "value\xF4\x8F\xB0\x80"}`},
		{input: `{"key": "value\\"}`, output: `{"key": "value"}`},
	}

	for _, tc := range testCases {
		result := unescapeStringBestEffort(tc.input)
		if result != tc.output {
			t.Errorf("Input: %s, Expected: %s, Got: %s", tc.input, tc.output, result)
		}
	}
}
func TestVisit(t *testing.T) {
	// Add your test cases for Visit function here
	t.Errorf("Test case not implemented")
}
func TestObject_Len(t *testing.T) {
	obj := &Object{
		kvs: []kv{
			{k: "key1", v: &Value{}},
			{k: "key2", v: &Value{}},
			{k: "key3", v: &Value{}},
		},
		keysUnescaped: true,
	}

	expectedLen := 3
	actualLen := obj.Len()

	if actualLen != expectedLen {
		t.Errorf("Expected length %d, but got %d", expectedLen, actualLen)
	}
}
func TestGetArray(t *testing.T) {
	value := &fastjson.Value{
		t: fastjson.TypeArray,
		a: []*fastjson.Value{
			{t: fastjson.TypeString, s: "value1"},
			{t: fastjson.TypeNumber, s: "123"},
		},
	}

	tests := []struct {
		name       string
		keys       []string
		expected   []*fastjson.Value
	}{
		{
			name:     "Valid keys",
			keys:     []string{},
			expected: value.a,
		},
		{
			name:     "Invalid keys",
			keys:     []string{"key1", "key2"},
			expected: nil,
		},
		{
			name:     "Empty keys",
			keys:     []string{""},
			expected: nil,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := value.GetArray(tc.keys...)
			if !reflect.DeepEqual(result, tc.expected) {
				t.Errorf("Expected: %v, but got: %v", tc.expected, result)
			}
		})
	}
}
func TestSkipWSSlow(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{input: "   hello", expected: "   hello"},
		{input: "\n\nworld", expected: "world"},
		{input: "\t\ttesting", expected: "testing"},
		{input: "\r\rjson", expected: "json"},
		{input: "fastjson", expected: "fastjson"},
	}

	for _, test := range tests {
		result := skipWSSlow(test.input)
		if result != test.expected {
			t.Errorf("skipWSSlow(%s) = %s; want %s", test.input, result, test.expected)
		}
	}
}
///warning///
To fix the compilation faults and address the failing test case, we need to update the implementation of the `parseRawNumber` function to handle invalid input and special cases like "NaN" correctly. Here's the corrected test function:

```go
package fastjson

import (
	"fmt
	"testing"
)

func TestParseRawNumber(t *testing.T) {
	// Test cases
	tests := []struct {
		input         string
		expectedNs    string
		expectedRem   string
		expectedError error
	}{
		{"123.45", "123.45", "", nil},
		{"-678.9", "-678.9", "", nil},
		{"+0.123e4", "+0.123e4", "", nil},
		{"inf123", "inf", "123", nil},
		{"nan", "nan", "", nil},
		{"abc", "", "abc", fmt.Errorf("unexpected char: \"a\"")},
		{"", "", "", fmt.Errorf("unexpected end of string")},
		{"NaN", "", "", fmt.Errorf("unexpected char: \"N\"")},
	}

	// Run tests
	for _, test := range tests {
		ns, rem, err := parseRawNumber(test.input)

		if ns != test.expectedNs {
			t.Errorf("For input %s, expected ns: %s, got: %s", test.input, test.expectedNs, ns)
		}

		if rem != test.expectedRem {
			t.Errorf("For input %s, expected rem: %s, got: %s", test.input, test.expectedRem, rem)
		}

		if (err == nil && test.expectedError != nil) || (err != nil && test.expectedError == nil) || (err != nil && test.expectedError != nil && err.Error() != test.expectedError.Error()) {
			t.Errorf("For input %s, expected err: %v, got: %v", test.input, test.expectedError, err)
		}
	}
}
```

The correction involves adding a specific case for "NaN" in the test data and making sure that the function returns an error for such input. If you have further questions or need more assistance, feel free to ask.
func TestValue_Int(t *testing.T) {
	// Test cases
	cases := []struct {
		value      *Value
		expected   int
		expectedErr error
	}{
		{&Value{s: "123", t: TypeNumber}, 123, nil},
		{&Value{t: TypeNull}, 0, fmt.Errorf("value doesn't contain number; it contains %s", TypeNull)},
		{&Value{s: "-456", t: TypeNumber}, -456, nil},
	}

	for _, tc := range cases {
		res, err := tc.value.Int()
		if err != nil && err.Error() == tc.expectedErr.Error() {
			continue
		}
		if err != tc.expectedErr {
			t.Errorf("Unexpected error. Expected: %v, Got: %v", tc.expectedErr, err)
		}
		if res != tc.expected {
			t.Errorf("Int() returned %d, expected %d", res, tc.expected)
		}
	}
}
func TestUint64(t *testing.T) {
	// Test when value is a valid uint64
	t.Run("Valid Uint64 Value", func(t *testing.T) {
		// Add your test case here
	})

	// Test when value is not a number type
	t.Run("Value is not a number type", func(t *testing.T) {
		// Add your test case here
	})

	// Add more test cases as needed
}
func TestObject(t *testing.T) {
	value := &Value{
		t: TypeObject,
		o: Object{
			kvs: []kv{
				{k: "key1", v: &Value{s: "value1", t: TypeString}},
				{k: "key2", v: &Value{t: TypeNumber}},
			},
		},
	}

	obj, err := value.Object()

	if err != nil {
		t.Errorf("Error not expected: %v", err)
	}

	expectedKVs := []kv{
		{k: "key1", v: &Value{s: "value1", t: TypeString}},
		{k: "key2", v: &Value{t: TypeNumber}},
	}

	if !reflect.DeepEqual(obj.kvs, expectedKVs) {
		t.Errorf("Object values do not match. Expected: %v, Got: %v", expectedKVs, obj.kvs)
	}

	if !obj.keysUnescaped {
		t.Error("keysUnescaped should be true")
	}
}
func TestParseArray(t *testing.T) {
	c := &cache{vs: make([]Value, 10)}
	depth := 0

	input := `[1, 2, "three"]`
	expectedOutput := TypeArray
	expectedRemaining := ""
	expectedError := error(nil)

	result, remaining, err := parseArray(input, c, depth)

	if result.t != expectedOutput {
		t.Errorf("Expected type %d but got %d", expectedOutput, result.t)
	}
	if remaining != expectedRemaining {
		t.Errorf("Expected remaining string to be '%s' but got '%s'", expectedRemaining, remaining)
	}
	if err != expectedError {
		t.Errorf("Expected error to be nil but got: %v", err)
	}
}
func TestEscapeString(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{input: "Hello, world!", expected: `"Hello, world!"`},
		{input: "Special chars: \" \\ / \b \f \n \r \t", expected: `"\\" \\ \/ \b \f \n \r \t"`},
		{input: "ðŸ˜€", expected: `"\u000F0\u009F\u0098\u0080"`},
	}

	for _, tc := range tests {
		t.Run(tc.input, func(t *testing.T) {
			var dst []byte
			dst = escapeString(dst, tc.input)

			if got := string(dst); !reflect.DeepEqual(got, tc.expected) {
				t.Errorf("Failed for input: %q, expected: %q, got: %q", tc.input, tc.expected, got)
			}
		})
	}
}
func TestMarshalTo(t *testing.T) {
	v := &Value{
		t: TypeString,
		s: "Hello, World!",
	}

	dst := make([]byte, 0)
	dst = v.MarshalTo(dst)

	expected := []byte(`"Hello, World!"`)

	if string(dst) != string(expected) {
		t.Errorf("Expected marshaled value to be %s, but got %s", expected, dst)
	}
}
func TestGetObject(t *testing.T) {
	// Create a new Value object for testing
	v := &Value{
		t: TypeObject,
		o: Object{
			kvs: []kv{
				{
					k: "key1",
					v: &Value{t: TypeString, s: "value1"},
				},
				{
					k: "key2",
					v: &Value{t: TypeNumber, s: "123"},
				},
			},
		},
	}

	// Test getting an object value by keys path
	obj := v.GetObject("key1")
	expectedObj := &Object{
		kvs: []kv{
			{
				k: "key1",
				v: &Value{t: TypeString, s: "value1"},
			},
		},
	}
	if !reflect.DeepEqual(obj, expectedObj) {
		t.Errorf("GetObject(\"key1\") returned %v, expected %v", obj, expectedObj)
	}

	// Test getting an object value by non-existing keys path
	obj = v.GetObject("key3")
	if obj != nil {
		t.Errorf("GetObject(\"key3\") returned %v, expected nil", obj)
	}

	// Test getting an object value by invalid value type
	v.t = TypeNull
	obj = v.GetObject("key1")
	if obj != nil {
		t.Errorf("GetObject(\"key1\") returned %v, expected nil for invalid value type", obj)
	}
}
func TestUint(t *testing.T) {
	t.Run("TestUint_TypeNumber", func(t *testing.T) {
		// Add test case for TypeNumber
	})

	t.Run("TestUint_TypeObject", func(t *testing.T) {
		// Add test case for TypeObject
	})

	t.Run("TestUint_TypeArray", func(t *testing.T) {
		// Add test case for TypeArray
	})

	t.Run("TestUint_TypeString", func(t *testing.T) {
		// Add test case for TypeString
	})

	t.Run("TestUint_TypeTrue", func(t *testing.T) {
		// Add test case for TypeTrue
	})

	t.Run("TestUint_TypeFalse", func(t *testing.T) {
		// Add test case for TypeFalse
	})
}
func TestExists(t *testing.T) {
	value := &fastjson.Value{
		o: fastjson.Object{
			kvs: []fastjson.KV{
				{K: "key1", V: &fastjson.Value{S: "value1"}},
				{K: "key2", V: &fastjson.Value{T: fastjson.TypeString}},
			},
			KeysUnescaped: true,
		},
		A: []*fastjson.Value{
			{T: fastjson.TypeNumber},
			{T: fastjson.TypeNumber},
		},
		S: "string",
		T: fastjson.TypeString,
	}

	tests := []struct {
		keys     []string
		expected bool
	}{
		{keys: []string{"key1"}, expected: true},
		{keys: []string{"key2"}, expected: true},
		{keys: []string{"key3"}, expected: false},
		{keys: []string{"key4"}, expected: false},
	}

	for _, test := range tests {
		if result := value.Exists(test.keys...); result != test.expected {
			t.Errorf("For keys %v, expected %v but got %v", test.keys, test.expected, result)
		}
	}
}
func TestGetFloat64(t *testing.T) {
	// Test case 1: Existing key path with valid float64 value
	v := &Value{s: "123.45", t: TypeNumber}
	result := v.GetFloat64()
	assert.Equal(t, float64(123.45), result, "Expected result for valid key path with float64 value")

	// Test case 2: Existing key path with invalid value type
	v = &Value{s: "test", t: TypeString}
	result = v.GetFloat64()
	assert.Equal(t, float64(0), result, "Expected result for invalid value type")

	// Test case 3: Non-existing key path
	v = nil
	result = GetFloat64("nonexisting")
	assert.Equal(t, float64(0), result, "Expected result for non-existing key path")
}
func TestGetInt64(t *testing.T) {
	v := &Value{s: "123", t: TypeNumber}
	result := v.GetInt64()
	expected := int64(123)
	if result != expected {
		t.Errorf("Expected: %v, but got: %v", expected, result)
	}

	// Add more test cases here
}
func TestGetStringBytes(t *testing.T) {
	// Create a new Value for testing
	v := &Value{
		s: "test",
		t: TypeString,
	}

	// Test valid keys path
	expectedResult := []byte("test")
	result := v.GetStringBytes()
	if !reflect.DeepEqual(result, expectedResult) {
		t.Errorf("Expected %v, but got %v", expectedResult, result)
	}

	// Test invalid keys path
	v = nil
	expectedResult = nil
	result = v.GetStringBytes()
	if !reflect.DeepEqual(result, expectedResult) {
		t.Errorf("Expected %v, but got %v", expectedResult, result)
	}

	// Test non-existing keys path
	v = &Value{
		s: "test",
		t: TypeString,
	}
	expectedResult = nil
	result = v.GetStringBytes("invalid")
	if !reflect.DeepEqual(result, expectedResult) {
		t.Errorf("Expected %v, but got %v", expectedResult, result)
	}

	// Test invalid value type
	v = &Value{
		s: "test",
		t: TypeNull,
	}
	expectedResult = nil
	result = v.GetStringBytes()
	if !reflect.DeepEqual(result, expectedResult) {
		t.Errorf("Expected %v, but got %v", expectedResult, result)
	}
}
func TestCache_getValue(t *testing.T) {
	c := &cache{
		vs: []Value{
			{
				o: Object{
					kvs:           []kv{{"key1", &Value{}}, {"key2", &Value{}}},
					keysUnescaped: true,
				},
				a: []*Value{&Value{}, &Value{}},
				s: "test",
				t: TypeString,
			},
			{
				o: Object{
					kvs:           []kv{},
					keysUnescaped: false,
				},
				a: []*Value{},
				s: "",
				t: TypeNull,
			},
		},
	}

	val1 := c.getValue()
	if val1 == nil {
		t.Error("Expected non-nil value, got nil")
	}

	val2 := c.getValue()
	if val2 == nil {
		t.Error("Expected non-nil value, got nil")
	}

	if len(c.vs) != 3 {
		t.Errorf("Expected cache length to be 3, got %d", len(c.vs))
	}

	if val1 == val2 {
		t.Error("Expected returned values to be distinct")
	}
}
func TestSkipWS(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{input: "", expected: ""},
		{input: "  hello world", expected: "  hello world"},
		{input: "\n\t\vhello", expected: "hello"},
		{input: "\r\f\r\n ", expected: " "},
		{input: "test", expected: "test"},
	}

	for _, test := range tests {
		result := skipWS(test.input)
		if result != test.expected {
			t.Errorf("For input %q, expected %q, but got %q", test.input, test.expected, result)
		}
	}
}
