func TestUint(t *testing.T) {
	// Add test cases for the Uint function here
}

func TestMarshalTo(t *testing.T) {
	// Add test cases for MarshalTo function here
}

func TestType(t *testing.T) {
	// Add test cases here
}

func TestGetUint(t *testing.T) {
	// Add test cases here
}

func TestUint64(t *testing.T) {
	// Add test cases here
}

func TestEscapeString(t *testing.T) {
	// Test case 1: string with special characters
	dst := make([]byte, 0)
	s := "Hello, \"world\"!"
	expected := []byte(`"Hello, \"world\"!"`)
	result := escapeString(dst, s)
	if string(result) != string(expected) {
		t.Errorf("Expected %s, but got %s", expected, result)
	}

	// Test case 2: string without special characters
	dst = make([]byte, 0)
	s = "Hello world"
	expected = []byte(`"Hello world"`)
	result = escapeString(dst, s)
	if string(result) != string(expected) {
		t.Errorf("Expected %s, but got %s", expected, result)
	}
}

func TestInt64(t *testing.T) {
	// Add test cases here
}

func TestHasSpecialChars(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{"hello", false},
		{"world", false},
		{"hello world", false},
		{"hello\"world", true},
		{"hello\\world", true},
		{"hello\nworld", true},
		{"hello\tworld", true},
		{"hello\vworld", true},
		{"hello\rworld", true},
		{"hello\x00world", true},
	}

	for _, test := range tests {
		result := hasSpecialChars(test.input)
		if result != test.expected {
			t.Errorf("Expected hasSpecialChars(%s) to be %t, but got %t", test.input, test.expected, result)
		}
	}
}

func TestParseRawKey(t *testing.T) {
	// Add test cases here
}

func TestReset(t *testing.T) {
	// Test cases for reset function
}

func TestExists(t *testing.T) {
	// Test cases for Exists function
}

func TestCache_getValue(t *testing.T) {
	cache := &cache{
		vs: make([]Value, 0),
	}

	value := cache.getValue()

	if value == nil {
		t.Error("Expected non-nil value, got nil")
	}

	if len(cache.vs) != 1 {
		t.Errorf("Expected cache length to be 1, got %d", len(cache.vs))
	}

	if &cache.vs[0] != value {
		t.Error("Expected returned value to be the last element in cache")
	}
}

func TestGetInt64(t *testing.T) {
	// Add test cases here
}

func TestParseArray(t *testing.T) {
	// Add your test cases for parseArray function here
}

func TestSkipWSSlow(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"   hello", "hello"},
		{"\nworld", "world"},
		{"\t\t\tgoodbye", "goodbye"},
		{"\r\r\rwelcome", "welcome"},
		{"12345", "12345"},
		{"", ""},
	}

	for _, test := range tests {
		result := skipWSSlow(test.input)
		if result != test.expected {
			t.Errorf("skipWSSlow(%s) = %s; want %s", test.input, result, test.expected)
		}
	}
}

func TestGetUint64(t *testing.T) {
	// Add test cases here
}

func TestUnescapeStringBestEffort(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"Hello,\\nWorld!", "Hello,\nWorld!"},
		{"This is a \\\"test\\\" string", "This is a \"test\" string"},
		{"Unicode: \\u0048\\u0065\\u006c\\u006c\\u006f", "Unicode: Hello"},
		{"Invalid Unicode: \\u123", "Invalid Unicode: \\u123"},
		{"Escaped backslash: \\\\", "Escaped backslash: \\"},
	}

	for _, test := range tests {
		result := unescapeStringBestEffort(test.input)
		if result != test.expected {
			t.Errorf("Input: %s, Expected: %s, Got: %s", test.input, test.expected, result)
		}
	}
}

func TestParser_Parse(t *testing.T) {
	parser := &Parser{}
	
	tests := []struct {
		input    string
		expected *Value
	}{
		{`{"key": "value"}`, &Value{Type: TypeObject}},
		{`[1, 2, 3]`, &Value{Type: TypeArray}},
		{`"string"`, &Value{Type: TypeString}},
		{`123`, &Value{Type: TypeNumber}},
		{`true`, &Value{Type: TypeTrue}},
		{`false`, &Value{Type: TypeFalse}},
		{`null`, &Value{Type: TypeNull}},
	}
	
	for _, test := range tests {
		result, err := parser.Parse(test.input)
		if err != nil {
			t.Errorf("Error parsing JSON: %v", err)
		}
		
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("Expected %v, but got %v", test.expected, result)
		}
	}
}

func TestGetInt(t *testing.T) {
	// Add test cases here
}

func TestParseRawNumber(t *testing.T) {
	// Add your test cases here
}

func TestParseBytes(t *testing.T) {
	// Add test cases for ParseBytes function here
}

func TestValue_Get(t *testing.T) {
	// Add test cases here
}

func TestLen(t *testing.T) {
	// Test cases
}

func TestGetBool(t *testing.T) {
	// Add test cases here
}

func TestGetArray(t *testing.T) {
	// Add test cases for GetArray function here
}

func TestType_String(t *testing.T) {
	tests := []struct {
		name string
		t    Type
		want string
	}{
		{name: "Object", t: TypeObject, want: "object"},
		{name: "Array", t: TypeArray, want: "array"},
		{name: "String", t: TypeString, want: "string"},
		{name: "Number", t: TypeNumber, want: "number"},
		{name: "True", t: TypeTrue, want: "true"},
		{name: "False", t: TypeFalse, want: "false"},
		{name: "Null", t: TypeNull, want: "null"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.t.String(); got != tt.want {
				t.Errorf("Type.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestObject(t *testing.T) {
	// Add test cases here
}

func TestGetFloat64(t *testing.T) {
	// Test cases for GetFloat64 function
}

func TestSkipWS(t *testing.T) {
	// Add test cases for the skipWS function here
}

func TestValue_Int(t *testing.T) {
	// Add test cases for the Int function here
}

func TestGetStringBytes(t *testing.T) {
	value := &Value{s: "test"}
	expected := []byte("test")

	result := value.GetStringBytes()

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}
}

func TestArray(t *testing.T) {
	// Add test cases here
}

func TestParseObject(t *testing.T) {
	// Add your test cases for the parseObject function here
}

func TestUnescapeKeys(t *testing.T) {
	// create an Object with escaped keys
	obj := Object{
		keysUnescaped: false,
		kvs: []keyValue{
			{`\"key1\"`, "value1"},
			{`\"key2\"`, "value2"},
		},
	}

	// call unescapeKeys method
	obj.unescapeKeys()

	// check if keys are unescaped
	for _, kv := range obj.kvs {
		if kv.k == `\"key1\"` || kv.k == `\"key2\"` {
			t.Errorf("Key was not unescaped: %s", kv.k)
		}
	}

	// check if keysUnescaped flag is set to true
	if !obj.keysUnescaped {
		t.Error("keysUnescaped flag was not set to true")
	}
}

func TestFloat64(t *testing.T) {
	// Add test cases here
}

func TestVisit(t *testing.T) {
	// Test cases for Visit function
	// Add test cases here
}

func TestParseRawString(t *testing.T) {
	tests := []struct {
		input          string
		expectedPrefix string
		expectedSuffix string
		expectedError  string
	}{
		{"\"hello\"", "hello", "", ""},
		{"\"hello\\\"world\"", "hello\\\"world", "", ""},
		{"\"hello\\\"world", "", "", "missing closing '\"'"},
		{"\"hello\\\\\"", "hello\\", "", ""},
		{"\"hello\\\\\\\"", "hello\\\\", "", ""},
		{"\"hello\\\\\\\"world", "", "", "missing closing '\"'"},
	}

	for _, test := range tests {
		prefix, suffix, err := parseRawString(test.input)

		if prefix != test.expectedPrefix {
			t.Errorf("For input %q, expected prefix %q, but got %q", test.input, test.expectedPrefix, prefix)
		}

		if suffix != test.expectedSuffix {
			t.Errorf("For input %q, expected suffix %q, but got %q", test.input, test.expectedSuffix, suffix)
		}

		if err != nil && err.Error() != test.expectedError {
			t.Errorf("For input %q, expected error %q, but got %q", test.input, test.expectedError, err.Error())
		}
	}
}

func TestGetObject(t *testing.T) {
	// Add test cases for GetObject function here
}

func TestBool(t *testing.T) {
	// Add test cases for the Bool function here
}

func TestParseValue(t *testing.T) {
	// Add your test cases here
}

func TestGetKV(t *testing.T) {
	// Write your test cases for the getKV function here
}

func TestStringBytes(t *testing.T) {
	// Create a new Value with a string value
	v := NewStringValue("test")

	// Call the StringBytes method on the Value
	b, err := v.StringBytes()

	// Check if the error is nil
	if err != nil {
		t.Errorf("Expected error to be nil, got: %v", err)
	}

	// Check if the returned value is of type []byte
	if reflect.TypeOf(b).Kind() != reflect.Slice || reflect.TypeOf(b).Elem().Kind() != reflect.Uint8 {
		t.Errorf("Expected return value to be of type []byte, got: %v", reflect.TypeOf(b))
	}
}

