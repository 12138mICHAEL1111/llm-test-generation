func TestGetStringBytes(t *testing.T) {
	// Add your test cases for GetStringBytes function here
}

func TestValue_Object(t *testing.T) {
	// Add test cases here
}

func TestObject_getKV(t *testing.T) {
	obj := &Object{
		kvs: []kv{},
	}

	kv := obj.getKV()

	// Perform assertions or validations here
	// For example, check if the returned kv is not nil
	if kv == nil {
		t.Error("Expected non-nil kv, but got nil")
	}
}

func TestUnescapeStringBestEffort(t *testing.T) {
	// Test cases for unescaping strings
	tests := []struct {
		input    string
		expected string
	}{
		{`Hello\nWorld`, "Hello\nWorld"},
		{`This is a \"test\" string`, `This is a "test" string`},
		{`Unicode \u00A9 example`, "Unicode Â© example"},
		{`Escaped backslash \\`, `Escaped backslash \`},
		{`New line \n tab \t`, "New line \n tab \t"},
	}

	for _, test := range tests {
		result := unescapeStringBestEffort(test.input)
		if result != test.expected {
			t.Errorf("Unexpected result. Input: %s, Expected: %s, Got: %s", test.input, test.expected, result)
		}
	}
}

func TestParseObject(t *testing.T) {
	// Add your test cases for the parseObject function here
	t.Error("Test not implemented")
}

func TestValue_Type(t *testing.T) {
	// Write your test cases for the Type function here
}

func TestSkipWSSlow(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"   hello", "   hello"},
		{"\n\tworld", "\n\tworld"},
		{"\rtest", "\rtest"},
		{"  \n  \t\rtext", "text"},
		{"", ""},
		{"abc", "abc"},
	}

	for _, test := range tests {
		result := skipWSSlow(test.input)
		if result != test.expected {
			t.Errorf("skipWSSlow(%v) = %v; want %v", test.input, result, test.expected)
		}
	}
}

func TestExists(t *testing.T) {
	// add test cases for Exists function here
}

func TestValue_GetFloat64(t *testing.T) {
	// Test cases
}

func TestMarshalTo(t *testing.T) {
	v := fastjson.Value{
		t: fastjson.TypeString,
		s: "test",
	}

	expected := []byte{'"', 't', 'e', 's', 't', '"'}
	
	result := v.MarshalTo([]byte{})
	
	if !bytes.Equal(result, expected) {
		t.Errorf("MarshalTo returned unexpected result. Expected: %v, Got: %v", expected, result)
	}
}

func TestEscapeString(t *testing.T) {
	testCases := []struct {
		input    string
		expected string
	}{
		{input: "", expected: `""`},
		{input: "abc", expected: `"abc"`},
		{input: "\"", expected: `"\\"`},
		{input: "abc\"", expected: `"abc\""`},
	}

	for _, tc := range testCases {
		var dst []byte
		result := escapeString(dst, tc.input)
		if string(result) != tc.expected {
			t.Errorf("Failed for input: %s, expected: %s, got: %s", tc.input, tc.expected, string(result))
		}
	}
}

func TestValue_Get(t *testing.T) {
	tests := []struct {
		name  string
		value *Value
		keys  []string
		want  *Value
	}{
		{
			name:  "Get key from object",
			value: &Value{t: TypeObject, o: Object{kvs: []kv{{k: "key", v: &Value{t: TypeString, s: "value"}}}}},
			keys:  []string{"key"},
			want:  &Value{t: TypeString, s: "value"},
		},
		{
			name:  "Get invalid key from object",
			value: &Value{t: TypeObject, o: Object{kvs: []kv{{k: "key", v: &Value{t: TypeString, s: "value"}}}}},
			keys:  []string{"invalid"},
			want:  nil,
		},
		{
			name:  "Get element from array",
			value: &Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: "1"}, {t: TypeNumber, s: "2"}, {t: TypeNumber, s: "3"}}},
			keys:  []string{"1"},
			want:  &Value{t: TypeNumber, s: "2"},
		},
		{
			name:  "Get invalid element from array",
			value: &Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: "1"}, {t: TypeNumber, s: "2"}, {t: TypeNumber, s: "3"}}},
			keys:  []string{"5"},
			want:  nil,
		},
		{
			name:  "Get key from nil value",
			value: nil,
			keys:  []string{"key"},
			want:  nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.value.Get(tt.keys...); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Get() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestValue_StringBytes(t *testing.T) {
	v := &Value{s: "test string", t: TypeString}

	expectedBytes := []byte("test string")
	expectedError := error(nil)

	bytes, err := v.StringBytes()

	if !reflect.DeepEqual(bytes, expectedBytes) {
		t.Errorf("Expected bytes %v, but got %v", expectedBytes, bytes)
	}

	if !reflect.DeepEqual(err, expectedError) {
		t.Errorf("Expected error %v, but got %v", expectedError, err)
	}
}

func TestObjectUnescapeKeys(t *testing.T) {
	obj := Object{
		kvs: []kv{
			{k: "key1", v: &Value{}},
			{k: "key2", v: &Value{}},
		},
		keysUnescaped: false,
	}

	obj.unescapeKeys()

	for _, kv := range obj.kvs {
		if kv.k == "" || kv.v == nil {
			t.Error("Key or value should not be empty after unescaping")
		}
	}

	if !obj.keysUnescaped {
		t.Error("Object keys should be marked as unescaped")
	}
}

func TestVisit(t *testing.T) {
	obj := &fastjson.Object{
		kvs: []fastjson.kv{
			{k: "key1", v: &fastjson.Value{s: "value1"}},
			{k: "key2", v: &fastjson.Value{s: "value2"}},
			{k: "key3", v: &fastjson.Value{s: "value3"}},
		},
		keysUnescaped: false,
	}

	obj.Visit(func(key []byte, v *fastjson.Value) {
		t.Logf("Key: %s, Value: %s", string(key), v.s)
	})
}

func TestValue_GetArray(t *testing.T) {
	v := &Value{
		a: []*Value{
			{t: TypeString, s: "apple"},
			{t: TypeString, s: "banana"},
			{t: TypeString, s: "orange"},
		},
	}

	// Test case where keys are provided
	keys := []string{"fruits"}
	result := v.GetArray(keys...)
	expected := []*Value{
		{t: TypeString, s: "apple"},
		{t: TypeString, s: "banana"},
		{t: TypeString, s: "orange"},
	}

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}

	// Test case where keys are not valid
	keys = []string{"vegetables"}
	result = v.GetArray(keys...)
	if result != nil {
		t.Errorf("Expected nil, but got %v", result)
	}

	// Test case where v is nil
	v = nil
	keys = []string{"fruits"}
	result = v.GetArray(keys...)
	if result != nil {
		t.Errorf("Expected nil, but got %v", result)
	}
}

func TestValue_Array(t *testing.T) {
	value := &Value{
		t: TypeArray,
		a: []*Value{
			&Value{t: TypeString, s: "apple"},
			&Value{t: TypeString, s: "banana"},
			&Value{t: TypeString, s: "orange"},
		},
	}

	arr, err := value.Array()

	if err != nil {
		t.Errorf("Error encountered: %v", err)
	}

	expected := []*Value{
		&Value{t: TypeString, s: "apple"},
		&Value{t: TypeString, s: "banana"},
		&Value{t: TypeString, s: "orange"},
	}

	if !reflect.DeepEqual(arr, expected) {
		t.Errorf("Arrays do not match. Expected: %v, Got: %v", expected, arr)
	}
}

func TestReset(t *testing.T) {
	// Create an Object to test the reset function
	obj := &Object{
		kvs: []kv{
			{"key1", &Value{}},
			{"key2", &Value{}},
		},
		keysUnescaped: true,
	}

	// Call the reset function
	obj.reset()

	// Check if kvs is empty after reset
	if len(obj.kvs) != 0 {
		t.Errorf("Expected kvs to be empty after reset, got %v", obj.kvs)
	}

	// Check if keysUnescaped is set to false after reset
	if obj.keysUnescaped {
		t.Error("Expected keysUnescaped to be false after reset, got true")
	}
}

func TestValue_GetUint64(t *testing.T) {
	value := &Value{s: "123"}
	result := value.GetUint64()
	assert.Equal(t, uint64(123), result)

	value = &Value{t: TypeNumber, s: "456"}
	result = value.GetUint64()
	assert.Equal(t, uint64(456), result)

	value = &Value{t: TypeString, s: "abc"}
	result = value.GetUint64()
	assert.Equal(t, uint64(0), result)

	value = nil
	result = value.GetUint64()
	assert.Equal(t, uint64(0), result)
}

func TestUint(t *testing.T) {
	// Create a test Value with a number
	v := &Value{s: "42", t: TypeNumber}

	// Test the Uint function with the test Value
	u, err := v.Uint()
	if err != nil {
		t.Errorf("Uint() returned an error: %v", err)
	}

	// Check if the returned uint value is correct
	if u != 42 {
		t.Errorf("Uint() returned incorrect uint value: got %d, want %d", u, 42)
	}

	// Test the Uint function with a non-numeric Value
	v.t = TypeString
	_, err = v.Uint()
	if err == nil {
		t.Errorf("Uint() did not return an error for non-numeric value")
	}
}

func TestParse(t *testing.T) {
	// Test cases for Parse function
}



func TestValue_Int(t *testing.T) {
	// Test cases
	tests := []struct {
		input string
		want  int
		err   bool
	}{
		{"123", 123, false},
		{"-456", -456, false},
		{"notanumber", 0, true},
		{"999999999999999999999999999999999999999999999999", 0, true}, // Number too large for int
	}

	// Create Value object
	value := &Value{s: ""} // You can initialize the object with appropriate values

	// Run tests
	for _, test := range tests {
		value.s = test.input
		got, err := value.Int()

		if test.err && err == nil {
			t.Errorf("Input: %s - Expected error but none occurred", test.input)
		}

		if !test.err && err != nil {
			t.Errorf("Input: %s - Expected no error but got: %v", test.input, err)
		}

		if got != test.want {
			t.Errorf("Input: %s - Expected: %d, Got: %d", test.input, test.want, got)
		}
	}
}

func TestValue_Uint64(t *testing.T) {
	testCases := []struct {
		name          string
		value         fastjson.Value
		expectedValue uint64
		expectedError bool
	}{
		{
			name:          "Valid JSON number",
			value:         fastjson.Value{Type: fastjson.TypeNumber, s: "42"},
			expectedValue: 42,
			expectedError: false,
		},
		{
			name:          "Invalid JSON type",
			value:         fastjson.Value{Type: fastjson.TypeString, s: "42"},
			expectedValue: 0,
			expectedError: true,
		},
		{
			name:          "Invalid JSON number",
			value:         fastjson.Value{Type: fastjson.TypeNumber, s: "not_a_number"},
			expectedValue: 0,
			expectedError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result, err := tc.value.Uint64()

			if !tc.expectedError && err != nil {
				t.Errorf("Expected no error, got %v", err)
			}

			if result != tc.expectedValue {
				t.Errorf("Expected value %d, got %d", tc.expectedValue, result)
			}
		})
	}
}

func TestParseRawKey(t *testing.T) {
	tests := []struct {
		input          string
		expectedBefore string
		expectedAfter  string
		expectError    bool
	}{
		{input: `"key":"value"`, expectedBefore: "key", expectedAfter: ":\"value\"", expectError: false},
		{input: `\"key":"value"`, expectedBefore: `key`, expectedAfter: `:"value"`, expectError: false},
		{input: `missing`, expectedBefore: `missing`, expectedAfter: ``, expectError: true},
	}

	for _, test := range tests {
		before, after, err := parseRawKey(test.input)

		if before != test.expectedBefore || after != test.expectedAfter {
			t.Errorf("For input: %s, expected: (%s, %s), got: (%s, %s)", test.input, test.expectedBefore, test.expectedAfter, before, after)
		}

		if test.expectError && err == nil {
			t.Errorf("For input: %s, expected an error but got none", test.input)
		}

		if !test.expectError && err != nil {
			t.Errorf("For input: %s, expected no error but got: %v", test.input, err)
		}
	}
}

func TestParseValue(t *testing.T) {
	// Add test cases for parseValue function here
	// Make sure to cover different scenarios and edge cases
}

func TestParseBytes(t *testing.T) {
	p := &Parser{}
	input := []byte(`{"key": "value"}`)
	expected := &Value{
		o: Object{
			kvs: []kv{
				{
					k: "key",
					v: &Value{
						s: "value",
						t: TypeString,
					},
				},
			},
			keysUnescaped: false,
		},
	}
	result, err := p.ParseBytes(input)

	if err != nil {
		t.Errorf("ParseBytes returned an error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("ParseBytes did not return the expected result")
	}
}

func TestParseArray(t *testing.T) {
	// Add your test cases for parseArray function here
}

func TestValue_Int64(t *testing.T) {
	value := &fastjson.Value{t: fastjson.TypeNumber, s: "123"}
	expected := int64(123)

	result, err := value.Int64()

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if result != expected {
		t.Errorf("Int64() = %d; want %d", result, expected)
	}
}

func TestValue_Int64_TypeError(t *testing.T) {
	value := &fastjson.Value{t: fastjson.TypeString, s: "abc"}

	_, err := value.Int64()

	if err == nil {
		t.Error("Expected error, got nil")
	}
}

func TestValue_Int64_ParseError(t *testing.T) {
	value := &fastjson.Value{t: fastjson.TypeNumber, s: "abc"}

	_, err := value.Int64()

	if err == nil {
		t.Error("Expected error, got nil")
	}
}

func TestCache_getValue(t *testing.T) {
	cache := cache{
		vs: []Value{},
	}

	value := cache.getValue()

	if value == nil {
		t.Error("Expected non-nil value, got nil")
	}

	// Add more assertions based on the behavior of getValue() function
}

func TestType_String(t *testing.T) {
	tests := []struct {
		name     string
		t        Type
		expected string
	}{
		{"Object", TypeObject, "object"},
		{"Array", TypeArray, "array"},
		{"String", TypeString, "string"},
		{"Number", TypeNumber, "number"},
		{"True", TypeTrue, "true"},
		{"False", TypeFalse, "false"},
		{"Null", TypeNull, "null"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.t.String()
			if result != tt.expected {
				t.Errorf("Expected %s, but got %s", tt.expected, result)
			}
		})
	}
}

func TestParseRawString(t *testing.T) {
	// Add your test cases for parseRawString function here
}

func TestParseRawNumber(t *testing.T) {
	tests := []struct {
		input       string
		expectedNs  string
		expectedRem string
		expectedErr error
	}{
		{input: "123.456", expectedNs: "123.456", expectedRem: "", expectedErr: nil},
		{input: "-789.0E+24", expectedNs: "-789.0E+24", expectedRem: "", expectedErr: nil},
		{input: "NaN", expectedNs: "", expectedRem: "", expectedErr: fmt.Errorf("unexpected char: %q", "N")},
		{input: "invalid", expectedNs: "", expectedRem: "invalid", expectedErr: nil},
	}

	for _, test := range tests {
		ns, rem, err := parseRawNumber(test.input)

		if ns != test.expectedNs {
			t.Errorf("For input %q, expected ns: %q, got: %q", test.input, test.expectedNs, ns)
		}

		if rem != test.expectedRem {
			t.Errorf("For input %q, expected rem: %q, got: %q", test.input, test.expectedRem, rem)
		}

		if err != test.expectedErr {
			t.Errorf("For input %q, expected err: %v, got: %v", test.input, test.expectedErr, err)
		}
	}
}

func TestValue_GetUint(t *testing.T) {
	// create test cases for GetUint function
	tests := []struct {
		input       *Value
		keys        []string
		expected    uint
		expectedErr bool
	}{
		// Add test cases here
	}

	// run tests
	for _, tc := range tests {
		result := tc.input.GetUint(tc.keys...)
		if result != tc.expected {
			t.Errorf("For keys %v, expected %d but got %d", tc.keys, tc.expected, result)
		}
	}
}

func TestLen(t *testing.T) {
	obj := fastjson.Object{
		kvs: []fastjson.kv{
			{k: "key1", v: &fastjson.Value{}},
			{k: "key2", v: &fastjson.Value{}},
			{k: "key3", v: &fastjson.Value{}},
		},
		keysUnescaped: false,
	}

	expectedLen := 3
	actualLen := obj.Len()

	if actualLen != expectedLen {
		t.Errorf("Length of object kvs incorrect, got: %d, want: %d", actualLen, expectedLen)
	}
}

func TestValue_Bool(t *testing.T) {
	tests := []struct {
		input    Value
		expected bool
		err      error
	}{
		{Value{t: TypeTrue}, true, nil},
		{Value{t: TypeFalse}, false, nil},
		{Value{t: TypeNull}, false, fmt.Errorf("value doesn't contain bool; it contains %s", TypeNull)},
	}

	for _, test := range tests {
		result, err := test.input.Bool()
		if result != test.expected {
			t.Errorf("Expected %v, but got %v", test.expected, result)
		}
		if (err != nil && test.err == nil) || (err == nil && test.err != nil) || (err != nil && test.err != nil && err.Error() != test.err.Error()) {
			t.Errorf("Expected error: %v, but got error: %v", test.err, err)
		}
	}
}

func TestValue_GetInt(t *testing.T) {
	value := &Value{s: "123"}
	result := value.GetInt()
	if result != 123 {
		t.Errorf("GetInt() = %d; want 123", result)
	}
	
	value2 := &Value{s: "abc"}
	result2 := value2.GetInt()
	if result2 != 0 {
		t.Errorf("GetInt() = %d; want 0", result2)
	}
}

func TestSkipWS(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{input: "   hello", expected: "   hello"},
		{input: "\nworld", expected: "\nworld"},
		{input: "\t\tgoodbye", expected: "\t\tgoodbye"},
		{input: "", expected: ""},
		{input: "normal", expected: "normal"},
	}

	for _, test := range tests {
		result := skipWS(test.input)
		if result != test.expected {
			t.Errorf("skipWS(%s) = %s; want %s", test.input, result, test.expected)
		}
	}
}

func TestValue_GetInt64(t *testing.T) {
	// Create a test case
	tests := []struct {
		input  string
		keys   []string
		output int64
	}{
		{`{"value": 100}`, "value", 100},
		{`{"value": -50}`, "value", -50},
		{`{"value": "invalid"}`, "value", 0},
		{`{"nested": {"key": 123}}`, "nested", 123},
	}

	// Run test cases
	for _, test := range tests {
		v := Parse(test.input)
		result := v.GetInt64(test.keys...)

		if result != test.output {
			t.Errorf("GetInt64(%s) = %d; want %d", test.keys, result, test.output)
		}
	}
}

func TestHasSpecialChars(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{input: "", expected: false},
		{input: "Hello, World!", expected: false},
		{input: "Special Character: \"", expected: true},
		{input: "Special Character: \\ ", expected: true},
		{input: "Control Character: \x1F", expected: true},
	}

	for _, test := range tests {
		result := hasSpecialChars(test.input)
		if result != test.expected {
			t.Errorf("For input '%s', expected %t but got %t", test.input, test.expected, result)
		}
	}
}

func TestGetObject(t *testing.T) {
	// Test cases for GetObject function
}

func TestValue_Float64(t *testing.T) {
	// Create a sample Value with a number
	v := &Value{s: "123.45", t: TypeNumber}

	// Expected result
	expected := 123.45

	// Call the Float64() method
	result, err := v.Float64()

	// Check if error is nil
	if err != nil {
		t.Errorf("Float64() returned an error: %v", err)
	}

	// Check if the result matches the expected value
	if result != expected {
		t.Errorf("Float64() returned %f, expected %f", result, expected)
	}
}

