func TestUint(t *testing.T) {
	tests := []struct {
		input  string
		output uint
		err    bool
	}{
		{input: "123", output: 123, err: false},
		{input: "abc", output: 0, err: true},
		{input: "18446744073709551615", output: 0, err: true}, // larger than maximum uint value
	}

	for _, test := range tests {
		v := &Value{s: test.input}
		result, err := v.Uint()

		if test.err && err == nil {
			t.Errorf("Expected error for input %s, but got nil", test.input)
		}

		if !test.err && err != nil {
			t.Errorf("Unexpected error for input %s: %v", test.input, err)
		}

		if result != test.output {
			t.Errorf("For input %s, expected %d but got %d", test.input, test.output, result)
		}
	}
}
func TestUint64(t *testing.T) {
	tests := []struct {
		input    string
		expected uint64
	}{
		{"123", 123},
		{"0", 0},
		{"18446744073709551615", 18446744073709551615}, // Max uint64 value
		{"-123", 0}, // Invalid input, expected 0
		{"abc", 0},  // Invalid input, expected 0
	}

	for _, test := range tests {
		v := &Value{s: test.input}
		result, err := v.Uint64()

		if err != nil {
			t.Errorf("Uint64() returned an error for input %s: %v", test.input, err)
		}

		if result != test.expected {
			t.Errorf("Uint64() returned %d for input %s, expected %d", result, test.input, test.expected)
		}
	}
}
func TestCache_getValue(t *testing.T) {
	cache := &cache{
		vs: make([]Value, 0),
	}

	value := cache.getValue()

	if value == nil {
		t.Error("Expected non-nil value, got nil")
	}

	if len(cache.vs) != 1 {
		t.Errorf("Expected cache length to be 1, got %d", len(cache.vs))
	}

	if &cache.vs[0] != value {
		t.Error("Expected returned value to be the last element in cache")
	}
}
func TestParseArray(t *testing.T) {
	// Test case 1: empty array
	s := "[]"
	c := &cache{}
	depth := 0
	expectedValue := &Value{t: TypeArray, a: []*Value{}}
	expectedRemaining := ""
	expectedError := nil

	resultValue, resultRemaining, resultError := parseArray(s, c, depth)

	if resultValue != expectedValue {
		t.Errorf("Expected value %v, but got %v", expectedValue, resultValue)
	}
	if resultRemaining != expectedRemaining {
		t.Errorf("Expected remaining %v, but got %v", expectedRemaining, resultRemaining)
	}
	if resultError != expectedError {
		t.Errorf("Expected error %v, but got %v", expectedError, resultError)
	}
}
func TestParseRawNumber(t *testing.T) {
	s := "123.45"
	expectedNs := "123.45"
	expectedRemain := ""
	expectedErr := nil

	ns, remain, err := parseRawNumber(s)

	if ns != expectedNs {
		t.Errorf("Expected ns: %s, but got: %s", expectedNs, ns)
	}

	if remain != expectedRemain {
		t.Errorf("Expected remain: %s, but got: %s", expectedRemain, remain)
	}

	if err != expectedErr {
		t.Errorf("Expected error: %v, but got: %v", expectedErr, err)
	}
}
func TestLen(t *testing.T) {
	obj := &Object{kvs: map[string]interface{}{"key1": "value1", "key2": "value2"}}

	expected := 2
	result := obj.Len()

	if result != expected {
		t.Errorf("Len() returned incorrect result, got: %d, want: %d", result, expected)
	}
}
func TestGetFloat64(t *testing.T) {
	value := parseJSON([]byte(`{"key": 123.45}`))

	result := value.GetFloat64("key")

	expected := 123.45
	if result != expected {
		t.Errorf("Expected: %f, but got: %f", expected, result)
	}
}
func TestValue_Int(t *testing.T) {
	// Create a test case where the value contains a valid integer number
	// Create a test case where the value does not contain a number
	// Create a test case where the number does not fit into an int
	// Add more test cases as needed
}
func TestType(t *testing.T) {
	v := &Value{t: typeRawString, s: "test"}
	expectedType := TypeString

	result := v.Type()

	if result != expectedType {
		t.Errorf("Expected type to be %v, but got %v", expectedType, result)
	}
}
func TestInt64(t *testing.T) {
	tests := []struct {
		input    string
		expected int64
	}{
		{input: "123", expected: 123},
		{input: "-456", expected: -456},
		{input: "abc", expected: 0}, // Invalid input should return 0
	}

	for _, test := range tests {
		v := &Value{s: test.input}
		result, err := v.Int64()
		if err != nil {
			t.Errorf("Int64() returned an error: %v", err)
		}
		if result != test.expected {
			t.Errorf("Int64() returned %d, expected %d", result, test.expected)
		}
	}
}
func TestReset(t *testing.T) {
	obj := &Object{
		kvs:           []kv{{"key1", "value1"}, {"key2", "value2"}},
		keysUnescaped: true,
	}

	obj.reset()

	if len(obj.kvs) != 0 {
		t.Errorf("Expected kvs to be empty after reset, but got %v", obj.kvs)
	}

	if obj.keysUnescaped {
		t.Error("Expected keysUnescaped to be false after reset, but it is still true")
	}
}
func TestSkipWSSlow(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"   hello", "hello"},
		{"\nworld", "world"},
		{"\t\t\tgoodbye", "goodbye"},
		{"\r\r\rwelcome", "welcome"},
		{"12345", "12345"},
		{"", ""},
	}

	for _, test := range tests {
		result := skipWSSlow(test.input)
		if result != test.expected {
			t.Errorf("skipWSSlow(%s) = %s; want %s", test.input, result, test.expected)
		}
	}
}
func TestValue_Get(t *testing.T) {
	v := &Value{
		t: TypeObject,
		o: &Object{},
	}
	v.o.Set("key1", &Value{t: TypeNumber})
	v.o.Set("key2", &Value{t: TypeString})

	// Test getting existing keys
	result1 := v.Get("key1")
	if result1 == nil {
		t.Error("Expected non-nil result for key1, got nil")
	}

	result2 := v.Get("key2")
	if result2 == nil {
		t.Error("Expected non-nil result for key2, got nil")
	}

	// Test getting non-existing key
	result3 := v.Get("key3")
	if result3 != nil {
		t.Error("Expected nil result for key3, got non-nil")
	}
}
///warning///
package fastjson

import (
	"reflect"
	"testing"
)

func TestGetArray(t *testing.T) {
	value := &Value{
		t: TypeArray,
		a: []*Value{
			{t: TypeNumber, n: 1},
			{t: TypeString, s: "hello"},
			{t: TypeObject, o: map[string]*Value{"key": {t: TypeBoolean, b: true}},
		},
	}

	tests := []struct {
		name     string
		keys     []string
		expected []*Value
	}{
		{
			name:     "Valid array",
			keys:     []string{},
			expected: value.a,
		},
		{
			name:     "Empty keys",
			keys:     []string{},
			expected: nil,
		},
		{
			name:     "Invalid type",
			keys:     []string{"key"},
			expected: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := value.GetArray(tt.keys...)
			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("Expected %v, but got %v", tt.expected, result)
			}
		})
	}
}
func TestSkipWS(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"   hello", "   hello"},
		{"world", "world"},
		{"\t\t\tgoodbye", "\t\t\tgoodbye"},
		{"", ""},
		{"\n\n\n", "\n\n\n"},
	}

	for _, test := range tests {
		result := skipWS(test.input)
		if result != test.expected {
			t.Errorf("Expected skipWS(%s) to be %s, but got %s", test.input, test.expected, result)
		}
	}
}
func TestParseObject(t *testing.T) {
	c := newCache()
	depth := 0

	t.Run("ParseObject_ValidInput", func(t *testing.T) {
		input := `{"key1": "value1", "key2": 123}`
		expectedRemaining := ""
		expectedError := nil

		result, remaining, err := parseObject(input, c, depth)

		if remaining != expectedRemaining {
			t.Errorf("Expected remaining string: %s, but got: %s", expectedRemaining, remaining)
		}

		if err != expectedError {
			t.Errorf("Expected error: %v, but got: %v", expectedError, err)
		}

		// Add more assertions to validate the result object
	})

	// Add more test cases for different scenarios
}
func TestHasSpecialChars(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{"hello", false},
		{"world", false},
		{"hello world", false},
		{"hello\"world", true},
		{"hello\\world", true},
		{"hello\nworld", true},
		{"hello\tworld", true},
		{"hello\vworld", true},
		{"hello\rworld", true},
		{"hello\x00world", true},
	}

	for _, test := range tests {
		result := hasSpecialChars(test.input)
		if result != test.expected {
			t.Errorf("Expected hasSpecialChars(%s) to be %t, but got %t", test.input, test.expected, result)
		}
	}
}
func TestUnescapeStringBestEffort(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"Hello,\\nWorld!", "Hello,\nWorld!"},
		{"This is a \\\"test\\\" string", "This is a \"test\" string"},
		{"Unicode: \\u0048\\u0065\\u006c\\u006c\\u006f", "Unicode: Hello"},
		{"Invalid Unicode: \\u123", "Invalid Unicode: \\u123"},
		{"Escaped backslash: \\\\", "Escaped backslash: \\"},
	}

	for _, test := range tests {
		result := unescapeStringBestEffort(test.input)
		if result != test.expected {
			t.Errorf("Input: %s, Expected: %s, Got: %s", test.input, test.expected, result)
		}
	}
}
func TestGetInt(t *testing.T) {
	// Create a test Value object
	value := &Value{
		s: "123",
	}

	// Test case 1: Valid input
	result := value.GetInt()
	expected := 123
	if result != expected {
		t.Errorf("Expected: %d, but got: %d", expected, result)
	}

	// Test case 2: Invalid input
	value = &Value{
		s: "abc",
	}
	result = value.GetInt()
	expected = 0
	if result != expected {
		t.Errorf("Expected: %d, but got: %d", expected, result)
	}
}
func TestGetBool(t *testing.T) {
	value := &Value{t: TypeTrue}
	result := value.GetBool()
	if !result {
		t.Errorf("Expected true, got false")
	}

	value = &Value{t: TypeFalse}
	result = value.GetBool()
	if result {
		t.Errorf("Expected false, got true")
	}

	// Add more test cases here
}
func TestObject(t *testing.T) {
	v := &Value{t: TypeObject, o: Object{}}

	obj, err := v.Object()

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if reflect.TypeOf(obj) != reflect.TypeOf(&Object{}) {
		t.Errorf("Expected object type to be Object, got %v", reflect.TypeOf(obj))
	}
}
func TestGetStringBytes(t *testing.T) {
	value := &Value{s: "test"}
	expected := []byte("test")

	result := value.GetStringBytes()

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}
}
func TestArray(t *testing.T) {
	v := &Value{
		t: TypeArray,
		a: []*Value{
			{t: TypeNumber, n: "1"},
			{t: TypeString, s: "hello"},
		},
	}

	arr, err := v.Array()
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	expected := []*Value{
		{t: TypeNumber, n: "1"},
		{t: TypeString, s: "hello"},
	}

	if !reflect.DeepEqual(arr, expected) {
		t.Errorf("Arrays do not match. Expected: %v, Got: %v", expected, arr)
	}
}
func TestFloat64(t *testing.T) {
	tests := []struct {
		input  string
		output float64
		err    bool
	}{
		{input: "123.45", output: 123.45, err: false},
		{input: "abc", output: 0, err: true},
		{input: "789", output: 789, err: false},
	}

	for _, test := range tests {
		v := &Value{s: test.input}
		result, err := v.Float64()

		if test.err && err == nil {
			t.Errorf("Expected error for input %s, but got nil", test.input)
		}

		if !test.err && err != nil {
			t.Errorf("Unexpected error for input %s: %s", test.input, err.Error())
		}

		if result != test.output {
			t.Errorf("Expected output %f for input %s, but got %f", test.output, test.input, result)
		}
	}
}
func TestEscapeString(t *testing.T) {
	// Test case 1: string with special characters
	dst := make([]byte, 0)
	s := "Hello, \"world\"!"
	expected := []byte(`"Hello, \"world\"!"`)
	result := escapeString(dst, s)
	if string(result) != string(expected) {
		t.Errorf("Expected %s, but got %s", expected, result)
	}

	// Test case 2: string without special characters
	dst = make([]byte, 0)
	s = "Hello world"
	expected = []byte(`"Hello world"`)
	result = escapeString(dst, s)
	if string(result) != string(expected) {
		t.Errorf("Expected %s, but got %s", expected, result)
	}
}
func TestParseRawKey(t *testing.T) {
	tests := []struct {
		input       string
		expectedKey string
		expectedRem string
		expectedErr error
	}{
		{`"key":"value"`, "key", ":\"value\"", nil},
		{`"key":"value`, "", "", fmt.Errorf(`missing closing '"'`)},
		{`"key":"val\"ue"`, "key", ":\"val\\\"ue\"", nil},
	}

	for _, test := range tests {
		key, rem, err := parseRawKey(test.input)
		if key != test.expectedKey || rem != test.expectedRem || !reflect.DeepEqual(err, test.expectedErr) {
			t.Errorf("parseRawKey(%s) = (%s, %s, %v), expected (%s, %s, %v)", test.input, key, rem, err, test.expectedKey, test.expectedRem, test.expectedErr)
		}
	}
}
func TestExists(t *testing.T) {
	v := &Value{} // Create a new instance of Value
	v.Set("key", "value") // Set a key-value pair for testing

	// Test case 1: Check if key "key" exists
	if !v.Exists("key") {
		t.Errorf("Expected key 'key' to exist, but it does not")
	}

	// Test case 2: Check if key "nonexistent" exists
	if v.Exists("nonexistent") {
		t.Errorf("Expected key 'nonexistent' to not exist, but it does")
	}
}
func TestGetInt64(t *testing.T) {
	value := NewFromBytes([]byte(`{"key": 123}`))

	result := value.GetInt64("key")
	expected := int64(123)

	if result != expected {
		t.Errorf("Expected %d, but got %d", expected, result)
	}
}
func TestGetUint64(t *testing.T) {
	value := Parse([]byte(`{"key": 123}`))

	result := value.GetUint64("key")
	expected := uint64(123)

	if result != expected {
		t.Errorf("Expected %d, but got %d", expected, result)
	}
}
func TestType_String(t *testing.T) {
	tests := []struct {
		name string
		t    Type
		want string
	}{
		{name: "Object", t: TypeObject, want: "object"},
		{name: "Array", t: TypeArray, want: "array"},
		{name: "String", t: TypeString, want: "string"},
		{name: "Number", t: TypeNumber, want: "number"},
		{name: "True", t: TypeTrue, want: "true"},
		{name: "False", t: TypeFalse, want: "false"},
		{name: "Null", t: TypeNull, want: "null"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.t.String(); got != tt.want {
				t.Errorf("Type.String() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestUnescapeKeys(t *testing.T) {
	// create an Object with escaped keys
	obj := Object{
		keysUnescaped: false,
		kvs: []keyValue{
			{`\"key1\"`, "value1"},
			{`\"key2\"`, "value2"},
		},
	}

	// call unescapeKeys method
	obj.unescapeKeys()

	// check if keys are unescaped
	for _, kv := range obj.kvs {
		if kv.k == `\"key1\"` || kv.k == `\"key2\"` {
			t.Errorf("Key was not unescaped: %s", kv.k)
		}
	}

	// check if keysUnescaped flag is set to true
	if !obj.keysUnescaped {
		t.Error("keysUnescaped flag was not set to true")
	}
}
func TestVisit(t *testing.T) {
	obj := &Object{
		kvs: []keyValue{
			{[]byte("key1"), &Value{}},
			{[]byte("key2"), &Value{}},
			{[]byte("key3"), &Value{}},
		},
	}

	visitedKeys := make(map[string]bool)
	obj.Visit(func(key []byte, v *Value) {
		visitedKeys[string(key)] = true
	})

	// Check if all keys were visited
	if len(visitedKeys) != 3 || !visitedKeys["key1"] || !visitedKeys["key2"] || !visitedKeys["key3"] {
		t.Errorf("Visit function did not visit all keys")
	}
}
func TestMarshalTo(t *testing.T) {
	tests := []struct {
		name string
		v    *Value
		dst  []byte
		want []byte
	}{
		// Add test cases here
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.v.MarshalTo(tt.dst); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MarshalTo() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestGetUint(t *testing.T) {
	v := &Value{
		s: "123",
	}

	result := v.GetUint()
	expected := uint(123)

	if result != expected {
		t.Errorf("Expected %d, but got %d", expected, result)
	}
}
func TestParser_Parse(t *testing.T) {
	parser := &Parser{}
	
	tests := []struct {
		input    string
		expected *Value
	}{
		{`{"key": "value"}`, &Value{Type: TypeObject}},
		{`[1, 2, 3]`, &Value{Type: TypeArray}},
		{`"string"`, &Value{Type: TypeString}},
		{`123`, &Value{Type: TypeNumber}},
		{`true`, &Value{Type: TypeTrue}},
		{`false`, &Value{Type: TypeFalse}},
		{`null`, &Value{Type: TypeNull}},
	}
	
	for _, test := range tests {
		result, err := parser.Parse(test.input)
		if err != nil {
			t.Errorf("Error parsing JSON: %v", err)
		}
		
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("Expected %v, but got %v", test.expected, result)
		}
	}
}
func TestParseBytes(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected *Value
	}{
		// Add test cases here
	}

	p := &Parser{}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := p.ParseBytes(tt.input)
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
			}

			if !reflect.DeepEqual(result, tt.expected) {
				t.Errorf("Unexpected result. Expected: %v, Got: %v", tt.expected, result)
			}
		})
	}
}
func TestParseRawString(t *testing.T) {
	tests := []struct {
		input          string
		expectedPrefix string
		expectedSuffix string
		expectedError  string
	}{
		{"\"hello\"", "hello", "", ""},
		{"\"hello\\\"world\"", "hello\\\"world", "", ""},
		{"\"hello\\\"world", "", "", "missing closing '\"'"},
		{"\"hello\\\\\"", "hello\\", "", ""},
		{"\"hello\\\\\\\"", "hello\\\\", "", ""},
		{"\"hello\\\\\\\"world", "", "", "missing closing '\"'"},
	}

	for _, test := range tests {
		prefix, suffix, err := parseRawString(test.input)

		if prefix != test.expectedPrefix {
			t.Errorf("For input %q, expected prefix %q, but got %q", test.input, test.expectedPrefix, prefix)
		}

		if suffix != test.expectedSuffix {
			t.Errorf("For input %q, expected suffix %q, but got %q", test.input, test.expectedSuffix, suffix)
		}

		if err != nil && err.Error() != test.expectedError {
			t.Errorf("For input %q, expected error %q, but got %q", test.input, test.expectedError, err.Error())
		}
	}
}
func TestGetObject(t *testing.T) {
	value := NewFromBytes([]byte(`{"key1": "value1", "key2": {"nestedKey": "nestedValue"}}`))
	obj := value.GetObject("key2")

	if obj == nil {
		t.Error("Expected non-nil object, got nil")
	}

	expected := map[string]*Value{
		"nestedKey": NewFromInterface("nestedValue"),
	}
	if !reflect.DeepEqual(obj, expected) {
		t.Errorf("Expected object %v, got %v", expected, obj)
	}
}
func TestBool(t *testing.T) {
	tests := []struct {
		input    *Value
		expected bool
		err      error
	}{
		{NewTrue(), true, nil},
		{NewFalse(), false, nil},
		{NewString("test"), false, fmt.Errorf("value doesn't contain bool; it contains string")},
		// Add more test cases as needed
	}

	for _, test := range tests {
		result, err := test.input.Bool()
		if result != test.expected {
			t.Errorf("Expected Bool() to return %v, but got %v", test.expected, result)
		}
		if err != nil && err.Error() != test.err.Error() {
			t.Errorf("Expected error message to be %q, but got %q", test.err.Error(), err.Error())
		}
	}
}
func TestParseValue(t *testing.T) {
	c := newCache()
	depth := 0

	t.Run("ParseObject", func(t *testing.T) {
		s := `{"key": "value"}`
		v, tail, err := parseValue(s, c, depth)
		if err != nil {
			t.Errorf("Error parsing object: %v", err)
		}
		if v == nil {
			t.Error("Parsed value is nil")
		}
		if tail != "" {
			t.Errorf("Unexpected tail: %s", tail)
		}
		// Add more assertions if needed
	})

	t.Run("ParseArray", func(t *testing.T) {
		s := `["value1", "value2"]`
		v, tail, err := parseValue(s, c, depth)
		if err != nil {
			t.Errorf("Error parsing array: %v", err)
		}
		if v == nil {
			t.Error("Parsed value is nil")
		}
		if tail != "" {
			t.Errorf("Unexpected tail: %s", tail)
		}
		// Add more assertions if needed
	})

	// Add more test cases for other scenarios

}
func TestGetKV(t *testing.T) {
	obj := &Object{
		kvs: []kv{
			{key: "key1", value: "value1"},
			{key: "key2", value: "value2"},
		},
	}

	kv := obj.getKV()

	if !reflect.DeepEqual(kv, &kv{key: "", value: ""}) {
		t.Errorf("Expected empty kv, but got %v", kv)
	}

	// Add more test cases here
}
func TestStringBytes(t *testing.T) {
	// Create a new Value with a string value
	v := &Value{t: TypeString, s: "test"}

	// Call the StringBytes method on the Value
	b, err := v.StringBytes()

	// Check if the error is nil
	if err != nil {
		t.Errorf("Expected error to be nil, got: %v", err)
	}

	// Check if the returned value is of type []byte
	if reflect.TypeOf(b).Kind() != reflect.Slice || reflect.TypeOf(b).Elem().Kind() != reflect.Uint8 {
		t.Errorf("Expected return value to be of type []byte, got: %v", reflect.TypeOf(b))
	}
}
