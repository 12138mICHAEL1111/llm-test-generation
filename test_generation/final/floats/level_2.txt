package floats

import (
	"math"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestAdd(t *testing.T) {
	tests := []struct {
		dst    []float64
		s      []float64
		result []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},
		{[]float64{10, 20, 30}, []float64{1, 2, 3}, []float64{11, 22, 33}},
	}

	for _, test := range tests {
		Add(test.dst, test.s)
		for i := 0; i < len(test.dst); i++ {
			if test.dst[i] != test.result[i] {
				t.Errorf("For dst %v and s %v, expected %v but got %v", test.dst, test.s, test.result, test.dst)
			}
		}
	}

	// Test for panic when lengths do not match
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("Add did not panic when lengths do not match")
		}
	}()
	Add([]float64{1, 2}, []float64{4, 5, 6})
}

func TestAddTo(t *testing.T) {
	type args struct {
		dst []float64
		s   []float64
		t   []float64
	}
	tests := []struct {
		name string
		args args
		want []float64
	}{
		{
			name: "AddTo test case 1",
			args: args{
				dst: []float64{1.0, 2.0, 3.0},
				s:   []float64{4.0, 5.0, 6.0},
				t:   []float64{7.0, 8.0, 9.0},
			},
			want: []float64{11.0, 13.0, 15.0},
		},
		// Add more test cases as needed
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("AddTo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAddConst(t *testing.T) {
	tests := []struct {
		name   string
		c      float64
		dst    []float64
		result []float64
	}{
		{"Test case 1", 5.0, []float64{1.0, 2.0, 3.0}, []float64{6.0, 7.0, 8.0}},
		{"Test case 2", -2.0, []float64{4.0, 5.0, 6.0}, []float64{2.0, 3.0, 4.0}},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			AddConst(test.c, test.dst)
			assert.Equal(t, test.result, test.dst)
		})
	}
}

func TestAddScaled(t *testing.T) {
	tests := []struct {
		dst    []float64
		alpha  float64
		s      []float64
		result []float64
	}{
		{
			dst:    []float64{1, 2, 3},
			alpha:  2,
			s:      []float64{4, 5, 6},
			result: []float64{9, 12, 15},
		},
		{
			dst:    []float64{1, 2, 3},
			alpha:  0,
			s:      []float64{4, 5, 6},
			result: []float64{1, 2, 3},
		},
		// add more test cases as needed
	}

	for _, test := range tests {
		actualResult := make([]float64, len(test.dst))
		copy(actualResult, test.dst)

		AddScaled(actualResult, test.alpha, test.s)

		if !floatSlicesEqual(actualResult, test.result) {
			t.Errorf("Expected %v but got %v", test.result, actualResult)
		}
	}
}

func floatSlicesEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}


func TestLess(t *testing.T) {
	a := argsort{s: []float64{3, 1, 2}}
	result := a.Less(0, 1)
	if result != false {
		t.Errorf("Expected false but got %v", result)
	}

	result = a.Less(1, 2)
	if result != true {
		t.Errorf("Expected true but got %v", result)
	}
}


func TestArgsort_Swap(t *testing.T) {
	a := argsort{
		s:    []float64{1, 2, 3, 4, 5},
		inds: []int{0, 1, 2, 3, 4},
	}

	a.Swap(1, 3)

	expectedS := []float64{1, 4, 3, 2, 5}
	expectedInds := []int{0, 3, 2, 1, 4}

	if !reflect.DeepEqual(a.s, expectedS) {
		t.Errorf("Expected s to be %v, but got %v", expectedS, a.s)
	}

	if !reflect.DeepEqual(a.inds, expectedInds) {
		t.Errorf("Expected inds to be %v, but got %v", expectedInds, a.inds)
	}
}

func TestArgsort(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		inds []int
	}{
		{
			name: "Test sorting float64 slice",
			dst:  []float64{3.5, 1.2, 4.7, 2.1},
			inds: []int{0, 1, 2, 3},
		},
		{
			name: "Test sorting float64 slice with negative numbers",
			dst:  []float64{-2.5, 1.8, -4.2, 5.6},
			inds: []int{0, 1, 2, 3},
		},
		{
			name: "Test sorting empty float64 slice",
			dst:  []float64{},
			inds: []int{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			origDst := make([]float64, len(tt.dst))
			copy(origDst, tt.dst)
			origInds := make([]int, len(tt.inds))
			copy(origInds, tt.inds)

			Argsort(tt.dst, tt.inds)

			// Check if dst is sorted
			for i := 0; i < len(tt.dst)-1; i++ {
				if tt.dst[i] > tt.dst[i+1] {
					t.Errorf("Failed to sort dst slice")
				}
			}

			// Check if original elements match sorted elements
			for i := 0; i < len(tt.dst); i++ {
				if tt.dst[i] != origDst[tt.inds[i]] {
					t.Errorf("Failed to track original order")
				}
			}

			// Check if inds are shuffled
			for i := 0; i < len(tt.inds); i++ {
				if tt.inds[i] != origInds[i] {
					return
				}
			}
		})
	}
}

func TestArgsort_Len(t *testing.T) {
	t.Run("Test with non-empty array", func(t *testing.T) {
		arr := []float64{3, 1, 4, 1, 5, 9, 2, 6}
		argsort := argsort{s: arr}

		actual := argsort.Len()
		expected := len(arr)

		if actual != expected {
			t.Errorf("Length of argsort array is incorrect, got: %d, want: %d", actual, expected)
		}
	})

	t.Run("Test with empty array", func(t *testing.T) {
		arr := []float64{}
		argsort := argsort{s: arr}

		actual := argsort.Len()
		expected := len(arr)

		if actual != expected {
			t.Errorf("Length of argsort array is incorrect, got: %d, want: %d", actual, expected)
		}
	})
}

func TestArgsortStable(t *testing.T) {
	dst := []float64{3.2, 1.5, 4.8, 2.1}
	inds := make([]int, len(dst))
	ArgsortStable(dst, inds)

	expectedDst := []float64{1.5, 2.1, 3.2, 4.8}
	expectedInds := []int{1, 3, 0, 2}

	for i := range dst {
		if dst[i] != expectedDst[i] || inds[i] != expectedInds[i] {
			t.Errorf("Expected dst[%d] to be %f with ind %d but got %f with ind %d", i, expectedDst[i], expectedInds[i], dst[i], inds[i])
		}
	}
}

func TestCount(t *testing.T) {
	tests := []struct {
		name     string
		f        func(float64) bool
		s        []float64
		expected int
	}{
		{
			name: "count positive numbers",
			f: func(x float64) bool {
				return x > 0
			},
			s:        []float64{1.0, -2.0, 3.0, -4.0, 5.0},
			expected: 3,
		},
		{
			name: "count even numbers",
			f: func(x float64) bool {
				return int(x)%2 == 0
			},
			s:        []float64{2.0, 3.0, 4.0, 5.0, 6.0},
			expected: 3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Count(tt.f, tt.s)
			if result != tt.expected {
				t.Errorf("Count() returned %d, expected %d", result, tt.expected)
			}
		})
	}
}

func TestCumProd(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		s        []float64
		expected []float64
	}{
		{
			name:     "Test case 1",
			dst:      []float64{1, 2, 3, 4},
			s:        []float64{1, 2, 3, 4},
			expected: []float64{1, 2, 6, 24},
		},
		{
			name:     "Test case 2",
			dst:      []float64{1, 2, 3},
			s:        []float64{1, 2, 3, 4},
			expected: nil, // panic expected due to length mismatch
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil && tt.expected == nil {
					t.Errorf("expected panic, but got nil")
				}
			}()

			actual := CumProd(tt.dst, tt.s)

			if !reflect.DeepEqual(actual, tt.expected) {
				t.Errorf("CumProd() = %v, want %v", actual, tt.expected)
			}
		})
	}
}

func TestCumSum(t *testing.T) {
	tests := []struct {
		dst  []float64
		s    []float64
		want []float64
	}{
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{1, 3, 6}},
		{[]float64{}, []float64{}, []float64{}},
	}

	for _, tt := range tests {
		t.Run("", func(t *testing.T) {
			got := CumSum(tt.dst, tt.s)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("CumSum(%v, %v) = %v; want %v", tt.dst, tt.s, got, tt.want)
			}
		})
	}
}

func TestDiv(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		expected []float64
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, []float64{1.0, 1.0, 1.0}},
		{[]float64{4.0, 5.0, 6.0}, []float64{2.0, 1.0, 3.0}, []float64{2.0, 5.0, 2.0}},
	}

	for _, test := range tests {
		Div(test.dst, test.s)

		if !floatSlicesAreEqual(test.dst, test.expected) {
			t.Errorf("Div failed, expected: %v, got: %v", test.expected, test.dst)
		}
	}
}

func floatSlicesAreEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func TestDivTo(t *testing.T) {
	tests := []struct {
		dst []float64
		s   []float64
		t   []float64
	}{
		{[]float64{2, 4, 6}, []float64{4, 8, 12}, []float64{2, 2, 2}},
		{[]float64{1, 2, 3}, []float64{3, 6, 9}, []float64{3, 3, 3}},
	}

	for _, test := range tests {
		dst := make([]float64, len(test.s))
		DivTo(dst, test.s, test.t)

		for i := 0; i < len(dst); i++ {
			expected := test.s[i] / test.t[i]
			if math.Abs(dst[i]-expected) > 1e-9 || math.IsNaN(dst[i]) {
				t.Errorf("DivTo failed at index %d, got: %v, want: %v", i, dst[i], expected)
			}
		}
	}

	// Test for panic with bad lengths
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("DivTo did not panic with bad lengths")
		}
	}()

	DivTo(make([]float64, 2), []float64{1, 2}, []float64{3})
}

func TestEqual(t *testing.T) {
	tests := []struct {
		s1   []float64
		s2   []float64
		want bool
	}{
		{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},
		{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},
		{[]float64{1, 2}, []float64{1, 2, 3}, false},
		{[]float64{}, []float64{}, true},
	}

	for _, tt := range tests {
		got := Equal(tt.s1, tt.s2)
		if got != tt.want {
			t.Errorf("Equal(%v, %v) = %v; want %v", tt.s1, tt.s2, got, tt.want)
		}
	}
}

func TestEqualFunc(t *testing.T) {
	tests := []struct {
		slice1   []float64
		slice2   []float64
		expected bool
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.1}, false},
		{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},
	}

	for _, test := range tests {
		result := EqualFunc(test.slice1, test.slice2, func(a, b float64) bool {
			return a == b
		})
		if result != test.expected {
			t.Errorf("For %v and %v expected %t, but got %t", test.slice1, test.slice2, test.expected, result)
		}
	}
}

func TestEqualLengths(t *testing.T) {
	tests := []struct {
		name   string
		slices [][]float64
		want   bool
	}{
		{
			name:   "all slices have equal length",
			slices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
			want:   true,
		},
		{
			name:   "some slices have different lengths",
			slices: [][]float64{{1, 2, 3}, {4, 5, 6, 7}, {8, 9}},
			want:   false,
		},
		{
			name:   "empty slices",
			slices: [][]float64{},
			want:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := EqualLengths(tt.slices...)
			if got != tt.want {
				t.Errorf("EqualLengths() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFind(t *testing.T) {
	// Test case 1: k = -1
	inds, err := Find(nil, func(val float64) bool { return val > 5 }, []float64{1, 6, 2, 7, 9}, -1)
	expected := []int{1, 3, 4}
	if err != nil {
		t.Errorf("Expected error to be nil, got: %v", err)
	}
	if !reflect.DeepEqual(inds, expected) {
		t.Errorf("Expected indices to be %v, got: %v", expected, inds)
	}

	// Test case 2: k = 2
	inds, err = Find(nil, func(val float64) bool { return val < 5 }, []float64{1, 6, 2, 7, 9}, 2)
	expected = []int{0, 2}
	if err != nil {
		t.Errorf("Expected error to be nil, got: %v", err)
	}
	if !reflect.DeepEqual(inds, expected) {
		t.Errorf("Expected indices to be %v, got: %v", expected, inds)
	}

	// Test case 3: k = 4 (not enough elements satisfying f)
	inds, err = Find(nil, func(val float64) bool { return val < 5 }, []float64{6, 7, 8, 9}, 4)
	expectedErr := "floats: insufficient elements found"
	if err == nil {
		t.Error("Expected error, got nil")
	}
	if err.Error() != expectedErr {
		t.Errorf("Expected error message to be '%s', got: %v", expectedErr, err)
	}
}

func TestHasNaN(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected bool
	}{
		{"no NaN values", []float64{1.0, 2.0, 3.0}, false},
		{"NaN value present", []float64{1.0, math.NaN(), 3.0}, true},
		{"all NaN values", []float64{math.NaN(), math.NaN(), math.NaN()}, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := HasNaN(tt.input)
			if result != tt.expected {
				t.Errorf("Expected HasNaN(%v) to be %v, but got %v", tt.input, tt.expected, result)
			}
		})
	}
}

func floatEquals(a, b, eps float64) bool {
	return math.Abs(a-b) < eps
}

func TestLogSumExpEmptySlice(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic when it should have")
		}
	}()

	LogSumExp([]float64{})
}

func TestMax(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4, 5}, 5},
		{[]float64{10, 20, 30, 40, 50}, 50},
		{[]float64{4.5, 6.7, 8.9, 2.3}, 8.9},
		{[]float64{}, 0}, // This test case will check for panic
	}

	for _, test := range tests {
		func() {
			defer func() {
				if recover() != nil {
					return
				}
			}()
			result := Max(test.input)
			if result != test.expected {
				t.Errorf("Expected %f but got %f for input %v", test.expected, result, test.input)
			}
		}()
	}
}

func TestMaxIdx(t *testing.T) {
	tests := []struct {
		input []float64
		want  int
	}{
		{[]float64{1, 2, 3, 4, 3}, 3},
		{[]float64{0, 0, 0, 0, 0}, 0},
		{[]float64{10, 5, 8, 10, 5}, 0},
		{[]float64{7, 3, 5, 8, 1}, 3},
	}

	for _, test := range tests {
		got := MaxIdx(test.input)
		if got != test.want {
			t.Errorf("MaxIdx(%v) = %d; want %d", test.input, got, test.want)
		}
	}
}

func TestMaxIdxPanic(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic as expected")
		}
	}()

	MaxIdx([]float64{})
}

func TestMin(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4, 5}, 1},
		{[]float64{2.5, 3.7, 1.2, 4.5}, 1.2},
		{[]float64{5, 4, 3, 2, 1}, 1},
	}

	for _, test := range tests {
		result := Min(test.input)
		if result != test.expected {
			t.Errorf("Min(%v) = %v; want %v", test.input, result, test.expected)
		}
	}
}

func TestMinEmptySlice(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("Min did not panic for empty slice")
		}
	}()

	Min([]float64{})
}

func TestMul(t *testing.T) {
	tests := []struct {
		dst, s, want []float64
	}{
		{
			dst:  []float64{1, 2, 3},
			s:    []float64{4, 5, 6},
			want: []float64{4, 10, 18},
		},
		{
			dst:  []float64{1, 2, 3},
			s:    []float64{4, 5},
			want: []float64{}, // should panic
		},
	}

	for _, tc := range tests {
        // Defer the recover inside the loop
		defer func() {
			r := recover()
			if r == nil && len(tc.want) > 0 {
				t.Errorf("expected: %s, but got none", badLength)
			}
		}()

		Mul(tc.dst, tc.s)

		if !float64SlicesAreEqual(tc.dst, tc.want) {
			t.Errorf("Mul(%v, %v) = %v, want %v", tc.dst, tc.s, tc.dst, tc.want)
		}
	}
}

func float64SlicesAreEqual(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestMulTo(t *testing.T) {
	tests := []struct {
		dst []float64
		s   []float64
		t   []float64
	}{
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}},
		{[]float64{0, 0, 0, 0}, []float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}},
	}

	for _, test := range tests {
		result := MulTo(test.dst, test.s, test.t)

		if !reflect.DeepEqual(result, test.dst) {
			t.Errorf("Expected %v but got %v", test.dst, result)
		}
	}
}

func TestNearestIdx(t *testing.T) {
	tests := []struct {
		name           string
		s              []float64
		v              float64
		expectedOutput int
	}{
		{
			name:           "Test case 1",
			s:              []float64{1, 2, 3, 4, 5},
			v:              3.2,
			expectedOutput: 2,
		},
		{
			name:           "Test case 2",
			s:              []float64{1.2, 2.4, 3.6, 4.8, 5.9},
			v:              6.0,
			expectedOutput: 4,
		},
		{
			name:           "Test case 3",
			s:              []float64{5, 4, 3, 2, 1},
			v:              2.5,
			expectedOutput: 2, // Corrected expected output to 2 from 3
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output := NearestIdx(tt.s, tt.v)
			if output != tt.expectedOutput {
				t.Errorf("Expected: %d, Got: %d", tt.expectedOutput, output)
			}
		})
	}
}

func TestNorm(t *testing.T) {
	tests := []struct {
		name     string
		s        []float64
		L        float64
		expected float64
	}{
		{"L2 norm", []float64{1, 2, 3}, 2, 3.7416573867739413},
		{"L1 norm", []float64{1, 2, 3}, 1, 6},
		{"Infinity norm", []float64{1, -5, 3}, math.Inf(1), 5},
		{"Zero norm", []float64{}, 2, 0}, // Add test cases as needed
	}

	delta := 1e-10 // Define a small delta value for floating-point comparisons

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			actual := Norm(test.s, test.L)
			if math.Abs(actual-test.expected) > delta {
				t.Errorf("Expected norm value: %v, but got: %v", test.expected, actual)
			}
		})
	}
}

func TestProd(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4}, 24},
		{[]float64{0, 2, 3}, 0},
		{[]float64{}, 1},
	}

	for _, tt := range tests {
		result := Prod(tt.input)
		if result != tt.expected {
			t.Errorf("Prod(%v) = %v, want %v", tt.input, result, tt.expected)
		}
	}
}

func TestReverse(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected []float64
	}{
		{
			name:     "Reverse order of elements in slice",
			input:    []float64{1.0, 2.0, 3.0, 4.0},
			expected: []float64{4.0, 3.0, 2.0, 1.0},
		},
		{
			name:     "Empty slice",
			input:    []float64{},
			expected: []float64{},
		},
		{
			name:     "Single element slice",
			input:    []float64{1.0},
			expected: []float64{1.0},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			Reverse(test.input)
			if !reflect.DeepEqual(test.input, test.expected) {
				t.Errorf("Expected %v, but got %v", test.expected, test.input)
			}
		})
	}
}

func TestSame(t *testing.T) {
	tests := []struct {
		s      []float64
		t      []float64
		result bool
	}{
		{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},
		{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},
		{[]float64{1, math.NaN(), 3}, []float64{1, math.NaN(), 3}, true},
		{[]float64{1, math.NaN(), 3}, []float64{1, 2, 3}, false},
	}

	for _, test := range tests {
		if res := Same(test.s, test.t); res != test.result {
			t.Errorf("Expected Same(%v, %v) to be %t, but got %t", test.s, test.t, test.result, res)
		}
	}
}

func TestScale(t *testing.T) {
	tests := []struct {
		c      float64
		dst    []float64
		result []float64
	}{
		{2.0, []float64{1.0, 2.0, 3.0}, []float64{2.0, 4.0, 6.0}},
		{0.5, []float64{4.0, 5.0, 6.0}, []float64{2.0, 2.5, 3.0}},
		{3.0, []float64{0.5, 1.5, 2.5}, []float64{1.5, 4.5, 7.5}},
		{1.0, []float64{}, []float64{}},
	}

	for _, test := range tests {
		Scale(test.c, test.dst)
		if !reflect.DeepEqual(test.dst, test.result) {
			t.Errorf("Expected %v but got %v", test.result, test.dst)
		}
	}
}

func TestScaleTo(t *testing.T) {
	// Test case 1: Equal length slices
	dst := []float64{1.0, 2.0, 3.0}
	c := 2.0
	s := []float64{4.0, 5.0, 6.0}

	expected := []float64{8.0, 10.0, 12.0}
	result := ScaleTo(dst, c, s)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v but got %v", expected, result)
	}

	// Test case 2: Unequal length slices
	dst = []float64{1.0, 2.0}
	c = 3.0
	s = []float64{4.0, 5.0, 6.0}

	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic")
		}
	}()

	ScaleTo(dst, c, s)
}

func TestSpan(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		l    float64
		u    float64
		want []float64
	}{
		{
			name: "Test Case 1",
			dst:  []float64{0, 0},
			l:    0,
			u:    10,
			want: []float64{0, 10},
		},
		{
			name: "Test Case 2",
			dst:  []float64{0, 0, 0},
			l:    1,
			u:    5,
			want: []float64{1, 3, 5},
		},
		// Add more test cases as needed
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := Span(tt.dst, tt.l, tt.u)

			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Span() = %v, want %v", got, tt.want)
			}

			// Additional tests for panics can be added here
		})
	}
}

func TestSub(t *testing.T) {
	tests := []struct {
		name string
		dst  []float64
		s    []float64
		want []float64
	}{
		{
			name: "subtract elements successfully",
			dst:  []float64{1.0, 2.0, 3.0},
			s:    []float64{0.5, 1.0, 1.5},
			want: []float64{0.5, 1.0, 1.5},
		},
		{
			name: "panic if argument lengths do not match",
			dst:  []float64{1.0, 2.0, 3.0},
			s:    []float64{0.5, 1.0},
			want: nil, // Expecting panic
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r == nil && tt.want == nil {
					t.Errorf("Sub() did not panic")
				}
			}()

			Sub(tt.dst, tt.s)

			if !reflect.DeepEqual(tt.dst, tt.want) {
				t.Errorf("Sub() = %v, want %v", tt.dst, tt.want)
			}
		})
	}
}

func TestSum(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected float64
	}{
		{
			name:     "Test case 1",
			input:    []float64{1.5, 2.5, 3.5},
			expected: 7.5,
		},
		{
			name:     "Test case 2",
			input:    []float64{0.0, 0.0, 0.0},
			expected: 0.0,
		},
		{
			name:     "Test case 3",
			input:    []float64{10.5, -5.5, 3.0},
			expected: 8.0,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			result := Sum(test.input)
			if result != test.expected {
				t.Errorf("Expected: %v, but got: %v", test.expected, result)
			}
		})
	}
}

func TestSumCompensated(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected float64
	}{
		{
			name:     "Test case 1",
			input:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},
			expected: 15.0,
		},
		{
			name:     "Test case 2",
			input:    []float64{10.0, -5.0, 3.0, 7.0},
			expected: 15.0,
		},
		{
			name:     "Test case 3",
			input:    []float64{-1.0, -2.0, -3.0, -4.0},
			expected: -10.0,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := SumCompensated(tc.input)
			if !almostEqual1(result, tc.expected) {
				t.Errorf("Expected %f, but got %f", tc.expected, result)
			}
		})
	}
}

func almostEqual1(a, b float64) bool {
	const epsilon = 1e-9
	return math.Abs(a-b) < epsilon
}
func TestSubTo(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		t        []float64
		expected []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},
		{[]float64{1, 2}, []float64{3, 4}, []float64{1, 2, 3}, nil}, // Should panic due to different lengths
	}

	for _, test := range tests {
		if test.expected == nil {
			func() {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("SubTo did not panic for unequal lengths")
					}
				}()
				SubTo(test.dst, test.s, test.t)
			}()
		} else {
			result := SubTo(test.dst, test.s, test.t)
			if !reflect.DeepEqual(result, test.expected) {
				t.Errorf("SubTo(%v, %v, %v) returned %v, expected %v", test.dst, test.s, test.t, result, test.expected)
			}
		}
	}
}