package floats

import (
	"math"
	"reflect"
	"sort"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestAdd(t *testing.T) {
	tests := []struct {
		dst  []float64
		s    []float64
		want []float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},
		{[]float64{10, 20, 30}, []float64{1, 2, 3}, []float64{11, 22, 33}},
		{[]float64{1, -2, 3}, []float64{-4, 5, -6}, []float64{-3, 3, -3}},
		// Add more test cases here
	}

	for _, tt := range tests {
		Add(tt.dst, tt.s)
		if !reflect.DeepEqual(tt.dst, tt.want) {
			t.Errorf("Add(%v, %v) = %v, want %v", tt.dst, tt.s, tt.dst, tt.want)
		}
	}
}

func TestAddTo(t *testing.T) {
	tests := []struct {
		dst  []float64
		s    []float64
		t    []float64
		want []float64
	}{
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{10, 20, 30}, []float64{11, 22, 33}},
		{[]float64{0, 0, 0}, []float64{5, 10, 15}, []float64{2, 4, 6}, []float64{7, 14, 21}},
	}

	for _, test := range tests {
		got := AddTo(test.dst, test.s, test.t)

		if !reflect.DeepEqual(got, test.want) {
			t.Errorf("AddTo(%v, %v, %v) = %v, want %v", test.dst, test.s, test.t, got, test.want)
		}
	}
}

func TestAddConst(t *testing.T) {
	input := []float64{1.0, 2.0, 3.0}
	constant := 5.0
	expected := []float64{6.0, 7.0, 8.0}

	AddConst(constant, input)

	for i := range input {
		if input[i] != expected[i] {
			t.Errorf("Expected %f but got %f at index %d", expected[i], input[i], i)
		}
	}
}

func TestAddScaled(t *testing.T) {
	// Test case 1: Equal length slices
	dst := []float64{1, 2, 3}
	alpha := 2.0
	s := []float64{4, 5, 6}
	expected := []float64{9, 12, 15}

	AddScaled(dst, alpha, s)

	for i := 0; i < len(dst); i++ {
		if dst[i] != expected[i] {
			t.Errorf("Expected %f at index %d, but got %f", expected[i], i, dst[i])
		}
	}

	// Test case 2: Unequal length slices
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic")
		}
	}()

	dst = []float64{1, 2}
	alpha = 2.0
	s = []float64{4, 5, 6}

	AddScaled(dst, alpha, s)
}

func TestAddScaledTo(t *testing.T) {
	dst := make([]float64, 3)
	y := []float64{1, 2, 3}
	alpha := 2.0
	s := []float64{4, 5, 6}

	result := AddScaledTo(dst, y, alpha, s)

	expected := []float64{9, 12, 15}

	for i := range result {
		if result[i] != expected[i] {
			t.Errorf("Expected %f, got %f", expected[i], result[i])
		}
	}
}

func TestArgsort_Len(t *testing.T) {
	a := argsort{s: []float64{3.4, 2.5, 1.9}}
	expectedLength := 3
	result := a.Len()

	if expectedLength != result {
		t.Errorf("Expected length: %v, but got: %v", expectedLength, result)
	}
}

func TestArgsortLess(t *testing.T) {
	a := argsort{
		s:    []float64{4.5, 2.3, 7.8, 1.2, 9.6},
		inds: []int{0, 1, 2, 3, 4},
	}

	less := a.Less(2, 4)
	if !less {
		t.Errorf("Expected a.s[2] < a.s[4], but it was false")
	}

	less = a.Less(1, 3)
	if less {
		t.Errorf("Expected a.s[1] < a.s[3] to be false, but it was true")
	}
}

func TestArgsort_Swap(t *testing.T) {
	a := argsort{
		s:    []float64{1.0, 2.0, 3.0},
		inds: []int{0, 1, 2},
	}

	a.Swap(0, 1)

	expectedS := []float64{2.0, 1.0, 3.0}
	expectedInds := []int{1, 0, 2}

	if !compareFloat64Slices(a.s, expectedS) {
		t.Errorf("Incorrect swap operation on 's'. Expected %v, got %v", expectedS, a.s)
	}

	if !compareIntSlices(a.inds, expectedInds) {
		t.Errorf("Incorrect swap operation on 'inds'. Expected %v, got %v", expectedInds, a.inds)
	}
}

func compareFloat64Slices(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func compareIntSlices(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestArgsortStable(t *testing.T) {
	dst := []float64{3.4, 1.2, 9.8, 3.5, 2.7}
	inds := make([]int, len(dst))
	ArgsortStable(dst, inds)

	expectedIndices := []int{1, 4, 0, 3, 2}

	for i, v := range inds {
		if v != expectedIndices[i] {
			t.Errorf("Expected index %v but got %v", expectedIndices[i], v)
		}
	}

	// Test for panic with different destination length
	dst = []float64{3.4, 1.2, 9.8}
	inds = make([]int, len(dst)+1)

	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic")
		}
	}()

	ArgsortStable(dst, inds)
}

func TestCount(t *testing.T) {
	testFunc := func(x float64) bool {
		return x > 0
	}

	testCases := []struct {
		name  string
		input []float64
		want  int
	}{
		{"all positive numbers", []float64{1.0, 2.0, 3.0, 4.0}, 4},
		{"all negative numbers", []float64{-1.0, -2.0, -3.0, -4.0}, 0},
		{"mixed positive and negative numbers", []float64{-1.0, 2.0, -3.4, 4.5}, 2},
		{"empty input slice", []float64{}, 0},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := Count(testFunc, tc.input)
			if got != tc.want {
				t.Errorf("Count(testFunc, %v) = %v; want %v", tc.input, got, tc.want)
			}
		})
	}
}

func TestDistance(t *testing.T) {
	tests := []struct {
		s        []float64
		t        []float64
		L        float64
		expected float64
	}{
		{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0},                 // Example test case with L = 2
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632}, // Example test case with L = 2
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},                 // Example test case with L = 1
		// Add more test cases here
	}

	for _, test := range tests {
		result := Distance(test.s, test.t, test.L)
		if !almostEqual(result, test.expected) {
			t.Errorf("Distance(%v, %v, %f) returned %f, expected %f", test.s, test.t, test.L, result, test.expected)
		}
	}
}

func almostEqual(a, b float64) bool {
	const epsilon = 1e-9
	return math.Abs(a-b) < epsilon
}

func TestDot(t *testing.T) {
	tests := []struct {
		slice1   []float64
		slice2   []float64
		expected float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, 32},
		{[]float64{0.5, 0.5}, []float64{0.1, 0.2}, 0.15},
		{[]float64{0.1, 0.2}, []float64{0.3, 0.4}, 0.11},
	}

	for _, test := range tests {
		result := Dot(test.slice1, test.slice2)
		if math.Abs(result-test.expected) > 0.00001 {
			t.Errorf("Dot(%v, %v) = %v; want %v", test.slice1, test.slice2, result, test.expected)
		}
	}
}

func TestEqual(t *testing.T) {
	testCases := []struct {
		slice1   []float64
		slice2   []float64
		expected bool
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},
		{[]float64{4.0, 5.0}, []float64{4.0, 5.0, 6.0}, false},
	}

	for _, tc := range testCases {
		actual := Equal(tc.slice1, tc.slice2)
		if actual != tc.expected {
			t.Errorf("Expected Equal(%v, %v) to be %v, but got %v", tc.slice1, tc.slice2, tc.expected, actual)
		}
	}
}

func TestEqualApprox(t *testing.T) {
	t.Run("TestEqualArrays", func(t *testing.T) {
		s1 := []float64{1.0, 2.0, 3.0}
		s2 := []float64{1.0, 2.0, 3.0}
		tol := 0.0001
		expected := true
		result := EqualApprox(s1, s2, tol)
		assert.Equal(t, expected, result)
	})

	t.Run("TestNotEqualArrays", func(t *testing.T) {
		s1 := []float64{1.0, 2.0, 3.0}
		s2 := []float64{1.0, 2.0, 3.1}
		tol := 0.0001
		expected := false
		result := EqualApprox(s1, s2, tol)
		assert.Equal(t, expected, result)
	})

	t.Run("TestDifferentLengthArrays", func(t *testing.T) {
		s1 := []float64{1.0, 2.0}
		s2 := []float64{1.0, 2.0, 3.0}
		tol := 0.0001
		expected := false
		result := EqualApprox(s1, s2, tol)
		assert.Equal(t, expected, result)
	})
}

func TestEqualFunc(t *testing.T) {
	tests := []struct {
		name string
		s1   []float64
		s2   []float64
		f    func(float64, float64) bool
		want bool
	}{
		{
			name: "Equal slices with same length and same values",
			s1:   []float64{1.0, 2.0, 3.0},
			s2:   []float64{1.0, 2.0, 3.0},
			f:    func(a, b float64) bool { return a == b },
			want: true,
		},
		{
			name: "Equal slices with same length but different values",
			s1:   []float64{1.0, 2.0, 3.0},
			s2:   []float64{1.0, 4.0, 3.0},
			f:    func(a, b float64) bool { return a == b },
			want: false,
		},
		{
			name: "Slices with different length",
			s1:   []float64{1.0, 2.0, 3.0},
			s2:   []float64{1.0, 2.0},
			f:    func(a, b float64) bool { return a == b },
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := EqualFunc(tt.s1, tt.s2, tt.f)
			if got != tt.want {
				t.Errorf("EqualFunc() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestEqualLengths(t *testing.T) {
	// Test case 1: Empty slices
	if !EqualLengths() {
		t.Error("Empty slices should return true")
	}

	// Test case 2: Slices of equal length
	slice1 := []float64{1, 2, 3}
	slice2 := []float64{4, 5, 6}
	slice3 := []float64{7, 8, 9}
	if !EqualLengths(slice1, slice2, slice3) {
		t.Error("Slices of equal length should return true")
	}

	// Test case 3: Slices of different lengths
	slice4 := []float64{1, 2, 3}
	slice5 := []float64{4, 5}
	if EqualLengths(slice4, slice5) {
		t.Error("Slices of different lengths should return false")
	}
}

func TestFind(t *testing.T) {
	tests := []struct {
		name         string
		inds         []int
		f            func(float64) bool
		s            []float64
		k            int
		expectedInds []int
		expectedErr  error
	}{
		{
			name: "Test case 1",
			inds: []int{1, 2, 3}, // Input values
			f: func(val float64) bool { // Sample condition function
				return val > 0
			},
			s:            []float64{1.5, -2.2, 0.0, 4.5, -6.7},
			k:            2,
			expectedInds: []int{0, 3}, // Expected indices where condition is true
			expectedErr:  nil,
		},
		// Add more test cases as needed
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			inds, err := Find(tt.inds, tt.f, tt.s, tt.k)
			if !reflect.DeepEqual(inds, tt.expectedInds) || !reflect.DeepEqual(err, tt.expectedErr) {
				t.Errorf("Find() = %v, %v; want %v, %v", inds, err, tt.expectedInds, tt.expectedErr)
			}
		})
	}
}

func TestHasNaN(t *testing.T) {
	tests := []struct {
		input    []float64
		expected bool
	}{
		{[]float64{1.0, 2.0, 3.0}, false},
		{[]float64{1.0, 2.0, math.NaN()}, true},
		{[]float64{math.NaN(), math.NaN(), math.NaN()}, true},
		{[]float64{}, false},
	}

	for _, test := range tests {
		result := HasNaN(test.input)
		if result != test.expected {
			t.Errorf("For %v, expected %t but got %t", test.input, test.expected, result)
		}
	}
}

func TestMax(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4, 5}, 5},
		{[]float64{5, 4, 3, 2, 1}, 5},
		{[]float64{3.5, 6.7, 8.9}, 8.9},
	}

	for _, test := range tests {
		result := Max(test.input)
		if result != test.expected {
			t.Errorf("Max(%v) expected: %v, got: %v", test.input, test.expected, result)
		}
	}
}

func TestMin(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3, 4, 5}, 1},
		{[]float64{10, 20, 5, 30}, 5},
		{[]float64{-1, -5, -10}, -10},
		{[]float64{0, 0, 0}, 0},
	}

	for _, test := range tests {
		result := Min(test.input)
		if result != test.expected {
			t.Errorf("Expected Min(%v) to be %v, but got %v", test.input, test.expected, result)
		}
	}
}

func TestMinIdx(t *testing.T) {
	s := []float64{5, 3, 9, 2, 7, 4}
	expected := 3
	result := MinIdx(s)

	if result != expected {
		t.Errorf("Expected index %d, but got %d", expected, result)
	}

	s2 := []float64{-1, 0, 1, -2}
	expected2 := 3
	result2 := MinIdx(s2)

	if result2 != expected2 {
		t.Errorf("Expected index %d, but got %d", expected2, result2)
	}

	s3 := []float64{}
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic")
		}
	}()
	MinIdx(s3)
}

func TestMulTo(t *testing.T) {
	tests := []struct {
		dst      []float64
		s        []float64
		t        []float64
		expected []float64
	}{
		{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},
		{[]float64{0, 0, 0}, []float64{2, 3, 4}, []float64{1, 2, 3}, []float64{2, 6, 12}},
		{[]float64{0, 0, 0}, []float64{1, 1, 1}, []float64{1, 1, 1}, []float64{1, 1, 1}},
	}

	for _, test := range tests {
		result := MulTo(test.dst, test.s, test.t)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("Expected %v but got %v", test.expected, result)
		}
	}
}

func TestProd(t *testing.T) {
	tests := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{1, 2, 3}, 6},
		{[]float64{0.5, 0.5, 0.5}, 0.125},
		{[]float64{5, 10, 0.5}, 25},
	}

	for _, test := range tests {
		result := Prod(test.input)
		if result != test.expected {
			t.Errorf("Prod(%v) = %f; want %f", test.input, result, test.expected)
		}
	}
}

func TestReverse(t *testing.T) {
	input := []float64{1.0, 2.0, 3.0, 4.0, 5.0}
	expected := []float64{5.0, 4.0, 3.0, 2.0, 1.0}

	Reverse(input)

	if !reflect.DeepEqual(input, expected) {
		t.Errorf("Reverse failed, expected %v but got %v", expected, input)
	}
}

func TestSame(t *testing.T) {
	tests := []struct {
		s      []float64
		t      []float64
		result bool
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},
		{[]float64{1.0, math.NaN(), 3.0}, []float64{1.0, math.NaN(), 3.0}, true},
		{[]float64{1.0, math.Inf(1), 3.0}, []float64{1.0, math.Inf(1), 3.0}, true},
	}

	for _, test := range tests {
		if res := Same(test.s, test.t); res != test.result {
			t.Errorf("Expected Same(%v, %v) to be %t, but got %t", test.s, test.t, test.result, res)
		}
	}
}

func TestScale(t *testing.T) {
	tests := []struct {
		name string
		c    float64
		dst  []float64
		want []float64
	}{
		{
			name: "Scale positive values by 2",
			c:    2,
			dst:  []float64{1, 2, 3},
			want: []float64{2, 4, 6},
		},
		{
			name: "Scale negative values by -1",
			c:    -1,
			dst:  []float64{-1, -2, -3},
			want: []float64{1, 2, 3},
		},
		{
			name: "Scale empty slice",
			c:    10,
			dst:  []float64{},
			want: []float64{},
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			Scale(tc.c, tc.dst)
			if !reflect.DeepEqual(tc.dst, tc.want) {
				t.Errorf("got %v, want %v", tc.dst, tc.want)
			}
		})
	}
}

func TestScaleTo(t *testing.T) {
	dst := make([]float64, 3)
	s := []float64{1, 2, 3}
	c := 2.0

	expected := []float64{2, 4, 6}
	result := ScaleTo(dst, c, s)

	for i := 0; i < len(result); i++ {
		if result[i] != expected[i] {
			t.Errorf("Expected %f but got %f at index %d", expected[i], result[i], i)
		}
	}
}

func TestScaleToBadDstLength(t *testing.T) {
	dst := make([]float64, 2)
	s := []float64{1, 2, 3}
	c := 2.0

	defer func() {
		if r := recover(); r == nil {
			t.Errorf("The code did not panic when length of dst and s were not the same")
		}
	}()

	ScaleTo(dst, c, s)
}

func TestSub(t *testing.T) {
	dst := []float64{1.0, 2.0, 3.0}
	s := []float64{4.0, 5.0, 6.0}

	expected := []float64{-3.0, -3.0, -3.0}

	Sub(dst, s)

	for i := 0; i < len(dst); i++ {
		if dst[i] != expected[i] {
			t.Errorf("Sub did not calculate correctly, expected: %v, got: %v", expected, dst)
		}
	}
}

func TestSubTo(t *testing.T) {
	type args struct {
		dst []float64
		s   []float64
		t   []float64
	}
	tests := []struct {
		name string
		args args
		want []float64
	}{
		{
			name: "Test case 1",
			args: args{
				dst: []float64{0, 0, 0},
				s:   []float64{1, 2, 3},
				t:   []float64{4, 5, 6},
			},
			want: []float64{-3, -3, -3},
		},
		{
			name: "Test case 2",
			args: args{
				dst: []float64{0, 0, 0, 0},
				s:   []float64{1, 2, 3, 4},
				t:   []float64{5, 6, 7, 8},
			},
			want: []float64{-4, -4, -4, -4},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("SubTo() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestSum(t *testing.T) {
	input := []float64{1.0, 2.0, 3.0}
	expected := 6.0

	result := Sum(input)

	if result != expected {
		t.Errorf("Sum was incorrect, got: %f, want: %f.", result, expected)
	}
}

func TestArgsort(t *testing.T) {
	tests := []struct {
		dst  []float64
		inds []int
	}{
		{[]float64{4, 2, 1, 3}, []int{0, 0, 0, 0}},
		{[]float64{10, 5, 8, 3, 1}, []int{0, 0, 0, 0, 0}},
		{[]float64{100, 50, 25, 75, 10, 5}, []int{0, 0, 0, 0, 0, 0}},
	}

	for _, test := range tests {
		originalInds := make([]int, len(test.inds))
		copy(originalInds, test.inds)

		Argsort(test.dst, test.inds)

		sortedValues := make([]float64, len(test.dst))
		sortedIndices := make([]int, len(test.inds))
		copy(sortedValues, test.dst)
		copy(sortedIndices, test.inds)

		sort.Float64s(sortedValues)
		sort.Ints(sortedIndices)

		for i, index := range sortedIndices {
			if test.dst[index] != sortedValues[i] {
				t.Errorf("Sorting incorrect for input dst: %v, expected inds: %v, got: %v", test.dst, originalInds, test.inds)
				break
			}
		}
	}
}
func TestCumSum(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		s        []float64
		expected []float64
	}{
		{
			name:     "Empty arrays",
			dst:      []float64{},
			s:        []float64{},
			expected: []float64{},
		},
		{
			name:     "Equal length arrays",
			dst:      []float64{0, 0, 0},
			s:        []float64{1, 2, 3},
			expected: []float64{1, 3, 6},
		},
		{
			name:     "Unequal length arrays",
			dst:      []float64{0, 0, 0},
			s:        []float64{1, 2},
			expected: []float64{}, // Expecting panic due to badDstLength
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			if test.name == "Unequal length arrays" {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("Expected panic due to badDstLength, but it didn't occur")
					}
				}()
			}

			result := CumSum(test.dst, test.s)
			if !reflect.DeepEqual(result, test.expected) {
				t.Errorf("Unexpected result - Got: %v, Want: %v", result, test.expected)
			}
		})
	}
}

func TestMul(t *testing.T) {
	type args struct {
		dst []float64
		s   []float64
	}
	tests := []struct {
		name string
		args args
		want []float64
	}{
		{
			name: "Test case 1",
			args: args{
				dst: []float64{1, 2, 3},
				s:   []float64{2, 3, 4},
			},
			want: []float64{2, 6, 12},
		},
		{
			name: "Test case 2",
			args: args{
				dst: []float64{4, 5, 6},
				s:   []float64{2, 2, 2},
			},
			want: []float64{8, 10, 12},
		},
		{
			name: "Test case 3",
			args: args{
				dst: []float64{1, 2, 3, 4},
				s:   []float64{2, 3, 4},
			},
			want: nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if tt.want == nil {
						return
					}
					t.Errorf("Mul() panic = %v, want %v", r, nil)
				}
			}()
			Mul(tt.args.dst, tt.args.s)
			if !reflect.DeepEqual(tt.args.dst, tt.want) {
				t.Errorf("Mul() = %v, want %v", tt.args.dst, tt.want)
			}
		})
	}
}

func TestNorm(t *testing.T) {
	testCases := []struct {
		input    []float64
		L        float64
		expected float64
	}{
		{[]float64{1, 2, 3}, 1, 6},             // sum of absolute values
		{[]float64{1, 2, 3}, 2, 3.74165738677}, // L2-norm
		{[]float64{1, 2, 3}, math.Inf(1), 3},   // max absolute value
		{[]float64{}, 2, 0},                    // empty slice
	}

	// Define a function for float64 approximate equality
	approxEqual := func(a, b, tolerance float64) bool {
		return math.Abs(a-b) < tolerance
	}

	tolerance := 1e-10 // define a tolerance for float64 comparisons

	for _, tc := range testCases {
		output := Norm(tc.input, tc.L)
		if !approxEqual(output, tc.expected, tolerance) {
			t.Errorf("Norm(%v, %v) = %v; want %v", tc.input, tc.L, output, tc.expected)
		}
	}
}

// func TestSumCompensated(t *testing.T) {
// 	tests := []struct {
// 		name     string
// 		input    []float64
// 		expected float64
// 	}{
// 		{
// 			name:     "Test case 1",
// 			input:    []float64{1.1, 2.2, 3.3},
// 			expected: 6.6,
// 		},
// 		{
// 			name:     "Test case 2",
// 			input:    []float64{1, 0, -1, 2, -2},
// 			expected: 0,
// 		},
// 		{
// 			name:     "Test case 3",
// 			input:    []float64{1.1, -1.1, 0.0001, -0.0001},
// 			expected: 0.1,
// 		},
// 	}

// 	for _, test := range tests {
// 		t.Run(test.name, func(t *testing.T) {
// 			result := SumCompensated(test.input)

// 			// Increased tolerance for float comparison
// 			eps := 1e-6

// 			if math.Abs(result-test.expected) > eps {
// 				t.Errorf("Expected %v, got %v", test.expected, result)
// 			}
// 		})
// 	}
// }
// func TestCumProd(t *testing.T) {
// 	tests := []struct {
// 		name     string
// 		dst      []float64
// 		s        []float64
// 		expected []float64
// 	}{
// 		{
// 			name:     "Empty arrays",
// 			dst:      []float64{},
// 			s:        []float64{},
// 			expected: []float64{},
// 		},
// 		{
// 			name:     "Arrays with the same length",
// 			dst:      []float64{1, 2, 3, 4},
// 			s:        []float64{1, 2, 3, 4},
// 			expected: []float64{1, 2, 6, 24},
// 		},
// 		{
// 			name:     "Arrays with different lengths",
// 			dst:      []float64{1, 2, 3, 0},
// 			s:        []float64{1, 2, 3, 4},
// 			expected: []float64{1, 2, 6, 0},
// 		},
// 	}

// 	for _, tt := range tests {
// 		t.Run(tt.name, func(t *testing.T) {
// 			result := CumProd(tt.dst, tt.s)
// 			if len(result) != len(tt.expected) {
// 				t.Errorf("Expected result length %d, but got %d", len(tt.expected), len(result))
// 			}

// 			for i := 0; i < len(tt.expected); i++ {
// 				if result[i] != tt.expected[i] {
// 					t.Errorf("Expected %f at index %d, but got %f", tt.expected[i], i, result[i])
// 				}
// 			}
// 		})
// 	}
// }
// func TestSpan(t *testing.T) {
// 	tests := []struct {
// 		dst      []float64
// 		l, u     float64
// 		expected []float64
// 	}{
// 		{make([]float64, 4), math.NaN(), 10, []float64{math.NaN(), math.NaN(), math.NaN(), 10}},
// 		{make([]float64, 6), math.Inf(+1), 10, []float64{math.Inf(+1), math.Inf(+1), math.Inf(+1), 10, math.Inf(+1), math.Inf(+1)}},
// 	}

// 	for _, test := range tests {
// 		result := Span(test.dst, test.l, test.u)
// 		if !reflect.DeepEqual(result, test.expected) {
// 			t.Errorf("For input dst=%v, l=%v, u=%v, expected %v but got %v", test.dst, test.l, test.u, test.expected, result)
// 		}
// 	}
// }
// func TestDiv(t *testing.T) {
// 	tests := []struct {
// 		name string
// 		dst  []float64
// 		s    []float64
// 		want []float64
// 	}{
// 		{
// 			name: "Test Case 1",
// 			dst:  []float64{10, 20, 30},
// 			s:    []float64{2, 2, 3},
// 			want: []float64{5, 10, 10},
// 		},
// 		{
// 			name: "Test Case 2",
// 			dst:  []float64{10, 20, 30},
// 			s:    []float64{0, 2, 3},
// 			want: []float64{math.Inf(1), 10, 10},
// 		},
// 		{
// 			name: "Test Case 3",
// 			dst:  []float64{10, 20, 30},
// 			s:    []float64{2, 0, 3},
// 			want: nil,
// 		},
// 	}

// 	for _, tt := range tests {
// 		t.Run(tt.name, func(t *testing.T) {
// 			defer func() {
// 				if r := recover(); r != nil {
// 					if tt.want != nil {
// 						t.Errorf("Div panicked, but not expected. want = %v", tt.want)
// 					}
// 				}
// 			}()

// 			Div(tt.dst, tt.s)

// 			if tt.want == nil {
// 				t.Errorf("Div() did not panic as expected. want = %v", tt.want)
// 			} else if !reflect.DeepEqual(tt.dst, tt.want) {
// 				t.Errorf("Div() got = %v, want %v", tt.dst, tt.want)
// 			}
// 		})
// 	}
// }
// func TestMaxIdx(t *testing.T) {
// 	tests := []struct {
// 		input    []float64
// 		expected int
// 	}{
// 		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},
// 		{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},
// 		{[]float64{5.0, math.NaN(), 3.0, 2.0, 1.0}, 0},
// 		{[]float64{}, 0}, // test zero-length array
// 	}

// 	for _, test := range tests {
// 		func() {
// 			defer func() {
// 				if r := recover(); r != nil {
// 					t.Errorf("Panic occurred: %v", r)
// 				}
// 			}()
// 			result := MaxIdx(test.input)
// 			if result != test.expected {
// 				t.Errorf("For %v, expected %d, but got %d", test.input, test.expected, result)
// 			}
// 		}()
// 	}
// }


// func TestWithin(t *testing.T) {
// 	tests := []struct {
// 		s        []float64
// 		v        float64
// 		expected int
// 	}{
// 		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},
// 		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 4},
// 		{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -1},
// 		{[]float64{1.0}, 1.0, -1},
// 	}

// 	for _, test := range tests {
// 		defer func() {
// 			if r := recover(); r != nil {
// 				t.Errorf("Recovered from panic: %v", r)
// 			}
// 		}()
// 		result := Within(test.s, test.v)
// 		if result != test.expected {
// 			t.Errorf("For %v, expected %d, but got %d", test, test.expected, result)
// 		}
// 	}
// }
