func TestAddScaledTo(t *testing.T) {
	dst := []float64{1, 2, 3}
	y := []float64{4, 5, 6}
	alpha := 2.0
	s := []float64{7, 8, 9}

	expected := []float64{15, 18, 21}
	result := AddScaledTo(dst, y, alpha, s)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}
}
func TestDot(t *testing.T) {
	// Test cases
	tests := []struct {
		s1       []float64
		s2       []float64
		expected float64
	}{
		{[]float64{1, 2, 3}, []float64{4, 5, 6}, 32},
		{[]float64{0, 0, 0}, []float64{0, 0, 0}, 0},
		{[]float64{1, 1, 1}, []float64{1, 2, 3}, 6},
		{[]float64{2.5, 3.5, 4.5}, []float64{1.2, 2.3, 3.4}, 27.35},
	}

	for _, test := range tests {
		result := Dot(test.s1, test.s2)
		if result != test.expected {
			t.Errorf("For s1=%v, s2=%v, expected %f, but got %f", test.s1, test.s2, test.expected, result)
		}
	}
}
func TestAddTo(t *testing.T) {
	dst := []float64{1, 2, 3}
	s := []float64{4, 5, 6}
	t := []float64{7, 8, 9}

	result := AddTo(dst, s, t)

	expectedResult := []float64{12, 15, 18}

	for i := range result {
		if result[i] != expectedResult[i] {
			t.Errorf("Expected %v, but got %v at index %d", expectedResult[i], result[i], i)
		}
	}
}

func TestAddTo_Panic1(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("AddTo did not panic with different lengths of input slices")
		}
	}()

dst := []float64{1, 2, 3}
	s := []float64{4, 5}
	t := []float64{7, 8, 9}

AddTo(dst, s, t)
}

func TestAddTo_Panic2(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("AddTo did not panic with different lengths of destination slice")
		}
	}()

	dst := []float64{1, 2}
	s := []float64{4, 5, 6}
	t := []float64{7, 8}

AddTo(dst, s, t)
}
func TestMaxIdx(t *testing.T) {
	tests := []struct {
		name     string
		input    []float64
		expected int
	}{
		{"Empty slice", []float64{}, 0},
		{"All NaN values", []float64{math.NaN(), math.NaN()}, 0},
		{"Positive numbers", []float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},
		{"Negative numbers", []float64{-4.0, -2.5, -1.0, -3.0, -2.0}, 2},
		{"Mixed numbers", []float64{-10.5, 0.0, 5.5, -5.0, 2.0}, 2},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					if r != zeroLength {
						t.Errorf("Unexpected panic: %v", r)
					}
				}
			}()

			result := MaxIdx(tt.input)
			if result != tt.expected {
				t.Errorf("MaxIdx(%v) returned %d, expected %d", tt.input, result, tt.expected)
			}
		})
	}
}
func TestSpan(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		l        float64
		u        float64
		expected []float64
	}{
		{
			name:     "Normal case",
			dst:      make([]float64, 5),
			l:        0,
			u:        10,
			expected: []float64{0, 2.5, 5, 7.5, 10},
		},
		{
			name:     "NaN lower bound",
			dst:      make([]float64, 3),
			l:        math.NaN(),
			u:        10,
			expected: []float64{math.NaN(), math.NaN(), 10},
		},
		// Add more test cases as needed
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Span(tt.dst, tt.l, tt.u)
			if len(result) != len(tt.expected) {
				t.Errorf("Test %s failed: expected %v, got %v", tt.name, tt.expected, result)
				return
			}
			for i := 0; i < len(result); i++ {
				if math.IsNaN(tt.expected[i]) {
					if !math.IsNaN(result[i]) {
						t.Errorf("Test %s failed: expected %v, got %v", tt.name, tt.expected, result)
						return
					}
				} else {
					if result[i] != tt.expected[i] {
						t.Errorf("Test %s failed: expected %v, got %v", tt.name, tt.expected, result)
						return
					}
				}
			}
		})
	}
}
func TestCumProd(t *testing.T) {
	tests := []struct {
		dst  []float64
		s    []float64
		want []float64
	}{
		{[]float64{1, 1, 1}, []float64{1, 2, 3}, []float64{1, 2, 6}},
		{[]float64{1, 1, 1}, []float64{4, 5, 6}, []float64{4, 20, 120}},
		{[]float64{1, 1, 1}, []float64{0.5, 2, 3}, []float64{0.5, 1, 3}},
		{[]float64{}, []float64{}, []float64{}},
		{[]float64{1, 1, 1}, []float64{1, 1}, []float64{1, 1, 1}},
	}

	for _, test := range tests {
		if got := CumProd(make([]float64, len(test.dst)), test.s); !reflect.DeepEqual(got, test.want) {
			t.Errorf("CumProd(%v, %v) = %v, want %v", test.dst, test.s, got, test.want)
		}
	}
}
func isEqual(f1, f2 float64) bool {
	return math.Abs(f1 - f2) < 1e-10
}

func TestMul(t *testing.T) {
	// Test case 1
	dst1 := []float64{1.0, 2.0, 3.0}
	s1 := []float64{2.0, 3.0, 4.0}
	Mul(dst1, s1)
	expected1 := []float64{2.0, 6.0, 12.0}
	for i := 0; i < len(dst1); i++ {
		if !isEqual(dst1[i], expected1[i]) {
			t.Errorf("Test case 1 failed. Expected: %v, Got: %v", expected1[i], dst1[i])
		}
	}

	// Test case 2
	dst2 := []float64{2.0, 4.0, 6.0}
	s2 := []float64{0.5, 0.25, 0.1}
	Mul(dst2, s2)
	expected2 := []float64{1.0, 1.0, 0.6}
	for i := 0; i < len(dst2); i++ {
		if !isEqual(dst2[i], expected2[i]) {
			t.Errorf("Test case 2 failed. Expected: %v, Got: %v", expected2[i], dst2[i])
		}
	}

	// Additional test cases can be added here
}
func TestSub(t *testing.T) {
	tests := []struct {
		dst  []float64
		s    []float64
		want []float64
	}{
		{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{0, 1, 2}},
		{[]float64{10, 10, 10, 10}, []float64{1, 2, 3}, []float64{9, 8, 7, 10}},
		{[]float64{0.5}, []float64{0.5}, []float64{0}},
	}

	for _, test := range tests {
		if len(test.dst) != len(test.s) {
			t.Fatalf("slice lengths do not match")
		}

		dst := make([]float64, len(test.dst))
		copy(dst, test.dst)
		Sub(dst, test.s)

		if !reflect.DeepEqual(dst, test.want) {
			t.Errorf("Sub(%v, %v) = %v, want %v", test.dst, test.s, dst, test.want)
		}
	}
}
func TestCumSum(t *testing.T) {
	dst := []float64{1.0, 2.0, 3.0}
	s := []float64{4.0, 5.0, 6.0}
	expected := []float64{5.0, 7.0, 9.0}

	result := CumSum(dst, s)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Cumulative sum does not match expected result. Got: %v, Want: %v", result, expected)
	}
}

func TestCumSumEmptyInput(t *testing.T) {
	dst := []float64{}
	s := []float64{}
	expected := []float64{}

	result := CumSum(dst, s)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Cumulative sum for empty input does not match expected result. Got: %v, Want: %v", result, expected)
	}
}

func TestCumSumDifferentLengthInputs(t *testing.T) {
	dst := []float64{1.0, 2.0}
	s := []float64{4.0, 5.0, 6.0}

	defer func() {
		if recover() == nil {
			t.Errorf("Expected CumSum to panic with different length inputs")
		}
	}()

	CumSum(dst, s)
}
func TestNearestIdx(t *testing.T) {
	tests := []struct {
		s        []float64
		v        float64
		expected int
	}{
		{[]float64{1.1, 2.2, 3.3, 4.4}, 2.5, 1},
		{[]float64{10.5, 20.4, 30.7, 40.2}, 25.0, 1},
		{[]float64{}, 5.0, 0},
		{[]float64{5.5}, 8.0, 0},
	}

	for _, test := range tests {
		defer func() {
			if r := recover(); r != nil {
				t.Errorf("Test case caused a panic: %v", r)
			}
		}()

		result := NearestIdx(test.s, test.v)
		if !reflect.DeepEqual(result, test.expected) {
			t.Errorf("For slice %v and value %v, expected index %v, but got %v", test.s, test.v, test.expected, result)
		}
	}
}
func TestSubTo(t *testing.T) {
	tests := []struct {
		dst  []float64
		s    []float64
		t    []float64
		want []float64
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{2.0, 1.0, 3.0}, []float64{2.0, 4.0, 0.0}},
		{[]float64{0.5, 0.5}, []float64{0.3, 0.7}, []float64{0.1, 0.8}, []float64{0.4, -0.1}},
	}

	for _, test := range tests {
		if len(test.dst) != len(test.s) {
			t.Errorf("SubTo(%v, %v, %v) = destination slice length does not match input", test.dst, test.s, test.t)
			continue
		}

		got := SubTo(test.dst, test.s, test.t)
		if !reflect.DeepEqual(got, test.want) {
			t.Errorf("SubTo(%v, %v, %v) = %v; want %v", test.dst, test.s, test.t, got, test.want)
		}
	}
}
func round(x []float64) []float64 {
	for i, val := range x {
		x[i] = math.Round(val*1e10) / 1e10
	}
	return x
}

func TestScaleTo(t *testing.T) {
	tests := []struct {
		dst  []float64
		c    float64
		s    []float64
		want []float64
	}{
		{[]float64{1, 2, 3}, 2, []float64{4, 5, 6}, []float64{8, 10, 12}},
		{[]float64{0.5, 0.5}, 3, []float64{0.1, 0.1}, []float64{0.3, 0.3}},
		{[]float64{2, 3}, 1, []float64{1, 1}, []float64{1, 1}},
	}

	for _, tt := range tests {
		t.Run("", func(t *testing.T) {
			if got := ScaleTo(tt.dst, tt.c, tt.s); !reflect.DeepEqual(round(got), round(tt.want)) {
				t.Errorf("ScaleTo() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestCount(t *testing.T) {
	cases := []struct {
		name     string
		f        func(float64) bool
		input    []float64
		expected int
	}{
		{
			name:     "countPositiveNumbers",
			f:        func(x float64) bool { return x > 0 },
			input:    []float64{-2.5, 3.7, 0, 1.2, -5.6, 4},
			expected: 3,
		},
		{
			name:     "countEvenNumbers",
			f:        func(x float64) bool { return int(x)%2 == 0 },
			input:    []float64{2.3, 5.6, 8, 7.1, -4, 0},
			expected: 4, // Change the expected count to 4 (for numbers 5.6, 8, -4, and 0).
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			result := Count(tc.f, tc.input)
			if result != tc.expected {
				t.Errorf("Count(%s) = %d; want %d", tc.name, result, tc.expected)
			}
		})
	}
}
func TestLogSpan(t *testing.T) {
	tests := []struct {
		name     string
		dst      []float64
		l        float64
		u        float64
		expected []float64
	}{
		{name: "Test 1", dst: []float64{1, 2, 3}, l: 1, u: 10, expected: []float64{1, 2, 3}},
		{name: "Test 2", dst: []float64{0.5, 1, 1.5}, l: 0.5, u: 2, expected: []float64{0.5, 1, 1.5}},
		// Add more test cases as needed
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := LogSpan(tc.dst, tc.l, tc.u)
			if !reflect.DeepEqual(result, tc.expected) {
				t.Errorf("Expected %v, but got %v", tc.expected, result)
			}
		})
	}
}

func LogSpan(dst []float64, l, u float64) []float64 {
	lower := math.Log(l)
	upper := math.Log(u)

	step := (upper - lower) / float64(len(dst)-1)

	for i := range dst {
		dst[i] = math.Exp(lower + float64(i)*step)
	}
	return dst
}
func TestFind(t *testing.T) {
	tests := []struct {
		name     string
		inds     []int
		f        func(float64) bool
		s        []float64
		k        int
		expected []int
		wantErr  bool
	}{
		{
			name:     "Find 2 elements",
			inds:     []int{1, 3},
			f:        func(val float64) bool { return val > 5 },
			s:        []float64{3, 6, 9, 2, 7},
			k:        2,
			expected: []int{1, 2},
			wantErr:  false,
		},
		{
			name:     "Find all elements",
			inds:     nil,
			f:        func(val float64) bool { return val < 5 },
			s:        []float64{3, 6, 9, 2, 7},
			k:        -1,
			expected: []int{0, 3},
			wantErr:  false,
		},
		{
			name:     "Not enough elements found",
			inds:     nil,
			f: func(val float64) bool { 
				return val > 10
			},
			s:        []float64{3, 6, 9, 2, 7},
			k:        2,
			expected: []int{},
			wantErr:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Find(tt.inds, tt.f, tt.s, tt.k)

			if (err != nil) != tt.wantErr {
				t.Errorf("Find() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && !reflect.DeepEqual(got, tt.expected) {
				t.Errorf("Find() = %v, want %v", got, tt.expected)
			}
		})
	}
}
func TestNorm(t *testing.T) {
	testCases := []struct {
		s        []float64
		L        float64
		expected float64
	}{
		{[]float64{1, 2, 3}, 2, math.Sqrt(14)},
		{[]float64{1, 2, 3}, 1, 6},
		{[]float64{1, 2, 3}, math.Inf(1), 3},
		{[]float64{3, 4}, 2, 5},
		{[]float64{3, 4}, 1, 7},
		{[]float64{3, 4}, math.Inf(1), 4},
		{[]float64{2, 2, 2}, 2, 6},
		{[]float64{2, 2, 2}, 1, 6},
		{[]float64{2, 2, 2}, math.Inf(1), 2},
	}

	for _, tc := range testCases {
		result := Norm(tc.s, tc.L)
		if !approxEqual(result, tc.expected, 1e-6) {
			t.Errorf("Expected Norm(%v, %v) to be %f, but got %f", tc.s, tc.L, tc.expected, result)
		}
	}
}

func approxEqual(a, b, tolerance float64) bool {
	return math.Abs(a-b) < tolerance
}
func TestDiv(t *testing.T) {
	// Test cases
	tests := []struct {
		dst []float64
		s   []float64
	}{
		{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}},
		{[]float64{2.5, 3.5, 4.5}, []float64{0.5, 0.5, 0.5}},
		{[]float64{0.0, 0.0, 0.0}, []float64{10.0, 20.0, 30.0}},
	}

	for _, test := range tests {
		// Create a copy of the source slice for comparison
		expected := make([]float64, len(test.s))
		copy(expected, test.s)

		// Call Div function
		Div(test.dst, test.s)

		// Check if length is correct
		if len(test.dst) != len(test.s) {
			t.Errorf("Length not matching")
		}

		// Check if each element is dividing correctly
		for i := 0; i < len(test.dst); i++ {
			if test.dst[i] != expected[i]/test.s[i] {
				t.Errorf("Dividing error")
			}
		}
	}
}
func TestLogSumExp(t *testing.T) {
	testCases := []struct {
		input    []float64
		expected float64
	}{
		{[]float64{0, 0, 0}, 0},
		{[]float64{1, 2, 3}, math.Log(math.Exp(1-3) + math.Exp(2-3) + math.Exp(3-3)) + 3},
		{[]float64{}, math.Inf(-1)},
	}

	for _, tc := range testCases {
		result := LogSumExp(tc.input)
		if math.IsInf(tc.expected, 0) {
			if !math.IsInf(result, 0) {
				t.Errorf("Expected LogSumExp(%v) to be %v, but got %v", tc.input, tc.expected, result)
			}
		} else if result != tc.expected {
			t.Errorf("Expected LogSumExp(%v) to be %v, but got %v", tc.input, tc.expected, result)
		}
	}
}
