{
    "0509e0638a4b45d441f01d4ba3e331eb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttests := []struct {\n\t\tc    float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{2.0, []float64{1.0, 2.0, 3.0}, []float64{2.0, 4.0, 6.0}},\n\t\t{-1.5, []float64{1.0, 2.0, 3.0}, []float64{-1.5, -3.0, -4.5}},\n\t\t{0.0, []float64{1.0, 2.0, 3.0}, []float64{0.0, 0.0, 0.0}},\n\t\t{5.0, []float64{}, []float64{}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tfloats.Scale(tt.c, tt.dst)\n\t\tfor i, v := range tt.dst {\n\t\t\tif v != tt.want[i] {\n\t\t\t\tt.Errorf(\"Scale(%f, %v) = %v, want %v\", tt.c, tt.dst, tt.dst, tt.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "02dace20380755f8b679152b01cb1c37": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tdst          []float64\n\t\tl            float64\n\t\tu            float64\n\t\texpectedDst  []float64\n\t\texpectedPanic bool\n\t}{\n\t\t{\n\t\t\tname:         \"Normal case\",\n\t\t\tdst:          []float64{0, 0, 0, 0},\n\t\t\tl:            0,\n\t\t\tu:            10,\n\t\t\texpectedDst:  []float64{0, 5, 10, 15},\n\t\t\texpectedPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"Invalid length of dst\",\n\t\t\tdst:          []float64{0},\n\t\t\tl:            0,\n\t\t\tu:            10,\n\t\t\texpectedDst:  nil,\n\t\t\texpectedPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"Special case with NaN\",\n\t\t\tdst:          []float64{0, 0, 0, 0},\n\t\t\tl:            0,\n\t\t\tu:            math.NaN(),\n\t\t\texpectedDst:  []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectedPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"Special case with Inf\",\n\t\t\tdst:          []float64{0, 0, 0, 0},\n\t\t\tl:            math.Inf(1),\n\t\t\tu:            math.Inf(-1),\n\t\t\texpectedDst:  []float64{math.Inf(1), 0, math.Inf(-1), 0},\n\t\t\texpectedPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.expectedPanic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, but got: %v\", tt.expectedPanic, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(result, tt.dst) {\n\t\t\t\tt.Errorf(\"Expected destination: %v, but got: %v\", tt.expectedDst, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0026966f482687b357882089f4e9ee0f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{3, 1, 3, 5, 2},\n\t\t{4, 1, 3, 5, 2},\n\t\t{4, -5, 5, 0, 2},\n\t\t{6, 0, 10, 10, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected index=%d, but got %d\", test.n, test.l, test.u, test.v, test.index, index)\n\t\t}\n\t}\n}",
    "00ff8da04f0e838382a81a82fbe07efe": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:    1,\n\t\t\twant: 15,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:    2,\n\t\t\twant: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname: \"Max absolute value\",\n\t\t\ts:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    1,\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := floats.Norm(tc.s, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f; want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "013e5ee407fb258d6a8c3fda98af7c6a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\".\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{}, 0, 1},\n\t\t{[]float64{0}, 0, 1},\n\t\t{[]float64{1, 2, 3}, 1, 3},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Span length error. Expected %d, got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"First element error. Expected %f, got %f\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Last element error. Expected %f, got %f\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}\n\nfunc TestSpanShort(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for short dst length\")\n\t\t}\n\t}()\n\n\tfloats.Span([]float64{1}, 0, 1)\n}",
    "0215348bb87bbfbf266f19937ec2247e": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/gonum/floats\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst: []float64{1, 2, 3},\n\t\t\ts:   []float64{1, 1, 1},\n\t\t\texpected: []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst: []float64{5, 5, 5},\n\t\t\ts:   []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 3, 2},\n\t\t},\n\t\t{\n\t\t\tdst: []float64{10, 20, 30},\n\t\t\ts:   []float64{3, 5, 7},\n\t\t\texpected: []float64{7, 15, 23},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := make([]float64, len(test.dst))\n\t\tfloats.Sub(result, test.dst, test.s)\n\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Subtraction failed, expected: %v, got: %v\", test.expected, result)\n\t\t}\n\t}\n\n\t// Test panic caused by bad length\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Subtraction did not panic with different lengths\")\n\t\t}\n\t}()\n\tfloats.Sub([]float64{1, 2, 3, 4}, []float64{1, 2, 3})\n}",
    "028e90cbce778d1961c87aa647c65dad": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your_import_path/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn         int\n\t\tl, u, v   float64\n\t\texpected  int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -10.0, 10.0, 0.0, 2},\n\t\t{5, 1.0, 9.0, 5.7, 3},\n\t\t{6, 0.5, 2.5, 1.5, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, and v=%f, expected index %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "02c76544e44aa50c3890e81b07f8e90f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.2, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4.7, 3},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{[]float64{1.0, 3.0, 5.0, 7.0, 9.0}, 6.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For NearestIdx(%v, %v), expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "02d05743532d1daecf41e66d43e30cae": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{5, 1.0, 10.0, 5.0, 2},\n\t\t{3, 0.0, 5.0, 3.0, 1},\n\t\t{4, -5.0, 5.0, 0.0, 2},\n\t\t{3, -10.0, 10.0, -15.0, 0},\n\t\t{4, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "02fbbeaf9207bbe077f089b5539b257d": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/yourmodule/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{3, 4}, math.Inf(-1), 4},\n\t\t{[]float64{1, 2, 3}, 2, 3.7416573867739413},\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{1, 2, 3}, 3, 3.3019272488946263},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 2, 3.7416573867739413},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := floats.Norm(test.input, test.L)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, want %v\", test.input, test.L, got, test.want)\n\t\t}\n\t}\n}",
    "0448c285f2fcbc79b86a5077593f1471": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 4},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{0, 1, 2, 3}, 0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\toriginal := make([]float64, len(test.dst))\n\t\tcopy(original, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\t// Check if mutated slice is the same as the original slice\n\t\tif !reflect.DeepEqual(test.dst, original) {\n\t\t\tt.Errorf(\"Mutated slice is not the same as the original slice\")\n\t\t}\n\n\t\t// Check if the final element of dst is u\n\t\tif test.dst[len(test.dst)-1] != test.u {\n\t\t\tt.Errorf(\"Final element of dst is not equal to u\")\n\t\t}\n\n\t\t// Check if the length of mutated dst is the same as the original length\n\t\tif len(test.dst) != len(result) {\n\t\t\tt.Errorf(\"Length of mutated dst is not the same as the original length\")\n\t\t}\n\t}\n}\n",
    "0481378a1b09214b71ea7267f94d33e1": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"Test normal case\",\n\t\t\tinput: []float64{4.5, 2.7, 3.2, 1.2},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Test negative numbers\",\n\t\t\tinput: []float64{-4.5, -2.7, -3.2, -1.2},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Test NaN\",\n\t\t\tinput: []float64{4.5, 2.7, 3.2, -1.2, 1.5, 1.5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Test mixed numbers and NaN\",\n\t\t\tinput: []float64{4.5, 2.7, 3.2, -1.2, 1.5, 1.5, 0, -2.5},\n\t\t\texpected: 7,\n\t\t},\n\t\t{\n\t\t\tname: \"Test all numbers as NaN\",\n\t\t\tinput: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected MinIdx(%v) to return %v, but got %v\", tt.input, tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "049bf5e147c76a4cefac4edd03539ef1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{name: \"Test Case 1\", n: 5, l: 0, u: 10, v: 3, want: 0},\n\t\t{name: \"Test Case 2\", n: 4, l: 0, u: 10, v: 12, want: 3},\n\t\t{name: \"Test Case 3\", n: 3, l: -10, u: 10, v: -20, want: 0},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "078c692d78e6f34adcf892727898b8a7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\tl           float64\n\t\tu           float64\n\t\texpectedDst []float64\n\t}{\n\t\t{\n\t\t\t\"Normal Span\",\n\t\t\t[]float64{0, 0, 0, 0, 0},\n\t\t\t0.0,\n\t\t\t10.0,\n\t\t\t[]float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\t\"NaN Lower Bound\",\n\t\t\t[]float64{0, 0, 0, 0, 0},\n\t\t\tmath.NaN(),\n\t\t\t10.0,\n\t\t\t[]float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\t\"Inf Bounds\",\n\t\t\t[]float64{0, 0, 0, 0, 0},\n\t\t\tmath.Inf(-1),\n\t\t\tmath.Inf(1),\n\t\t\t[]float64{math.Inf(-1), -5, 0, 5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.expectedDst) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expectedDst, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "07a3669a4df39454690361c55d14ee12": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 0},\n\t\t{5, -5.0, 5.0, 3.0, 4},\n\t\t{4, 0.0, 100.0, 50.0, 2},\n\t\t{3, -10.0, 10.0, -15.0, 0},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t\t{2, 0.0, 5.0, 10.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "082fe751a23930a68a019f44025e09cd": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Test Span with length 5\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\texpect: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with length 3\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -1,\n\t\t\tu:      1,\n\t\t\texpect: []float64{-1, 0, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with NaN values\",\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      0,\n\t\t\tu:      floats.NaN(),\n\t\t\texpect: []float64{0, floats.NaN(), floats.NaN(), floats.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.expect) {\n\t\t\t\tt.Errorf(\"Span() result = %v, want %v\", result, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "08367c21374f71c8896f648b0805835b": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your_package_name/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 1, 2}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0}, 0, 0, []float64{0, 0, 0}},\n\t\t{[]float64{10, 20, 30, 40, 50}, 10, 50, []float64{10, 20, 30, 40, 50}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := floats.Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0843ef585b873a1a79ee4ad7a8360783": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn         int\n\t\tl         float64\n\t\tu         float64\n\t\tv         float64\n\t\texpected  int\n\t\tshouldPanic bool\n\t}{\n\t\t{5, 2.0, 8.0, 5.0, 2, false},\n\t\t{3, 0.0, 10.0, -5.0, 0, false},\n\t\t{10, -5.0, 5.0, 3.2, 8, false},\n\t\t{2, 1.0, 5.0, 3.0, 1, false},\n\t\t{4, 0.0, 0.0, 0.0, 0, false}, // Special case for l=u=0\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0, false},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(-1), 0, false},\n\t\t{4, -10.0, 10.0, math.Inf(-1), 0, false},\n\t\t{4, -10.0, 10.0, math.Inf(1), 3, false},\n\t\t{4, 10.0, -10.0, 5.0, 0, false},\n\t\t{10, 1.0, 10.0, 5.5, 4, false},\n\t\t{2, 1.0, 5.0, 7.0, 1, false},\n\t\t{2, 1.0, 5.0, 0.0, 0, false},\n\t\t{5, 2.0, 8.0, math.NaN(), 0, false},\n\t\t{1, 2.0, 8.0, 5.0, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.shouldPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(%d, %f, %f, %f)\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Unexpected result for NearestIdxForSpan(%d, %f, %f, %f) - got: %d, want: %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n}",
    "08d82e43185b5ac68d847ab24ea6f61b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\toutput int\n\t}{\n\t\t{3, 0.0, 2.0, 1.0, 1},\n\t\t{5, 1.0, 5.0, 3.0, 2},\n\t\t{4, 0.5, 2.5, 4.0, 3},\n\t\t{2, 1.0, 2.0, 1.5, 0},\n\t\t{6, 0.0, 10.0, -2.0, 0},\n\t}\n\n\tfor _, tc := range tests {\n\t\tresult := floats.NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif result != tc.output {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", tc.n, tc.l, tc.u, tc.v, result, tc.output)\n\t\t}\n\t}\n}",
    "092d969bdc8d331e1383b09ae960574d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\"L1 norm of {1, 2, 3}\", []float64{1, 2, 3}, 1, 6},\n\t\t{\"L2 norm of {1, 2, 3}\", []float64{1, 2, 3}, 2, 3.7416573867739413},\n\t\t{\"Zero norm\", []float64{}, 2, 0},\n\t\t{\"Infinity norm of {1, -5, 10}\", []float64{1, -5, 10}, math.Inf(1), 10},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Norm(tt.s, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0a4296a1d29592be5b3cbae3eddad4e4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tl := 0.0\n\tu := 10.0\n\tdst := make([]float64, 5)\n\tresult := floats.Span(dst, l, u)\n\n\tif len(result) != len(dst) {\n\t\tt.Errorf(\"Expected result length %d, got %d\", len(dst), len(result))\n\t}\n\n\tfor i, val := range result {\n\t\tif val != l+float64(i)*(u-l)/float64(len(dst)-1) {\n\t\t\tt.Errorf(\"Unexpected value at index %d, got %f\", i, val)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n// func TestSpan_YourTestCase(t *testing.T) {}\n\n// Add more test functions for other functions in the floats package if needed\n// func TestFunctionName(t *testing.T) {}",
    "0a81dba7d0fdfeb9b2ee90d5fffab1ef": "// Package floats provides functions for mathematical operations on slices of floats.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn             int\n\t\tl             float64\n\t\tu             float64\n\t\tv             float64\n\t\texpectedIndex int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 1},      // Span [1, 2], v = 1.5, closest to 1\n\t\t{4, 0.0, 10.0, 5.5, 2},      // Span [0, 10], v = 5.5, closest to 5\n\t\t{3, -2.0, 2.0, -1.5, 0},     // Span [-2, 2], v = -1.5, closest to -2\n\t\t{5, -1.0, 1.0, 0.8, 4},      // Span [-1, 1], v = 0.8, closest to 1\n\t\t{3, 0.0, 5.0, 2.0, 2},       // Span [0, 5], v = 2.0, closest to 2\n\t\t{6, 1.0, 10.0, 5.5, 2},      // Span [1, 10], v = 5.5, closest to 5\n\t\t{4, -5.0, -1.0, -3.0, 2},    // Span [-5, -1], v = -3.0, closest to -3\n\t\t{5, 0.0, 100.0, 50.0, 2},    // Span [0, 100], v = 50.0, closest to 50\n\t\t{3, -10.0, 0.0, -7.5, 1},    // Span [-10, 0], v = -7.5, closest to -10\n\t\t{4, 10.0, 20.0, 15.0, 2},    // Span [10, 20], v = 15.0, closest to 15\n\t\t{6, -50.0, -10.0, -30.0, 3}, // Span [-50, -10], v = -30.0, closest to -30\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.expectedIndex {\n\t\t\tt.Errorf(\"For Span(%d)[%f, %f] and v=%f, expected index %d, but got %d\", test.n, test.l, test.u, test.v, test.expectedIndex, index)\n\t\t}\n\t}\n}\n",
    "0b097e9900feb8b9e641c792209cf25f": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{name: \"empty slice\", input: []float64{}, expected: 0},\n\t\t{name: \"one element slice\", input: []float64{5.0}, expected: 0},\n\t\t{name: \"multiple elements\", input: []float64{3.0, 1.0, 4.0, 2.0}, expected: 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0b471cefc5359254a2f629459fb3aade": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test span with N=3\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test span with N=4\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    4,\n\t\t\twant: []float64{1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"Test span with N=5\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    -2,\n\t\t\tu:    3,\n\t\t\twant: []float64{-2, -1, 0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Test panic for short span\",\n\t\t\tdst:  []float64{0},\n\t\t\tl:    -2,\n\t\t\tu:    3,\n\t\t\twant: []float64{0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span should have panicked for short span\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0c3582a382574f253a9d3e2de6f04b2e": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\"Same slices with same values\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{\"Same slices with different values\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 4.0, 3.0}, false},\n\t\t{\"Slices with different lengths\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{\"Slices with NaN\", []float64{1.0, 2.0, 3.0, NaN}, []float64{1.0, 2.0, 3.0, NaN}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Same(tt.slice1, tt.slice2)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected result to be %v but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0cbfee12334c61b215b68e7039d3e04c": "package floats\n\nimport \"testing\"\n\nfunc TestSpan(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test Span with length 2\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\texpected: []float64{0.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with length 5\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        2.0,\n\t\t\tu:        7.0,\n\t\t\texpected: []float64{2.0, 3.25, 4.5, 5.75, 7.0},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tc.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", tc.expected[i], i, result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d144bb389e3e2f7fce75bb9ab4c36ba": "// Package floats contains various mathematical functions for float64 slices.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn, l, u  float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Case 1\", 5, 2, 10, 4, 0},\n\t\t{\"Case 2\", 5, 1, 5, 10, 4},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d37d4ebe8ea732945906d799178ed91": "package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"count all true\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"count none true\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003c 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"count some true\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x%2 == 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif output := Count(tt.f, tt.s); output != tt.expected {\n\t\t\t\tt.Errorf(\"Count(%v, %v) = %v, want %v\", tt.f, tt.s, output, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d38cf851eedbeb3bf60880a2ff1cb98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2.0, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1.0, 3.0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3.0, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5}, 2.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"For s=%v, t=%v, L=%v, expected %v but got %v\", test.s, test.t, test.L, test.expected, result)\n\t\t}\n\t}\n}\n\n// Additional tests can be added for edge cases and special scenarios\n",
    "0e04172c6c2d5d231457bf49bbcc2001": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your_module_path/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"Successful span calculation\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  []float64{0, 2.5, 5, 7.5, 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Panic on dst length less than 2\",\n\t\t\tdst:   make([]float64, 1),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  []float64{},\n\t\t\tpanic: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"panic = %v, want %v\", r != nil, tt.panic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0e9561493f6229f9472a0d33b0425509": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{1, 1, 1, 1, 1}, 1, 2, []float64{1, 1.25, 1.5, 1.75, 2}},\n\t\t{[]float64{10, 10, 10}, 1, 2, []float64{1, 1.5, 2}},\n\t\t{[]float64{0, 0}, math.NaN(), 5, []float64{math.NaN(), 5}},\n\t}\n\n\tfor i, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\tt.Errorf(\"Test case %d failed - got: %v, want: %v\", i+1, got, tt.want)\n\t\t}\n\t}\n\n\t// Test panic if dst length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test did not panic when dst length was less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{1}, 1, 2)\n}\n",
    "0f3a51095de34ca23f6513dd63718b5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 1, 1}, 1, 2, []float64{1, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 2, 5, []float64{2, 2.5, 3, 3.5, 4, 5}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := LogSpan(tt.dst, tt.l, tt.u)\n\t\t\tif len(got) != len(tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tt.want[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif got[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "0fd11dba8dbc082251b5cc7acfffe5cd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\tout []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}, []float64{11, 13, 15}},\n\t\t{[]float64{1, 2}, []float64{4, 5}, []float64{7, 8, 9}, nil},\n\t}\n\n\tfor _, tc := range tests {\n\t\tgot := AddTo(tc.dst, tc.s, tc.t)\n\n\t\tif !reflect.DeepEqual(got, tc.out) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", tc.dst, tc.s, tc.t, got, tc.out)\n\t\t}\n\t}\n}",
    "10520592a0f56f200f0a6b8fc4e6f903": "func TestEqualFunc(t *testing.T) {\n\t// Test cases for EqualFunc\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal Slices\",\n\t\t\tslice1:   []float64{1.1, 2.2, 3.3},\n\t\t\tslice2:   []float64{1.1, 2.2, 3.3},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different Length Slices\",\n\t\t\tslice1:   []float64{4.4, 5.5},\n\t\t\tslice2:   []float64{4.4, 5.5, 6.6},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different Elements\",\n\t\t\tslice1:   []float64{7.7, 8.8, 9.9},\n\t\t\tslice2:   []float64{7.7, 8.8, 0.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\t// Test cases\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(test.slice1, test.slice2, Same)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "11f572eb365996ad3a7cf07e62825761": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\"Test L2 Norm\", []float64{1, 2, 3}, 2, 3.7416573867739413},\n\t\t{\"Test L1 Norm\", []float64{1, 2, 3}, 1, 6},\n\t\t{\"Test Max Abs Value\", []float64{-1, -2, 3}, math.Inf(1), 3},\n\t\t{\"Test Norm with Empty Slice\", []float64{}, 2, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "1233b208bd7b9681685f0e7a71169e0f": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"your-package-path/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t{5, 0.0, 10.0, 4.2, 0},\n\t\t{4, -5.0, 5.0, 7.5, 1},\n\t\t{3, -10.0, 10.0, -15.0, 0},\n\t\t{2, 0.0, 100.0, 50.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tactualIdx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif actualIdx != test.expectedIdx {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expectedIdx, actualIdx)\n\t\t}\n\t}\n}",
    "128299297328105251c94c426bd401ac": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic test case\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    6.5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\tn:    4,\n\t\t\tl:    -10.0,\n\t\t\tu:    -5.0,\n\t\t\tv:    -7.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"V outside of bounds\",\n\t\t\tn:    3,\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\tv:    10.0,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "156e9026367d2431fbba36241809755c": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\n\nfunc TestSpan(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Span test case 1\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span test case 2\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 2.333333333333333, 3.6666666666666665, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span test case 3\",\n\t\t\tdst:      []float64{0, 0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        100,\n\t\t\texpected: []float64{0, 25, 50, 75, 100},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span() - Expected: %v, got: %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "16389cca552661e959b771ae10933bd1": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tvalue float64\n\t\tindex int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{10.0, 20.0, 30.0}, 25.0, 2},\n\t\t{[]float64{0.5, 1.5, 2.5}, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdx(test.slice, test.value)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"Expected index %d, but got %d for slice %v and value %f\", test.index, index, test.slice, test.value)\n\t\t}\n\t}\n\n\t// Test panic with zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected NearestIdx to panic with zero length slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 5.0)\n}",
    "16b961141bad023dbcab537e8956f070": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-module-path/floats\" // Update with your actual module path\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0.0, 0.0}, 0.0, 0.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 3.0},\n\t\t{[]float64{1.0, 1.5, 2.0, 2.5, 3.0}, 1.0, 3.0},\n\t\t{[]float64{2.0, 2.5, 3.0, 3.5, 4.0}, 2.0, 4.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Mismatch in length, expected: %v, got: %v\", len(test.dst), len(result))\n\t\t}\n\n\t\tfor i := 0; i \u003c len(test.dst); i++ {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Mismatch at index %v, expected: %v, got: %v\", i, test.dst[i], result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test functions for other functions in the same package...",
    "175bec1e74ac88c0ebf6618319ad2aea": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 5, []float64{1, 3, 5}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 2, []float64{0, 0.6666666666666666, 1.3333333333333333, 2}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(test.dst, test.l, test.u)\n\t\t\tif !reflect.DeepEqual(got, test.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 4)\n}\n",
    "178631791ebe40ac3e37a083dbafcaf0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Subtracting two slices of equal length\",\n\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\ts:    []float64{4.0, 5.0, 6.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: []float64{3.0, 3.0, 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Panic if lengths of s and t do not match\",\n\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\ts:    []float64{4.0, 5.0, 6.0, 7.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif got := SubTo(tt.dst, tt.s, tt.t); !Equal(got, tt.want) {\n\t\t\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSubTo(tt.dst, tt.s, tt.t)\n\t\t})\n\t}\n}",
    "17b48362ee126933a53c1a193c164509": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname        string\n\t\targs        args\n\t\twant        []float64\n\t\tpanicReason string\n\t}{\n\t\t{\n\t\t\tname: \"Lengths match\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{1.0, 2.0, 3.0},\n\t\t\t\ty:     []float64{2.0, 3.0, 4.0},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: []float64{8.0, 11.0, 14.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Lengths do not match\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{1.0, 2.0},\n\t\t\t\ty:     []float64{2.0, 3.0, 4.0},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\tpanicReason: \"panic\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.panicReason != \"\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil || r.(string) != tt.panicReason {\n\t\t\t\t\t\tt.Errorf(\"Expected panic reason: %v, got: %v\", tt.panicReason, r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := floats.AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "1830f8f917008a5af3ab25c87b2ae2dc": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 10.0, 5.0, 2},\n\t\t{3, -5.0, 5.0, 7.0, 2},\n\t\t{4, -10.0, -1.0, -5.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %.1f, %.1f, %.1f), expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "18f63684bb35c6121ee813332812b6fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\"L2 norm\", []float64{3, 4}, 2, 5},\n\t\t{\"L1 norm\", []float64{3, 4}, 1, 7},\n\t\t{\"Infinity norm\", []float64{3, -5, 1, -8}, math.Inf(1), 8},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := Norm(tt.input, tt.L)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"Expected Norm of %v with L=%v to be %v, but got %v\", tt.input, tt.L, tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1968ed211494d5115fccc7fbe0d9b841": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Valid Span Test\",\n\t\t\tdst:     []float64{0.0, 0.0, 0.0},\n\t\t\tl:       0.0,\n\t\t\tu:       2.0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Invalid Length Test\",\n\t\t\tdst:     []float64{0.0},\n\t\t\tl:       0.0,\n\t\t\tu:       2.0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Special Cases Test\",\n\t\t\tdst:     []float64{0.0, 0.0, 0.0},\n\t\t\tl:       1.0 / 0.0,\n\t\t\tu:       -1.0 / 0.0,\n\t\t\twantErr: false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantErr %v\", r, tt.wantErr)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(got) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Span() length = %v, want %v\", len(got), len(tt.dst))\n\t\t\t}\n\t\t\tfor i, v := range got {\n\t\t\t\tif v != tt.dst[i] {\n\t\t\t\t\tt.Errorf(\"Span() value = %v, want %v\", v, tt.dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "19b2aa9741f579897b5c9a00dec4d507": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname  string\n\t\targs  args\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts:   []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2 - Panics\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts:   []float64{2.0, 3.0},\n\t\t\t},\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3 - Panics\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts:   []float64{2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"TestMul() recover = %v, panic %v\", r, tt.panic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tMul(tt.args.dst, tt.args.s)\n\n\t\t\tif !reflect.DeepEqual(tt.args.dst, tt.args.s) {\n\t\t\t\tt.Errorf(\"TestMul() = %v, want %v\", tt.args.dst, tt.args.s)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ad9c3bf09c1a9d8050c0ee5abf9560b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\t// Test case 1: Matching lengths\n\tdst1 := []float64{1, 2, 3}\n\ts1 := []float64{4, 5, 6}\n\texpected1 := []float64{5, 7, 9}\n\tAdd(dst1, s1)\n\tfor i := range dst1 {\n\t\tif dst1[i] != expected1[i] {\n\t\t\tt.Errorf(\"Test case 1 failed at index %d. Expected: %f, Got: %f\", i, expected1[i], dst1[i])\n\t\t}\n\t}\n\n\t// Test case 2: Mismatching lengths (expecting panic)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case 2: Expected panic due to mismatching lengths\")\n\t\t}\n\t}()\n\tdst2 := []float64{1, 2}\n\ts2 := []float64{4, 5, 6}\n\tAdd(dst2, s2)\n}",
    "1c4cb9f8a7e88f9578abe483cfc61f88": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"All Positive\", []float64{1.0, 2.0, 3.0, 2.0}, 2},\n\t\t{\"All Negative\", []float64{-1.0, -2.0, -3.0, -2.0}, 0},\n\t\t{\"Mixed\", []float64{-1.0, 5.0, 6.0, 3.0}, 2},\n\t\t{\"Empty Slice\", []float64{}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c5f72f2d5979de07ba7baa8000ca229": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 0, 4},\n\t\t{[]float64{3, 6, 9, 12}, 3, 12},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Check if the length of the output matches the input\n\t\t\tif len(got) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected output length to be %d, but got %d\", len(tt.dst), len(got))\n\t\t\t}\n\n\t\t\t// Check if the first element of the output is l\n\t\t\tif got[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, got[0])\n\t\t\t}\n\n\t\t\t// Check if the last element of the output is u\n\t\t\tif got[len(got)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, got[len(got)-1])\n\t\t\t}\n\n\t\t\t// Check if the output is equally spaced between l and u\n\t\t\tstep := (tt.u - tt.l) / float64(len(got)-1)\n\t\t\tfor i := 0; i \u003c len(got); i++ {\n\t\t\t\texpected := tt.l + step*float64(i)\n\t\t\t\tif math.Abs(got[i]-expected) \u003e 1e-9 { // Tolerance for floating point comparison\n\t\t\t\t\tt.Errorf(\"Expected element at index %d to be %f, but got %f\", i, expected, got[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ca3cc76bc3280f4036eb5e02262113a": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttolerance := 1e-9\n\n\t// Test panic for length less than 2\n\tdst := make([]float64, 1)\n\tl := 1.0\n\tu := 10.0\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(dst, l, u)\n\n\t// Test special case for NaN\n\tdst = make([]float64, 5)\n\tl = math.NaN()\n\tu = 10.0\n\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0}\n\tresult := Span(dst, l, u)\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %v, but got: %v\", expected, result)\n\t}\n\n\t// Test special case for Inf\n\tdst = make([]float64, 6)\n\tl = math.Inf(-1)\n\tu = math.Inf(1)\n\texpected = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tresult = Span(dst, l, u)\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected: %v, but got: %v\", expected, result)\n\t}\n\n\t// Test general case\n\tdst = make([]float64, 4)\n\tl = 0.0\n\tu = 10.0\n\texpected = []float64{0.0, 3.333333333, 6.666666666, 10.0}\n\tresult = Span(dst, l, u)\n\tfor i := range result {\n\t\tif math.Abs(result[i]-expected[i]) \u003e tolerance {\n\t\t\tt.Errorf(\"Expected: %v, but got: %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
    "1d6ce67971a15d6b9f8427cb2884ae20": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{\n\t\t\tname:  \"Test case 1\",\n\t\t\tinput: []float64{1.0, 2.0, 3.0},\n\t\t\twant:  6.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Test case 2\",\n\t\t\tinput: []float64{-1.0, -2.0, -3.0},\n\t\t\twant:  -6.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Test case 3\",\n\t\t\tinput: []float64{0.1, 0.2, 0.3, 0.4},\n\t\t\twant:  1.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.input)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1fdd45a9c18c7c68f389281bb34338b8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 0.0, 10.0, 12.0, 3},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t\t{6, 1.0, 2.0, 1.5, 1},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "1fe92cb8cfb822ebbb0cb855c24a048d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice      []float64\n\t\tvalue      float64\n\t\texpectedIdx int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 3.6, 3},\n\t\t{[]float64{10, 20, 30, 40, 50}, 17, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tidx := NearestIdx(test.slice, test.value)\n\t\tif idx != test.expectedIdx {\n\t\t\tt.Errorf(\"For slice %v and value %v, expected index: %d, but got: %d\", test.slice, test.value, test.expectedIdx, idx)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdx_panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\n\tNearestIdx([]float64{}, 2.0)\n}\n",
    "200507033a4953d93b579d69ed390e88": "package floats\n\nimport \"testing\"\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := MaxIdx(tt.input)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", tt.input, got, tt.want)\n\t\t}\n\t}\n}",
    "20b1c7750ca546302f3faea997b5b38d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn          int\n\t\tl          float64\n\t\tu          float64\n\t\tv          float64\n\t\texpected   int\n\t\tshouldPanic bool\n\t}{\n\t\t{5, 0.0, 10.0, 5.0, 2, false},\n\t\t{3, 0.0, 10.0, 5.0, -1, true},\n\t\t{4, 0.0, 0.0, 5.0, 0, false},\n\t\t{4, 0.0, 0.0, 0.0, 0, true},\n\t\t{2, 5.0, 10.0, 7.0, 1, false},\n\t\t{6, 3.0, 8.0, 1.0, 0, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != test.shouldPanic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, but got panic: %v\", test.shouldPanic, r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For n=%d, l=%.1f, u=%.1f, v=%.1f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "210f3b2cc25d3852c35a761e34477c91": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst        []float64\n\t\tl, u       float64\n\t\twantResult []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5, []float64{1, 2, 3, 4, 5}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := floats.Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.wantResult) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.wantResult)\n\t\t\t}\n\t\t})\n\t}\n}",
    "213b596d12483bcacb7cf3ba03419666": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        4.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test 2\",\n\t\t\ts:        []float64{10.0, 20.0, 30.0, 40.0},\n\t\t\tv:        25.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test 3\",\n\t\t\ts:        []float64{5.0, 10.0, 15.0},\n\t\t\tv:        0,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "226111ab2928dc905e44814f6f9015be": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\"L2 norm of {3, 4, 0} should be 5\", []float64{3, 4, 0}, 2, 5},\n\t\t{\"L1 norm of {3, 4, 0} should be 7\", []float64{3, 4, 0}, 1, 7},\n\t\t{\"Maximum absolute value of {3, 4, 0} should be 4\", []float64{3, 4, 0}, math.Inf(1), 4},\n\t\t{\"L2 norm of {3, 4, 0, -3} should be 5.099\", []float64{3, 4, 0, -3}, 2, 5.099}),\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.input, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "22bd207af381f87686834da5d600c1ad": "package floats\n\nimport \"testing\"\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"Nearest value in slice\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:      2.5,\n\t\t\texpect: 1,\n\t\t},\n\t\t{\n\t\t\tname:   \"Multiple nearest values\",\n\t\t\ts:      []float64{1.0, 2.5, 2.5, 4.0, 5.0},\n\t\t\tv:      2.6,\n\t\t\texpect: 1,\n\t\t},\n\t\t{\n\t\t\tname:   \"Zero length slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      1.0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Positive infinity value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      Inf(1),\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"Negative infinity value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "252ed22fd9f5304c94adacddc06a1137": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{\"No NaN values\", []float64{1.0, 2.0, 3.0}, false},\n\t\t{\"Contains NaN\", []float64{1.0, 2.0, 3.0, 0.0/0.0}, true},\n\t\t{\"Empty slice\", []float64{}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := HasNaN(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected HasNaN(%v) to be %v, got %v\", tt.input, tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "253f0b1f1c4b549501d40eca15d5eced": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 2, 1.5, 1},\n\t\t{4, 0, 10, 7, 2},\n\t\t{5, -5, 5, 3, 4},\n\t\t{3, 1, 2, 1.5, 0},\n\t\t{3, 1, 2, 2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Test failed for n=%d, l=%f, u=%f, v=%f. Expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, actual)\n\t\t}\n\t}\n}",
    "25ce682804023f9a12509c8ac3f9216a": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname: \"Normal Case\",\n\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\tl:   1.0,\n\t\t\tu:   5.0,\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Panic Case\",\n\t\t\tdst: []float64{0.0},\n\t\t\tl:   1.0,\n\t\t\tu:   5.0,\n\t\t\twant: []float64{0.0},\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, Got panic: %v\", tt.panic, r != nil)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26a35a13561a9794e4226386d82986f3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\ts, t   []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{}, []float64{}, 2, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\tif result != tc.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", tc.s, tc.t, tc.L, result, tc.result)\n\t\t}\n\t}\n\n\t// Test panic for different length slices\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for slices of different lengths\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}",
    "273f0a878b8e6f3562e9f28f044dc394": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Positive numbers\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative numbers\",\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\texpected: -15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed numbers\",\n\t\t\tinput:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\texpected: 3.0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := floats.SumCompensated(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "275967bd3d165d6f5e107ac14d6101cc": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn, l, u  float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", 5, 2.0, 8.0, 5.5, 3},\n\t\t{\"Test case 2\", 4, 0.0, 10.0, 8.0, 3},\n\t\t{\"Test case 3\", 3, 1.0, 3.0, 2.5, 1},\n\t\t{\"Test case 4\", 10, -5.0, 5.0, 0.0, 5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v; want %v\", tt.n, tt.l, tt.u, tt.v, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "27980de3e3145bbf91a6bce006ce4d0c": "\npackage floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{\n\t\t\tname:  \"Normal case\",\n\t\t\tinput: []float64{5.5, 2.3, 7.8, 1.2, 3.4},\n\t\t\twant:  3,\n\t\t},\n\t\t{\n\t\t\tname:  \"All elements equal\",\n\t\t\tinput: []float64{2.0, 2.0, 2.0, 2.0},\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Negative numbers\",\n\t\t\tinput: []float64{-5.4, -2.1, -7.8},\n\t\t\twant:  2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Empty slice - should panic\",\n\t\t\tinput: []float64{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 tc.want == -1 {\n\t\t\t\t\tt.Errorf(\"Function did not panic as expected\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := floats.MinIdx(tc.input)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d; want %d\", tc.input, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "2799b7f6d5b93f89992e821705bebff0": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\tv:        6.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Unexpected result for test %s: got %d, want %d\", tt.name, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "28520fc1a5692c9c87d9da5daba3a32d": "test file located at floats/minidx_test.go:\n\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.5, 2.7, 1.3, 4.9, 0.8}, 4},\n\t\t{[]float64{0.5, 1.2, 0.5, 3.6, 0.5}, 0},\n\t\t{[]float64{-2.3, -5.4, -1.1, -3.9, -0.4}, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected MinIdx(%v) to return %d, but got %d\", test.input, test.expected, result)\n\t\t}\n\t}\n}",
    "288f617c62576d3f1a88038094c17195": "// Package floats implements functions to manipulate slices of float64.\npackage floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"All positive numbers\",\n\t\t\tinput:    []float64{5.2, 10.4, 3.1, 7.5, 1.0},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"All negative numbers\",\n\t\t\tinput:    []float64{-5.2, -10.4, -3.1, -7.5, -1.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed positive and negative numbers\",\n\t\t\tinput:    []float64{5.2, -10.4, 3.1, -7.5, 1.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"All zeros\",\n\t\t\tinput:    []float64{0, 0, 0, 0, 0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{5.2, 10.4, 3.1, 7.5, floats.NaN()},\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected: %d, Got: %d\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "28ebcdc9ba99fb1af3edf4495a630a68": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Positive values\", []float64{2.5, 4.5, 1.0, 0.5}, 3},\n\t\t{\"Negative values\", []float64{-2.0, -1.0, -3.5, -0.5}, 2},\n\t\t{\"Mixed values\", []float64{5.0, -3.0, 2.0, -1.0, -5.0}, 4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected MinIdx to panic on empty slice, but it didn't\")\n\t\t\t}\n\t\t}()\n\t\tfloats.MinIdx([]float64{})\n\t})\n}\n",
    "28f9800a7a4182bbc7af30b587ca4260": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 Norm\",\n\t\t\tinput:    []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 3.7416573867739413,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 Norm\",\n\t\t\tinput:    []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L Inf Norm\",\n\t\t\tinput:    []float64{1, -5, 2, 7},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 7,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Empty Slice\",\n\t\t\tinput:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Norm(test.input, test.L)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For input %v and L=%f, expected %f, but got %f\", test.input, test.L, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29038392105c5bc234f760656fcb22e2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},\n\t\t{[]float64{1.0, 5.0, 3.0, 5.0, 1.0}, 1},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0, 1.0}, 0},\n\t\t{[]float64{-1.0, -2.0, -3.0, -4.0, -5.0}, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := floats.MaxIdx(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n// func TestMaxIdx(t *testing.T) {\n// \t...\n// }\n// func TestMaxIdx(t *testing.T) {\n// \t...\n// }\n// ...",
    "2912766f5fa08aadae1282284cedee38": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t// Test case for valid input\n\t\t{\n\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\tl:   1,\n\t\t\tu:   4,\n\t\t\twant: []float64{1, 2, 3, 4},\n\t\t},\n\t\t// Test case for special case with NaN\n\t\t{\n\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\tl:   1,\n\t\t\tu:   math.NaN(),\n\t\t\twant: []float64{1, 1, 1, math.NaN()},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29321ecf0482984dd39ea3b7ce875e3b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Test Span with valid input\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tresult: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with NaN values\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\tresult: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with Inf values\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0, 0},\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tresult: []float64{math.Inf(-1), 0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with zero length slice\",\n\t\t\tdst:    []float64{},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tresult: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.result) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.result)\n\t\t\t}\n\t\t})\n\t}\n}\n```",
    "29360998acd13b342952710bb8afacf3": "package floats\n\nimport (\n\t\"testing\"\n\t\"reflect\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0.0, 1.0, 2.0, 3.0, 4.0}, 0.0, 4.0, []float64{0.0, 1.0, 2.0, 3.0, 4.0}},\n\t\t{[]float64{0.0, 1.5, 3.0, 4.5, 6.0}, 0.0, 6.0, []float64{0.0, 1.5, 3.0, 4.5, 6.0}},\n\t\t{[]float64{0.0, 5.0, 10.0, 15.0, 20.0}, 0.0, 20.0, []float64{0.0, 5.0, 10.0, 15.0, 20.0}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t}\n\t}\n}",
    "295ed50fd8578a673bb2e3fcc8350d9c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 10.0},\n\t\t{[]float64{0.1, 0.2, 0.3}, 0.6},\n\t\t{[]float64{10.5, 20.3, 30.1}, 60.9},\n\t\t{[]float64{-1.0, -2.0, -3.0, -4.0}, -10.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := SumCompensated(tt.input)\n\t\tif math.Abs(got-tt.want) \u003e 1e-6 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.input, got, tt.want)\n\t\t}\n\t}\n}",
    "29b9b1c0f0123acdc4bd5a5dcb577350": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourmodule/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{[]float64{3.5, 2.6, 1.7, 3.5, 1.9}, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := floats.MaxIdx(tc.input)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v; want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "2a86c48c0b34e51f7e81c07ad226cfc8": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Subtract two slices of equal length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\tt:    []float64{1, 1, 1},\n\t\t\twant: []float64{3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Panic when lengths do not match\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\tt:    []float64{1, 1},\n\t\t\twant: nil, // Expected panic\n\t\t},\n\t\t{\n\t\t\tname: \"Subtract two empty slices\",\n\t\t\tdst:  []float64{},\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif !reflect.DeepEqual(tt.want, tt.dst) {\n\t\t\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := floats.SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "2adf7865b18d991dea53dc6df7a87df3": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty Slice\", []float64{}, 1.0},\n\t\t{\"Positive Values\", []float64{2.0, 3.0, 4.0}, 24.0},\n\t\t{\"Negative Values\", []float64{-2.0, -3.0, -4.0}, -24.0},\n\t\t{\"Mixed Values\", []float64{2.0, -3.0, 4.0}, -24.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c01766532bd63aa2abc38cc94eb14e6": "// Package floats contains various mathematical functions for working with slices of float64.\npackage floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"positive length span\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\texpected: []float64{1, 4, 7, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative length span\",\n\t\t\tdst:      []float64{0},\n\t\t\tl:        4.5,\n\t\t\tu:        6.8,\n\t\t\texpected: []float64{4.5},\n\t\t},\n\t\t{\n\t\t\tname:     \"log span\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\tl:        0.1,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0.1, 10},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.dst))\n\t\t\tcopy(dst, tt.dst)\n\n\t\t\tresult := Span(dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(dst, tt.expected) {\n\t\t\t\tt.Errorf(\"Span did not modify destination slice as expected. Got %v, expected %v\", dst, tt.expected)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span did not return the expected slice. Got %v, expected %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic case\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when dst length is less than 2\")\n\t\t}\n\t}()\n\n\tSpan([]float64{1}, 1, 5)\n}",
    "2c0b11a375fc921998c1c9c945a1e821": "\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 1, 8, 3, 0},\n\t\t{4, 0, 5, 7, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %f, %f, %f), expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n```",
    "2d185405319948d8cbedc6a6a50ab7fc": "package floats\n\nimport (\n\t\"testing\"\n\t\"reflect\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{10, 20, 30},\n\t\t\ts:        []float64{2, 4, 6},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: []float64{5, 10, 15},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{6, 5, 4},\n\t\t\tt:        []float64{3, 2, 1},\n\t\t\texpected: []float64{2, 2.5, 3},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := DivTo(test.dst, test.s, test.t)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t}\n\t}\n}",
    "2d9592ac59a1a355ee03def9ab0094c3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, expected int\n\t\tl, u, v float64\n\t}{\n\t\t{2, 0, 1.0, 2.0, 1.5},\n\t\t{5, 2, 1.0, 10.0, 5.5},\n\t\t{3, 0, 1.0, 2.0, 0.5},\n\t\t{4, 3, 0.0, 5.0, 6.0},\n\t\t{2, 0, 0.0, 0.0, 0.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "2e64769798a5cc94d729f8d90e29adfd": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tc    float64\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Case 1\",\n\t\t\tdst:  []float64{1, 2, 3, 4},\n\t\t\tc:    2,\n\t\t\ts:    []float64{5, 6, 7, 8},\n\t\t\twant: []float64{10, 12, 14, 16},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 2\",\n\t\t\tdst:  []float64{0.5, 0.7, 0.9},\n\t\t\tc:    -2,\n\t\t\ts:    []float64{3, 4, 5},\n\t\t\twant: []float64{-6, -8, -10},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := ScaleTo(tt.dst, tt.c, tt.s)\n\t\t\tfor i := 0; i \u003c len(got); i++ {\n\t\t\t\tif got[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "2e8f04b46a7cc612ea38ffd806e2eb04": "// Package floats provides functions for operating on slices of float64.\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Normal case\",\n\t\t\tdst:     []float64{0, 0, 0, 0, 0},\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Error case\",\n\t\t\tdst:     []float64{0},\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif tt.wantErr \u0026\u0026 got != nil {\n\t\t\t\tt.Errorf(\"Span() = %v, wanted error\", got)\n\t\t\t}\n\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, wanted %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2f1a12d46d26c88d281ab17f5d43f813": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\tvalue float64\n\t\texpected int\n\t}{\n\t\t{\"nearest to middle value\", []float64{1.2, 3.4, 5.6, 7.8, 9.0}, 5.0, 2},\n\t\t{\"nearest to first value\", []float64{1.2, 3.4, 5.6, 7.8, 9.0}, 0.5, 0},\n\t\t{\"nearest to last value\", []float64{1.2, 3.4, 5.6, 7.8, 9.0}, 10.0, 4},\n\t\t{\"empty slice\", []float64{}, 5.0, -1},\n\t\t{\"NaN value\", []float64{1.2, 3.4, 5.6, 7.8, 9.0}, float64(\"nan\"), -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdx(test.input, test.value)\n\t\t\tassert.Equal(t, test.expected, result)\n\t\t})\n\t}\n}",
    "3089a094a99d51ef78034874e78c9a53": "package floats_test\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your-module-path/floats\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{0, 0, 0}, math.Log(3)},\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))},\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := floats.LogSumExp(tc.input)\n\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}\n",
    "30dee26f57fa90a8a53794231ce2c69e": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  [][]float64\n\t\toutput bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tinput:  [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\toutput: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths\",\n\t\t\tinput:  [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}},\n\t\t\toutput: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tinput:  [][]float64{},\n\t\t\toutput: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.EqualLengths(tt.input...)\n\t\t\tif result != tt.output {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.output, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "310cb20bedefcc5ffc221258026fc89f": "package floats\n\nimport (\n\t\"testing\"\n\t\"reflect\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 4.0, []float64{0.0, 2.0, 4.0}},\n\t\t{[]float64{0.0, 0.0}, 0.0, 10.0, []float64{0.0, 10.0}},\n\t\t{[]float64{1.0}, 1.0, 1.0, []float64{1.0}},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, -1.0, 1.0, []float64{-1.0, 0.0, 1.0, 2.0}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "315d479ff232fd65956f9b3da7e0e12b": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{\"n=5 l=0 u=10 v=4.5\", 5, 0, 10, 4.5, 2},\n\t\t{\"n=5 l=0 u=10 v=11\", 5, 0, 10, 11, 4},\n\t\t{\"n=3 l=5 u=0 v=2\", 3, 5, 0, 2, 0},\n\t\t{\"n=4 l=-2 u=3 v=1\", 4, -2, 3, 1, 2},\n\t\t{\"n=4 l=2 u=2 v=0\", 4, 2, 2, 0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.result {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.result, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "31da813b746c7eabd381b135198484d7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -10.0, 10.0, 0.0, 1},\n\t\t{5, -5.0, 5.0, 2.5, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif idx != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.result, idx)\n\t\t}\n\t}\n}\n",
    "32bb0402b219e3687bbce36b83414407": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinputS []float64\n\t\tinputV float64\n\t\twant   int\n\t}{\n\t\t{\n\t\t\tname:   \"Example 1\",\n\t\t\tinputS: []float64{1, 2, 3, 4, 5},\n\t\t\tinputV: 3.5,\n\t\t\twant:   3,\n\t\t},\n\t\t{\n\t\t\tname:   \"Example 2\",\n\t\t\tinputS: []float64{1.5, 2.5, 3.5, 4.5, 5.5},\n\t\t\tinputV: 4.8,\n\t\t\twant:   4,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty Slice\",\n\t\t\tinputS: []float64{},\n\t\t\tinputV: 5.0,\n\t\t\twant:   -1,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Within(tc.inputS, tc.inputV)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", tc.inputS, tc.inputV, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "345c9a3be0ead2a6bb443889e1480273": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t// Add your test cases here\n\t\t{\n\t\t\tname:    \"Test case 1\",\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    []float64{0, 5, 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Test case 2\",\n\t\t\tdst:     []float64{0, 0, 0, 0, 0},\n\t\t\tl:       0,\n\t\t\tu:       100,\n\t\t\twant:    []float64{0, 25, 50, 75, 100},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Test case 3 - Error\",\n\t\t\tdst:     []float64{0},\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif tt.wantErr \u0026\u0026 got != nil {\n\t\t\t\tt.Errorf(\"Span() error = %v, want nil\", got)\n\t\t\t}\n\t\t\tif !tt.wantErr {\n\t\t\t\tfor i := range tt.want {\n\t\t\t\t\tif got[i] != tt.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "34830695dc149b4a5cc409e9b2a8f053": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinput:    []float64{10.5, -3.5, 7.0, 1.5},\n\t\t\texpected: 15.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 4\",\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\texpected: -15.0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(test.input)\n\t\t\tif math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34c0d99226cdf4b4227be15a1f145e68": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // import the package where the NearestIdxForSpan function is located\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// test cases\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\twant    int\n\t}{\n\t\t{2, 0, 10, 5, 0},   // midpoint when n is even\n\t\t{3, 0, 10, 5, 1},   // midpoint when n is odd\n\t\t{2, 10, 0, 5, 1},   // decreasing bounds\n\t\t{2, 0, 10, 20, 1},  // v greater than u\n\t\t{2, 0, 10, -5, 0},  // v less than l\n\t\t{3, 0, 10, 15, 2},  // v greater than u with odd n\n\t\t{3, 10, 0, -5, 2},  // v less than l with odd n\n\t\t{3, 5, 5, 1, 0},    // equal bounds\n\t\t{5, 0, 10, 7.5, 3}, // mid-range value\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}\n",
    "34ff38c1847746783a7293319ecf85f8": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{0, 2, 4},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x == 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !tt.err \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"Expected no error, but got: %v\", err)\n\t\t\t}\n\n\t\t\tif tt.err \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"Expected error, but got nil\")\n\t\t\t}\n\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t} else {\n\t\t\t\tfor i := range result {\n\t\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "356d6aedd0b043c46f7fcf7e3ff1cbc9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(1 + 4 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 1 + 2 + 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -5, 3, -7},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 7,\n\t\t},\n\t}\n\t\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "358cb99636fbb9e701ee9e0d5a0edac1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 0},\n\t\t{5, 0.0, 10.0, 7.5, 3},\n\t\t{4, -5.0, 5.0, -3.0, 0},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t\t{4, 0.0, 0.0, 5.0, 0},\n\t}\n  \n\tfor _, test := range tests {\n\t\tindex := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"Expected index %d but got %d for n=%d, l=%f, u=%f, v=%f\", test.index, index, test.n, test.l, test.u, test.v)\n\t\t}\n\t}\n}",
    "35e4e0a40afe6a5e168783bb39d5cb1d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{5.5, 3.2, 1.7, 0.9},\n\t\t\tv:        4.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{10.0, 15.0, 20.0},\n\t\t\tv:        17.0,\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tc.s, tc.v)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d but got %d for input %v and %f\", tc.expected, result, tc.s, tc.v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "36b46310cb1e47d0cbd345cbb5e97feb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tn, l, u, v float64\n\t\texpected  int\n\t}{\n\t\t{\"Case 1\", 5, 0, 10, 4, 1},\n\t\t{\"Case 2\", 3, 0, 10, 15, 2},\n\t\t{\"Case 3\", 4, 0, 10, 5, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3777da618e67948fe1f0988381d359df": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 6.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\ts:    []float64{0.1, 0.2, 0.3, 0.4},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\ts:    []float64{1.23456789, 2.3456789, 3.456789},\n\t\t\twant: 7.03703579,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.s)\n\t\t\tif math.Abs(got-tt.want) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "382421897ddac293a7eaf5803663f8ba": "package floatstest\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttestCases := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}},\n\t\t{[]float64{5, 5, 5}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\toriginalDst := make([]float64, len(tc.dst))\n\t\tcopy(originalDst, tc.dst)\n\n\t\tfloats.Sub(tc.dst, tc.s)\n\n\t\tfor i := 0; i \u003c len(tc.dst); i++ {\n\t\t\texpected := originalDst[i] - tc.s[i]\n\t\t\tif tc.dst[i] != expected {\n\t\t\t\tt.Errorf(\"Subtraction incorrect. Expected %f, got %f\", expected, tc.dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Other test functions for other functions in floats package can be added here.",
    "3843bad289f379e1a739b632988424fb": "package floats\n\nimport (\n\t\"testing\"\n\t\"reflect\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t\texpectedResult []int\n\t\texpectedError  error\n\t}{\n\t\t// Test case 1\n\t\t{[]int{}, func(x float64) bool { return x \u003e 0 }, []float64{-1, 0, 1, 2, 3}, 3, []int{2, 3, 4}, nil},\n\t\t// Test case 2\n\t\t{[]int{}, func(x float64) bool { return x \u003c 0 }, []float64{-1, 0, 1, 2, 3}, 2, []int{0}, nil},\n\t\t// Test case 3\n\t\t{[]int{}, func(x float64) bool { return x \u003e 0 }, []float64{-1, -2, -3, -4, -5}, 2, []int{}, errors.New(\"floats: insufficient elements found\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, err := Find(test.inds, test.f, test.s, test.k)\n\t\tif !reflect.DeepEqual(result, test.expectedResult) {\n\t\t\tt.Errorf(\"For inds %v, f %v, s %v, k %d, expected %v, but got %v\", test.inds, test.f, test.s, test.k, test.expectedResult, result)\n\t\t}\n\t\tif err != nil \u0026\u0026 test.expectedError == nil || (err == nil \u0026\u0026 test.expectedError != nil) || (err != nil \u0026\u0026 test.expectedError != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"For inds %v, f %v, s %v, k %d, expected error %v, but got %v\", test.inds, test.f, test.s, test.k, test.expectedError, err)\n\t\t}\n\t}\n}",
    "39db05dc4a24eb9227f51017d3d973fe": "\npackage floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/yourpackage/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl       float64\n\t\tu       float64\n\t\tv       float64\n\t\texpects int\n\t}{\n\t\t{4, 0.0, 10.0, 4.5, 2},\n\t\t{5, -5.0, 5.0, 3.0, 3},\n\t\t{3, -10.0, 10.0, 8.0, 2},\n\t\t{2, 0.0, 0.0, 4.0, 0},\n\t\t{7, -1.0, 1.0, 0.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expects {\n\t\t\tt.Errorf(\"Expected %v for NearestIdxForSpan(%v, %v, %v, %v), but got %v\", test.expects, test.n, test.l, test.u, test.v, result)\n\t\t}\n\t}\n}\n",
    "3a76d4dd149871d67008d88252023be3": "// Package floats provides functions for float64 slices.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"All positive numbers\", []float64{1.0, 2.5, 3.7, 4.2, 5.9}, 0},\n\t\t{\"All negative numbers\", []float64{-1.0, -2.5, -3.7, -4.2, -5.9}, 4},\n\t\t{\"Mixed positive and negative numbers\", []float64{-1.0, 2.5, -3.7, 4.2, -5.9}, 4},\n\t\t{\"Repeated minimum value\", []float64{7.1, 3.7, 1.2, 1.2, 5.5}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d for input %v\", tt.expected, result, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3adb71339e22f88f256492a10f5ad403": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{3, 1.0, 3.0, 2.5, 1},\n\t\t{4, 0.0, 5.0, 3.7, 3},\n\t\t{5, -1.0, 1.0, -0.5, 0},\n\t\t{6, -10.0, 10.0, 8.0, 5},\n\t\t{5, 2.0, 3.0, 10.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%.1f, u=%.1f, v=%.1f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "3bddc91a49dd0c307d9de0e1281590c7": "// Package floats contains utility functions for float64 slices.\npackage floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\tl          float64\n\t\tu          float64\n\t\texpected   []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid span\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 3.3333333333333335, 6.666666666666667, 10},\n\t\t},\n\t\t{\n\t\t\tname:       \"Panic: dst length less than 2\",\n\t\t\tdst:        []float64{1},\n\t\t\tl:          0,\n\t\t\tu:          10,\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.shouldPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, shouldPanic %v\", r, tt.shouldPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tactual := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(actual, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", actual, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d239a05153f127756cc4206cf13ce2f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1.1, 2.2, 3.3}, 6.6},\n\t\t{[]float64{-1.1, -2.2, -3.3}, -6.6},\n\t\t{[]float64{0.1, 0.2, 0.3}, 0.6},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := SumCompensated(tc.input)\n\t\tif math.Abs(got-tc.want) \u003e 1e-10 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "3f1fcb2afc428a0210f30e3b742123c1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{\"Test1\", 5, 0.0, 1.0, 0.5, 2},\n\t\t{\"Test2\", 4, -10.0, 10.0, 7.5, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.result {\n\t\t\t\tt.Errorf(\"Expected result: %d, but got: %d\", tt.result, got)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "3fa7e3b95f5c707b1cf62da5c1bdb6f4": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\tdst := []float64{1.0, 2.0, 3.0}\n\tc := 5.0\n\texpected := []float64{6.0, 7.0, 8.0}\n\n\tAddConst(c, dst)\n\n\tfor i := 0; i \u003c len(dst); i++ {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %f, but got %f at index %d\", expected[i], dst[i], i)\n\t\t}\n\t}\n}",
    "402da2b0239a95cd0ad9382497c83698": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{\n\t\t\tname: \"Regular span\",\n\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\tl:   0,\n\t\t\tu:   10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case: NaN\",\n\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\tl:   math.NaN(),\n\t\t\tu:   10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case: Inf\",\n\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\tl:   math.Inf(-1),\n\t\t\tu:   math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected length of result to be %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "408bf5d6763678341e7519c97944b765": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Span with n=3, l=0, u=10\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with n=5, l=-3, u=3\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -3,\n\t\t\tu:        3,\n\t\t\texpected: []float64{-3, -1.5, 0, 1.5, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with n=4, l=1, u=5\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 2.5, 4, 5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, expected %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Add more test cases as needed\n```",
    "4171fcb628d4c71d3830d56fe113e994": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 0, 0, 0},\n\t\t{3, 0, 10, 5, 1},\n\t\t{5, -10, 10, 0, 2},\n\t\t{4, -5, 5, 100, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "425513ae8a69a98a714e8b3f95e333d2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{5, 0.0, 10.0, 12.0, 4},\n\t\t{4, 0.0, 10.0, -3.0, 0},\n\t\t{6, 0.0, 10.0, 7.5, 3},\n\t\t{2, 0.0, 10.0, 5.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %f, %f, %f), expected %d, but got %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4255a92f176f4d91698166bcd5e8c176": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourmodule/floats\"\n)\n\nfunc TestMul(t *testing.T) {\n\tdst := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\n\tfloats.Mul(dst, s)\n\n\texpected := []float64{4, 10, 18}\n\n\tfor i := 0; i \u003c len(dst); i++ {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %f but got %f for index %d\", expected[i], dst[i], i)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\nfunc TestMul_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tdst := []float64{1, 2}\n\ts := []float64{4, 5, 6}\n\n\tfloats.Mul(dst, s)\n}",
    "427a068f7b9d98292d45ba8f0298d820": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 0, 10},\n\t\t{[]float64{0, 0, 0, 0, 0, 0, 0}, 1, 10},\n\t\t{[]float64{0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected result length to be %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tif dst[0] != test.l {\n\t\t\tt.Errorf(\"First element of destination slice is not equal to l\")\n\t\t}\n\n\t\tif dst[len(dst)-1] != test.u {\n\t\t\tt.Errorf(\"Last element of destination slice is not equal to u\")\n\t\t}\n\n\t\tif len(dst) \u003c 2 {\n\t\t\tt.Errorf(\"Destination slice length is less than 2\")\n\t\t}\n\t}\n}",
    "437c902372f0d98605b3971c25a238e2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 2, 1, 1},\n\t\t{3, 0, 2, 1, 1},\n\t\t{4, 0, 2, 1, 1},\n\t\t{5, 0, 2, 1, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "43b37766db5973e6b66d2f8e975f0b50": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Case 1: k = 3, elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 3 },\n\t\t\ts:        []float64{1, 4, 5, 2, 6},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Case 2: k = 2, not enough elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 1 },\n\t\t\ts:        []float64{2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Case 3: k = -1, all elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{0, 0, 0, 0},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := floats.Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected result to be %v, but got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tif !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected error to be %v, but got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "43da2b9b629e14fe67c3831d7c5be202": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/source/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 5.0, 3.0, 1},\n\t\t{5, 0.0, 10.0, 7.0, 4},\n\t\t{3, -10.0, 10.0, -5.0, 0},\n\t\t{4, 5.0, 15.0, 20.0, 3},\n\t\t{6, 2.0, 8.0, 2.5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %.1f, %.1f, %.1f) to be %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "448e96e64dc8a814b9196333c8e74a69": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{2, 0, 10, -5, 1},\n\t\t{4, 0, 10, 2, 1},\n\t\t{4, 0, 10, -2, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n\n\t// Add more test cases as needed\n}\n",
    "44b252eb7d64662d0890dd69335bcff7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test case 1\n\ts := []float64{1.5, 2.5, 3.5, 4.5, 5.5}\n\tf := func(val float64) bool {\n\t\treturn val \u003e 3.0\n\t}\n\tk := 2\n\texpectedResults := []int{3, 4}\n\n\tinds, err := Find(nil, f, s, k)\n\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\n\tif len(inds) != len(expectedResults) {\n\t\tt.Errorf(\"Expected %d indices, but got %d\", len(expectedResults), len(inds))\n\t}\n\n\tfor i, result := range inds {\n\t\tif result != expectedResults[i] {\n\t\t\tt.Errorf(\"Expected index %d, but got %d\", expectedResults[i], result)\n\t\t}\n\t}\n\n\t// Test case 2\n\tk = -1\n\texpectedResults = []int{1, 2, 3, 4}\n\n\tinds, err = Find(nil, f, s, k)\n\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\n\tif len(inds) != len(expectedResults) {\n\t\tt.Errorf(\"Expected %d indices, but got %d\", len(expectedResults), len(inds))\n\t}\n\n\tfor i, result := range inds {\n\t\tif result != expectedResults[i] {\n\t\t\tt.Errorf(\"Expected index %d, but got %d\", expectedResults[i], result)\n\t\t}\n\t}\n\n\t// Test case 3\n\tk = 3\n\n\t_, err = Find(nil, f, s, k)\n\n\tif err == nil {\n\t\tt.Error(\"Expected error for insufficient elements found, but got nil\")\n\t}\n}\n",
    "4511cbb301b7d8bfcf0b0dedbc359aa4": "// Filename: span_test.go\n// Package test floats\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 1}, 1, 1},\n\t\t{[]float64{}, 0, 0},\n\t\t{[]float64{3, 4, 5, 6, 7}, 3, 7},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.dst))\n\t\t\tcopy(dst, tt.dst)\n\n\t\t\tresult := Span(dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(result, tt.dst) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.dst, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Testing Panic for dst length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but got none\")\n\t\t}\n\t}()\n\tSpan([]float64{1}, 0, 1)\n}",
    "453441fed479c6b931c95d8e6a2dc624": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // Update the path to the actual package location\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 0, 0, 0},\n\t\t{6, 5, 10, 15, 5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif result != tt.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to be %d, but got %d\", tt.n, tt.l, tt.u, tt.v, tt.result, result)\n\t\t}\n\t}\n}\n",
    "45a30c5828885a89ba83eb56d93bcb68": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, v        int\n\t\tl, u, want float64\n\t}{\n\t\t{5, 0.5, 0, 1, 1},\n\t\t{5, 3.2, 2.8, 3.5, 3},\n\t\t{3, 2.5, 1, 3, 2},\n\t\t{10, 5.5, 4, 6, 5},\n\t\t{6, 7.5, 5, 8, 5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %f\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}",
    "4627622097568676db1c4bb86f0f6c45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test case for n \u003c 2, should panic\n\tassertPanic(t, func() { NearestIdxForSpan(1, 0, 10, 5) })\n\n\t// Special case for NaN v\n\tif idx := NearestIdxForSpan(5, 0, 10, math.NaN()); idx != 0 {\n\t\tt.Errorf(\"Expected nearest index to be 0 for NaN v, but got %d\", idx)\n\t}\n\n\t// Special case for all Inf bounds\n\tif idx := NearestIdxForSpan(5, math.Inf(-1), math.Inf(1), 5); idx != 2 {\n\t\tt.Errorf(\"Expected nearest index to be 2 for all Inf bounds, but got %d\", idx)\n\t}\n\n\t// Test for value outside bounds\n\tif idx := NearestIdxForSpan(5, 0, 10, 15); idx != 4 {\n\t\tt.Errorf(\"Expected nearest index to be 4 for value outside bounds, but got %d\", idx)\n\t}\n}\n\nfunc assertPanic(t *testing.T, f func()) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic, but did not panic\")\n\t\t}\n\t}()\n\tf()\n}",
    "4779c1536b5e5170e27ec9a3d10c39ae": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCumProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test 1 - Cumulative product of [1, 2, 3, 4]\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\texpected: []float64{1, 2, 6, 24},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test 2 - Cumulative product of [5, 2, 1, 8]\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\ts:        []float64{5, 2, 1, 8},\n\t\t\texpected: []float64{5, 10, 10, 80},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test 3 - Cumulative product of [3, 0, 5, 6]\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\ts:        []float64{3, 0, 5, 6},\n\t\t\texpected: []float64{3, 0, 0, 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := CumProd(test.dst, test.s)\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", test.expected[i], i, result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "47f60ea89af4f421e1d95c0dab96a75e": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{name: \"Max at Beginning\", input: []float64{9, 1, 3, 5}, expected: 0},\n\t\t{name: \"Max at Middle\", input: []float64{1, 3, 9, 5}, expected: 2},\n\t\t{name: \"Max at End\", input: []float64{1, 3, 5, 9}, expected: 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d for input %v\", tt.expected, result, tt.input)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Empty Slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tMaxIdx([]float64{})\n\t})\n}",
    "485f3f9430a5c1ee9fe363f2c8c5ca6b": "// File: minidx_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected int\n\t}{\n\t\t{name: \"Positive values\", input: []float64{5.5, 2.2, 3.3, 1.1, 4.4}, expected: 3},\n\t\t{name: \"Negative values\", input: []float64{-5.5, -2.2, -3.3, -1.1, -4.4}, expected: 0},\n\t\t{name: \"Mixed values\", input: []float64{5.5, -2.2, 0, -1.1, 4.4}, expected: 1},\n\t\t{name: \"Equal values\", input: []float64{0, 0, 0, 0, 0}, expected: 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index: %d, but got: %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Add more test cases as needed\n```",
    "4902acfcc99189c581fc8a8766675600": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // Update the path to the actual package location\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{5, 0, 5, 7, 4},\n\t\t{3, 0, 5, 3, 1},\n\t\t{4, -10, 10, 0, 2},\n\t\t{5, 10, 0, 9, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %f, %f, %f), expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "498646d911c3405408999849c323ca03": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput  []float64\n\t\tL      float64\n\t\toutput float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2, 7.416198487095663},\n\t\t{[]float64{1, 2, 3, 4, 5}, 3, 5.443208325478958},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{1, -2, -3, 4, -5}, float64('+Inf'), 5},\n\t\t{[]float64{}, 2, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := floats.Norm(tc.input, tc.L)\n\t\tif result != tc.output {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tc.input, tc.L, result, tc.output)\n\t\t}\n\t}\n}\n",
    "49ba2faa968d0b16296a65774ac0301a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test Case 1\", 5, 0, 10, 4, 2},\n\t\t{\"Test Case 2\", 4, 1, 5, 3, 1},\n\t\t{\"Test Case 3\", 3, 2, 8, 6, 1},\n\t\t{\"Test Case 4\", 6, -5, 5, 2, 4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\toutput := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif output != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %v, Got: %v\", tt.expected, output)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "49f1f6060a6fe1ef71ebca94b2d03f19": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{5, 0, 10, 5, 2},\n\t\t{3, 5, 10, 7, 1},\n\t\t{4, -5, 5, 0, 3},\n\t\t{5, -10, -5, -7.5, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %.2f, %.2f, %.2f) to return %d, but got %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "4a76c915a614c1a32e928870371d7c11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 2, 1.5, 1},\n\t\t{4, 0, 10, 5.5, 2},\n\t\t{3, math.NaN(), 5, 4.5, 2},\n\t\t{3, 2, math.Inf(+1), 3, 0},\n\t\t{5, math.Inf(-1), 0, -0.5, 4},\n\t\t{4, 3, 1, 2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "4b1a23c141eedc527eec4c3fbbbf89e3": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 5, 6}, []float64{-3, -3, -3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{0, 0, 0}, []float64{4, 5, 6}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := SubTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4ba005c9cdfe22faa8fc506e95a25089": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{5, 0.0, 1.0, 0.3, 1},\n\t\t{3, 1.0, 2.0, 1.8, 2},\n\t\t{4, -1.0, 1.0, 0.0, 2},\n\t\t{2, 0.0, 2.0, 1.0, 1},\n\t\t{6, 3.0, 9.0, 7.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to be %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "4c6cdb436525f21ceeedad76790926b9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1.0, 2.0, 3.0}\n\tt1 := []float64{1.0, 2.0, 3.0}\n\tt2 := []float64{3.0, 2.0, 1.0}\n\n\tresult1 := Distance(s, t1, 2.0)\n\tif result1 != 0.0 {\n\t\tt.Errorf(\"Distance between same slices should be 0, got %f\", result1)\n\t}\n\n\tresult2 := Distance(s, t2, 1.0)\n\texpected2 := 4.0\n\tif result2 != expected2 {\n\t\tt.Errorf(\"Expected distance of %f, got %f\", expected2, result2)\n\t}\n\n\tresult3 := Distance(s, t1, math.Inf(1))\n\texpected3 := 2.0\n\tif result3 != expected3 {\n\t\tt.Errorf(\"Expected maximum absolute value of %f, got %f\", expected3, result3)\n\t}\n}",
    "4cbcd075e4543798c309fb6ee26e85d1": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Regular case\", 5, 0, 10, 4.8, 4},\n\t\t{\"NaN case\", 5, 0, 10, floats.NaN(), 0},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "4e1af0d7b8ed5d716b99fd19e75c5557": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\t// Test case 1: equal length slices\n\tdst1 := []float64{1.0, 2.0, 3.0}\n\ts1 := []float64{4.0, 5.0, 6.0}\n\texpected1 := []float64{5.0, 7.0, 9.0}\n\tAdd(dst1, s1)\n\tfor i := range dst1 {\n\t\tif dst1[i] != expected1[i] {\n\t\t\tt.Errorf(\"Test case 1 failed: expected %v, got %v\", expected1, dst1)\n\t\t}\n\t}\n\n\t// Test case 2: unequal length slices (panic expected)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case 2 failed: Add did not panic for unequal length slices\")\n\t\t}\n\t}()\n\tdst2 := []float64{1.0, 2.0, 3.0}\n\ts2 := []float64{4.0, 5.0}\n\tAdd(dst2, s2)\n}",
    "4eb979ccf40b8e4948c951fe71f3192c": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your_package_name/floats\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{4.0, 10.0, 18.0}},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, []float64{0.0, 0.0, 0.0}, []float64{0.0, 0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.MulTo(test.dst, test.s, test.t)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t}\n\t}\n\n\t// Add more test cases if needed\n}\n",
    "4ee2b8620a8d952f91ac91175e990d11": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 0},\n\t\t{3, 1.0, 4.0, 2.8, 2},\n\t\t{4, 0.0, 10.0, 5.5, 2},\n\t\t{5, -5.0, 5.0, -2.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"For Span with n=%d, l=%f, u=%f and v=%f, expected index %d but got %d\", test.n, test.l, test.u, test.v, test.index, index)\n\t\t}\n\t}\n}\n",
    "50a644966ebeb9b5f9f075ffe29701a4": "func TestSpan(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := 0.0\n\tu := 10.0\n\n\tresult := Span(dst, l, u)\n\n\tif len(result) != len(dst) {\n\t\tt.Errorf(\"Expected result length %d, but got %d\", len(dst), len(result))\n\t}\n\n\tfor i := 0; i \u003c len(result); i++ {\n\t\texpected := l + (u-l)/4*float64(i)\n\t\tif result[i] != expected {\n\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected, i, result[i])\n\t\t}\n\t}\n}\n\n// Additional test cases can be added for edge cases and special cases\nfunc TestSpanEdgeCases(t *testing.T) {\n\tdst := make([]float64, 2)\n\tl := 5.0\n\tu := 10.0\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but no panic occurred\")\n\t\t}\n\t}()\n\n\tSpan(dst, l, u)\n}\n\nfunc TestSpanSpecialCases(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := math.NaN()\n\tu := 10.0\n\n\tresult := Span(dst, l, u)\n\n\tif math.IsNaN(result[0]) {\n\t\tt.Errorf(\"Expected first element to be NaN, but got %f\", result[0])\n\t}\n\n\tif result[len(result)-1] != u {\n\t\tt.Errorf(\"Expected last element to be %f, but got %f\", u, result[len(result)-1])\n\t}\n}",
    "50bf89e11cdfc6a5f67944e93b69ded7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, -1, -2, 4},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, -1, -2, 4},\n\t\t\tk:        -1,\n\t\t\texpected: []int{3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x == 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.expected), len(result))\n\t\t\t}\n\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", tt.expected[i], i, result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5100393d9c20179d1f466df07560df26": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\talpha:  0.5,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tresult: []float64{3, 4.5, 6},\n\t\t},\n\t\t{\n\t\t\tdst:    []float64{10, 20, 30},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tresult: []float64{12, 24, 36},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tfloats.AddScaled(test.dst, test.alpha, test.s)\n\n\t\tif !floats.Equal(test.dst, test.result) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.result, test.dst)\n\t\t}\n\t}\n}",
    "513e0f7a072d293d0d8efdd905153883": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"subtracting slices of equal length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{5, 4, 3},\n\t\t\tt:    []float64{4, 3, 2},\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"subtracting slices of different length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{5, 4, 3},\n\t\t\tt:    []float64{4, 3},\n\t\t\twant: nil, // this test case should panic\n\t\t},\n\t\t{\n\t\t\tname: \"subtracting empty slices\",\n\t\t\tdst:  []float64{},\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif !reflect.DeepEqual(tt.want, tt.dst) {\n\t\t\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tSubTo(tt.dst, tt.s, tt.t)\n\t\t})\n\t}\n}",
    "51de97e964a1fffb9b422eb59da5400d": "\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{4, 8, 12}, []float64{2, 4, 6}, []float64{2, 2, 2}},\n\t\t{[]float64{10, 15, 20}, []float64{2, 3, 4}, []float64{5, 5, 5}},\n\t\t{[]float64{1, 1, 1}, []float64{1, 1, 1}, []float64{1, 1, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tDiv(test.dst, test.s)\n\t\tfor i := range test.dst {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, test.dst)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed.",
    "51e62d3003c1cef2b289488bb49642bc": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Add your test cases here\n\t// Make sure to cover edge cases and different scenarios\n}",
    "51e6755e7f508768bca93b584325caa1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"n=3, l=0, u=10, v=7\", 3, 0, 10, 7, 2},\n\t\t{\"n=4, l=-10, u=10, v=0\", 4, -10, 10, 0, 1},\n\t\t{\"n=5, l=-5, u=5, v=-3\", 5, -5, 5, -3, 1},\n\t\t{\"n=6, l=0, u=100, v=150\", 6, 0, 100, 150, 5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n\nfunc TestNearestIdxForSpan_SpecialCases(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"v=NaN\", 0, 10, math.NaN(), 0},\n\t\t{\"l=+Inf, u=-Inf, v=5\", math.Inf(1), math.Inf(-1), 5, 0},\n\t\t{\"l=+Inf, u=+Inf, v=5\", math.Inf(1), math.Inf(1), 5, 0},\n\t\t{\"l=-Inf, u=-Inf, v=5\", math.Inf(-1), math.Inf(-1), 5, 0},\n\t\t{\"l=NaN, u=10, v=5\", math.NaN(), 10, 5, 0},\n\t\t{\"l=5, u=NaN, v=10\", 5, math.NaN(), 10, 0},\n\t\t{\"l=-5, u=5, v=-Inf\", -5, 5, math.Inf(-1), 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(3, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51f37ea8b340d88b86dd6365594f823f": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test1\", []float64{1, 2, 3}, 3.4076059644443804},\n\t\t{\"Test2\", []float64{5, 5, 5}, 5.402585107172385},\n\t\t{\"Test3\", []float64{0, 0, 0}, 0},\n\t\t{\"Test4\", []float64{-1, 0, 1}, 1.4076059644443804},\n\t\t{\"Test5\", []float64{1, 1, 1, 1}, 1.541324854612918},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := LogSumExp(tc.input)\n\t\t\tif !floatsEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatsEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}\n",
    "535e683dd7462e2c87fae6b37215e513": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{0, 0}, []float64{3, 4}, math.Inf(1), 5},\n\t\t{[]float64{1, 2}, []float64{4, 5}, math.Inf(1), 3},\n\t\t{[]float64{1, 2}, []float64{4, 5}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Distance(test.s, test.t, test.L)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.result)\n\t\t}\n\t}\n}",
    "54cf5f7fc12931717650aaf61a9e1990": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t. \"github.com/your_module/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, math.Inf(1), 5, 0},\n\t\t{5, math.Inf(-1), 0, 5, 4},\n\t\t{4, -10, 10, 5, 3},\n\t\t{4, 10, -10, 5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to be %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "5510c4a37a65894d6414bbbb693794cd": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t\t{4, 1.0, 5.0, 2.3, 1},\n\t\t{3, -5.0, 5.0, 3.5, 1},\n\t\t{2, 0.0, 10.0, 20.0, 1},\n\t\t{5, -10.0, 10.0, -8.0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}",
    "553492048d9a895e0c7a6480f8a52aa9": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\" // Update the import path to the actual package path\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test when length of dst is 0\n\terr := false\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = true\n\t\t}\n\t\tif !err {\n\t\t\tt.Error(\"Expected panic for length of dst \u003c 2\")\n\t\t}\n\t}()\n\tfloats.Span([]float64{}, 0, 10)\n\t\n\t// Test when length of dst is 1\n\terr = false\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = true\n\t\t}\n\t\tif !err {\n\t\t\tt.Error(\"Expected panic for length of dst \u003c 2\")\n\t\t}\n\t}()\n\tfloats.Span([]float64{0}, 0, 10)\n\t\n\t// Test special case for Inf and NaN\n\tdst := make([]float64, 5)\n\tfloats.Span(dst, 0, float64(\"NaN\"))\n\tif !math.IsNaN(dst[len(dst)-1]) {\n\t\tt.Error(\"Expected NaN as final element\")\n\t}\n\t\n\t// Add more test cases as needed\n}",
    "557c377cf77cfee5862a9c9ac824624d": "package floats_test\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // Update the import path\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"SumCompensated of empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"SumCompensated of positive numbers\",\n\t\t\tinput:    []float64{1.1, 2.2, 3.3},\n\t\t\texpected: 6.6,\n\t\t},\n\t\t{\n\t\t\tname:     \"SumCompensated of negative numbers\",\n\t\t\tinput:    []float64{-1.1, -2.2, -3.3},\n\t\t\texpected: -6.6,\n\t\t},\n\t\t{\n\t\t\tname:     \"SumCompensated of mixed numbers\",\n\t\t\tinput:    []float64{1.1, -2.2, 3.3, -4.4},\n\t\t\texpected: -2.2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.SumCompensated(tc.input)\n\t\t\tif !floatsEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatsEqual(a, b float64) bool {\n\tconst epsilon = 1e-14\n\treturn math.Abs(a-b) \u003c epsilon || math.Abs(a-b)/math.Max(math.Abs(a), math.Abs(b)) \u003c epsilon\n}\n",
    "566741d6f8a87aed21ab7e8ff5149d73": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{n: 4, l: 1.5, u: 3.5, v: 2.7, expect: 2},\n\t\t{n: 3, l: 2, u: 5, v: 7, expect: 2},\n\t\t{n: 5, l: 1, u: 3, v: 2.5, expect: 2},\n\t\t{n: 2, l: -1, u: 1, v: -2, expect: 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t}\n\t}\n}",
    "585b7ac09a3b8d7ae48ddfa3fb2ed341": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Case 1\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    5,\n\t\t\tu:    7,\n\t\t\twant: []float64{5, 5.666666666666667, 6.333333333333333, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 3\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\twant: []float64{-10, -5, 0, 5, 10},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c241954b2664727c41d7721efab838": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\" // Import the source code package\n)\n\nfunc TestAdd(t *testing.T) {\n\t// Test case 1: Equal lengths\n\tdst1 := []float64{1.0, 2.0, 3.0}\n\ts1 := []float64{4.0, 5.0, 6.0}\n\texpected1 := []float64{5.0, 7.0, 9.0}\n\tfloats.Add(dst1, s1)\n\tfor i := range dst1 {\n\t\tif dst1[i] != expected1[i] {\n\t\t\tt.Errorf(\"Test case 1 failed. Expected: %v, got: %v\", expected1, dst1)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 2: Unequal lengths (should panic)\n\tdst2 := []float64{1.0, 2.0}\n\ts2 := []float64{3.0, 4.0, 5.0}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case 2 failed. Add did not panic for unequal lengths\")\n\t\t}\n\t}()\n\tfloats.Add(dst2, s2)\n}",
    "596038e104a8cfd0669b4e0ae9d834d2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test case 1: k \u003c 0\n\tslice := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tinds := make([]int, 0)\n\tf := func(val float64) bool {\n\t\treturn val \u003e 3.0\n\t}\n\tk := -1\n\n\tresult, err := Find(inds, f, slice, k)\n\n\tif err != nil {\n\t\tt.Errorf(\"Expected error to be nil, got: %v\", err)\n\t}\n\n\texpected := []int{3, 4}\n\tfor i := range expected {\n\t\tif expected[i] != result[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 2: k \u003e 0\n\tslice2 := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tinds2 := make([]int, 0)\n\tf2 := func(val float64) bool {\n\t\treturn val \u003e 3.0\n\t}\n\tk2 := 2\n\n\tresult2, err2 := Find(inds2, f2, slice2, k2)\n\n\tif err2 != nil {\n\t\tt.Errorf(\"Expected error to be nil, got: %v\", err2)\n\t}\n\n\texpected2 := []int{3, 4}\n\tfor i := range expected2 {\n\t\tif expected2[i] != result2[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected2, result2)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 3: k \u003e 0 but not enough elements found\n\tslice3 := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tinds3 := make([]int, 0)\n\tf3 := func(val float64) bool {\n\t\treturn val \u003e 5.0\n\t}\n\tk3 := 2\n\n\t_, err3 := Find(inds3, f3, slice3, k3)\n\n\texpectedError := \"floats: insufficient elements found\"\n\tif err3.Error() != expectedError {\n\t\tt.Errorf(\"Expected %v, got %v\", expectedError, err3.Error())\n\t}\n}\n",
    "59cfb0df3d116931d8ef233f5c4d4ba1": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0}, 0, 10, []float64{0}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), 10, []float64{math.Inf(-1), math.Inf(0), 10}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 5, []float64{1, 2, 3, 4, 5}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Add test cases with expected panics\n}",
    "59e9807e410b3b1e42476d1626350de1": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 3, []float64{1, 2, 3}},\n\t\t{[]float64{0, 0, 0, 0}, 5, 11, []float64{5, 8, 11, 14}},\n\t\t{[]float64{0, 0}, 2, 4, []float64{2, 4}},\n\t}\n\n\tfor _, test := range tests {\n\t\tinitialDst := make([]float64, len(test.dst))\n\t\tcopy(initialDst, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", initialDst, test.l, test.u, test.dst, test.expected)\n\t\t}\n\n\t\tif result != test.dst {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\t}\n\n\t// Test panic when length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when length of dst is less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 1, 5)\n}",
    "5a067b714f12586ffcf7e6ed3a76e094": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"All positive numbers\",\n\t\t\tinput:    []float64{5, 10, 2, 8},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"All negative numbers\",\n\t\t\tinput:    []float64{-5, -10, -2, -8},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed positive and negative numbers\",\n\t\t\tinput:    []float64{5, -10, 2, -8},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal numbers\",\n\t\t\tinput:    []float64{2, 2, 2, 2},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5aa15949cd7c6551c734080cf1d8b245": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Normal case\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Edge case - value in first bucket\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Edge case - value in last bucket\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    5.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value outside range\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    6.0,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.input, tt.value)\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}",
    "5cab14684e3236374aff22310a463d29": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected int\n\t}{\n\t\t{\"All positive values\", []float64{1.0, 2.0, 3.0, 4.0}, 3},\n\t\t{\"All negative values\", []float64{-4.0, -3.0, -2.0, -1.0}, 0},\n\t\t{\"Mixed values\", []float64{-10.0, 0.0, 15.0, 7.0, 2.0}, 2},\n\t\t{\"Multiple max values\", []float64{1.0, 3.0, 8.0, 8.0, 2.0}, 2},\n\t\t{\"NaN values ignored\", []float64{1.0, 3.0, math.NaN(), 8.0, 2.0}, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cfd5efc057e14d6f915e2f0e3a7a4e1": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttestCases := []struct {\n\t\tslice1 []float64\n\t\tslice2 []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := Equal(tc.slice1, tc.slice2)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"Expected Equal(%v, %v) to be %v, but got %v\", tc.slice1, tc.slice2, tc.expected, result)\n\t\t}\n\t}\n}",
    "5db0ca7cc9e199b358e4086356bd249f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n \tdesc     string\n\ts        []float64\n\tL        float64\n\texpected float64\n \t}{\n\t\t{\n\t\t\tdesc:     \"Test L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Test L2 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 3.7416573867739413,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Test Inf norm\",\n\t\t\ts:        []float64{1, -2, 3, -4},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Test empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.desc, func(t *testing.T) {\n\t\t\tresult := Norm(test.s, test.L)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5e5b494cf15f876e881c448b70eb2381": "// Package floats provides ...\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Subtracting slices of equal lengths\",\n\t\t\tdst:  []float64{1, 2, 3, 4},\n\t\t\ts:    []float64{5, 6, 7, 8},\n\t\t\tt:    []float64{1, 1, 1, 1},\n\t\t\twant: []float64{4, 5, 6, 7},\n\t\t},\n\t\t{\n\t\t\tname: \"Subtracting slices of different lengths\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{5, 6, 7, 8},\n\t\t\tt:    []float64{1, 1, 1, 1},\n\t\t\twant: []float64{4, 5, 6},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5ec0328f90a34d616e3b204f7b27312c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{n: 5, l: 1, u: 10, v: 4, expected: 1},\n\t\t{n: 10, l: 0, u: 100, v: 75, expected: 7},\n\t\t{n: 3, l: -5, u: 5, v: -8, expected: 0},\n\t\t{n: 4, l: 2, u: 4, v: 2.5, expected: 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "61372161edf3c9defd238b1135cd48bc": "package floats\n\nimport (\n\t\"testing\"\n\t\"reflect\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst []float64\n\t\tl float64\n\t\tu float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span test 1\",\n\t\t\tdst: []float64{0, 0, 0},\n\t\t\tl: 0,\n\t\t\tu: 10,\n\t\t\texpected: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span test 2\",\n\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\tl: -5,\n\t\t\tu: 5,\n\t\t\texpected: []float64{-5, -2.5, 0, 2.5, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span test 3\",\n\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\tl: 0,\n\t\t\tu: 0,\n\t\t\texpected: []float64{0, 0, 0, 0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "619b5b88adc14dd5e12b4896a2e60292": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0}, 2},\n\t\t{\"Test2\", []float64{10.5, 5.3, 8.7, 9.1}, 0},\n\t\t{\"Test3\", []float64{-1.0, -5.0, -3.0, -2.0}, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63eb0a38dfc2724cfeb1f978ccfde92a": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u, v, expected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{4, 0, 10, -5, 0},\n\t\t{4, 0, 10, 15, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "63fa0b8a84228ec317cfed7688363a0a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourmodule/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"Test Case 1\",\n\t\t\tdst:   []float64{0, 0, 0},\n\t\t\tl:     1,\n\t\t\tu:     5,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"Test Case 2\",\n\t\t\tdst:   []float64{0, 0, 0, 0},\n\t\t\tl:     1,\n\t\t\tu:     5,\n\t\t\tpanic: false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, but got: %v\", tt.panic, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length: %d, but got: %d\", len(tt.dst), len(result))\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "6413829de65ffe830657a47656e35ce0": "// File: nearestidxforspan_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl, u  float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{5, 0.0, 10.0, 4.5, 1},\n\t\t{3, 0.0, 5.0, 2.0, 1},\n\t\t{4, -5.0, 5.0, 2.5, 4},\n\t\t{6, -10.0, 0.0, -5.5, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tindex := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif index != tt.index {\n\t\t\tt.Errorf(\"For n=%d, l=%.1f, u=%.1f, v=%.1f; Expected index: %d, Got: %d\", tt.n, tt.l, tt.u, tt.v, tt.index, index)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0.0, 5.0, 2.0)\n}",
    "656d8243e7ab61dd1b5d5d4c0a1c2a51": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 10},\n\t\t{[]float64{5, 5, 5, 5}, 5, 5},\n\t\t{[]float64{2, 4, 6, 8, 10}, 2, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := Span(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(actual, test.dst) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, actual, test.dst)\n\t\t}\n\t}\n}\n\n// Add more test cases here as needed.",
    "65a07e02fcce872028436f8a915909a7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"nearest_to_positive_value\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.8, 3},\n\t\t{\"nearest_to_negative_value\", []float64{-5.0, -4.0, -3.0, -2.0, -1.0}, -2.8, 3},\n\t\t{\"nearest_to_zero_value\", []float64{-0.5, 0.0, 0.5, 1.0}, 0.25, 2},\n\t\t{\"nearest_to_NaN\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 1.0 / 0.0, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fd8ad4512dfef4102fe3bfb9270a4f": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 5, []float64{1, 3, 5}},\n\t\t{[]float64{3, 3, 3}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{1, 1, 1, 1, 1}, -5, 5, []float64{-5, 0, 5, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Errorf(\"Span did not panic with insufficient length\")\n\t\t}\n\t}()\n\n\tSpan([]float64{1}, 2, 5)\n}",
    "6614f0f640bed3219f6edca88d44dd37": "// Package floats provides float64 functions complementing the functions in the math package.\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn         int\n\t\tl         float64\n\t\tu         float64\n\t\tv         float64\n\t\texpected  int\n\t\tshouldPanic bool\n\t}{\n\t\t{2, 0, 10, 5, 1, false},\n\t\t{3, 0, 10, 7, 1, false},\n\t\t{4, 0, 10, 9, 2, false},\n\t\t{5, 0, 10, 4, 0, false},\n\t\t{6, 0, 10, 11, 5, false},\n\t\t{7, 0, math.Inf(0), 15, 6, false},\n\t\t{8, 2, math.Inf(-1), 1, 0, false},\n\t\t{9, math.Inf(-1), 0, -5, 0, false},\n\t\t{10, 0, 0, 0, 0, false},\n\t\t{11, 0, 0, -1, 0, false},\n\t\t{12, 0, 0, 1, 0, false},\n\t\t{13, math.Inf(-1), math.Inf(1), 0, 0, false},\n\t\t{14, math.Inf(-1), math.Inf(1), math.NaN(), 0, false},\n\t\t{15, 0, 10, math.NaN(), 0, false},\n\t\t{16, 0, 0, math.Inf(-1), 0, false},\n\t\t{2, 0, 10, 5, 0, true}, // Should panic - n less than 2\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != test.shouldPanic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, but got panic: %v\", test.shouldPanic, r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "662f2e407358b89be4281a5a18880939": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}\n",
    "66d292c1ce226e5c8864cc13fe05bc21": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{\"Test1\", 5, 0.0, 10.0, 4.7, 1},\n\t\t{\"Test2\", 5, 0.0, 10.0, 8.9, 4},\n\t\t{\"Test3\", 5, 0.0, 10.0, 5.5, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "67dd6295b47259e6fb279f0555c34da2": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t\t{\"Equal lengths slices\", [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}, true},\n\t\t{\"Different lengths slices\", [][]float64{{1.0, 2.0}, {4.0, 5.0, 6.0}}, false},\n\t\t{\"Equal lengths slices with one empty slice\", [][]float64{{}, {4.0, 5.0, 6.0}}, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68474e5a72e61670a6cb46b5ac1305bf": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"EmptySlice\", []float64{}, 1.0},\n\t\t{\"SingleElement\", []float64{3.0}, 3.0},\n\t\t{\"MultipleElements\", []float64{2.0, 3.0, 4.0}, 24.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68899a430ddf4f6f239e756b66bbbffb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Same slices with same values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Same slices with different values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 5.0, 3.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Same slices with NaN values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, floats.NaN()},\n\t\t\tt:        []float64{1.0, 2.0, 3.0, floats.NaN()},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slices with different lengths\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Same(tt.s, tt.t)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected result to be %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "68e0afb435fbddde65eef21993523abe": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your-module-path/floats\" // Update with the correct module path\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Middle value\", []float64{1.0, 3.0, 5.0, 7.0, 9.0}, 4.0, 1},\n\t\t{\"First value\", []float64{1.0, 3.0, 5.0, 7.0, 9.0}, 0.0, 0},\n\t\t{\"Last value\", []float64{1.0, 3.0, 5.0, 7.0, 9.0}, 9.0, 3},\n\t\t{\"Value outside range\", []float64{1.0, 3.0, 5.0, 7.0, 9.0}, 10.0, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Within(tt.input, tt.value)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "690866bf0f92f2e1f2a6c438c10bc8eb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{5, 1.0, 5.0, 3.0, 2},\n\t\t{4, -5.0, 5.0, 0.0, 2},\n\t\t{2, 0.0, 10.0, 5.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"Expected index %d, but got %d for n=%d, l=%f, u=%f, v=%f\",\n\t\t\t\ttest.index, index, test.n, test.l, test.u, test.v)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tNearestIdxForSpan(1, 0.0, 10.0, 5.0)\n}",
    "6930d616072f2ca90b31519426117788": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n\t\"math\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.4076059644443807},\n\t\t{[]float64{0.0, 0.0, 0.0}, 0.6931471805599453},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -0.3068528194400547},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.LogSumExp(test.input)\n\t\tif math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"For %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\n// Additional test cases can be added here\n",
    "69897caeb65fe72f7aa78c474973b3a4": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{5, 0, 10, 3, 1},\n\t\t{5, 0, 10, -1, 0},\n\t\t{4, 0, 10, 15, 3},\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 5, 10, 8, 1},\n\t\t{6, 0, 10, 10, 5},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", tc.n, tc.l, tc.u, tc.v, tc.result, actual)\n\t\t}\n\t}\n}\n",
    "6aede9c09c69006b852dd6e16ffad905": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Span test\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 10.0\n\n\t\tresult := Span(dst, l, u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(dst) {\n\t\t\tt.Errorf(\"Length of result slice is not the same as the input slice\")\n\t\t}\n\n\t\tfor i := 0; i \u003c len(result); i++ {\n\t\t\texpected := l + (u-l)*float64(i)/float64(len(result)-1)\n\t\t\tif result[i] != expected {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected, i, result[i])\n\t\t\t}\n\t\t}\n\n\t\t// Adding more test cases for different slice lengths\n\t\tdst = make([]float64, 3)\n\t\tresult = Span(dst, l, u)\n\n\t\tif len(result) != len(dst) {\n\t\t\tt.Errorf(\"Length of result slice is not the same as the input slice\")\n\t\t}\n\n\t\texpected := []float64{1.0, 5.5, 10.0}\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", expected, result)\n\t\t}\n\n\t\t// Test panic if slice length is less than 2\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic when the length of dst is less than 2\")\n\t\t\t}\n\t\t}()\n\n\t\tdst = make([]float64, 1)\n\t\tSpan(dst, l, u)\n\t})\n}",
    "6af629ddd937cab703589d0bb7a8abe6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // Update the path to the correct location\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{4, 1.0, 5.0, 2.5, 1},\n\t\t{3, 1.0, 5.0, 2.5, 1},\n\t\t{5, 1.0, 5.0, 0.0, 0},\n\t\t{5, 1.0, 5.0, 6.0, 4},\n\t\t{5, 5.0, 1.0, 2.5, 4},\n\t\t{4, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "6bfc7b9f97ba65b7653d66b1e69f0b80": "// Package floats provides functions for float64 slices.\npackage floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourmodule/floats\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tslice1  []float64\n\t\tslice2  []float64\n\t\tequal   bool\n\t\tmessage string\n\t}{\n\t\t{\n\t\t\tname:    \"Equal slices\",\n\t\t\tslice1:  []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:  []float64{1.0, 2.0, 3.0},\n\t\t\tequal:   true,\n\t\t\tmessage: \"Expected slices to be equal\",\n\t\t},\n\t\t{\n\t\t\tname:    \"Slices with different lengths\",\n\t\t\tslice1:  []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:  []float64{1.0, 2.0},\n\t\t\tequal:   false,\n\t\t\tmessage: \"Expected slices lengths to be different\",\n\t\t},\n\t\t{\n\t\t\tname:    \"Slices with different elements\",\n\t\t\tslice1:  []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:  []float64{1.0, 4.0, 3.0},\n\t\t\tequal:   false,\n\t\t\tmessage: \"Expected elements to be different\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := floats.EqualFunc(test.slice1, test.slice2, floats.Equal)\n\t\t\tif result != test.equal {\n\t\t\t\tt.Errorf(\"Failed test case: %s. %s\", test.message, test.name)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "6c7c9566e0529939e343a754e38af8a8": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t// Add test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d06d0759e4be25c7b630ad5ceb5bc13": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"Test Case 1\", 4, 0.0, 10.0, 5.0, 2},\n\t\t{\"Test Case 2\", 6, 1.0, 5.0, 2.5, 1},\n\t\t{\"Test Case 3\", 5, -5.0, 5.0, -10.0, 0},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d21515f8125323eb177cf800f931b07": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\"span n \u003c 2\", []float64{1.0}, 1.0, 2.0, nil},\n\t\t{\"span normal case\", []float64{0, 0, 0}, 1.0, 4.0, []float64{1.0, 2.5, 4.0}},\n\t\t{\"span NaN l\", []float64{0, 0, 0}, math.NaN(), 4.0, []float64{math.NaN(), math.NaN(), 4.0}},\n\t\t{\"span NaN u\", []float64{0, 0, 0}, 1.0, math.NaN(), []float64{1.0, math.NaN(), math.NaN()}},\n\t\t{\"span Inf l and Inf u\", []float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(0)}},\n\t\t{\"span Inf l\", []float64{0, 0, 0}, math.Inf(1), 4.0, []float64{math.Inf(1), math.Inf(1), 4.0}},\n\t\t{\"span Inf u\", []float64{0, 0, 0}, 1.0, math.Inf(1), []float64{1.0, math.Inf(1), math.Inf(1)}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.want != nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic, got none\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6deba74db0b90460246258ff700fb465": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{0, 0, 0}, -5, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tif reflect.DeepEqual(Span(test.dst, test.l, test.u), expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, test.dst, expected)\n\t\t}\n\t}\n}",
    "6f60e11c27d167cc98a6c777b2ed309f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{5, 0, 10, -5, 0},\n\t\t{5, 0, 10, 15, 4},\n\t\t{3, 0, 10, 11, 2},\n\t\t{4, 0, 10, 10, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"For n = %v, l = %v, u = %v, and v = %v got index %v, expected %v\", test.n, test.l, test.u, test.v, index, test.index)\n\t\t}\n\t}\n}\n",
    "6f8f0cf089b9296b93c93e650fdcf0f6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4.4, 3},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 4.4, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For s=%v and v=%f, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "705779804a0d6e416d989d33e5d71d2c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 5, 3, 1},     // regular case\n\t\t{3, 1, 6, 0, 0},     // l bound case\n\t\t{3, 1, 6, 7, 2},     // u bound case\n\t\t{5, -10, 10, -5, 0}, // negative numbers case\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, got %d, expected %d\", test.n, test.l, test.u, test.v, result, test.result)\n\t\t}\n\t}\n}\n",
    "70ef5cf162ccbbbeaffa61109d9d5327": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{4, 0.0, 10.0, 5.5, 2},\n\t\t{5, 0.0, 10.0, 5.5, 2},\n\t\t{4, 0.0, 10.0, 0.0, 0},\n\t\t{4, 0.0, 10.0, 10.0, 3},\n\t\t{2, 0.0, 10.0, 5.5, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "719fbaed10eb9f84af07d905fd6dc8b6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your_package_path/floats\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{[]float64{-1.0, 2.0, -3.0, 4.0, -5.0}, -3.0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := floats.SumCompensated(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}",
    "72080191d1a0f6a037ea1ba79b729034": "// This is the test file for the Dot function in the floats package\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttests := []struct {\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, 32.0},\n\t\t{[]float64{0.0, 0.0, 0.0}, []float64{1.0, 2.0, 3.0}, 0.0},\n\t\t{[]float64{1.0}, []float64{2.0}, 2.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Dot(test.s1, test.s2)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Dot(%v, %v) = %f; want %f\", test.s1, test.s2, result, test.expected)\n\t\t}\n\t}\n\n\t// Add additional test cases if needed\n}",
    "731ef9c1650a0835b8d91c3e5645ea3d": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf and NaN\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    floats.NaN(),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Perform assertions here, based on the expected behavior of the Span function\n\n\t\t\t// Example assertion (replace with actual assertions)\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length: %d, got: %d\", len(tt.dst), len(result))\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7342be149dca4d93bbc1c7058fc4b165": "package floats\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tslice1 []float64\n\t\tslice2 []float64\n\t\texpected bool\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{\"Test2\", []float64{3.0, 2.0, 1.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{\"Test3\", []float64{1.0, math.NaN(), 3.0}, []float64{1.0, math.NaN(), 3.0}, true},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Same(tt.slice1, tt.slice2)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected result to be %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "735adf687a18e301fe773c3aa12dfa6b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    4.7,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\tn:    3,\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\tv:    20,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\tn:    2,\n\t\t\tl:    0.5,\n\t\t\tu:    1.5,\n\t\t\tv:    3,\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "742c3a0e60b52275548045f9937128ed": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\tdst := []float64{4.3, 2.7, 5.1, 3.9}\n\tinds := make([]int, len(dst))\n\texpectedDst := []float64{2.7, 3.9, 4.3, 5.1}\n\texpectedInds := []int{1, 3, 0, 2}\n\n\tfloats.ArgsortStable(dst, inds)\n\n\tif !reflect.DeepEqual(dst, expectedDst) {\n\t\tt.Errorf(\"Expected sorted dst: %v, got: %v\", expectedDst, dst)\n\t}\n\n\tif !reflect.DeepEqual(inds, expectedInds) {\n\t\tt.Errorf(\"Expected inds after sorting: %v, got: %v\", expectedInds, inds)\n\t}\n}",
    "74b6c2682cd0091c2b1d38011061c6ec": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{7.0, 8.0, 9.0}, []float64{11.0, 13.0, 15.0}},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{7.0, 8.0}, nil}, // mismatched lengths\n\t}\n\n\tfor _, test := range tests {\n\t\tinitialDst := make([]float64, len(test.dst))\n\t\tcopy(initialDst, test.dst)\n\t\tif result := AddTo(test.dst, test.s, test.t); !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v, expected %v\", initialDst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}\n",
    "7531e22078872885620137b8f10e36fa": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}, []float64{11, 13, 15}},\n\t\t{[]float64{10, 20, 30}, []float64{40, 50, 60}, []float64{70, 80, 90}, []float64{120, 150, 180}},\n\t\t{[]float64{0.5, 0.5, 0.5}, []float64{1, 2, 3}, []float64{-0.5, -1, -1.5}, []float64{0.5, 1, 1.5}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := AddTo(test.dst, test.s, test.t)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}",
    "75568582d0db1dd3b3d9aaadf9b871d7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{\"Test case 2\", []float64{1, 2, 3, 4, 5}, 5.5, -1},\n\t\t{\"Test case 3\", []float64{1, 2, 3, 4, 5}, 0, -1},\n\t\t{\"Test case 4\", []float64{5, 4, 3, 2, 1}, 2.5, 3},\n\t\t{\"Test case 5\", []float64{1, 1, 1, 1, 1}, 1, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "764003bc0b16664630dab25d0a7361f9": "// Package floats provides mathematical functions for float64 slices.\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{2, 4, 6}, []float64{1, 3, 5}, 2, 2.449489742783178},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %f) returned %f, expected %f\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "7775eae90044d2b83c4ba237a18e6524": "package floats\n\nimport \"testing\"\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\ts          []float64\n\t\tv          float64\n\t\texpectedIdx int\n\t}{\n\t\t{name: \"Test1\", s: []float64{1, 2, 3, 4, 5}, v: 3.2, expectedIdx: 2},\n\t\t{name: \"Test2\", s: []float64{1, 2, 3, 4, 5}, v: 2.6, expectedIdx: 1},\n\t\t{name: \"Test3\", s: []float64{1, 2, 3, 4, 5}, v: 4.5, expectedIdx: 4},\n\t\t{name: \"Test4\", s: []float64{-1, 0, 1}, v: -0.8, expectedIdx: 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expectedIdx {\n\t\t\t\tt.Errorf(\"For %v and %v, expected index %v but got %v\", test.s, test.v, test.expectedIdx, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "77b93326ee7c291bfa127d16988aa7d8": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 0}},\n\t\t{[]float64{0, 0, 0, 0}, math.NaN(), 10, []float64{math.NaN(), math.NaN(), 10, 0}},\n\t\t{[]float64{0, 0, 0, 0}, 0, math.Inf(0), []float64{0, math.Inf(0), math.Inf(0), 0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79104be89c9c1a79798d2bc6dce60d34": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-6\n\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{}, 0, 10},\n\t\t{[]float64{0}, 0, 10},\n\t\t{[]float64{1, 2, 3}, 1, 3},\n\t\t{[]float64{5, 5, 5, 5}, 5, 5},\n\t\t{[]float64{0.5, 1, 1.5, 2}, 0.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, test.dst) {\n\t\t\tt.Errorf(\"Span did not return expected slice. Expected: %v, Got: %v\", test.dst, result)\n\t\t}\n\n\t\tif len(result) != len(dstCopy) {\n\t\t\tt.Errorf(\"Span mutated the length of the slice. Expected length: %d, Got length: %d\", len(dstCopy), len(result))\n\t\t}\n\n\t\tfor i := 0; i \u003c len(result); i++ {\n\t\t\texpected := test.l + (test.u-test.l)*float64(i)/(float64(len(result)-1))\n\t\t\tif math.Abs(result[i]-expected) \u003e tol {\n\t\t\t\tt.Errorf(\"Span did not return expected value at index %d. Expected: %v, Got: %v\", i, expected, result[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "79ba96a414ec58600a22cf4d6a65c7d9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn          int\n\t\tl          float64\n\t\tu          float64\n\t\tv          float64\n\t\texpected   int\n\t\tshouldPanic bool\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 1, false},\n\t\t{4, 0.0, 10.0, 6.0, 2, false},\n\t\t{3, 0.0, 10.0, 10.0, 2, false},\n\t\t{5, 0.0, 10.0, -5.0, 0, false},\n\t\t{2, 0.0, 10.0, 15.0, 2, false},\n\t\t{7, 0.0, 10.0, 7.5, 4, false},\n\t\t{6, 0.0, 10.0, 12.0, 5, false},\n\t\t{8, 0.0, 10.0, -2.0, 0, false},\n\t\t{4, 0.0, 10.0, 0.0, 0, false},\n\t\t{3, 0.0, 10.0, 5.0, 1, false},\n\t\t{2, 0.0, 10.0, 7.0, 1, false},\n\t\t{3, 0.0, 10.0, 2.0, 0, false},\n\t\t{5, 0.0, 10.0, -3.0, 0, false},\n\t\t{6, 0.0, 10.0, -15.0, 0, false},\n\t\t{4, 0.0, 10.0, 9.5, 3, false},\n\t\t{2, 0.0, 0.0, 0.0, 0, false},\n\t\t{3, 0.0, 0.0, 5.0, 0, false},\n\t\t{4, 0.0, 0.0, -5.0, 0, false},\n\t\t{2, 5.0, 0.0, 2.0, 0, false},\n\t\t{3, 5.0, 0.0, 7.0, 0, false},\n\t\t{4, 5.0, 0.0, 10.0, 0, false},\n\t\t{2, -5.0, 5.0, 0.0, 1, false},\n\t\t{3, -5.0, 5.0, 0.0, 1, false},\n\t\t{4, -5.0, 5.0, 0.0, 1, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != test.shouldPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan panicked = %v, expected %v\", r != nil, test.shouldPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t}()\n\t}\n}",
    "79f3aca3977491f8d5f9776daa658477": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test Span with valid input\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with NaN\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with Inf\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(0),\n\t\t\tu:        math.Inf(0),\n\t\t\texpected: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7ae0b412168e3741e885695e100e10dc": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case: Inf bounds\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    float64('+'),\n\t\t\tu:    float64('+'),\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    float64('nan'),\n\t\t\tu:    float64('nan'),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Assert the contents of the mutated slice\n\t\t\tfor i, val := range got {\n\t\t\t\tif i == 0 \u0026\u0026 val != tt.l {\n\t\t\t\t\tt.Errorf(\"Expected first element to be %v, got %v\", tt.l, val)\n\t\t\t\t} else if i == len(got)-1 \u0026\u0026 val != tt.u {\n\t\t\t\t\tt.Errorf(\"Expected last element to be %v, got %v\", tt.u, val)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Assert length of the returned slice\n\t\t\tif len(got) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected returned slice length to be %d, got %d\", len(tt.dst), len(got))\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ba6c1a9d9cfc826feb1c6cc29a7d1d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected float64\n\t}{\n\t\t{\"EmptySlice\", []float64{}, 0},\n\t\t{\"SingleElement\", []float64{5.5}, 5.5},\n\t\t{\"MultipleElements\", []float64{1, 2, 3, 4, 5}, 15},\n\t\t{\"NegativeNumbers\", []float64{-1, -2, -3}, -6},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected: %v, Got: %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test with large numbers\n\tlargeInput := []float64{1e16, 2e16, 3e16, 4e16, 5e16}\n\tlargeExpected := 1.5e17\n\tlargeResult := SumCompensated(largeInput)\n\tif math.Abs(largeResult-largeExpected) \u003e 1e-5 {\n\t\tt.Errorf(\"Expected: %v, Got: %v\", largeExpected, largeResult)\n\t}\n}",
    "7be2cfa5773f77e57f0b52a902a37906": "// Package floats contains functions for manipulating slices of floats.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 2, 1, 0},\n\t\t{4, 0, 10, 5, 2},\n\t\t{3, -2, 2, 0, 1},\n\t\t{5, -5, 5, -10, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "7ce7e0ff5d5a26e4ace3cfba39e5cd75": "func TestFind(t *testing.T) {\n\ts := []float64{1.1, 2.2, 3.3, 4.4, 5.5}\n\t\n\tt.Run(\"Test case where k is -1\", func(t *testing.T) {\n\t\tf := func(val float64) bool {\n\t\t\treturn val \u003e 2.0\n\t\t}\n\t\texpected := []int{2, 3, 4}\n\t\tresult, err := Find(nil, f, s, -1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", expected, result)\n\t\t}\n\t})\n\t\n\tt.Run(\"Test case where k is positive and elements found\", func(t *testing.T) {\n\t\tf := func(val float64) bool {\n\t\t\treturn val \u003e 2.0\n\t\t}\n\t\texpected := []int{2, 3}\n\t\tresult, err := Find(nil, f, s, 2)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", expected, result)\n\t\t}\n\t})\n\t\n\tt.Run(\"Test case where k is positive but not enough elements found\", func(t *testing.T) {\n\t\tf := func(val float64) bool {\n\t\t\treturn val \u003e 6.0\n\t\t}\n\t\texpectedErr := \"floats: insufficient elements found\"\n\t\t_, err := Find(nil, f, s, 2)\n\t\tif err == nil || err.Error() != expectedErr {\n\t\t\tt.Errorf(\"Expected error: %v, but got %v\", expectedErr, err)\n\t\t}\n\t})\n}",
    "7dbdc50dd0c7ca092a6eb33c2b115cb4": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test case with equal lengths\n\tslice1 := []float64{1, 2, 3}\n\tslice2 := []float64{4, 5, 6}\n\tslice3 := []float64{7, 8, 9}\n\n\tequal := EqualLengths(slice1, slice2, slice3)\n\tif !equal {\n\t\tt.Errorf(\"Expected slices to have equal lengths, but they did not\")\n\t}\n\n\t// Test case with unequal lengths\n\tslice4 := []float64{1, 2, 3}\n\tslice5 := []float64{4, 5}\n\n\tunequal := EqualLengths(slice4, slice5)\n\tif unequal {\n\t\tt.Errorf(\"Expected slices to have unequal lengths, but they did\")\n\t}\n\n\t// Test case with empty slices\n\tempty1 := []float64{}\n\tempty2 := []float64{}\n\n\tempty := EqualLengths(empty1, empty2)\n\tif !empty {\n\t\tt.Errorf(\"Expected empty slices to return true, but it did not\")\n\t}\n}\n",
    "7dee733e37d1cd403fa43e560561b44b": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 3},\n\t\t{[]float64{1, 1.5, 2, 2.5, 3}, 1, 3},\n\t\t{[]float64{0, 10, 20, 30}, 0, 30},\n\t\t{[]float64{1, 2, 3}, -1, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(test.dst, result) {\n\t\t\tt.Errorf(\"Expected output %v, but got %v\", test.dst, result)\n\t\t}\n\n\t\tfor i, x := range result {\n\t\t\tif x != test.l+float64(i)*(test.u-test.l)/(float64(len(result))-1) {\n\t\t\t\tt.Errorf(\"Expected element %v at index %v, but got %v\", test.l+float64(i)*(test.u-test.l)/(float64(len(result))-1), i, x)\n\t\t\t}\n\t\t}\n\n\t\tif !reflect.DeepEqual(expected, result) {\n\t\t\tt.Errorf(\"Expected mutated slice to match original, but got %v\", result)\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when length of dst was less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{1}, 1, 3)\n}",
    "7e067ec2eec8c0ce92a797561684a201": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 0},\n\t\t{3, 1.0, 3.0, 2.5, 1},\n\t\t{4, 0.0, 4.0, 2.0, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "7e0e584ee99bb04f534bf4a061567134": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t\twant []int\n\t}{\n\t\t{[]int{}, func(x float64) bool { return x \u003e 0 }, []float64{1, 2, 3, 4, 5}, 3, []int{1, 2, 3}},\n\t\t{[]int{}, func(x float64) bool { return x \u003c 0 }, []float64{1, 2, 3, 4, 5}, -1, []int{}},\n\t\t{[]int{}, func(x float64) bool { return x \u003e 5 }, []float64{1, 2, 3, 4, 5}, 2, []int{}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got, _ := Find(tt.inds, tt.f, tt.s, tt.k); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7e338ea1edf5d53d16546d7262adfbf3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t\t{3, -5.0, 5.0, 2.5, 1},\n\t\t{5, 1.0, 3.0, 2.5, 3},\n\t\t{4, -10.0, 10.0, -15.0, 0},\n\t\t{6, 0.0, 100.0, 50.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif idx != test.expectedIdx {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected idx=%d, but got idx=%d\", test.n, test.l, test.u, test.v, test.expectedIdx, idx)\n\t\t}\n\t}\n}\n",
    "7f25d22513ef6e04b64a192ed3cfc5b0": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1}, // n=2, l=0.0, u=1.0, v=0.5 -\u003e Expected index 1\n\t\t{3, 0.0, 2.0, 1.5, 2}, // n=3, l=0.0, u=2.0, v=1.5 -\u003e Expected index 2\n\t\t{4, -1.0, 1.0, 0.1, 3}, // n=4, l=-1.0, u=1.0, v=0.1 -\u003e Expected index 3\n\t\t{5, -10.0, 10.0, 5.0, 3}, // n=5, l=-10.0, u=10.0, v=5.0 -\u003e Expected index 3\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v - Expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "7f3a126a386b9ed26bfb0769fd5122a4": "// Package floats provides a collection of float64 slices functions.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Empty slice\", []float64{}, -1}, // Expected to panic\n\t\t{\"Single element\", []float64{5}, 0},\n\t\t{\"Multiple elements\", []float64{3, 5, 2, 7, 9}, 4},\n\t\t{\"Multiple elements with NaN\", []float64{3, 5, math.NaN(), 7, 9}, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for '%s' test case\", test.name)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := MaxIdx(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d for '%s' test case\", test.expected, result, test.name)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7f6810e613aee48e70477e69512564f4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"All slices have equal length\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Slices have different lengths\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}, {6.0, 7.0, 8.0, 9.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"No input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f69ce5884584bab680bef849c1ae2aa": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Normal case\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 0.0\n\t\tu := 10.0\n\t\texpected := []float64{0.0, 2.5, 5.0, 7.5, 10.0}\n\n\t\tresult := Span(dst, l, u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Expected %v but got %v\", expected, result)\n\t\t}\n\t})\n\n\tt.Run(\"Panic case: length less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\n\t\tdst := make([]float64, 1)\n\t\tl := 0.0\n\t\tu := 10.0\n\n\t\t_ = Span(dst, l, u)\n\t})\n}",
    "806936f5d9d784f8306b0ac2a5943872": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  [][]float64\n\t\toutput bool\n\t}{\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2}, {3, 4, 5}, {6, 7}}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tt.input...)\n\t\t\tif result != tt.output {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.output, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "809daefdfb910db4c42b0f1b1277fcbe": "package floats\n\nimport \"testing\"\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1\n\tdst := make([]float64, 5)\n\tl := 0.0\n\tu := 10.0\n\tresult := Span(dst, l, u)\n\tif len(result) != len(dst) {\n\t\tt.Errorf(\"Expected result length to be %d, but got %d\", len(dst), len(result))\n\t}\n\tfor i := 0; i \u003c len(result); i++ {\n\t\texpected := float64(i) * 2.0\n\t\tif result[i] != expected {\n\t\t\tt.Errorf(\"Expected result[%d] to be %f, but got %f\", i, expected, result[i])\n\t\t}\n\t}\n\n\t// Test case 2\n\tdst = make([]float64, 3)\n\tl = -1.0\n\tu = 1.0\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"Expected Span to panic for dst length less than 2\")\n\t\t}\n\t}()\n\tSpan(dst, l, u)\n}\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Write test cases for NearestIdx function here\n}\n\n// Add more test functions for other functions in the source file as needed\n",
    "80ffe1ef1dc80434c8321ba0d2fb1c7c": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 0}},\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0}, 0, 10, []float64{0, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span = %v; want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panics\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif recover() == nil {\n\t\t\t\tt.Errorf(\"Span did not panic\")\n\t\t\t}\n\t\t}()\n\n\t\tSpan([]float64{0, 0}, 0, 10)\n\t})\n}",
    "8164f904edbace0e687a6eb1a01a3af5": "// Package floats_test provides unit tests for the floats package\npackage floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L2 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) returned %v, expected %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "820e22f4df79d99e681e83421197f3ad": "// File: norm_test.go\n\npackage floats\n\nimport package \"testing\"\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 2, 3.7416573867739413},\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{1, 2, 3}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, 2, -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.s, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Norm(%v, %v) returned %v, expected %v\", test.s, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "8237b765f07159af3926d27949397523": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 10},\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{3, 4, 5, 6, 7, 8}, 3, 8},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(result, test.dst) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.dst)\n\t\t}\n\t}\n}",
    "82cfd02b37e335e4d6d30fe85596f5fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\"L2 norm of [3, 4] should be 5\", []float64{3, 4}, 2, 5},\n\t\t{\"L1 norm of [3, -4, 5] should be 12\", []float64{3, -4, 5}, 1, 12},\n\t\t{\"LInfinity norm of [3, -4, 5] should be 5\", []float64{3, -4, 5}, math.Inf(1), 5},\n\t\t{\"L3 norm of [3, -4, 5] should be 6.708203932499369\", []float64{3, -4, 5}, 3, 6.708203932499369},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\toutput := Norm(tt.slice, tt.L)\n\t\t\tif output != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %v, but got: %v\", tt.expected, output)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8316756719bd266dc16a02ec38ac71fe": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/floats/package\" // Assuming correct import path\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u int\n\t\tv, want int\n\t}{\n\t\t{10, 0, 100, 35.5, 3},\n\t\t{10, 0, 100, 99.9, 9},\n\t\t{5, -10, 10, -5.5, 0},\n\t\t{5, -10, 10, 10, 4},\n\t\t{5, 0, 0, 0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := floats.NearestIdxForSpan(tt.n, float64(tt.l), float64(tt.u), tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v; want %v\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n```",
    "833b21a0075c577fde94c189898f66a9": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // import the package containing the Swap function\n)\n\nfunc TestSwap(t *testing.T) {\n\ts := []float64{4.3, 2.1, 9.7, 5.5, 1.2}\n\ta := floats.argsort{s: s}\n\n\t// Before swapping\n\texpected := []float64{4.3, 2.1, 9.7, 5.5, 1.2}\n\tif !floats.Equal(a.s, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, a.s)\n\t}\n\n\t// Swapping elements at index 1 and 3\n\ta.Swap(1, 3)\n\texpected = []float64{4.3, 5.5, 9.7, 2.1, 1.2}\n\tif !floats.Equal(a.s, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, a.s)\n\t}\n\n\t// Swapping elements at index 2 and 4\n\ta.Swap(2, 4)\n\texpected = []float64{4.3, 5.5, 1.2, 2.1, 9.7}\n\tif !floats.Equal(a.s, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, a.s)\n\t}\n}",
    "84cba209de73be9fc8a65c3115cd478d": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Find k \u003c 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2},\n\t\t\tk:        -1,\n\t\t\texpected: []int{2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find k = 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find k = 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2},\n\t\t\tk:        3,\n\t\t\texpected: []int{2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find k = 4\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2},\n\t\t\tk:        4,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected indices %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif tt.k \u003e 0 \u0026\u0026 err == nil {\n\t\t\t\tt.Error(\"Expected error when not enough elements found, but got nil\")\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cf1db0881ba9374d11a631125e887c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl, u  float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 7.0, 3},\n\t\t{5, 1.0, 2.0, 1.5, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"Expected index %d but got %d for n=%d, l=%f, u=%f, v=%f\", test.index, index, test.n, test.l, test.u, test.v)\n\t\t}\n\t}\n}",
    "84fc49945a232770c24f21a053cee5a1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 3, 1},\n\t\t{6, -5, 5, -5, 0},\n\t\t{4, 1, 2, 3, 3},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{7, 2, 8, 7, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n: %d, l: %f, u: %f, v: %f - Expected: %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "8660c16f640958be268b424125fc3fec": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: 3.7416573867739413,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, -2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"Max absolute value\",\n\t\t\ts:    []float64{1, -2, 3},\n\t\t\tL:    floats.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"General norm\",\n\t\t\ts:    []float64{2, 2, 2},\n\t\t\tL:    3,\n\t\t\twant: 3.3019272488946263,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := floats.Norm(tc.s, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "876a136b2371b18a843f206bffeb3c2a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0.0, 10.0, 7.0, 3},\n\t\t{2, 0.0, 10.0, 7.0, 1},\n\t\t{4, 0.0, 10.0, 15.0, 3},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%.1f, u=%.1f, v=%.1f - Expected: %d, but got %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "88a0193ded84b9e893d23ff426b1843c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2.0, 5.196152422706632},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 1.0, 0.0},\n\t\t{[]float64{1, 1, 1, 1}, []float64{2, 3, 4, 5}, 1.0, 8.0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1.0, 9.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif math.Abs(result-test.result) \u003e 1e-9 {\n\t\t\tt.Errorf(\"Distance of %v and %v with L=%.1f returned %f, expected %f\", test.s, test.t, test.L, result, test.result)\n\t\t}\n\t}\n\n\t// Add more test cases here\n}",
    "8900aa68771056c6d140df5d1c575cfa": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tdst := []float64{0, 0, 0}\n\tl, u := 0.0, 10.0\n\n\t// Test for normal operation\n\texpected := []float64{0, 5, 10}\n\tresult := Span(dst, l, u)\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Span test failed, expected: %v, got: %v\", expected, result)\n\t}\n\n\t// Test for panic if length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic with insufficient dst length\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, l, u)\n}",
    "8957cbfb628c000e6a23a0af86dc0e6d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts, t   []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t{[]float64{1, 2, 3, 4}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n\n\t// Add more test cases as needed\n}",
    "8a268a807febdd1589044723d42783f7": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 1},\n\t\t{5, 0.0, 10.0, 3.0, 1},\n\t\t{4, -10.0, 10.0, -5.0, 0},\n\t\t{3, 5.0, 15.0, 6.0, 1},\n\t\t{6, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif idx != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected index: %d, but got: %d\", test.n, test.l, test.u, test.v, test.result, idx)\n\t\t}\n\t}\n}\n",
    "8d7bf8dcb492c4994dab8bf626b97ed0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case where length of destination is less than 2\n\tdst := []float64{1.0}\n\tl := 0.0\n\tu := 5.0\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for insufficient length of destination slice\")\n\t\t}\n\t}()\n\tSpan(dst, l, u)\n\n\t// Test normal case with 5 elements\n\tdst = make([]float64, 5)\n\texpected := []float64{0.0, 1.25, 2.5, 3.75, 5.0}\n\tresult := Span(dst, l, u)\n\tfor i, v := range result {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected[i], i, v)\n\t\t}\n\t}\n\n\t// Test special case with NaN and Inf values\n\tdst = make([]float64, 4)\n\tl = math.Inf(1)\n\tu = math.NaN()\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.NaN()}\n\tresult = Span(dst, l, u)\n\tfor i, v := range result {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected[i], i, v)\n\t\t}\n\t}\n}",
    "8db84bf8b529bb0fc69aa47c2d3ac7c6": "package floats\n\nimport \"testing\"\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Basic test case\", []float64{1.0, 2.5, 3.8, 4.2, 5.6}, 3.0, 2},\n\t\t{\"Empty slice\", []float64{}, 3.0, 0},\n\t\t{\"NaN value\", []float64{1.0, 2.5, 3.8, 4.2, 5.6}, NaN(), 0},\n\t\t{\"Positive Inf value\", []float64{1.0, 2.5, 3.8, 4.2, 5.6}, Inf(1), 4},\n\t\t{\"Negative Inf value\", []float64{1.0, 2.5, 3.8, 4.2, 5.6}, Inf(-1), 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "8f9e9416d8c0aaecb379aacadcf67c50": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn, l, u, v, want int\n\t}{\n\t\t{name: \"Normal case #1\", n: 5, l: 0, u: 10, v: 4, want: 0},\n\t\t{name: \"Normal case #2\", n: 5, l: 0, u: 10, v: 8, want: 4},\n\t\t{name: \"V equals l\", n: 5, l: 0, u: 10, v: 0, want: 0},\n\t\t{name: \"V equals u\", n: 5, l: 0, u: 10, v: 10, want: 4},\n\t\t{name: \"V outside (l, u)\", n: 5, l: 0, u: 10, v: -5, want: 0},\n\t\t{name: \"N less than two\", n: 1, l: 0, u: 10, v: -5, want: 0}, // expect a panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 tt.n \u003c 2 {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan did not panic for n less than two\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9012a9920bb033f073d1054b802c5912": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-module-path/floats\" // Import the package where Find function is defined\n)\n\nfunc TestFind(t *testing.T) {\n\ts := []float64{1.1, 2.2, 3.3, 4.4, 5.5}\n\tf := func(val float64) bool {\n\t\treturn val \u003e 3.0\n\t}\n\tk := 2\n\tresult, err := floats.Find(nil, f, s, k)\n\n\tif err != nil {\n\t\tt.Errorf(\"Error occurred: %v\", err)\n\t}\n\n\texpected := []int{3, 4}\n\tif len(result) != len(expected) {\n\t\tt.Errorf(\"Expected indices %v, but got %v\", expected, result)\n\t}\n\n\tfor i := 0; i \u003c len(expected); i++ {\n\t\tif result[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected indices %v, but got %v\", expected, result)\n\t\t}\n\t}\n}\n",
    "90eda1a8282de7144480b0cef156e607": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{\"Test2\", []float64{3.0, 2.0, 1.0, 2.0, 3.0}, 0},\n\t\t{\"Test3\", []float64{10.0, 5.0, 8.0, 5.0, 10.0}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %v, but got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9303356005fcdaa7752836a212c96a6f": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tL      float64\n\t\toutput float64\n\t}{\n\t\t{name: \"Test L2 norm\",\n\t\t\ts:      []float64{1, 2, 3, 4, 5},\n\t\t\tL:      2,\n\t\t\toutput: 7.416198487095663,\n\t\t},\n\t\t{name: \"Test L1 norm\",\n\t\t\ts:      []float64{1, 2, 3, 4, 5},\n\t\t\tL:      1,\n\t\t\toutput: 15,\n\t\t},\n\t\t{name: \"Test Inf norm\",\n\t\t\ts:      []float64{-1, 2, -3, 4, -5},\n\t\t\tL:      floats.Inf(1),\n\t\t\toutput: 5,\n\t\t},\n\t\t// Add more test cases here as needed\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.s, tc.L)\n\t\t\tif result != tc.output {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.output, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "930bfa10b6dc4b7a361ff5e9c117915b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\tinput: []float64{1, 2, 3},\n\t\t\texpected: 3.4076059644443802,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\tinput: []float64{-10, -5, 0},\n\t\t\texpected: 0,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := LogSumExp(tt.input)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected result: %v, Actual result: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "93bb65f0c24933e8c6e5822ca34a87d6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{name: \"Reverse empty slice\", input: []float64{}, expected: []float64{}},\n\t\t{name: \"Reverse single element slice\", input: []float64{1.0}, expected: []float64{1.0}},\n\t\t{name: \"Reverse multiple element slice\", input: []float64{1.0, 2.0, 3.0, 4.0}, expected: []float64{4.0, 3.0, 2.0, 1.0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tReverse(tt.input)\n\t\t\tfor i := range tt.input {\n\t\t\t\tif tt.input[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", tt.expected[i], i, tt.input[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "95db695f7002f97cfcc763d5f131bde2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{\"Test1\", 5, 2.0, 5.0, 3.0, 1},\n\t\t{\"Test2\", 3, 0.0, 10.0, 5.0, 1},\n\t\t{\"Test3\", 4, -5.0, 5.0, -2.5, 0},\n\t\t{\"Test4\", 4, 0.0, 0.0, 0.0, 0},\n\t\t{\"Test5\", 7, -10.0, -5.0, -7.5, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tindex := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif index != tt.index {\n\t\t\t\tt.Errorf(\"Expected index to be %v, but got %v\", tt.index, index)\n\t\t\t}\n\t\t})\n\t}\n}",
    "971cdb9966ab10f3b6a66f22cf666530": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/source/package/floats\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tslice1, slice2 []float64\n\t\ttolerance      float64\n\t\texpected       bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.1, 2.1, 3.1}, 0.2, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.1, 2.1, 3.1}, 0.01, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.01, 2.01, 3.01}, 0.02, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.1, 2.1, 3.1, 4.1}, 0.1, false},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, []float64{1.1, 2.1, 3.9, 4.1}, 0.2, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.EqualApprox(test.slice1, test.slice2, test.tolerance)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected %v, but got %v for slices %v and %v with tolerance %v\",\n\t\t\t\ttest.expected, result, test.slice1, test.slice2, test.tolerance)\n\t\t}\n\t}\n}\n",
    "97f6a508a005bcc949f1573f054387f8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tname     string\n\t\tn, l, u  float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{name: \"v outside (l, u)\", n: 5, l: 0, u: 10, v: 15, expected: 4},\n\t\t{name: \"v within (l, u)\", n: 5, l: 0, u: 10, v: 5, expected: 2},\n\t\t// Add more test cases here\n\t}\n\n\t// Run tests\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "98455f52f62b2e50bb908d3d0ed0a1ec": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1.0},\n\t\t{\"Single element\", []float64{5.0}, 5.0},\n\t\t{\"Multiple elements\", []float64{2.0, 3.0, 4.0}, 24.0},\n\t\t{\"Negative numbers\", []float64{-2.0, -3.0, -4.0}, -24.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Prod(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %f but got %f\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9968eecfdf30082706212c97588e7293": "package floats_test\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/floats/package\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Example 1\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 5.748872653768704,\n\t\t},\n\t\t{\n\t\t\tname: \"Example 2\",\n\t\t\ts:    []float64{-1, -2, -3, -4, -5},\n\t\t\twant: -0.05112734623129629,\n\t\t},\n\t\t{\n\t\t\tname: \"Example 3\",\n\t\t\ts:    []float64{0.5, 0.7, 0.9},\n\t\t\twant: 0.9382650012332326,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "99d6db2036d4ac3edc0116983f0e560d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L2 Norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 Norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity Norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Other L Norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: math.Sqrt(math.Pow(3, 3) + math.Pow(3, 3) + math.Pow(3, 3)),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected result: %v, but got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a496ba17ec527d8f006609f6f843ff6": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{4, 6, 8}, []float64{2, 3, 4}, []float64{2, 2, 2}},\n\t\t{[]float64{10, 15, 20}, []float64{2, 3, 4}, []float64{5, 5, 5}},\n\t\t{[]float64{6, 9, 12}, []float64{2, 3, 4}, []float64{3, 3, 3}},\n\t}\n\n\tfor _, test := range tests {\n\t\tfloats.Div(test.dst, test.s)\n\t\tif !floats.Equal(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Div(%v, %v) = %v, want %v\", test.dst, test.s, test.dst, test.expected)\n\t\t}\n\t}\n}\n\n// Additional test cases can be added here\n```",
    "9a6f496faafe107e1f1f8261c46d7bf1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Positive values\",\n\t\t\tinput:    []float64{1, 3, 5, 8},\n\t\t\tvalue:    6,\n\t\t\texpected: 2, // Nearest value is 5 at index 2\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative values\",\n\t\t\tinput:    []float64{-5, -3, -1, 0, 2},\n\t\t\tvalue:    -2,\n\t\t\texpected: 4, // Nearest value is -1 at index 2\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple elements closest\",\n\t\t\tinput:    []float64{1, 2, 2, 3},\n\t\t\tvalue:    1.5,\n\t\t\texpected: 0, // Nearest value is 1 at index 0\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdx(tc.input, tc.value)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Add more test cases as needed\n",
    "9a98ff29fee4e9f72e766486242fbc11": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourpackage/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 2, 4, 6, 8}, 0, 8},\n\t\t{[]float64{3, 4, 5, 6, 7}, 3, 7},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(got) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of output slice to be %d, but got %d\", len(test.dst), len(got))\n\t\t}\n\n\t\tfor i, val := range got {\n\t\t\tif val != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected value at index %d to be %f, but got %f\", i, test.dst[i], val)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test functions as needed for other functions in the package.",
    "9ab1d4dcd4e6e4dd07be351879e21a61": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\" // import the package where NearestIdxForSpan function is defined\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1}, // Example test case where n=2, l=0.0, u=1.0, v=0.5, expected result is 1\n\t\t// Add more test cases here\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := floats.NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif result != tc.result {\n\t\t\tt.Errorf(\"For n=%d, l=%.2f, u=%.2f, v=%.2f - expected %d but got %d\", tc.n, tc.l, tc.u, tc.v, tc.result, result)\n\t\t}\n\t}\n}\n",
    "9b77ccabddafb9d8dc5b4b9224996375": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\tresult: []float64{18, 21, 24},\n\t\t},\n\t\t{\n\t\t\tdst:    []float64{0, -1, -2},\n\t\t\ty:      []float64{-3, -4, -5},\n\t\t\talpha:  1,\n\t\t\ts:      []float64{0, 0, 0},\n\t\t\tresult: []float64{-3, -4, -5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tif !reflect.DeepEqual(test.dst, test.result) {\n\t\t\tt.Errorf(\"Expected %v but got %v\", test.result, test.dst)\n\t\t}\n\t}\n}\n",
    "9c55932632ea7107edec31327f638aa7": "// Package floats provides functions for manipulating slices of float64.\npackage floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Case1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Case2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 3},\n\t\t{\"Case3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Case4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.input, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d for value %f in slice %v\", tt.expected, result, tt.value, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "9cb0d360d85ad376bf2194447eafd178": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"No NaN values\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value present\",\n\t\t\tinput:    []float64{1.0, math.NaN(), 3.0},\n\t\t\texpected: true,\n\t\t},\n\t}\n\t\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := HasNaN(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected HasNaN(%v) to be %v, but got %v\", tt.input, tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d291a0a7219e71f1248386c72c4ebdd": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.0, 7.416198487095663},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1.0, 5},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t// add more test cases here\n\t}\n\n\tfor _, test := range tests {\n\t\tif output := floats.Norm(test.s, test.L); output != test.result {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.s, test.L, output, test.result)\n\t\t}\n\t}\n}",
    "9d4ab18a2d3be262fae27fe7439bf295": "func TestFind(t *testing.T) {\n\ts := []float64{1.5, 2.5, 3.5, 4.5, 5.5}\n\n\tt.Run(\"Find first 2 elements satisfying condition\", func(t *testing.T) {\n\t\tinds, err := Find(nil, func(val float64) bool { return val \u003e 3 }, s, 2)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Expected error to be nil, got %v\", err)\n\t\t}\n\n\t\texpected := []int{3, 4}\n\t\tif !reflect.DeepEqual(inds, expected) {\n\t\t\tt.Errorf(\"Expected indices %v, got %v\", expected, inds)\n\t\t}\n\t})\n\n\tt.Run(\"Find all elements satisfying condition\", func(t *testing.T) {\n\t\tinds, err := Find(nil, func(val float64) bool { return val \u003c 6 }, s, -1)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Expected error to be nil, got %v\", err)\n\t\t}\n\n\t\texpected := []int{0, 1, 2, 3, 4}\n\t\tif !reflect.DeepEqual(inds, expected) {\n\t\t\tt.Errorf(\"Expected indices %v, got %v\", expected, inds)\n\t\t}\n\t})\n\n\tt.Run(\"Error case: insufficient elements found\", func(t *testing.T) {\n\t\tinds, err := Find(nil, func(val float64) bool { return val \u003e 10 }, s, 3)\n\n\t\texpectedErr := \"floats: insufficient elements found\"\n\t\tif err == nil || err.Error() != expectedErr {\n\t\t\tt.Errorf(\"Expected error %s, got %v\", expectedErr, err)\n\t\t}\n\n\t\texpected := []int{}\n\t\tif !reflect.DeepEqual(inds, expected) {\n\t\t\tt.Errorf(\"Expected indices %v, got %v\", expected, inds)\n\t\t}\n\t})\n}",
    "9e6b0f9dd9f49f75a5ba370e3a417163": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{4.0, 5.0, 6.0},\n\t\t\tL:    2.0,\n\t\t\twant: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{4.0, 5.0, 6.0},\n\t\t\tL:    1.0,\n\t\t\twant: 9.0,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", tc.s, tc.t, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a016dbc2f0d6caf11e2cb0a3b863ab48": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{3, 1.0, 3.0, 2.5, 1},\n\t\t{4, 0.0, 10.0, 4.8, 2},\n\t\t{3, -10.0, 10.0, -5.0, 0},\n\t\t{5, 1.0, 5.0, 7.0, 4},\n\t\t{6, -5.0, 5.0, 0.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "a27f6a53f7ef837c6a2016083242e078": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Test span with valid input\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, 10.0)\n\t\t\n\t\texpected := []float64{1.0, 3.25, 5.5, 7.75, 10.0}\n\t\t\n\t\tassert.Equal(t, expected, result)\n\t})\n\t\n\tt.Run(\"Test span with NaN input\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tresult := Span(dst, math.NaN(), 5.0)\n\t\t\n\t\texpected := []float64{math.NaN(), math.NaN(), 5.0}\n\t\t\n\t\tassert.Equal(t, expected, result)\n\t})\n\t\n\tt.Run(\"Test span with Inf input\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\t\n\t\texpected := []float64{math.Inf(-1), 0, 0, math.Inf(1)}\n\t\t\n\t\tassert.Equal(t, expected, result)\n\t})\n\t\n\tt.Run(\"Test span with unequal length of dst\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\t\n\t\tassert.PanicsWithError(t, \"shortSpan\", func() {\n\t\t\tSpan(dst, 1.0, 10.0)\n\t\t})\n\t})\n}",
    "a2bf07ba250a0365f9ac0b0f63d41c94": "// Package floats contains functions for operating on slices of floats.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{4, 5, 6}, []float64{1, 2, 3}, 1, 9},\n\t\t{[]float64{4, 5, 6}, []float64{1, 2, 3}, 2, 5.196152422706632},\n\t\t{[]float64{4, 5, 6}, []float64{1, 2, 3}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %f) returned %f, expected %f\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "a3fe2ed40acd3b91aacc802c7c7b7333": "// Package floats is used for mathematical operations on float64 slices\npackage floats\n\nimport \"testing\"\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.6, 2},\n\t\t{[]float64{10, 20, 30, 40, 50}, 25, 2},\n\t\t{[]float64{0.1, 0.5, 0.9, 1.3, 1.7}, 0.8, 2},\n\t\t{[]float64{-5, -3, -1, 1, 3}, -2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v, Expected %v, but got %v\", test.s, test.expected, result)\n\t\t}\n\t}\n}\n",
    "a41f57f74af72aeefcd635aa831db8f0": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ts         []float64\n\t\tv         float64\n\t\texpected  int\n\t\tshouldPanic bool\n\t}{\n\t\t{\"empty slice\", []float64{}, 5.0, -1, true},\n\t\t{\"slice with one element\", []float64{10.0}, 5.0, -1, true},\n\t\t{\"unsorted slice\", []float64{20.0, 10.0, 30.0}, 15.0, -1, true},\n\t\t{\"value outside range\", []float64{10.0, 20.0, 30.0}, 5.0, -1, false},\n\t\t{\"value within range\", []float64{10.0, 20.0, 30.0}, 25.0, 1, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.shouldPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic, but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\t\n\t\t\tgot := Within(tt.s, tt.v)\n\t\t\tif !reflect.DeepEqual(got, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, but got %v\", tt.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a47dd1cdc3dc83bbdb439193cd64f607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{n: 4, l: 0, u: 10, v: 3, expected: 1},\n\t\t{n: 5, l: -5, u: 5, v: -10, expected: 0},\n\t\t{n: 3, l: 2, u: 8, v: 4, expected: 1},\n\t\t{n: 6, l: -7, u: -1, v: -4, expected: 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n\n\t// Additional test for NaN input values\n\tnanResult := NearestIdxForSpan(2, 1, 2, math.NaN())\n\tif nanResult != 0 {\n\t\tt.Errorf(\"For NaN input value - Expected: 0, Got: %d\", nanResult)\n\t}\n}",
    "a497dd8b46bc2c813c600319f2b295de": "package floats\n\nimport (\n\t\"testing\"\n\t\"sort\"\n\t\"math\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    5.0,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid input\",\n\t\t\ts:    []float64{5.0},\n\t\t\tv:    5.0,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"nan value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"within range\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:    2.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"outside range\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:    5.0,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"equal values\",\n\t\t\ts:    []float64{1.0, 1.0, 2.0, 3.0},\n\t\t\tv:    1.0,\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Within(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a4b60974e46bfdf6e006c7d82aaa379c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{4, 2.0, 10.0, 5.0, 2},\n\t\t{3, 1.0, 5.0, 10.0, 2},\n\t\t{2, -5.0, 5.0, 3.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to be %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "a4d1d307540cd4a4d2ac0b2fb9d31721": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tinput:    []float64{3, 4},\n\t\t\tL:        2,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tinput:    []float64{2, 3, -4},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test maximum absolute value norm\",\n\t\t\tinput:    []float64{7, -10, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 10,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.input, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a521218401b9b8dba09f0819080b73d1": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "a54d54664865f2c31b2989b19aa1f707": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, -10, []float64{0, -3.3333333333333335, -6.666666666666667, -10}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) expected %v, but got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}",
    "a5e41a7195939f58c03fbd26820a8ba7": "\npackage floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Standard case\",\n\t\t\ts:    []float64{1, 3, 5, 7},\n\t\t\tv:    4,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Duplicate values\",\n\t\t\ts:    []float64{1, 3, 5, 5, 7},\n\t\t\tv:    4,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1, 3, 5, 7},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity value\",\n\t\t\ts:    []float64{1, 3, 5, 7},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity value\",\n\t\t\ts:    []float64{1, 3, 5, 7},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v; want %v\", tc.s, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a69b30c54f2b14f26c3f18c8767573b0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, 2.0, 5.196152422706632},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, 1.0, 9.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, 3.0, 3.3019272488946263},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0}, 2.0, -1}, // mismatched lengths\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "a7d15f2cc559aa317134a3b5cf5abf3b": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{-1, -2, -3}},\n\t\t{[]float64{4, 5}, []float64{1, 2, 3}, nil},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Sub did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSub(tt.dst, tt.s)\n\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub(%v, %v) = %v, want %v\", tt.dst, tt.s, tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a9d4441a857e403200ecd0cceab9906d": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your-module-path/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname         string\n\t\tdst          []float64\n\t\tl            float64\n\t\tu            float64\n\t\texpectedDst  []float64\n\t\texpectedPanic bool\n\t}{\n\t\t{\n\t\t\tname:        \"ValidSpan\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           0,\n\t\t\tu:           10,\n\t\t\texpectedDst: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:         \"ShortDst\",\n\t\t\tdst:          make([]float64, 1),\n\t\t\tl:            0,\n\t\t\tu:            10,\n\t\t\texpectedPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"NegativeBounds\",\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           -10,\n\t\t\tu:           10,\n\t\t\texpectedDst: []float64{-10, 0, 10},\n\t\t},\n\t\t{\n\t\t\tname:        \"InfBounds\",\n\t\t\tdst:         make([]float64, 4),\n\t\t\tl:           floats.Inf(-1),\n\t\t\tu:           floats.Inf(1),\n\t\t\texpectedDst: []float64{floats.Inf(-1), 0, 0, floats.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.expectedPanic {\n\t\t\t\t\tt.Errorf(\"expected panic: %v, got panic: %v\", tt.expectedPanic, r != nil)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.dst) {\n\t\t\t\tt.Errorf(\"expected mutated slice: %v, got: %v\", tt.expectedDst, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aaf32cd17c4604ddafa4458bb47ea3c4": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t. \"github.com/yourModule/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttolerance := 1e-6\n\n\t// Test case 1\n\tdst1 := make([]float64, 5)\n\texpected1 := []float64{1, 2, 3, 4, 5}\n\tresult1 := Span(dst1, 1, 5)\n\tif !reflect.DeepEqual(result1, expected1) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected1, result1)\n\t}\n\n\t// Test case 2\n\tdst2 := make([]float64, 3)\n\t// We expect a panic here due to invalid dst length\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Errorf(\"Expected panic, but got nil\")\n\t\t}\n\t}()\n\t_ = Span(dst2, 1, 5)\n}",
    "ab7dc606c0b084ab5d94a2ed91fc6c4b": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\ts     []float64\n\t\tt     []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname: \"Divide slices of equal length\",\n\t\t\tdst:   []float64{8, 10, 12},\n\t\t\ts:     []float64{16, 20, 24},\n\t\t\tt:     []float64{2, 2, 2},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Panic: unequal slice lengths\",\n\t\t\tdst:   []float64{1, 2, 3},\n\t\t\ts:     []float64{4, 5},\n\t\t\tt:     []float64{1, 1, 1},\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, got panic: %v\", tt.panic, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := DivTo(tt.dst, tt.s, tt.t)\n\n\t\t\tif !reflect.DeepEqual(result, tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result: %v, got: %v\", tt.dst, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "abb812288b8de738509d66c3ec95412e": "// Package floats is for mathematical operations on float slices.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tvalue float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.7, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.5, 4},\n\t\t{[]float64{1.5, 2.5, 3.5}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdx(test.slice, test.value)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d; want %d\", test.slice, test.value, got, test.want)\n\t\t}\n\t}\n}",
    "adc5acf237e9d9e0b0eaa3cab7609c7a": "package floats\n\nimport \"testing\"\n\nfunc TestSwap(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\tindex1 int\n\t\tindex2 int\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname: \"Swap elements at index 0 and 1\",\n\t\t\tinput: []float64{1.0, 2.0, 3.0},\n\t\t\tindex1: 0,\n\t\t\tindex2: 1,\n\t\t\texpected: []float64{2.0, 1.0, 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Swap elements at index 2 and 3\",\n\t\t\tinput: []float64{4.0, 5.0, 6.0, 7.0},\n\t\t\tindex1: 2,\n\t\t\tindex2: 3,\n\t\t\texpected: []float64{4.0, 5.0, 7.0, 6.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Swap elements at index 0 and 2\",\n\t\t\tinput: []float64{8.0, 9.0, 10.0},\n\t\t\tindex1: 0,\n\t\t\tindex2: 2,\n\t\t\texpected: []float64{10.0, 9.0, 8.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ta := argsort{inds: make([]int, len(test.input))}\n\t\t\tcopy(a.inds, test.input)\n\n\t\t\ta.Swap(test.index1, test.index2)\n\n\t\t\tfor i, val := range a.inds {\n\t\t\t\tif val != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", test.expected[i], i, val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "af54b607219a486ffb62bfa2478b3568": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"All slices have equal length\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Slices have different lengths\",\n\t\t\tslices: [][]float64{{1.0}, {2.0, 3.0}, {4.0, 5.0, 6.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"No input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Single input slice\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}},\n\t\t\twant:   true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af91ec866fc2f872635e8cfdd90e66fa": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\ts1:   []float64{1.1, 2.2, 3.3},\n\t\t\ts2:   []float64{1.1, 2.2, 3.3},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\ts1:   []float64{1.1, 2.2},\n\t\t\ts2:   []float64{1.1, 2.2, 3.3},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\ts1:   []float64{1.1, 2.2, 3.3},\n\t\t\ts2:   []float64{1.1, 2.2, 4.4},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\ts1:   []float64{},\n\t\t\ts2:   []float64{},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.s1, tt.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "afb6691cc094d2b363d8525e14a19ac8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCumSum(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 3, 6}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{1, 3, 6}},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3, 0}, []float64{1, 2, 3}, []float64{1, 3, 6, 0}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tCumSum(tc.dst, tc.s)\n\t\tif !reflect.DeepEqual(tc.dst, tc.want) {\n\t\t\tt.Errorf(\"CumSum(%v, %v) = %v; want %v\", tc.dst, tc.s, tc.dst, tc.want)\n\t\t}\n\t}\n}",
    "afc5e1b592f391571a48959e2f9e490f": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestCount(t *testing.T) {\n\tcases := []struct {\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tresult int\n\t}{\n\t\t{\n\t\t\tfunc(x float64) bool { return x \u003e 0 },\n\t\t\t[]float64{1, -2, 3, -4, 5},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\tfunc(x float64) bool { return x \u003c 0 },\n\t\t\t[]float64{1, 2, 3, 4, 5},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\tfunc(x float64) bool { return x % 2 == 0 },\n\t\t\t[]float64{1, 2, 3, 4, 5},\n\t\t\t2,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tcount := floats.Count(tc.f, tc.s)\n\t\tif count != tc.result {\n\t\t\tt.Errorf(\"Count(%v, %v) = %d; want %d\", tc.f, tc.s, count, tc.result)\n\t\t}\n\t}\n}\n",
    "b023a706762e4bc46743e63893e9d4ca": "// File: floats_test.go\n\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, want []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 4, 9}},\n\t\t{[]float64{0, 0}, []float64{0, 0}, []float64{0, 0}, []float64{0, 0}},\n\t\t{[]float64{3, 3}, []float64{1, 2}, []float64{3, 1}, []float64{3, 2}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\tt.Errorf(\"MulTo(%v, %v, %v) = %v, want %v\", tt.dst, tt.s, tt.t, got, tt.want)\n\t\t}\n\t}\n}\n",
    "b057253b10925d31efe70b9b96fdeb78": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\tresult int\n\t\tpanic  bool\n\t}{\n\t\t{name: \"Sorted slice with v in between\", s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}, v: 3.5, result: 2, panic: false},\n\t\t{name: \"Sorted slice with v at first element\", s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}, v: 1.0, result: 0, panic: false},\n\t\t{name: \"Sorted slice with v at last element\", s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}, v: 5.0, result: 4, panic: false},\n\t\t{name: \"Unsorted slice should panic\", s: []float64{3.0, 2.0, 1.0}, v: 2.0, result: -1, panic: true},\n\t\t{name: \"Slice length less than 2 should panic\", s: []float64{3.0}, v: 2.0, result: -1, panic: true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, got panic: %v\", tt.panic, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tactual := Within(tt.s, tt.v)\n\n\t\t\tif actual != tt.result {\n\t\t\t\tt.Errorf(\"Expected index %v, got %v\", tt.result, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0f9a3504d61dd97d7d30c129c71d603": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0}, 2.5, 1},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0}, 0.5, -1},\n\t\t{\"Test case 3\", []float64{1.0, 1.5, 2.0, 2.5}, 2.0, -1},\n\t\t{\"Test case 4\", []float64{1.0, 2.0}, 1.5, 0},\n\t\t{\"Test case 5\", []float64{-2.0, -1.0, 0.0, 1.0, 2.0}, 0.0, 2},\n\t\t{\"Test case 6\", []float64{5.0, 5.0, 5.0}, 5.0, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b1237c007a154e7551e96e4abef395ac": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.8, 2},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 5.0, 3},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v and %v, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "b171a68a65a0482c47261417a55b4971": "package floats\n\nimport \"testing\"\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn, l, u, v, expected int\n\t}{\n\t\t{\"Test 1\", 5, 1, 9, 4, 0},\n\t\t{\"Test 2\", 7, 2, 8, 7, 6},\n\t\t{\"Test 3\", 4, 0, 10, 12, 3},\n\t\t{\"Test 4\", 3, 1, 3, 2, 1},\n\t\t{\"Test 5\", 6, -5, 5, -10, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b19603c719cd669e4b4e7417b1673a44": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/gonum/floats\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\texpects int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.5, -1},\n\t\t{[]float64{5, 4, 3, 2, 1}, 3.5, 2},\n\t\t{[]float64{1, 2, 2, 3, 4, 5}, 2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Within(test.s, test.v)\n\t\tif result != test.expects {\n\t\t\tt.Errorf(\"Expected index %d, but got %d for slice %v and value %f\", test.expects, result, test.s, test.v)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n",
    "b1c211d15e5b97db52c1164cf02ab259": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{5, 0.0, 10.0, 3.0, 0},\n\t\t{5, 0.0, 10.0, 7.2, 3},\n\t\t{5, -5.0, 5.0, 0.0, 2},\n\t\t{5, -5.0, 5.0, -10.0, 0},\n\t\t{5, -5.0, 5.0, 10.0, 4},\n\t\t{5, 3.0, 3.0, 3.0, 0},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif idx != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, idx)\n\t\t}\n\t}\n}\n",
    "b213bf54d996e0039fda47719746bfab": "// Package floats provides functions for float64 slices.\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{0.1, 0.2, 0.3}, 0.6},\n\t\t{[]float64{0.1, 0.2, -0.3}, 0.0},\n\t\t{[]float64{1.23456789, 2.3456789, 3.456789}, 7.03703579},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.Abs(result-test.expected) \u003e 1e-15 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}",
    "b24730c325c23f8e9cf5a440666a54cd": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your_package_name/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Span Test Case 1\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 5, 10, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span Test Case 2\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        5,\n\t\t\tu:        15,\n\t\t\texpected: []float64{5, 10, 15},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() - Expected: %v, but got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b247c18384f0d8daf42cbf9e1815e8cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname: \"Test 1\",\n\t\t\tinput: []float64{1.1, 2.2, 3.3, 4.4, 5.5},\n\t\t\texpected: 16.5,\n\t\t},\n\t\t{\n\t\t\tname: \"Test 2\",\n\t\t\tinput: []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname: \"Test 3\",\n\t\t\tinput: []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := SumCompensated(tc.input)\n\t\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b274b8c757536346f03da55ed0a60c98": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tlower  float64\n\t\tupper  float64\n\t\tval    float64\n\t\texpect int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t\t{4, 1.0, 4.0, 2.5, 1},\n\t\t{5, 0.0, 100.0, 55.0, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := floats.NearestIdxForSpan(tt.n, tt.lower, tt.upper, tt.val)\n\t\tif result != tt.expect {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to be %d, but got %d\", tt.n, tt.lower, tt.upper, tt.val, tt.expect, result)\n\t\t}\n\t}\n}\n",
    "b2b41c0984a6fc130569c29ce9ac8aed": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case for normal values\n\tdst := make([]float64, 5)\n\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tresult := Span(dst, 1.0, 5.0)\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %v but got %v\", expected, result)\n\t}\n\n\t// Test case for NaN\n\tdst = make([]float64, 5)\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\tresult = Span(dst, math.NaN(), 5.0)\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %v but got %v\", expected, result)\n\t}\n\n\t// Test case for Inf\n\tdst = make([]float64, 5)\n\texpected = []float64{1.0, 1.0, 1.0, 1.0, math.Inf(0)}\n\tresult = Span(dst, 1.0, math.Inf(0))\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %v but got %v\", expected, result)\n\t}\n\n\t// Test case for zero length dst (should panic)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 0), 1.0, 5.0)\n}",
    "b39b4e92d68ff04931e1f9c49dce0d52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632}, // L2 distance between [1,2,3] and [4,5,6]\n\t\t{[]float64{1, 1, 1}, []float64{4, 4, 4}, 1, 9},                // L1 distance between [1,1,1] and [4,4,4]\n\t\t{[]float64{2, 4, 6}, []float64{3, 5, 7}, math.Inf(1), 1},      // Infinity distance between [2,4,6] and [3,5,7]\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.301927248894626}, // L3 distance between [1,2,3] and [4,5,6]\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance between %v and %v with L=%f expected %f, but got %f\", test.s, test.t, test.L, test.expected, result)\n\t\t}\n\t}\n}",
    "b40f3129f28d9f1eeaeb9805d894b2d5": "func TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3}\n\tt1 := []float64{4, 5, 6}\n\tt2 := []float64{1, 2, 3}\n\n\toutput1 := Distance(s, t1, 2)\n\toutput2 := Distance(s, t2, 1)\n\n\tif output1 != math.Sqrt(27) {\n\t\tt.Errorf(\"Distance test case 1 failed, expected: %f, got: %f\", math.Sqrt(27), output1)\n\t}\n\n\tif output2 != 0 {\n\t\tt.Errorf(\"Distance test case 2 failed, expected: %f, got: %f\", 0.0, output2)\n\t}\n}",
    "b453eeefaf291a83ffcb9e4516aac460": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.3, 0},\n\t\t{3, 0.0, 1.0, 0.8, 2},\n\t\t{5, -10.0, 10.0, 5.5, 3},\n\t\t{4, 0.0, 0.0, 0.0, 0},\n\t\t{4, 1.0, -1.0, 0.5, 1},\n\t\t{5, -1.0, 1.0, -10.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n",
    "b4b092207079221ea52e0eecea53fb6f": "package floats\n\nimport (\n\t\"testing\"\n\t\"math\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tassert.Equal(t, test.expected, result)\n\t}\n}\n",
    "b517facd54cabc2f4032e18bd4d107cd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{2, 3, 4}, []float64{2, 6, 12}},\n\t\t{[]float64{0, 0, 0}, []float64{2, 3, 4}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 1, 1}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tMul(test.dst, test.s)\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, test.dst)\n\t\t}\n\t}\n}",
    "b62580acc0fe992fad3b01981ef69e94": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}, []float64{11, 13, 15}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8}, nil},\n\t\t{[]float64{1, 2}, []float64{4, 5, 6}, []float64{7, 8, 9}, nil},\n\t\t{[]float64{1}, []float64{4, 5, 6}, []float64{7, 8, 9}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := AddTo(test.dst, test.s, test.t)\n\t\tif !reflect.DeepEqual(got, test.want) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, got, test.want)\n\t\t}\n\t}\n}",
    "b62c0496f8758e4bda8819180b790391": "package floats\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 1, 0},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, math.Inf(1), 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}\n",
    "b7f2edbdc613f82d19b5b99c215ff5f3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/golang/example/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{}, 0, 10},\n\t\t{[]float64{0}, 0, 10},\n\t\t{[]float64{0, 10}, 0, 10},\n\t\t{[]float64{0, 5, 10}, 0, 10},\n\t\t{[]float64{100, 200, 300, 400}, 100, 400},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected %d points, got %d points\", len(test.dst), len(result))\n\t\t}\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"First element should be %f, got %f\", test.l, result[0])\n\t\t}\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Last element should be %f, got %f\", test.u, result[len(result)-1])\n\t\t}\n\t\tfor i := 1; i \u003c len(result)-1; i++ {\n\t\t\tif result[i] \u003c test.l || result[i] \u003e test.u {\n\t\t\t\tt.Errorf(\"Point %d is outside of range [%f, %f]: %f\", i, test.l, test.u, result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "b89f9f1089868798b9e02bcd5e68794b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{}, 1.0, 10.0}, // Test case with empty dst\n\t\t{[]float64{1.0}, 1.0, 10.0}, // Test case with dst of length 1\n\t\t{[]float64{1.0, 2.0}, 1.0, 10.0}, // Test case with dst of length 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 10.0}, // Test case with dst of length 3\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdst := tt.dst\n\t\t\tl := tt.l\n\t\t\tu := tt.u\n\n\t\t\tresult := floats.Span(dst, l, u)\n\n\t\t\t// Check that returned slice has the same length as dst\n\t\t\tif len(result) != len(dst) {\n\t\t\t\tt.Errorf(\"Expected result length: %d, but got %d\", len(dst), len(result))\n\t\t\t}\n\n\t\t\t// Check if the first element of result is l\n\t\t\tif result[0] != l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", l, result[0])\n\t\t\t}\n\n\t\t\t// Check if the last element of result is u\n\t\t\tif result[len(result)-1] != u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b8a05ba3a712e311a1d2e9009147f26b": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    5.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    0.5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.input, tt.value)\n\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b90b25d30caac34e602553815fe2c041": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test 1: Positive values\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test 2: Negative values\",\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\texpected: -15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test 3: Mix of positive and negative values\",\n\t\t\tinput:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\texpected: 3.0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(test.input)\n\t\t\tif !floatsEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"Expected sum: %v, but got: %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatsEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}\n\nfunc TestAllFloats(t *testing.T) {\n\tt.Run(\"TestSumCompensated\", TestSumCompensated)\n}",
    "ba6c5492461668b1361d8b51e520bf52": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst        []float64\n\t\tl          float64\n\t\tu          float64\n\t\texpected   []float64\n\t\tpanics     bool\n\t\tpanicsType reflect.Value\n\t}{\n\t\t{[]float64{}, 0, 1, nil, true, reflect.ValueOf(shortSpan)},\n\t\t{[]float64{0}, math.NaN(), 1, []float64{math.NaN()}, false, reflect.Value{}},\n\t\t{[]float64{0, 0}, 1, math.NaN(), []float64{1, math.NaN()}, false, reflect.Value{}},\n\t\t{[]float64{0, 0}, math.NaN(), math.Inf(-1), []float64{math.NaN(), math.Inf(-1)}, false, reflect.Value{}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}, false, reflect.Value{}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 2, []float64{math.Inf(1), 1, 2}, false, reflect.Value{}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif !tc.panics {\n\t\t\t\t\t\tt.Errorf(\"Expected not to panic, but panicked with: %v\", r)\n\t\t\t\t\t} else if !reflect.TypeOf(r).AssignableTo(tc.panicsType) {\n\t\t\t\t\t\tt.Errorf(\"Expected panic type %v; got %T\", tc.panicsType, r)\n\t\t\t\t\t}\n\t\t\t\t} else if tc.panics {\n\t\t\t\t\tt.Errorf(\"Expected panic, but did not\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd09c4b3139e4799017cb559fa235589": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/your-package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 0, 10, []float64{0, 2.5, 5, 7.5, 10}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -5, 5, []float64{-5, -2.5, 0, 2.5, 5}},\n\t\t{[]float64{10, 20, 30, 40}, 0, 50, []float64{0, 16.666666666666668, 33.333333333333336, 50}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\t\tfor i, val := range result {\n\t\t\tif val != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected: %v, but got: %v\", test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Include additional test cases as needed for different scenarios.",
    "bd0baf941d695935d5dc6dc476aff106": "// Package floats provides functions for float64 slices.\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 0},\n\t\t{4, 0.0, 10.0, 5.5, 2},\n\t\t{3, -10.0, 10.0, 5.0, 2},\n\t\t{5, -5.0, 5.0, 0.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For Span(%d, %f, %f, %f), expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "bdbac0eb9fce9bd1874ee7d0e7ca5d5a": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your_package_name/floats\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttestCases := []struct {\n\t\tdst    []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tresult: []float64{9, 12, 15},\n\t\t},\n\t\t{\n\t\t\tdst:    []float64{0.5, 0.5},\n\t\t\talpha:  -1,\n\t\t\ts:      []float64{1, 1},\n\t\t\tresult: []float64{-0.5, -0.5},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdstCopy := make([]float64, len(tc.dst))\n\t\tcopy(dstCopy, tc.dst)\n\n\t\tfloats.AddScaled(tc.dst, tc.alpha, tc.s)\n\n\t\tif !reflect.DeepEqual(tc.dst, tc.result) {\n\t\t\tt.Errorf(\"Expected result: %v, got: %v\", tc.result, tc.dst)\n\t\t}\n\n\t\tif len(tc.dst) != len(dstCopy) {\n\t\t\tt.Errorf(\"Expected length of dst: %d, got: %d\", len(dstCopy), len(tc.dst))\n\t\t}\n\t}\n}\n",
    "bf076eed918d7c3223f67e7e25518cf2": "// Package floats contains functions for operating on slices of float64.\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\"Equal slices\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{\"Different lengths\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{\"Different values\", []float64{1.0, 2.0}, []float64{1.0, 3.0}, false},\n\t\t{\"NaN values\", []float64{math.NaN()}, []float64{math.NaN()}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "bfda35f3c18a5baeca503393dbab6526": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tinputDst []float64\n\t\tinputL   float64\n\t\tinputU   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 3},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1},\n\t\t{[]float64{0, 0.5, 1}, 0, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, -2, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.inputDst, test.inputL, test.inputU)\n\n\t\tif len(result) != len(test.inputDst) {\n\t\t\tt.Errorf(\"Expected length of result to be %d, but got %d\", len(test.inputDst), len(result))\n\t\t}\n\n\t\tif result[0] != test.inputL {\n\t\t\tt.Errorf(\"Expected first element of result to be %f, but got %f\", test.inputL, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.inputU {\n\t\t\tt.Errorf(\"Expected last element of result to be %f, but got %f\", test.inputU, result[len(result)-1])\n\t\t}\n\t}\n}",
    "c0ec03dca8cd07a84c9284fb4860376c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn         int\n\t\tl, u, v   float64\n\t\texpected  int\n\t\tshouldPanic bool\n\t}{\n\t\t{2, 0.0, 1.0, 0.6, 1, false},\n\t\t{3, 0.0, 10.0, 5.5, 2, false},\n\t\t{5, 1.0, 5.0, 4.5, 3, false},\n\t\t{4, 0.0, 10.0, 6.5, 3, false},\n\t\t{2, 0.0, 10.0, 5.0, 1, false},\n\t\t{2, 5.0, 10.0, 7.5, 1, false},\n\t\t{3, 0.0, 10.0, 20.0, 2, false},\n\t\t{3, 10.0, 0.0, 5.0, 2, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.shouldPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(%v, %v, %v, %v), but did not panic\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, %v) to return %v, but got %v\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "c0edc28b0bb8ad039cd83dc2899be0c1": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tt.Parallel()\n\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Multiplying slices of equal length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts:   []float64{2.0, 3.0, 4.0},\n\t\t\t\tt:   []float64{3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: []float64{6.0, 12.0, 20.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Multiplying slices of different length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts:   []float64{2.0, 3.0, 4.0, 5.0},\n\t\t\t\tt:   []float64{3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c219c9759b2b913ab17a36a30c8a5282": "// Package floats provides ...\npackage floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2, 3}, {4, 5}, {7}}, false},\n\t\t{\"Single slice\", [][]float64{{1, 2, 3}}, true},\n\t\t{\"Two slices, equal lengths\", [][]float64{{1, 2}, {3, 4}}, true},\n\t\t{\"Two slices, different lengths\", [][]float64{{1, 2}, {3}}, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c245931e3d9384bd8814b85c1d7c28c5": "package floats\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Simple test case\",\n\t\t\tinput:    []float64{1.1, 2.2, 3.3, 4.4},\n\t\t\tvalue:    3.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value is NaN\",\n\t\t\tinput:    []float64{1.1, 2.2, 3.3, 4.4},\n\t\t\tvalue:    math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value is Inf\",\n\t\t\tinput:    []float64{1.1, 2.2, 3.3, 4.4},\n\t\t\tvalue:    math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\tvalue:    1.0,\n\t\t\texpected: -1, // expect panic\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 test.expected == -1 {\n\t\t\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := NearestIdx(test.input, test.value)\n\t\t\tassert.Equal(t, test.expected, result)\n\t\t})\n\t}\n}",
    "c319c9163393d0f1a232cc36990f80f8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        -5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{-5, 0, 5, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\tl:        2.5,\n\t\t\tu:        7.5,\n\t\t\texpected: []float64{2.5, 7.5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c36fad062905512cad6644b00bea6fb9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 4.5, 2},\n\t\t{5, 0, 10, 11, 4},\n\t\t{5, 0, 10, -1, 0},\n\t\t{3, 0, 10, 5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "c424d8a35f7c8b05e45733b34ada50f6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"Middle of Range\", 5, 0, 10, 4, 2},\n\t\t{\"Lower Bound\", 5, 0, 10, 0, 0},\n\t\t{\"Upper Bound\", 5, 0, 10, 10, 4},\n\t\t{\"Value Less than Lower Bound\", 5, 0, 10, -5, 0},\n\t\t{\"Even Number of Points\", 4, 0, 10, 5, 2},\n\t\t{\"Negative Lower Bound\", 4, -10, 10, 5, 3},\n\t\t{\"Negative Upper Bound\", 4, -10, -1, -5, 3},\n\t\t{\"Value in Between Lower and Upper Bound\", 5, 0, 10, 7, 3},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "c4347345bb3b757aabbc440dd959adf5": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected int\n\t}{\n\t\t{name: \"Test case 1\", input: []float64{1.0, 2.0, 3.0, 2.0, 1.0}, expected: 2},\n\t\t{name: \"Test case 2\", input: []float64{5.0, 4.0, 3.0, 2.0, 1.0}, expected: 0},\n\t\t{name: \"Test case 3\", input: []float64{1.0, 1.0, 1.0, 1.0, 1.0}, expected: 0},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"For %v, expected %d, but got %d\", tc.input, tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c44e095c6325fd9ca41dd7c3957a9234": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  [][]float64\n\t\toutput bool\n\t}{\n\t\t{\"All slices have equal length\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Some slices have different length\", [][]float64{{1}, {4, 5, 6}, {7, 8, 9}}, false},\n\t\t{\"No input slices\", [][]float64{}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tt.input...)\n\t\t\tif result != tt.output {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.output, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c50cc8843b4580e570dbf84f66a3386f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases for Find function\n\ttests := []struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t\twant []int\n\t}{\n\t\t// Test case 1\n\t\t{\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\ts:    []float64{1, -2, 3, -4, 5, -6},\n\t\t\tk:    3,\n\t\t\twant: []int{0, 2, 4},\n\t\t},\n\t\t// Test case 2\n\t\t{\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x \u003c 0 },\n\t\t\ts:    []float64{1, -2, 3, -4, 5, -6},\n\t\t\tk:    -1,\n\t\t\twant: []int{1, 3, 5},\n\t\t},\n\t\t// Test case 3\n\t\t{\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x == 0 },\n\t\t\ts:    []float64{1, -2, 3, -4, 5, 0},\n\t\t\tk:    2,\n\t\t\twant: []int{5},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tgot, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Find returned an unexpected error: %v\", err)\n\t\t}\n\n\t\tif len(got) != len(tc.want) {\n\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) = %v, want %v\", tc.inds, tc.f, tc.s, tc.k, got, tc.want)\n\t\t} else {\n\t\t\tfor i := 0; i \u003c len(got); i++ {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) = %v, want %v\", tc.inds, tc.f, tc.s, tc.k, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "c5390b0747a0390f595f5a93fd3be797": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 2, []float64{1, 1.5, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 15}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -10, 10, []float64{-10, -5, 0, 5, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c63de35547795507c7e26f34c81f2123": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\tcases := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{5, 3, 1}, []float64{2, 2, 2}},\n\t}\n\n\tfor _, tc := range cases {\n\t\tdstCopy := make([]float64, len(tc.dst))\n\t\tcopy(dstCopy, tc.dst)\n\n\t\tSub(tc.dst, tc.s)\n\n\t\tfor i := 0; i \u003c len(tc.dst); i++ {\n\t\t\texpected := dstCopy[i] - tc.s[i]\n\t\t\tif tc.dst[i] != expected {\n\t\t\t\tt.Errorf(\"Subtraction incorrect at index %d. Expected %f, got %f\", i, expected, tc.dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "c66f332326724bc488067fc1ae2dee45": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0}, 1.0, 2.0, []float64{1.0}},\n\t\t{[]float64{0, 0}, 0.0, 0.0, []float64{0.0, 0.0}},\n\t\t{[]float64{0, 0, 0}, -1.0, 1.0, []float64{0.0, 0.0, 0.0}},\n\t\t{[]float64{0, 0, 0, 0}, 1.0, 3.0, []float64{2.718281828459045}},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := LogSpan(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(got, test.want) {\n\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, got, test.want)\n\t\t}\n\t}\n}",
    "c67238fc1cdc7f32abd6e8a9759afd8f": "/*** \nTest file for Span function in floats package\n*/\n\npackage floats\n\nimport (\n\t\"testing\"\n\t\"reflect\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1.0, 5.0, []float64{1.0, 3.0, 5.0}},\n\t\t{[]float64{0, 0, 0, 0}, 0.0, 10.0, []float64{0.0, 3.3333333333333335, 6.666666666666667, 10.0}},\n\t\t{[]float64{0, 0, 0}, 2.0, 2.0, []float64{2.0, 2.0, 2.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(got, test.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, got, test.want)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed.",
    "c68f0eeab1152e158103052b21dc3f6f": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your_package_name/floats\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tout []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 5, 6}},\n\t\t{[]float64{10, 20, 30}, []float64{1, 2, 3}, []float64{1, 2, 3}},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 1, 1, 1}, []float64{1, 1, 1, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tfloats.Mul(test.dst, test.s)\n\t\tif !reflect.DeepEqual(test.dst, test.out) {\n\t\t\tt.Errorf(\"Expected result: %v, got: %v\", test.out, test.dst)\n\t\t}\n\t}\n}",
    "c6e905e1ad53e35ccd01273d9f1d7878": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{4, 0, 10, 5, 2},\n\t\t{3, 0, 7, 3, 1},\n\t\t{5, -10, 10, -5, 0},\n\t\t{5, -10, 10, 5, 4},\n\t\t{6, -10, 10, 0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tassert.Equal(t, test.result, result)\n\t}\n}",
    "c70bd4226e4382659ab756194d226ddb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tslice []float64\n\t\tvalue float64\n\t\tindex int\n\t}{\n\t\t{\n\t\t\tname:  \"Value within slice range\",\n\t\t\tslice: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tvalue: 2.5,\n\t\t\tindex: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Value less than first element\",\n\t\t\tslice: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tvalue: 0.5,\n\t\t\tindex: -1,\n\t\t},\n\t\t{\n\t\t\tname:  \"Value greater than last element\",\n\t\t\tslice: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tvalue: 5.0,\n\t\t\tindex: -1,\n\t\t},\n\t\t{\n\t\t\tname:  \"Empty slice\",\n\t\t\tslice: []float64{},\n\t\t\tvalue: 2.5,\n\t\t\tindex: -1,\n\t\t},\n\t\t{\n\t\t\tname:  \"Unsorted slice\",\n\t\t\tslice: []float64{4.0, 3.0, 2.0, 1.0},\n\t\t\tvalue: 2.5,\n\t\t\tindex: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tindex := floats.Within(tc.slice, tc.value)\n\t\t\tif index != tc.index {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tc.index, index)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c84004bbf3a69183c622f48e660f5b13": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\t\"Test case 1\",\n\t\t\t[]float64{1, 2, 3},\n\t\t\t[]float64{4, 5, 6},\n\t\t\t2,\n\t\t\t5.196152422706632,\n\t\t},\n\t\t{\n\t\t\t\"Test case 2\",\n\t\t\t[]float64{0, 0, 0},\n\t\t\t[]float64{1, 1, 1},\n\t\t\t1,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t\"Test case 3\",\n\t\t\t[]float64{3, 4},\n\t\t\t[]float64{0, 0},\n\t\t\t3,\n\t\t\t5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %v, but got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c9072aa3fc2774f4553a579a976d9871": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twantErr bool\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 5, false},\n\t\t{[]float64{1}, 1, 5, true},\n\t\t{[]float64{1, 2, 3}, 1, 1, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantErr {\n\t\t\tif !panics(func() { Span(tt.dst, tt.l, tt.u) }) {\n\t\t\t\tt.Errorf(\"Expected panic but function returned normally\")\n\t\t\t}\n\t\t} else {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(got) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected length of %d, but got %d\", len(tt.dst), len(got))\n\t\t\t}\n\n\t\t\tfor i, v := range got {\n\t\t\t\tif v != tt.dst[i] {\n\t\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", tt.dst[i], i, v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc panics(f func()) (panicked bool) {\n\tdefer func() {\n\t\tif recover() != nil {\n\t\t\tpanicked = true\n\t\t}\n\t}()\n\tf()\n\treturn\n}\n",
    "c9a488ed3661683813cdc9acf0983fe4": "// Package floats provides mathematical functions for float64 slices.\npackage floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 0, 10, []float64{0, 2.5, 5, 7.5, 10}},\n\t\t{[]float64{0, 0, 0}, -10, 10, []float64{-10, 0, 10}},\n\t\t{[]float64{}, 0, 10, []float64{}}, // Panics due to length \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"expected panic, got nil\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t})\n\n\t\tif !reflect.DeepEqual(Span(make([]float64, len(tt.want)), tt.l, tt.u), tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, Span(tt.dst, tt.l, tt.u), tt.want)\n\t\t}\n\t}\n}",
    "ca0939efcf7f3a8da4f08dbb68580e05": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestSame(t *testing.T) {\n\tt.Run(\"slices with same length and same values\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tt := []float64{1.0, 2.0, 3.0}\n\n\t\tresult := floats.Same(s, t)\n\n\t\tif !result {\n\t\t\tt.Error(\"Expected true, got false\")\n\t\t}\n\t})\n\n\tt.Run(\"slices with same length but different values\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tt := []float64{4.0, 5.0, 6.0}\n\n\t\tresult := floats.Same(s, t)\n\n\t\tif result {\n\t\t\tt.Error(\"Expected false, got true\")\n\t\t}\n\t})\n\n\tt.Run(\"slices with different lengths\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0}\n\t\tt := []float64{1.0, 2.0, 3.0}\n\n\t\tresult := floats.Same(s, t)\n\n\t\tif result {\n\t\t\tt.Error(\"Expected false, got true\")\n\t\t}\n\t})\n\n\tt.Run(\"slices with NaN values treated as equal\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, float64(NaN)}\n\t\tt := []float64{1.0, 2.0, float64(NaN)}\n\n\t\tresult := floats.Same(s, t)\n\n\t\tif !result {\n\t\t\tt.Error(\"Expected true, got false\")\n\t\t}\n\t})\n}\n",
    "ca5c8d4320f117c218de35798e287ba6": "// File: nearest_idx_for_span_test.go\n\npackage floats\n\nimport \"testing\"\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn                   int\n\t\tl, u, v             float64\n\t\texpectedNearestIdx  int\n\t}{\n\t\t{3, 0.0, 1.0, 0.6, 1},\n\t\t{4, -1.0, 1.0, 0.5, 2},\n\t\t{5, 0.0, 10.0, 7.5, 3},\n\t\t{2, 0.0, 1.0, 0.5, 0},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif actual != test.expectedNearestIdx {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, actual, test.expectedNearestIdx)\n\t\t}\n\t}\n}",
    "cad7b02fd7a43024f9e31aaa000ba4d7": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{2, 1.0, 5.0, 3.0, 1}, // Basic test case\n\t\t{3, 2.0, 6.0, 5.0, 2}, // Basic test case\n\t\t{5, 0.0, 10.0, 5.5, 3}, // Value closest to the middle\n\t\t{4, 0.0, 5.0, -1.0, 0}, // v below l, pick the first index\n\t\t{3, -3.0, -2.0, -1.5, 1}, // v in between l and u\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}\n",
    "cb2f4ecce6f8ce30d05a1cb5dedc4149": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"sorted slice with v inside the range\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tv:    3,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice with v equal to the first element\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice with v equal to the last element\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice with v outside the range\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tv:    6,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice, should panic\",\n\t\t\ts:    []float64{5, 4, 3, 2, 1},\n\t\t\tv:    3,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice, should panic\",\n\t\t\ts:    []float64{},\n\t\t\tv:    3,\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif got := floats.Within(tt.s, tt.v); got != tt.want {\n\t\t\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tfloats.Within(tt.s, tt.v)\n\t\t})\n\t}\n}",
    "cb50929c3d31ad17a3f460bf88000ad7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test Case 1\", []float64{1.1, 2.2, 3.3}, 6.6},\n\t\t{\"Test Case 2\", []float64{0.1, 0.2, 0.3, 0.4}, 1.0},\n\t\t{\"Test Case 3\", []float64{3.14159, 2.71828}, 5.85987},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif math.Abs(result-tc.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb535218c3f70cf84aad141358af65fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0.5, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) expected: %v, result: %v\", test.s, test.t, test.L, test.expected, result)\n\t\t}\n\t}\n}",
    "cba9f4ddaeffe47ca5b276cb857f5a91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{\n\t\t\tname:   \"Test case 1\",\n\t\t\ts:      []float64{1, 2, 3, 4, 5},\n\t\t\tL:      2,\n\t\t\tresult: math.Sqrt(55),\n\t\t},\n\t\t{\n\t\t\tname:   \"Test case 2\",\n\t\t\ts:      []float64{-2, -4, -6},\n\t\t\tL:      1,\n\t\t\tresult: 12,\n\t\t},\n\t\t{\n\t\t\tname:   \"Test case 3\",\n\t\t\ts:      []float64{3, -4, 5, -6},\n\t\t\tL:      math.Inf(1),\n\t\t\tresult: 6,\n\t\t},\n\t\t{\n\t\t\tname:   \"Test case 4\",\n\t\t\ts:      []float64{2.5, 3.5},\n\t\t\tL:      3,\n\t\t\tresult: math.Pow(61.25, 1.0/3),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\toutput := Norm(tt.s, tt.L)\n\t\t\tif output != tt.result {\n\t\t\t\tt.Errorf(\"Expected: %f, Got: %f\", tt.result, output)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cbb8d4e698be7f05734f9a6261da1335": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0, 0}, 1, 5, []float64{1, 2, 3, 5}},\n\t\t{[]float64{0, 0, 0, 0}, -5, 5, []float64{-5, 0, 5, 5}},\n\t\t{[]float64{0, 0, 0, 0}, -5, -1, []float64{-5, -4, -3, -1}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := floats.Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd1af6b4b2cac1a9911a1fa1e5f63565": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t. \"your-module/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{4, 1.0, 5.0, 2.5, 1},\n\t\t{5, 2.0, 6.0, 3.5, 1},\n\t\t{6, 1.0, 7.0, 3.0, 1},\n\t\t{4, 3.0, 5.0, 2.5, 0},\n\t\t{5, math.NaN(), 6.0, 3.5, 0},\n\t\t{6, 1.0, math.Inf(0), 3.0, 5},\n\t\t{6, math.Inf(-1), 2.0, 1.5, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tindex := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif index != tt.index {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %.1f, %.1f, %.1f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, index, tt.index)\n\t\t}\n\t}\n\n\t// Add more test cases as needed\n}\n",
    "cd2551357bf5a4761b1d93b27199cd8e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty Slice\", []float64{}, 0.0},\n\t\t{\"Single Element\", []float64{5.0}, 5.0},\n\t\t{\"Multiple Elements\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"Negative Numbers\", []float64{-1.0, -2.0, -3.0, -4.0, -5.0}, -15.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "cd59b1cd0bb3ec2ddb479fb44184b611": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: 3.3019272488946263,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "cdbdf12b54f31cf75f3fe8b5f104b1b6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 2, 4, []float64{2, 3, 4}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 10, []float64{0, 2.5, 5, 7.5, 10}},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, -5, 5, []float64{-5, -3.3333333333333335, -1.6666666666666667, 0, 1.6666666666666665, 3.333333333333333}},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cec8ccef0f30afa2aa52c89fdd1aaf3a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2, 7.416198487095663},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{1, 2, 3, 4, 5}, floats.Inf(1), 5},\n\t\t{[]float64{}, 2, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := floats.Norm(tc.s, tc.L)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"Expected Norm(%v, %v) to be %v, but got %v\", tc.s, tc.L, tc.expected, result)\n\t\t}\n\t}\n}\n",
    "ced77cd244892a4bc6b7d487dd1b6d4a": "func TestScaleTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1.0, 2.0, 3.0}\n\tc := 2.0\n\n\texpected := []float64{2.0, 4.0, 6.0}\n\n\tresult := ScaleTo(dst, c, s)\n\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"ScaleTo did not scale elements correctly. Expected: %v, Got: %v\", expected, result)\n\t}\n}",
    "cee9aea2c702fc18ba210f59a68d56ab": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span valid test case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf bounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, math.Inf(1), 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with unequal bounds\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    7,\n\t\t\twant: []float64{0, 3.5, 7},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cf3d2ac834f186c8f0097e850e7bbbbe": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tslice1  []float64\n\t\tslice2  []float64\n\t\tequal   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal slices\",\n\t\t\tslice1: []float64{1.0, 2.0, 3.0},\n\t\t\tslice2: []float64{1.0, 2.0, 3.0},\n\t\t\tequal:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths\",\n\t\t\tslice1: []float64{1.0, 2.0, 3.0},\n\t\t\tslice2: []float64{1.0, 2.0},\n\t\t\tequal:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different values\",\n\t\t\tslice1: []float64{1.0, 2.0, 3.0},\n\t\t\tslice2: []float64{1.0, 2.0, 4.0},\n\t\t\tequal:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.slice1, tt.slice2, func(a, b float64) bool {\n\t\t\t\treturn a == b\n\t\t\t})\n\t\t\tif result != tt.equal {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.equal, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfbb4651815b01c03980fee9bcea668b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"your-module-path/floats\" // Assuming \"your-module-path\" is the actual module path\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{3, 1.0, 5.0, 3.0, 1},\n\t\t{4, 2.0, 6.0, 1.5, 0},\n\t\t{5, 1.0, 10.0, 7.5, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "cfc03b5acebd84a7b4d5789bde286391": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your_module_path/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\tresult []int\n\t\terr    error\n\t}{\n\t\t{\n\t\t\tname:   \"Find all elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return true },\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tk:      -1,\n\t\t\tresult: []int{0, 1, 2, 3},\n\t\t\terr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Find first 2 elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x \u003e 2.0 },\n\t\t\ts:      []float64{1.0, 3.0, 5.0, 2.0},\n\t\t\tk:      2,\n\t\t\tresult: []int{1, 2},\n\t\t\terr:    nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Not enough elements found\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x \u003c 0 },\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tk:      2,\n\t\t\tresult: []int{},\n\t\t\terr:    errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinds, err := floats.Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(inds, tt.result) {\n\t\t\t\tt.Errorf(\"Find() expected %v, got %v\", tt.result, inds)\n\t\t\t}\n\t\t\tif (err != nil \u0026\u0026 tt.err == nil) || (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Find() expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d00820bb1a4bd89672dcb2c82326bc12": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},\n\t\t{[]float64{1.5, 2.5, 3.5}, []float64{2, 2, 2}, []float64{3, 5, 7}},\n\t\t{[]float64{0, 0, 0}, []float64{10, 20, 30}, []float64{0, 0, 0}},\n\t}\n\tfor _, tt := range tests {\n\t\tinitialDst := make([]float64, len(tt.dst))\n\t\tcopy(initialDst, tt.dst)\n\t\tMul(tt.dst, tt.s)\n\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\tt.Errorf(\"Mul(%v, %v): got %v, want %v\", initialDst, tt.s, tt.dst, tt.want)\n\t\t}\n\t}\n}",
    "d03fbbedb07ba59353ee3aa2469554c4": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t},\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3, -4, -5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t},\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return true },\n\t\t\ts:        []float64{},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tresult, err := Find(test.inds, test.f, test.s, test.k)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v but got %v\", i+1, test.expected, result)\n\t\t}\n\t\tif err != nil \u0026\u0026 len(test.expected) \u003e 0 {\n\t\t\tt.Errorf(\"Test case %d failed: error unexpected\", i+1)\n\t\t}\n\t}\n}",
    "d0618cf3772a1cbdb3f414697491934f": "func TestFind(t *testing.T) {\n\tinds := make([]int, 0)\n\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"k = -1\",\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"k = 2\",\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"k = 3\",\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4},\n\t\t\tk:        3,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"k = 2 with insufficient elements\",\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(inds, tt.f, tt.s, tt.k)\n\n\t\t\tif err != nil {\n\t\t\t\tif tt.k \u003e 0 \u0026\u0026 len(tt.expected) \u003c tt.k {\n\t\t\t\t\tassert.Equal(t, err.Error(), \"floats: insufficient elements found\")\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.ElementsMatch(t, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n```",
    "d1ae84045c77da5ac561a7f186238cb5": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 2, 1, 0},\n\t\t{3, 0, 3, 2, 1},\n\t\t{4, 1, 4, 0, 1},\n\t\t{5, 1, 5, 2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif idx != test.result {\n\t\t\tt.Errorf(\"Expected index %d for values n=%d, l=%f, u=%f, v=%f, but got %d\", test.result, test.n, test.l, test.u, test.v, idx)\n\t\t}\n\t}\n}",
    "d1e51f3ebef2601345a50316d8222b28": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.551267201643578},\n\t\t{[]float64{10, 10, 10}, 10.217983651053429},\n\t\t{[]float64{0, 0, 0}, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := LogSumExp(tc.input)\n\t\tif !approx(result, tc.expected, 1e-14) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n\n\t// Test case for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic with empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// approx checks if two float64 values are approximately equal within a tolerance\nfunc approx(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}\n",
    "d21d94f17836ef34ef6e24fe8f5c1794": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tinput  [][]float64\n\t\toutput bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tinput:  [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\toutput: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal lengths\",\n\t\t\tinput:  [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}},\n\t\t\toutput: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tinput:  [][]float64{},\n\t\t\toutput: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.input...)\n\t\t\tif result != tc.output {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tc.output, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d2d4683e15ed6c7820e9cc788de1ae6c": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif err != nil {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.ElementsMatch(t, tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d3f731fcec5e030b686db890c77b0152": "package floats\n\nimport \"testing\"\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"Test case 1\", []float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{\"Test case 2\", []float64{5, 4, 3, 2, 1}, 4.5, 1},\n\t\t{\"Test case 3\", []float64{10, 20, 30, 40, 50}, 25, 1},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d472e2d93552a6c0dda8754ae8121fc6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twantErr bool\n\t}{\n\t\t{[]float64{1, 2, 3}, 0, 10, false},\n\t\t{[]float64{1}, 0, 10, true},\n\t\t{[]float64{1, 2, 3}, 0, 0, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantErr %v\", r, tt.wantErr)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(got) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"len(Span) = %v, want %v\", len(got), len(tt.dst))\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d54d5f470d5f7010a1f68fb43aacbcd4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t. \"your-module-path/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{5, 0.0, 10.0, 7.0, 3},\n\t\t{3, 1.0, 5.0, 4.0, 2},\n\t\t{5, 2.0, 8.0, 3.0, 0},\n\t\t{4, -10.0, 10.0, 0.0, 2},\n\t\t{6, -3.0, 3.0, 5.0, 5},\n\t\t{2, 0.0, 10.0, 7.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\n\t\tif index != test.index {\n\t\t\tt.Errorf(\"For Span(%d, %.2f, %.2f) and value %.2f, expected index %d but got %d\", test.n, test.l, test.u, test.v, test.index, index)\n\t\t}\n\t}\n}",
    "d54f36e019297f6ad65085cc8a881991": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\ttol  float64\n\t\twant bool\n\t}{\n\t\t{\"Equal slices within tolerance\", []float64{1.0, 2.0, 3.0}, []float64{1.01, 1.99, 3.0}, 0.02, true},\n\t\t{\"Equal slices exactly\", []float64{4.0, 5.0}, []float64{4.0, 5.0}, 0.0, true},\n\t\t{\"Slices of different lengths\", []float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, 0.01, false},\n\t\t{\"Slices not equal within tolerance\", []float64{1.0, 2.0}, []float64{1.0, 2.2}, 0.1, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := floats.EqualApprox(tt.s1, tt.s2, tt.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d7391925b9ae35074c2ad1cdf8cee8b0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tslice1 []float64\n\t\tslice2 []float64\n\t\texpected bool\n\t}{\n\t\t{name: \"Equal slices\",\n\t\t\tslice1: []float64{1.0, 2.0, 3.0},\n\t\t\tslice2: []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{name: \"Different lengths\",\n\t\t\tslice1: []float64{1.0, 2.0, 3.0},\n\t\t\tslice2: []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{name: \"Different values\",\n\t\t\tslice1: []float64{1.0, 2.0, 3.0},\n\t\t\tslice2: []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Equal(test.slice1, test.slice2)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d799b91a3bd21a0eb9863753a3943661": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tlower float64\n\t\tupper float64\n\t\tvalue float64\n\t\twant  int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{4, 0, 10, 12, 3},\n\t\t{3, 0, 10, -5, 0},\n\t\t{2, 0, 10, 7, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := NearestIdxForSpan(tt.n, tt.lower, tt.upper, tt.value)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.lower, tt.upper, tt.value, got, tt.want)\n\t\t}\n\t}\n}",
    "d7b6ea6bd6829ec9f86229042aa6cc5b": "package floats\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 1},\n\t\t{3, 0.0, 10.0, 5.5, 2},\n\t\t{5, -5.0, 5.0, 2.5, 4},\n\t\t{4, -4.0, 4.0, -5.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tassert.Equal(t, test.expected, result)\n\t}\n}",
    "d8099fc547bc3e0cba409e34e0be5d49": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3}, 1, 3},\n\t\t{[]float64{0, 1, 2, 3}, 0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\t// Check if the length of the result matches the length of dst\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %d, but got length of %d\", len(test.dst), len(result))\n\t\t}\n\n\t\t// Check if the first element is l and the last element is u\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", test.l, result[0])\n\t\t}\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}",
    "d91536c4291955fa1cb968ab179e0f7a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t\t{5, 1.0, 5.0, 3.0, 1},\n\t\t{4, 0.0, 10.0, 15.0, 3},\n\t\t{3, 0.0, 0.0, 5.0, 0},\n\t\t{3, 5.0, 0.0, 2.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "d9c055ec104c56718a9f735546ef9f34": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{n: 5, l: 0, u: 10, v: 7, result: 3},\n\t\t{n: 3, l: -5, u: 5, v: 3, result: 2},\n\t\t{n: 4, l: -10, u: 0, v: -5, result: 2},\n\t\t{n: 6, l: 10, u: 20, v: 22, result: 5},\n\t\t{n: 8, l: -20, u: -10, v: -5, result: 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif index != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected index %d but got %d\", test.n, test.l, test.u, test.v, test.result, index)\n\t\t}\n\t}\n}",
    "db0efa97eac5aa38beace3d862c72995": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Normal Case\", 5, 1.0, 10.0, 5.5, 2},\n\t\t{\"n less than 2\", 1, 1.0, 10.0, 5.5, 0},\n\t\t{\"v is NaN\", 4, 1.0, 10.0, math.NaN(), 0},\n\t\t{\"l is NaN\", 4, math.NaN(), 10.0, 5.5, 3},\n\t\t{\"u is NaN\", 4, 1.0, math.NaN(), 5.5, 0},\n\t\t{\"l = u = Inf\", 5, math.Inf(0), math.Inf(0), 5.5, 2},\n\t\t{\"l = Inf\", 4, math.Inf(0), 10.0, 15.0, 0},\n\t\t{\"u = Inf\", 4, 1.0, math.Inf(0), 5.0, 3},\n\t\t{\"v = -Inf\", 4, 1.0, 10.0, math.Inf(-1), 3},\n\t\t{\"v = +Inf\", 4, 1.0, 10.0, math.Inf(1), 0},\n\t\t{\"v outside (l, u)\", 4, 1.0, 10.0, 15.0, 3},\n\t\t{\"v outside (u, l)\", 4, 10.0, 1.0, 0.5, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "dc0c51f114dd31f4e8df118530ca14e5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"Test1\", 5, 0, 10, 4, 1},\n\t\t{\"Test2\", 7, 1, 8, 2, 1},\n\t\t{\"Test3\", 10, -5, 5, -3.5, 0},\n\t\t{\"Test4\", 6, -3, 3, -2, 1},\n\t\t{\"Test5\", 8, -10, 100, 50, 5},\n\t}\n\t\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Add more test cases as needed\nfunc TestMoreCasesNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Add more test cases here\n\t}\n\t\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc352efe1934cd3627e87fc74681474a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 0},\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := floats.MaxIdx(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"Expected Max Index of %v to be %d, but got %d\", tc.input, tc.expected, result)\n\t\t}\n\t}\n}",
    "dcd2c202fca790496c6f66029cca00a0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{1.1, 2.1, 3.1, 4.1, 5.1}, 1.1, 5.1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %v, but got %v\", len(test.dst), len(result))\n\t\t}\n\t\tfor i := 0; i \u003c len(result); i++ {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %v, but got %v\", test.dst[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "dcfe3ecfae6fa288d7bcd0d33508722c": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttolerance := 1e-8\n\n\t// Test case 1\n\tdst1 := make([]float64, 5)\n\tl1 := 0.0\n\tu1 := 1.0\n\texpected1 := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tresult1 := Span(dst1, l1, u1)\n\tif !reflect.DeepEqual(result1, expected1) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected1, result1)\n\t}\n\n\t// Test case 2\n\tdst2 := make([]float64, 4)\n\tl2 := -2.0\n\tu2 := 2.0\n\texpected2 := []float64{-2.0, 0.0, 2.0, 4.0}\n\tresult2 := Span(dst2, l2, u2)\n\tif !reflect.DeepEqual(result2, expected2) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected2, result2)\n\t}\n\n\t// Test case 3 (panic case)\n\tdst3 := make([]float64, 1)\n\tl3 := 0.0\n\tu3 := 1.0\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic with insufficient length of destination slice\")\n\t\t}\n\t}()\n\tSpan(dst3, l3, u3)\n\n\t// Test case 4 (special case for NaN)\n\tdst4 := make([]float64, 5)\n\tl4 := math.NaN()\n\tu4 := 2.0\n\texpected4 := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 2.0}\n\tresult4 := Span(dst4, l4, u4)\n\tif !reflect.DeepEqual(result4, expected4) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected4, result4)\n\t}\n\n\t// Test case 5 (special case for Inf)\n\tdst5 := make([]float64, 6)\n\tl5 := math.Inf(1)\n\tu5 := math.Inf(-1)\n\texpected5 := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\tresult5 := Span(dst5, l5, u5)\n\tif !reflect.DeepEqual(result5, expected5) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected5, result5)\n\t}\n\n\t// Test case 6 (special case for negative Inf)\n\tdst6 := make([]float64, 3)\n\tl6 := math.Inf(-1)\n\tu6 := 5.0\n\texpected6 := []float64{math.Inf(-1), math.Inf(-1), 5.0}\n\tresult6 := Span(dst6, l6, u6)\n\tif !reflect.DeepEqual(result6, expected6) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected6, result6)\n\t}\n}",
    "de0f41c026a90025ceeee7a8b47d9b51": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\" // Update with the correct path\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v, expected int\n\t}{\n\t\t{5, 1, 10, 7, 3},\t\t// Middle value\n\t\t{4, 3, 8, 10, 3},\t\t// v \u003e u\n\t\t{3, -5, 0, -10, 2},\t// v \u003c l\n\t\t{5, 5, 5, 5, 0},\t\t// l == u == v\n\t\t{2, 10, 20, 15, 1},\t// Only two elements\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, float64(test.l), float64(test.u), float64(test.v))\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n = %d, l = %d, u = %d, v = %d, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "df7fb887ea18e4ff6789fa276836ed07": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Normal case\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tdst:      []float64{},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Special case with NaN\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Special case with Inf\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{-math.Inf(1), 0, math.Inf(1)},\n\t\t},\n\t\t// Add more test cases here if needed\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span() failed, expected %v but got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0511d81fad1093714fcf21a2a02a933": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"EmptySlice\", []float64{}, 1.0},\n\t\t{\"MultipleElements\", []float64{1.0, 2.0, 3.0, 4.0}, 24.0},\n\t\t{\"SingleElement\", []float64{5.0}, 5.0},\n\t\t{\"ZeroElement\", []float64{0.0}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v, want %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0de08f91bb8621093aea8a6f6895828": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tinds []int\n\t}{\n\t\t{\"Test1\", []float64{3, 2, 1}, []int{0, 1, 2}},\n\t\t{\"Test2\", []float64{5, 1, 4, 2, 3}, []int{0, 1, 2, 3, 4}},\n\t\t{\"Test3\", []float64{1, 2, 3, 4, 5}, []int{0, 1, 2, 3, 4}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\torigDst := make([]float64, len(tt.dst))\n\t\t\tcopy(origDst, tt.dst)\n\n\t\t\tArgsort(tt.dst, tt.inds)\n\n\t\t\t// Check if length is maintained\n\t\t\tif len(tt.dst) != len(origDst) {\n\t\t\t\tt.Errorf(\"Length mismatch. Expected: %d, Got: %d\", len(origDst), len(tt.dst))\n\t\t\t}\n\n\t\t\t// Check if indices are correctly sorted\n\t\t\tsorted := true\n\t\t\tfor i := 1; i \u003c len(tt.dst); i++ {\n\t\t\t\tif tt.dst[i-1] \u003e tt.dst[i] {\n\t\t\t\t\tsorted = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !sorted {\n\t\t\t\tt.Errorf(\"Destination slice not sorted\")\n\t\t\t}\n\n\t\t\t// Check if inds track original elements\n\t\t\tfor i := range tt.dst {\n\t\t\t\tif tt.dst[i] != origDst[tt.inds[i]] {\n\t\t\t\t\tt.Errorf(\"Original element tracking failed\")\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for panic if lengths do not match\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tArgsort(tt.dst, []int{1, 2, 3}) // Length mismatch should cause panic\n\t\t})\n\t}\n}",
    "e23f0499b54dde9b7d452678e119f319": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t. \"github.com/yourusername/yourrepository/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{4, 1.0, 5.0, 2.5, 1},\n\t\t{3, 2.0, 4.0, 3.2, 2},\n\t\t{5, -1.0, 1.0, 0.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif actual != test.result {\n\t\t\tt.Errorf(\"For n = %d, l = %f, u = %f, v = %f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.result, actual)\n\t\t}\n\t}\n\n\t// Additional edge case tests\n\tif NearestIdxForSpan(2, 1.0, 5.0, 2.5) != 1 {\n\t\tt.Error(\"Expected panic for n less than 2\")\n\t}\n\n\tif NearestIdxForSpan(5, math.NaN(), 5.0, 3.0) != 0 {\n\t\tt.Error(\"Expected result 0 for NaN lower bound\")\n\t}\n}\n",
    "e25ace83e9153cf53faa9bc86e8579de": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{n: 2, l: 1.0, u: 5.0, v: 3.0, expected: 1},\n\t\t{n: 3, l: 2.0, u: 4.0, v: 5.0, expected: 2},\n\t\t{n: 4, l: 0.0, u: 10.0, v: -5.0, expected: 0},\n\t\t{n: 5, l: -3.0, u: 3.0, v: 2.0, expected: 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%.1f, u=%.1f, v=%.1f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "e36e2d6500656f6ab7d05eebfb5207f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{\"Normal Case\", []float64{1, 2, 3, 4, 5}, 3.5, 2},\n\t\t{\"Multiple Nearest Elements\", []float64{1, 2, 3, 3, 4, 5}, 3.2, 2},\n\t\t{\"Empty Slice Panic\", []float64{}, 3.5, 0},\n\t\t{\"NaN Value\", []float64{1, 2, 3}, math.NaN(), 0},\n\t\t{\"Positive Infinity Value\", []float64{1, 2, 3}, math.Inf(1), 2},\n\t\t{\"Negative Infinity Value\", []float64{1, 2, 3}, math.Inf(-1), 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif tt.name == \"Empty Slice Panic\" {\n\t\t\t\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif got := NearestIdx(tt.s, tt.v); got != tt.index {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.index)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3d4b6f7a4af707bc819ae7f7d99fff2": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\"L2 norm\", []float64{3, 4}, 2, 5},\n\t\t{\"L1 norm\", []float64{3, 4}, 1, 7},\n\t\t{\"L-inf norm\", []float64{3, 4, -10, 100}, math.Inf(1), 100},\n\t\t{\"Empty slice\", []float64{}, 1, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Norm(tt.s, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3debfe533834eb7a925993f5da8abed": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tdst := []float64{3.0, 1.0, 2.0}\n\tinds := make([]int, len(dst))\n\texpectedDst := []float64{1.0, 2.0, 3.0}\n\texpectedInds := []int{1, 2, 0}\n\n\tArgsort(dst, inds)\n\n\tif !reflect.DeepEqual(dst, expectedDst) {\n\t\tt.Errorf(\"Expected sorted dst: %v, but got: %v\", expectedDst, dst)\n\t}\n\n\tif !reflect.DeepEqual(inds, expectedInds) {\n\t\tt.Errorf(\"Expected inds order: %v, but got: %v\", expectedInds, inds)\n\t}\n}\n",
    "e46741c04a2ae3e8fb5d63a0dfcf1389": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Example 1\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Example 2\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    6.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Example 3\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Example 4\",\n\t\t\tslice:    []float64{},\n\t\t\tvalue:    1.0,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tactual := Within(test.slice, test.value)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"Expected %d but got %d\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic test - input slice not sorted\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t\t}\n\t\t}()\n\t\tWithin([]float64{2.0, 1.0}, 1.5)\n\t})\n\n\tt.Run(\"Panic test - input slice length less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t\t}\n\t\t}()\n\t\tWithin([]float64{1.0}, 1.5)\n\t})\n}",
    "e4b1a35bdcaef67e0246950a70f8a28b": "// Package floats provides functions for float64 slices.\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 0},\n\t\t{3, 1.0, 3.0, 2.5, 1},\n\t\t{4, 0.0, 5.0, 3.0, 1},\n\t\t{5, -1.0, 3.0, 0.0, 1},\n\t\t{4, 2.0, 1.0, 0.5, 0},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\tt.Run(\"Panic for n \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\n\t\tNearestIdxForSpan(1, 0.0, 1.0, 0.5)\n\t})\n}",
    "e551b450b466d5af6639a408ad6d1cd2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Valid case\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0.0,\n\t\t\tu:       1.0,\n\t\t\twant:    []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Invalid case: dst length less than 2\",\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0.0,\n\t\t\tu:       1.0,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Special case: NaN values\",\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       1.0,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), 1.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() error = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e56decab21bda765dea786add27026fb": "package floats\n\nimport \"testing\"\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{5, 1.0, 10.0, 4.6, 2},\n\t\t{3, 0.0, 5.0, 7.2, 2},\n\t\t{4, -10.0, 10.0, -5.0, 0},\n\t\t{7, -5.0, 0.0, -10.0, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%d, %f, %f, %f) to return %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "e5e9fa216268e609baeb416605b77cd2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 2.0, 1.5, 0},\n\t\t{3, 1.0, 2.0, 1.5, 1},\n\t\t{4, 1.0, 2.0, 1.5, 1},\n\t\t{5, 1.0, 2.0, 1.7, 2},\n\t\t{6, 1.0, 2.0, 1.6, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n = %d, l = %f, u = %f, v = %f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "e7908f6ba9246e52947f0c450542ee07": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1},\n\t\t{\"Single element slice\", []float64{5}, 5},\n\t\t{\"Multiple elements - positive numbers\", []float64{2, 3, 4}, 24},\n\t\t{\"Multiple elements - including negative numbers\", []float64{2, -3, 4}, -24},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7de2bec59d8d297fc181da6f481f74b": "func TestAddScaledTo(t *testing.T) {\n\tdst := []float64{1, 2, 3}\n\ty := []float64{4, 5, 6}\n\talpha := 2.0\n\ts := []float64{7, 8, 9}\n\n\texpected := []float64{15, 18, 21}\n\n\tresult := AddScaledTo(dst, y, alpha, s)\n\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %v, but got %v\", expected, result)\n\t}\n\n\t// Add additional test cases here\n}",
    "e8244b76a457320d0ab3b95b58a6c2da": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0}, 0, 10, []float64{0}},\n\t\t{[]float64{1, 2, 3}, 1, 3, []float64{1, 2, 3}},\n\t\t{[]float64{0, 0, 0}, 0, 0, []float64{0, 0, 0}},\n\t\t{[]float64{0, 0, 0}, 10, 0, []float64{10, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic case\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{1}, 1, 3)\n}",
    "e846085b6c4d3e90047c324e42424143": "func TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{\"normal case\", []float64{1.0, 2.0, 3.0, 4.0}, 2.5, 2},\n\t\t{\"lower bound\", []float64{1.0, 2.0, 3.0, 4.0}, 1.0, 0},\n\t\t{\"upper bound\", []float64{1.0, 2.0, 3.0, 4.0}, 4.0, 3},\n\t\t{\"negative value\", []float64{-4.0, -3.0, -2.0, -1.0}, -2.5, 1},\n\t\t{\"NaN value\", []float64{1.0, 2.0, 3.0, 4.0}, math.NaN(), -1},\n\t\t{\"empty slice\", []float64{}, 2.5, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif tt.index == -1 {\n\t\t\t\t\t\tt.Errorf(\"Expected panic, but no panic occurred\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif tt.index != -1 {\n\t\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tindex := Within(tt.s, tt.v)\n\t\t\tif index != tt.index {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.index, index)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e84c735c076f2f8bd8d768404cfa6161": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl       float64\n\t\tu       float64\n\t\tv       float64\n\t\twant    int\n\t\tisPanic bool\n\t}{\n\t\t{n: 3, l: 0.0, u: 10.0, v: 5.0, want: 1, isPanic: false},\n\t\t{n: 2, l: 3.0, u: 8.0, v: 10.0, want: 1, isPanic: false},\n\t\t{n: 5, l: math.NaN(), u: 3.0, v: 2.0, want: 4, isPanic: false},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0.0, want: 2, isPanic: false},\n\t\t{n: 6, l: 1.0, u: 2.0, v: 10.0, want: 5, isPanic: false},\n\t\t{n: 3, l: 5.0, u: 1.0, v: 3.0, want: 0, isPanic: false},\n\t\t{n: 3, l: 1.0, u: 5.0, v: 1.0, want: 0, isPanic: false},\n\t\t{n: 2, l: 1.0, u: 1.0, v: 1.0, want: 0, isPanic: false},\n\t\t{n: 1, l: 1.0, u: 2.0, v: 1.5, want: 0, isPanic: true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif (recover() != nil) != tt.isPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) panicked: %v, want %v\", tt.n, tt.l, tt.u, tt.v, !tt.isPanic, tt.isPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "eaffafaa2e0ca1f7561e224cb9d3208c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"EmptySlice\", []float64{}, 1},\n\t\t{\"SingleElement\", []float64{2}, 2},\n\t\t{\"MultipleElements\", []float64{2, 3, 4}, 24},\n\t\t{\"NegativeValues\", []float64{-2, -3, -4}, -24},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Prod(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "eb2979221b37e0bc94da0f2b22cd5473": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\ts            []float64\n\t\tt            []float64\n\t\tL            float64\n\t\texpectedDist float64\n\t}{\n\t\t{\n\t\t\tname:         \"Test L2 norm\",\n\t\t\ts:            []float64{1, 2, 3},\n\t\t\tt:            []float64{4, 5, 6},\n\t\t\tL:            2,\n\t\t\texpectedDist: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:         \"Test L1 norm\",\n\t\t\ts:            []float64{1, 2, 3},\n\t\t\tt:            []float64{4, 5, 6},\n\t\t\tL:            1,\n\t\t\texpectedDist: 9,\n\t\t},\n\t\t{\n\t\t\tname:         \"Test Inf norm\",\n\t\t\ts:            []float64{1, 2, 3},\n\t\t\tt:            []float64{4, 5, 6},\n\t\t\tL:            math.Inf(1),\n\t\t\texpectedDist: 3,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdist := Distance(tt.s, tt.t, tt.L)\n\t\t\tif dist != tt.expectedDist {\n\t\t\t\tt.Errorf(\"Expected distance: %v, but got: %v\", tt.expectedDist, dist)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "ed4c3249384c384098afcc70d1b2cbca": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpectedOutput float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Case 1\",\n\t\t\tinput: []float64{1.0, 2.5, 3.7, 4.3, 5.1},\n\t\t\texpectedOutput: 16.6,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 2\",\n\t\t\tinput: []float64{1.5, 2.5},\n\t\t\texpectedOutput: 4.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 3\",\n\t\t\tinput: []float64{-1.0, -2.0, -3.0},\n\t\t\texpectedOutput: -6.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\toutput := floats.SumCompensated(tt.input)\n\t\t\tif output != tt.expectedOutput {\n\t\t\t\tt.Errorf(\"Expected output: %v, but got: %v\", tt.expectedOutput, output)\n\t\t\t}\n\t\t})\n\t}\n}",
    "edd6222fcf0881ddecd2e6230084c628": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your_username/your_repo/floats\" \n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0, 0}, 0, 5, []float64{0, 1.6666666666666665, 3.333333333333333, 5}},\n\t\t{[]float64{0, 0}, 1, 10, []float64{1, 10}},\n\t\t{[]float64{0, 0, 0}, 5, 5, []float64{5, 5, 5}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tfor i, val := range result {\n\t\t\tif val != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span test failed for input dst=%v, l=%v, u=%v. Expected %v, but got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "ede839d8aa21a2a990793caf464a7fa3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test Case 1\", 5, 1.0, 10.0, 5.0, 2},\n\t\t{\"Test Case 2\", 3, 0.0, 5.0, 10.0, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d but got %d\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "ee11c775a2b30640658618f6276f10f9": "// Package floats contains various functions for operations on float slices.\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\ts1   []float64\n\t\ts2   []float64\n\t\ttol  float64\n\t\twant bool\n\t}{\n\t\t{[]float64{1.1, 2.2, 3.3}, []float64{1.11, 2.21, 3.31}, 0.01, true},\n\t\t{[]float64{1.1, 2.2, 3.3}, []float64{1.11, 2.21, 3.31}, 0.001, false},\n\t\t{[]float64{1.1, 2.2, 3.3}, []float64{1.12, 2.22, 3.32}, 0.01, false},\n\t\t{[]float64{1.1, 2.2, 3.3}, []float64{1.11, 2.22, 3.33}, 0.01, false},\n\t\t{[]float64{1.1, 2.2, 3.3}, []float64{1.11, 2.21}, 0.01, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := EqualApprox(tt.s1, tt.s2, tt.tol)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %t; want %t\", tt.s1, tt.s2, tt.tol, got, tt.want)\n\t\t}\n\t}\n}",
    "eee73366a6b12e52db5a164b7574ac06": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements that are true\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements that are true\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find element that does not exist\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tk:        3,\n\t\t\texpected: nil, // Expected to return an error\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar inds []int\n\t\t\tresult, err := floats.Find(inds, func(val float64) bool {\n\t\t\t\treturn val \u003c 3.0\n\t\t\t}, tt.slice, tt.k)\n\n\t\t\tif err != nil \u0026\u0026 len(tt.expected) \u003e 0 {\n\t\t\t\tt.Errorf(\"Expected to find elements but got an error: %v\", err)\n\t\t\t}\n\n\t\t\tif !equal(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "ef173baae917f51659bbeea6f5a88278": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Basic test case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Edge case: v less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Edge case: v greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f000ba2650b7d541450f4670b4290607": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{make([]float64, 5), 0, 10, []float64{0, 2.5, 5, 7.5, 10}},\n\t\t{make([]float64, 3), -10, 10, []float64{-10, 0, 10}},\n\t\t{make([]float64, 4), 5, math.Inf(1), []float64{5, 10, math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 5), math.Inf(-1), 5, []float64{math.Inf(-1), 1.25, 2.5, 3.75, 5}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic when length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}",
    "f0b30df2d6d93e47dff67646e0ce6c10": "package floats_test\n\nimport (\n\t\"testing\"\n\t\"github.com/your-package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{4, 0.0, 10.0, 5.0, 2},\n\t\t{5, 0.0, 10.0, 12.0, 4},\n\t\t{3, -10.0, 10.0, -8.0, 0},\n\t\t{2, 5.0, 15.0, 6.0, 0},\n\t\t{6, -5.0, 5.0, 0.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.result)\n\t\t}\n\t}\n\n\t// Add more test cases here\n}",
    "f15c3362d300b641bf4f7188dbe271b2": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"github.com/yourpackage/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Normal case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tresult: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"Negative bounds\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\tresult: []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"Special case for NaN\",\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      0,\n\t\t\tu:      float64(\"nan\"),\n\t\t\tresult: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"Special case for Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tresult: []float64{inf, 0, -inf, 0, inf},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := floats.Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif !reflect.DeepEqual(actual, tc.result) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", actual, tc.result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f2c99ede0b70b8c7222aa22af27455ed": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\"Test case 1\", []float64{3.5, 2.1, 5.2, 1.7}, 3},\n\t\t{\"Test case 2\", []float64{10.0, 5.0, 7.0, 3.0, 7.0}, 3},\n\t\t{\"Test case 3\", []float64{1.0}, 0},\n\t\t{\"Test case 4\", []float64{0.0, 0.0, 0.0, 0.0}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.MinIdx(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2d0a4e0607696b81d0f7831b78f1a69": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, expected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\tt:        []float64{7, 8, 9},\n\t\t\texpected: []float64{28, 40, 54},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3, 4},\n\t\t\ts:        []float64{5, 6, 7},\n\t\t\tt:        []float64{8, 9, 10},\n\t\t\texpected: []float64{40, 54, 70, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\tt:        []float64{7, 8, 9, 10},\n\t\t\texpected: []float64{28, 40, 54},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MulTo(test.dst, test.s, test.t)\n\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t}\n\t}\n}",
    "f2f791bd017a2c0391ee414f8e34deb6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your_package_name/floats\"\n)\n\nfunc TestLess(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\targsort  floats.argsort\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\targsort:  floats.argsort{[]float64{1.0, 2.0, 3.0, 4.0}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\targsort:  floats.argsort{[]float64{4.0, 3.0, 2.0, 1.0}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\targsort:  floats.argsort{[]float64{0.0, 0.0, 0.0, 0.0}},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := test.argsort.Less(0, 1)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f4050e94ad42ab51bda296b51cea2843": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Valid Span calculation\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid dst length\",\n\t\t\tdst:  []float64{0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif len(tt.dst) \u003c 2 {\n\t\t\t\t\t\tt.Errorf(\"Expected panic due to invalid dst length, but no panic occurred\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(got) == 0 {\n\t\t\t\tt.Errorf(\"Span returned empty slice\")\n\t\t\t}\n\t\t})\n\t}\n}",
    "f51a1aaeae1dd7bf0c8e26f89b8b78ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := 1.0\n\tu := 100.0\n\n\tresult := LogSpan(dst, l, u)\n\n\t// Check that the length of the result is the same as the input\n\tif len(result) != len(dst) {\n\t\tt.Errorf(\"Expected result length %d, but got %d\", len(dst), len(result))\n\t}\n\n\t// Check that the first element is l\n\tif result[0] != l {\n\t\tt.Errorf(\"First element should be %f, but got %f\", l, result[0])\n\t}\n\n\t// Check that the last element is u\n\tif result[len(result)-1] != u {\n\t\tt.Errorf(\"Last element should be %f, but got %f\", u, result[len(result)-1])\n\t}\n\n\t// Check NaN values for negative input bounds\n\tdstNeg := make([]float64, 5)\n\tlNeg := -1.0\n\tuNeg := -100.0\n\n\tresultNeg := LogSpan(dstNeg, lNeg, uNeg)\n\n\tfor _, val := range resultNeg {\n\t\tif !math.IsNaN(val) {\n\t\t\tt.Errorf(\"Expected NaN value for negative input bounds, but got %f\", val)\n\t\t}\n\t}\n\n\t// Check zero values for zero input bounds\n\tdstZero := make([]float64, 5)\n\tlZero := 0.0\n\tuZero := 0.0\n\n\tresultZero := LogSpan(dstZero, lZero, uZero)\n\n\tfor _, val := range resultZero {\n\t\tif val != 0.0 {\n\t\t\tt.Errorf(\"Expected 0 value for zero input bounds, but got %f\", val)\n\t\t}\n\t}\n}",
    "f5730e5037fa3baa3a7797e3cf5e3a11": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{name: \"Test1\", input: []float64{3.5, 1.2, 5.8, 0.3, 1.2}, expected: 3},\n\t\t{name: \"Test2\", input: []float64{0.5, 1.2, 0.5, 1.2, 2.7, 0.5}, expected: 0},\n\t\t{name: \"Test3\", input: []float64{10.0, 8.7, 12.4, 15.6, 7.2}, expected: 4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f5bab763ada8fe7c36081efa09724629": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/floats\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, expected []float64\n\t}{\n\t\t{dst: []float64{1.0, 2.0, 3.0}, s: []float64{4.0, 5.0, 6.0}, expected: []float64{5.0, 7.0, 9.0}},\n\t\t{dst: []float64{1.0, 2.0}, s: []float64{4.0, 5.0, 6.0}, expected: nil}, // Expected to panic\n\t\t{dst: []float64{1.0, 2.0, 3.0}, s: []float64{4.0, 5.0}, expected: nil}, // Expected to panic\n\t}\n\n\tfor _, test := range tests {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tif !reflect.DeepEqual(test.expected, test.dst) {\n\t\t\t\t\tt.Errorf(\"Add(%v, %v) = %v, expected %v\", test.dst, test.s, test.dst, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfloats.Add(test.dst, test.s)\n\n\t\tif reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Add(%v, %v) = %v, expected %v\", test.dst, test.s, test.dst, test.expected)\n\t\t}\n\t}\n}\n",
    "f609d4620b7ad1d4e4f0ba7a78ef6ae8": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t. \"path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 1.0, 3.0, 2.0, 1},\n\t\t{4, 0.0, 10.0, 8.0, 2},\n\t\t{3, -5.0, 5.0, 0.0, 1},\n\t\t{10, -10.0, 10.0, 7.5, 8},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "f6c14f0baeb9d56eb54d29effcc34ad0": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ts         []float64\n\t\tv         float64\n\t\twantIndex int\n\t}{\n\t\t{\n\t\t\tname:      \"Simple Case\",\n\t\t\ts:         []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:         3.5,\n\t\t\twantIndex: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"Value Below Range\",\n\t\t\ts:         []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:         0.5,\n\t\t\twantIndex: -2,\n\t\t},\n\t\t{\n\t\t\tname:      \"Value Above Range\",\n\t\t\ts:         []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:         6.0,\n\t\t\twantIndex: -2,\n\t\t},\n\t\t{\n\t\t\tname:      \"Empty Slice\",\n\t\t\ts:         []float64{},\n\t\t\tv:         3.5,\n\t\t\twantIndex: -2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tif tt.wantIndex == -2 {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for empty slice or out of range value\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotIndex := Within(tt.s, tt.v)\n\t\t\tif gotIndex != tt.wantIndex {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", tt.s, tt.v, gotIndex, tt.wantIndex)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8164ef3c4d50b252e6a8135c40a0ab5": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\" // import the source package\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 3.4076059644443802},\n\t\t{[]float64{0, 0, 0}, 0},\n\t\t{[]float64{-1, -2, -3}, -0.4076059644443802},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := floats.LogSumExp(tc.input)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "f8a59234d5fba12b9c07d35cf59640d8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tdst := []float64{3, 1, 4, 1}\n\tinds := make([]int, len(dst))\n\tfloats.Argsort(dst, inds)\n\n\t// Check if dst is sorted in increasing order\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif dst[i] \u003e dst[i+1] {\n\t\t\tt.Errorf(\"dst not sorted at index %d\", i)\n\t\t}\n\t}\n\n\t// Check if inds contains the original positions\n\tfor i, ind := range inds {\n\t\tif dst[ind] != dst[i] {\n\t\t\tt.Errorf(\"inds does not match the original position at index %d\", i)\n\t\t}\n\t}\n}\n\n// Add more test cases as needed",
    "fbcec84a399d16e857a04dd4101ba926": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Test Span with n=3, l=0, u=1\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tresult: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with n=4, l=-1, u=1\",\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      -1,\n\t\t\tu:      1,\n\t\t\tresult: []float64{-1, -0.3333333333333333, 0.3333333333333333, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"Test Span with n=5, l=0.5, u=2.5\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.5,\n\t\t\tu:      2.5,\n\t\t\tresult: []float64{0.5, 1, 1.5, 2, 2.5},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tres := floats.Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(res) != len(tc.result) {\n\t\t\t\tt.Errorf(\"Expected result length: %v, Got: %v\", len(tc.result), len(res))\n\t\t\t}\n\t\t\tfor i := range res {\n\t\t\t\tif res[i] != tc.result[i] {\n\t\t\t\t\tt.Errorf(\"Expected: %v, Got: %v\", tc.result[i], res[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "fdddd85e91abddc251b9da767bee01fa": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\tout []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 2, 3}, []float64{2, 4, 6}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{3, 2, 1}, []float64{4, 4, 4}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 2}, nil}, // Panics\n\t}\n\n\tfor _, test := range tests {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == \"badLength\" \u0026\u0026 test.out == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Errorf(\"AddTo did not panic as expected for input (%v,%v,%v)\", test.dst, test.s, test.t)\n\t\t}()\n\n\t\tresult := AddTo(test.dst, test.s, test.t)\n\t\tif !reflect.DeepEqual(result, test.out) {\n\t\t\tt.Errorf(\"AddTo(%v,%v,%v) = %v; want %v\", test.dst, test.s, test.t, result, test.out)\n\t\t}\n\t}\n}",
    "fe478ab38e642e30157bc134e5ad80b3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tn             int\n\t\tlowerBound    float64\n\t\tupperBound    float64\n\t\tvalue         float64\n\t\texpectedIndex int\n\t}{\n\t\t{\n\t\t\tname:          \"Test case 1\",\n\t\t\tn:             5,\n\t\t\tlowerBound:    0,\n\t\t\tupperBound:    10,\n\t\t\tvalue:         4.5,\n\t\t\texpectedIndex: 1,\n\t\t},\n\t\t{\n\t\t\tname:          \"Test case 2\",\n\t\t\tn:             8,\n\t\t\tlowerBound:    -5,\n\t\t\tupperBound:    5,\n\t\t\tvalue:         -3,\n\t\t\texpectedIndex: 1,\n\t\t},\n\t\t{\n\t\t\tname:          \"Test case 3\",\n\t\t\tn:             3,\n\t\t\tlowerBound:    1,\n\t\t\tupperBound:    10,\n\t\t\tvalue:         7.5,\n\t\t\texpectedIndex: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdxForSpan(tt.n, tt.lowerBound, tt.upperBound, tt.value)\n\t\t\tif result != tt.expectedIndex {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expectedIndex, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "fffbfad0db7ae393fa0704ea9b316d33": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{4, 0, 10, 5, 1},\n\t\t{4, 0, 10, 15, 3},\n\t\t{3, 0, math.Inf(1), 10, 1},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 4},\n\t\t{6, math.Inf(1), math.Inf(-1), 0, 0},\n\t\t{4, 1, 5, 2, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.result {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.result)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}"
}