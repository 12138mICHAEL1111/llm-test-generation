{
    "0026966f482687b357882089f4e9ee0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - math.IsNaN(v)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\t// - math.IsInf(l, 0)\n\t// - math.IsInf(u, 0)\n\t// - math.IsInf(v, -1)\n\t// - math.IsInf(v, 1)\n\t// - l \u003c u\n\t// - l \u003e u\n\t// - l == u\n\t// - v \u003c l\n\t// - v \u003e u\n\t// - v in (l, u)\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, 0) did not panic\", n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t}\n\n\t// math.IsNaN(v)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tif got := NearestIdxForSpan(n, 0, 1, math.NaN()); got != 0 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, NaN) = %d, want 0\", n, got)\n\t\t}\n\t}\n\n\t// math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tif got := NearestIdxForSpan(n, math.NaN(), 1, 0); got != n-1 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, NaN, 1, 0) = %d, want %d\", n, got, n-1)\n\t\t}\n\t}\n\n\t// math.IsNaN(u)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tif got := NearestIdxForSpan(n, 0, math.NaN(), 0); got != 0 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, NaN, 0) = %d, want 0\", n, got)\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\tfor _, u := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif l == u {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t} else if n%2 == 1 {\n\t\t\t\t\t\tif !math.IsInf(v, 0) {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t} else if math.Copysign(1, v) == math.Copysign(1, l) {\n\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n/2 + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif math.Copysign(1, v) == math.Copysign(1, l) {\n\t\t\t\t\t\t\twant = 1\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\twant := n - 1\n\t\t\tif v == math.Inf(-1) {\n\t\t\t\twant = 0\n\t\t\t}\n\t\t\tif got := NearestIdxForSpan(n, math.Inf(-1), 1, v); got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, -Inf, 1, %v) = %d, want %d\", n, v, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\twant := 0\n\t\t\tif v == math.Inf(1) {\n\t\t\t\twant = n - 1\n\t\t\t}\n\t\t\tif got := NearestIdxForSpan(n, 0, math.Inf(1), v); got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, Inf, %v) = %d, want %d\", n, v, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(v, -1)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\twant := 0\n\t\t\t\tif l \u003e u {\n\t\t\t\t\twant = n - 1\n\t\t\t\t}\n\t\t\t\tif got := NearestIdxForSpan(n, l, u, math.Inf(-1)); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, -Inf) = %d, want %d\", n, l, u, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(v, 1)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\twant := n - 1\n\t\t\t\tif u \u003e l {\n\t\t\t\t\twant = 0\n\t\t\t\t}\n\t\t\t\tif got := NearestIdxForSpan(n, l, u, math.Inf(1)); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, Inf) = %d, want %d\", n, l, u, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003c u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l += 0.5 {\n\t\t\tfor u := l + 0.5; u \u003c 10; u += 0.5 {\n\t\t\t\tfor v := l - 1; v \u003c u+1; v += 0.1 {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif v \u003c= l {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t} else if v \u003e= u {\n\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\twant = int((float64(n)-1)/(u-l)*(v-l) + 0.5)\n\t\t\t\t\t}\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := 10.0; l \u003e -10; l -= 0.5 {\n\t\t\tfor u := l - 0.5; u \u003e -10; u -= 0.5 {\n\t\t\t\tfor v := u - 1; v \u003c l+1; v += 0.1 {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif v \u003e= l {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t} else if v \u003c= u {\n\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t} else {\n\t\t\t\t\t\twant = int((float64(n)-1)/(u-l)*(v-l) + 0.5)\n\t\t\t\t\t}\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l += 0.5 {\n\t\t\tfor v := l - 1; v \u003c l+1; v += 0.1 {\n\t\t\t\twant := 0\n\t\t\t\tif got := NearestIdxForSpan(n, l, l, v); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", n, l, l, v, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "00ff8da04f0e838382a81a82fbe07efe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slice contents\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the norm using the function being tested\n\t\tgot := Norm(tc.s, tc.L)\n\n\t\t// Check if the calculated norm matches the expected value\n\t\tif math.Abs(got-tc.want) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, want %v\", tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "013e5ee407fb258d6a8c3fda98af7c6a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-3.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfSameSign\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfDifferentSign\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LeftInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"RightInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-3.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range tc.want {\n\t\t\t\tif !EqualApprox([]float64{got[i]}, []float64{tc.want[i]}, 1e-10) {\n\t\t\t\t\tt.Errorf(\"Test case %s failed: got %v, want %v\", tc.name, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 1.0)\n}",
    "0215348bb87bbfbf266f19937ec2247e": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tans []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{3, 2, 1}, []float64{-2, 0, 2}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{-1, -2, -3}},\n\t\t{[]float64{-1, -2, -3}, []float64{-1, -2, -3}, []float64{0, 0, 0}},\n\t} {\n\t\tcopy(test.dst, test.ans)\n\t\tSub(test.dst, test.s)\n\t\tfor j := range test.dst {\n\t\t\tif test.dst[j] != test.ans[j] {\n\t\t\t\tt.Errorf(\"test %d: %v != %v\", i, test.dst, test.ans)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test that it panics when lengths don't match\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSub([]float64{1, 2, 3}, []float64{1, 2})\n}",
    "028e90cbce778d1961c87aa647c65dad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}\n",
    "02c76544e44aa50c3890e81b07f8e90f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"EmptySlice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaNValue\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"PositiveInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"NegativeInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"SingleElementSlice\", args{[]float64{1}, 1}, 0},\n\t\t{\"MultipleElementsSlice\", args{[]float64{1, 2, 3, 4, 5}, 3.2}, 2},\n\t\t{\"MultipleElementsSliceWithDuplicates\", args{[]float64{1, 2, 3, 3, 4, 5}, 3}, 2},\n\t\t{\"MultipleElementsSliceWithNaN\", args{[]float64{1, 2, math.NaN(), 4, 5}, 3}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"EmptySlice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "02d05743532d1daecf41e66d43e30cae": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 10, 0, 0},\n\t\t{2, 0, 10, 10, 1},\n\t\t{10, 0, 0, 0, 0},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}",
    "02dace20380755f8b679152b01cb1c37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular floats\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular floats\n\tt.Run(\"RegularFloats\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 4.0\n\t\texpected := []float64{1.0, 1.75, 2.5, 3.25, 4.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"LIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 4.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"UIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"BothInfSameSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf\n\tt.Run(\"LIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 4.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is Inf\n\tt.Run(\"UIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"LEqualsU\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 1.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != l {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "02fbbeaf9207bbe077f089b5539b257d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ts := []float64{1, 2, 3, 4, 5}\n\ttol := 1e-14\n\tif math.Abs(Norm(s, 1)-15) \u003e tol {\n\t\tt.Errorf(\"Failed to compute L1 norm\")\n\t}\n\tif math.Abs(Norm(s, 2)-math.Sqrt(55)) \u003e tol {\n\t\tt.Errorf(\"Failed to compute L2 norm\")\n\t}\n\tif math.Abs(Norm(s, math.Inf(1))-5) \u003e tol {\n\t\tt.Errorf(\"Failed to compute L-infinity norm\")\n\t}\n\tfor i := 3; i \u003c 10; i++ {\n\t\tL := float64(i)\n\t\tans := math.Pow(math.Pow(1, L)+math.Pow(2, L)+math.Pow(3, L)+math.Pow(4, L)+math.Pow(5, L), 1/L)\n\t\tif math.Abs(Norm(s, L)-ans) \u003e tol {\n\t\t\tt.Errorf(\"Failed to compute L%v norm\", L)\n\t\t}\n\t}\n\t// test case for empty slice\n\ts = []float64{}\n\tif Norm(s, 2) != 0 {\n\t\tt.Errorf(\"Failed to compute L2 norm for empty slice\")\n\t}\n}\n",
    "0448c285f2fcbc79b86a5077593f1471": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    2.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{2.0, 5.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-15) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tinfCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-2.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LeftInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"RightInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-2.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range infCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %v, want %v\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif !matchFloat(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2.\n\tt.Run(\"PanicsOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Span did not panic on a slice with length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\n// matchFloat compares two float64 values for equality,\n// considering NaN values as equal.\nfunc matchFloat(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}",
    "0481378a1b09214b71ea7267f94d33e1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, tc := range []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\ts:    []float64{},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"one\",\n\t\t\ts:    []float64{1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"two\",\n\t\t\ts:    []float64{1, 2},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"three\",\n\t\t\ts:    []float64{1, 2, 0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"withNaN\",\n\t\t\ts:    []float64{1, 2, math.NaN(), 0},\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tgot := MinIdx(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"want %v, got %v\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "049bf5e147c76a4cefac4edd03539ef1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d: n=%d, l=%v, u=%v, v=%v\", i, tc.n, tc.l, tc.u, tc.v), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panicking with n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\nfunc sf(format string, a ...interface{}) string {\n\treturn fmt.Sprintf(format, a...)\n}",
    "0509e0638a4b45d441f01d4ba3e331eb": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestScale(t *testing.T) {\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := rand.Intn(100)\n\t\tdst := make([]float64, n)\n\t\tfor j := range dst {\n\t\t\tdst[j] = rand.Float64()\n\t\t}\n\t\tc := rand.Float64()\n\t\tcpy := make([]float64, n)\n\t\tcopy(cpy, dst)\n\t\tScale(c, dst)\n\t\tfor j := range dst {\n\t\t\tif dst[j] != cpy[j]*c {\n\t\t\t\tt.Errorf(\"Got %v, want %v\", dst, cpy)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "078c692d78e6f34adcf892727898b8a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tdst := make([]float64, 8)\n\tgot := Span(dst, 0, 1)\n\twant := []float64{0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 1}\n\tassert.Equal(t, want, got)\n\n\t// Test case for len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst = make([]float64, 1)\n\tSpan(dst, 0, 1)\n\n\t// Test cases for NaN\n\tdst = make([]float64, 3)\n\tgot = Span(dst, math.NaN(), 1)\n\tassert.True(t, math.IsNaN(got[0]))\n\tassert.True(t, math.IsNaN(got[1]))\n\tassert.Equal(t, float64(1), got[2])\n\n\tdst = make([]float64, 3)\n\tgot = Span(dst, 0, math.NaN())\n\tassert.Equal(t, float64(0), got[0])\n\tassert.True(t, math.IsNaN(got[1]))\n\tassert.True(t, math.IsNaN(got[2]))\n\n\t// Test cases for Inf\n\tdst = make([]float64, 4)\n\tgot = Span(dst, math.Inf(1), math.Inf(-1))\n\tassert.Equal(t, math.Inf(1), got[0])\n\tassert.Equal(t, float64(0), got[1])\n\tassert.Equal(t, float64(0), got[2])\n\tassert.Equal(t, math.Inf(-1), got[3])\n\n\tdst = make([]float64, 3)\n\tgot = Span(dst, math.Inf(1), math.Inf(-1))\n\tassert.Equal(t, math.Inf(1), got[0])\n\tassert.Equal(t, float64(0), got[1])\n\tassert.Equal(t, math.Inf(-1), got[2])\n\n\tdst = make([]float64, 3)\n\tgot = Span(dst, math.Inf(1), math.Inf(1))\n\tassert.Equal(t, math.Inf(1), got[0])\n\tassert.Equal(t, math.Inf(1), got[1])\n\tassert.Equal(t, math.Inf(1), got[2])\n\n\tdst = make([]float64, 3)\n\tgot = Span(dst, math.Inf(1), 1)\n\tassert.Equal(t, math.Inf(1), got[0])\n\tassert.Equal(t, math.Inf(1), got[1])\n\tassert.Equal(t, float64(1), got[2])\n\n\tdst = make([]float64, 3)\n\tgot = Span(dst, 0, math.Inf(1))\n\tassert.Equal(t, float64(0), got[0])\n\tassert.Equal(t, math.Inf(1), got[1])\n\tassert.Equal(t, math.Inf(1), got[2])\n}",
    "07a3669a4df39454690361c55d14ee12": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "082fe751a23930a68a019f44025e09cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are very large values\n\t// - l and u are Inf\n\t// - l and u are NaN\n\t// - l and u are a mix of the above\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very large values\n\tt.Run(\"LargeValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, -1e10, 1e10)\n\t\texpected := []float64{-1e10, -5e9, 0, 5e9, 1e10}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are a mix of the above\n\tt.Run(\"MixedValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "08367c21374f71c8896f648b0805835b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\t// Each test case consists of:\n\t// - dst: The destination slice.\n\t// - l: The lower bound of the span.\n\t// - u: The upper bound of the span.\n\t// - expected: The expected values in dst after calling Span.\n\ttestCases := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t// Basic cases.\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 3, []float64{0, 1, 2, 3}},\n\n\t\t// Non-zero lower bound.\n\t\t{[]float64{0, 0}, 1, 2, []float64{1, 2}},\n\t\t{[]float64{0, 0, 0}, 1, 3, []float64{1, 2, 3}},\n\n\t\t// Negative bounds.\n\t\t{[]float64{0, 0}, -1, 0, []float64{-1, 0}},\n\t\t{[]float64{0, 0, 0}, -2, 0, []float64{-2, -1, 0}},\n\n\t\t// Fractional bounds.\n\t\t{[]float64{0, 0}, 0.5, 1.5, []float64{0.5, 1.5}},\n\t\t{[]float64{0, 0, 0}, 0.5, 2.5, []float64{0.5, 1.5, 2.5}},\n\n\t\t// Inf bounds.\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)}},\n\n\t\t// NaN bounds.\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 1, math.NaN(), []float64{1, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, 1, math.NaN(), []float64{1, math.NaN(), math.NaN()}},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tSpan(tc.dst, tc.l, tc.u)\n\t\tfor j := range tc.dst {\n\t\t\tif !equal(tc.dst[j], tc.expected[j]) {\n\t\t\t\tt.Errorf(\"Test case %d: got %v, want %v\", i, tc.dst, tc.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// equal compares two float64 values for equality, considering NaN values\n// as equal.\nfunc equal(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}",
    "0843ef585b873a1a79ee4ad7a8360783": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - v is NaN\n\t// - l or u is NaN\n\t// - l and u are Inf\n\t// - l or u is Inf\n\t// - v is Inf\n\t// - v is outside (l, u)\n\t// - v is inside (l, u)\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, 0) did not panic\", n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t}\n\n\t// v is NaN\n\tn := 3\n\tl := 0.0\n\tu := 1.0\n\tv := math.NaN()\n\tgot := NearestIdxForSpan(n, l, u, v)\n\twant := 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// l is NaN\n\tn = 3\n\tl = math.NaN()\n\tu = 1.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 2\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// u is NaN\n\tn = 3\n\tl = 0.0\n\tu = math.NaN()\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// l and u are Inf\n\tn = 3\n\tl = math.Inf(1)\n\tu = math.Inf(1)\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// l is Inf\n\tn = 3\n\tl = math.Inf(1)\n\tu = 1.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 2\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// u is Inf\n\tn = 3\n\tl = 0.0\n\tu = math.Inf(1)\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// v is Inf\n\tn = 3\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(1)\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 2\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// v is outside (l, u)\n\tn = 5\n\tl = 0.0\n\tu = 1.0\n\tv = -1.0\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// v is inside (l, u)\n\tn = 5\n\tl = 0.0\n\tu = 1.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 2\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n}",
    "08d82e43185b5ac68d847ab24ea6f61b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d: n=%d, l=%v, u=%v, v=%v\", i, tc.n, tc.l, tc.u, tc.v), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc sf(format string, a ...interface{}) string {\n\treturn fmt.Sprintf(format, a...)\n}",
    "092d969bdc8d331e1383b09ae960574d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slice contents.\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over the test cases and compare the output of Norm to the expected value.\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif math.Abs(got-tc.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test case %d failed: Norm(%v, %v) = %v, want %v\", i, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "0a4296a1d29592be5b3cbae3eddad4e4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"SmallSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-15) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc closeEnough(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c tol\n}",
    "0a81dba7d0fdfeb9b2ee90d5fffab1ef": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.75, 7},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, 1, 0, 0.75, 2},\n\t\t{10, 0, 1, -0.1, 0},\n\t\t{10, 0, 1, 1.1, 9},\n\t\t{10, 1, 0, -0.1, 9},\n\t\t{10, 1, 0, 1.1, 0},\n\t\t{10, 0, 0, 0.5, 0},\n\t\t{10, 1, 1, 0.5, 0},\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\t\t{10, 0, 10, 10.0, 9},\n\t\t{10, 10, 0, -10, 9},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got, want := have, test.want; got != want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d,%v,%v,%v) = %v, want %v\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, want)\n\t\t}\n\t}\n\t// Test cases where v is NaN\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0},\n\t\t{10, 1, 0, 0},\n\t\t{10, 0, 0, 0},\n\t\t{10, 1, 1, 0},\n\t\t{2, 0, 1, 0},\n\t\t{2, 1, 0, 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, math.NaN())\n\t\tif got, want := have, test.want; got != want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d,%v,%v,NaN) = %v, want %v\",\n\t\t\t\ti, test.n, test.l, test.u, got, want)\n\t\t}\n\t}\n\t// Test cases where l or u is NaN\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, math.NaN(), 1, 0.5, 9},\n\t\t{10, 0, math.NaN(), 0.5, 0},\n\t\t{10, math.NaN(), math.NaN(), 0.5, 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got, want := have, test.want; got != want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d,%v,%v,%v) = %v, want %v\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, want)\n\t\t}\n\t}\n\t// Test cases where l or u is Inf\n\tfor i, test := range []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, math.Inf(1), 0, 0.5, 0},\n\t\t{10, 0, math.Inf(1), 0.5, 9},\n\t\t{10, math.Inf(-1), 0, 0.5, 9},\n\t\t{10, 0, math.Inf(-1), 0.5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0.5, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0.5, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), 0.5, 5},\n\t\t{9, math.Inf(1), math.Inf(-1), 0.5, 4},\n\t\t{9, math.Inf(-1), math.Inf(1), 0.5, 4},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 9},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got, want := have, test.want; got != want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d,%v,%v,%v) = %v, want %v\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, want)\n\t\t}\n\t}\n\t// Test cases where v is Inf\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got, want := have, test.want; got != want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d,%v,%v,%v) = %v, want %v\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, want)\n\t\t}\n\t}\n}\n",
    "0b097e9900feb8b9e641c792209cf25f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\t// Test cases for MinIdx function\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 0},\n\t\t{[]float64{5, 4, 3, 2, 1}, 4},\n\t\t{[]float64{1, 5, 2, 4, 3}, 0},\n\t\t{[]float64{1, math.NaN(), 2, 4, 3}, 0},\n\t\t{[]float64{math.NaN(), 1, 2, 4, 3}, 1},\n\t}\n\n\t// Iterate over the test cases and check the output\n\tfor i, tc := range testCases {\n\t\tgot := MinIdx(tc.input)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: input=%v, want=%v, got=%v\", i+1, tc.input, tc.want, got)\n\t\t}\n\t}\n\n\t// Test case for panic when input slice is empty\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when the input slice was empty\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}",
    "0b471cefc5359254a2f629459fb3aade": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "0c3582a382574f253a9d3e2de6f04b2e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\t// Test cases for Same function\n\ttestCases := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},                // Same values\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},               // Different values\n\t\t{[]float64{1.0, 2.0, math.NaN()}, []float64{1.0, 2.0, math.NaN()}, true}, // NaN treated as same\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},                   // Different lengths\n\t\t{[]float64{}, []float64{}, true},                                           // Empty slices\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range testCases {\n\t\t// Call Same function\n\t\tactual := Same(tc.s, tc.t)\n\n\t\t// Check if the result matches the expected value\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "0cbfee12334c61b215b68e7039d3e04c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that length less than 2 panics.\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Verify that dst is modified in place.\n\t{\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, 1)\n\t\tif dst != result {\n\t\t\tt.Errorf(\"Span did not modify dst in place\")\n\t\t}\n\t}\n\n\t// Verify output for various valid lengths.\n\tfor n := 2; n \u003c 10; n++ {\n\t\tdst := make([]float64, n)\n\t\tSpan(dst, 0, 1)\n\t\t// Check that the first and last elements are correct.\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"For n = %v, expected first element to be 0, got %v\", n, dst[0])\n\t\t}\n\t\tif dst[n-1] != 1 {\n\t\t\tt.Errorf(\"For n = %v, expected last element to be 1, got %v\", n, dst[n-1])\n\t\t}\n\t\t// Check that the spacing is correct.\n\t\tfor i := 1; i \u003c n; i++ {\n\t\t\texpected := float64(i) / float64(n-1)\n\t\t\tif math.Abs(dst[i]-expected) \u003e 1e-14 {\n\t\t\t\tt.Errorf(\"For n = %v, index %v, expected %v, got %v\", n, i, expected, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Verify output for non-zero lower and upper bounds.\n\tn := 5\n\tl := -1.0\n\tu := 2.0\n\tdst := make([]float64, n)\n\tSpan(dst, l, u)\n\t// Check that the first and last elements are correct.\n\tif dst[0] != l {\n\t\tt.Errorf(\"For n = %v, expected first element to be %v, got %v\", n, l, dst[0])\n\t}\n\tif dst[n-1] != u {\n\t\tt.Errorf(\"For n = %v, expected last element to be %v, got %v\", n, u, dst[n-1])\n\t}\n\t// Check that the spacing is correct.\n\tfor i := 1; i \u003c n; i++ {\n\t\texpected := l + (u-l)*float64(i)/float64(n-1)\n\t\tif math.Abs(dst[i]-expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected %v, got %v\", n, i, expected, dst[i])\n\t\t}\n\t}\n\n\t// Verify output when l is +Inf\n\tn = 5\n\tl = math.Inf(1)\n\tu = 2.0\n\tdst = make([]float64, n)\n\tSpan(dst, l, u)\n\tfor i := 0; i \u003c n-1; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected +Inf, got %v\", n, i, dst[i])\n\t\t}\n\t}\n\tif dst[n-1] != u {\n\t\tt.Errorf(\"For n = %v, expected last element to be %v, got %v\", n, u, dst[n-1])\n\t}\n\n\t// Verify output when u is +Inf\n\tn = 5\n\tl = -2.0\n\tu = math.Inf(1)\n\tdst = make([]float64, n)\n\tSpan(dst, l, u)\n\tif dst[0] != l {\n\t\tt.Errorf(\"For n = %v, expected first element to be %v, got %v\", n, l, dst[0])\n\t}\n\tfor i := 1; i \u003c n; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected +Inf, got %v\", n, i, dst[i])\n\t\t}\n\t}\n\n\t// Verify output when l is -Inf\n\tn = 5\n\tl = math.Inf(-1)\n\tu = 2.0\n\tdst = make([]float64, n)\n\tSpan(dst, l, u)\n\tfor i := 0; i \u003c n-1; i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected -Inf, got %v\", n, i, dst[i])\n\t\t}\n\t}\n\tif dst[n-1] != u {\n\t\tt.Errorf(\"For n = %v, expected last element to be %v, got %v\", n, u, dst[n-1])\n\t}\n\n\t// Verify output when u is -Inf\n\tn = 5\n\tl = -2.0\n\tu = math.Inf(-1)\n\tdst = make([]float64, n)\n\tSpan(dst, l, u)\n\tif dst[0] != l {\n\t\tt.Errorf(\"For n = %v, expected first element to be %v, got %v\", n, l, dst[0])\n\t}\n\tfor i := 1; i \u003c n; i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected -Inf, got %v\", n, i, dst[i])\n\t\t}\n\t}\n\n\t// Verify output when l is NaN\n\tn = 5\n\tl = math.NaN()\n\tu = 2.0\n\tdst = make([]float64, n)\n\tSpan(dst, l, u)\n\tfor i := 0; i \u003c n-1; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected NaN, got %v\", n, i, dst[i])\n\t\t}\n\t}\n\tif dst[n-1] != u {\n\t\tt.Errorf(\"For n = %v, expected last element to be %v, got %v\", n, u, dst[n-1])\n\t}\n\n\t// Verify output when u is NaN\n\tn = 5\n\tl = -2.0\n\tu = math.NaN()\n\tdst = make([]float64, n)\n\tSpan(dst, l, u)\n\tif dst[0] != l {\n\t\tt.Errorf(\"For n = %v, expected first element to be %v, got %v\", n, l, dst[0])\n\t}\n\tfor i := 1; i \u003c n; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"For n = %v, index %v, expected NaN, got %v\", n, i, dst[i])\n\t\t}\n\t}\n}\n",
    "0d144bb389e3e2f7fce75bb9ab4c36ba": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2.1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    1.9,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"first element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"last element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4.1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"at n/2 for odd n\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"at n/2 for even n\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value for increasing span\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value for decreasing span\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign, odd n, finite v\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign, even n, finite v\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign, odd n, infinite v matching lower\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign, odd n, infinite v not matching lower\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign, even n, infinite v matching lower\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign, even n, infinite v not matching lower\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, odd n, finite v\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, even n, finite v\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, odd n, infinite v matching lower\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, odd n, infinite v matching upper\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, even n, infinite v matching lower\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, even n, infinite v matching upper\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound infinite, finite upper bound, v equals lower\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound infinite, finite upper bound, v less than lower\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(-2),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound infinite, finite lower bound, v equals upper\",\n\t\t\tn:    5,\n\t\t\tl:    -4,\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound infinite, finite lower bound, v greater than upper\",\n\t\t\tn:    5,\n\t\t\tl:    -4,\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d, %v, %v, %v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t}{\n\t\t{\n\t\t\tname: \"n = 0\",\n\t\t\tn:    0,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 1\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest.Panics(t, func() { NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v) })\n\t\t})\n\t}\n}\n",
    "0d37d4ebe8ea732945906d799178ed91": "package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{func(v float64) bool { return v \u003e 0 }, []float64{}}, 0},\n\t\t{\"all true\", args{func(v float64) bool { return v \u003e 0 }, []float64{1, 2, 3}}, 3},\n\t\t{\"some true\", args{func(v float64) bool { return v \u003e 0 }, []float64{-1, 2, -3}}, 1},\n\t\t{\"none true\", args{func(v float64) bool { return v \u003e 0 }, []float64{-1, -2, -3}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d38cf851eedbeb3bf60880a2ff1cb98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\tt1 := []float64{5, 6, 7, 8}\n\n\t// Test L = 2\n\texpectedL2 := 8.0\n\tactualL2 := Distance(s1, t1, 2)\n\tif actualL2 != expectedL2 {\n\t\tt.Errorf(\"Distance() L2 = %v, want %v\", actualL2, expectedL2)\n\t}\n\n\t// Test L = 1\n\texpectedL1 := 16.0\n\tactualL1 := Distance(s1, t1, 1)\n\tif actualL1 != expectedL1 {\n\t\tt.Errorf(\"Distance() L1 = %v, want %v\", actualL1, expectedL1)\n\t}\n\n\t// Test L = infinity\n\texpectedLInf := 4.0\n\tactualLInf := Distance(s1, t1, math.Inf(1))\n\tif actualLInf != expectedLInf {\n\t\tt.Errorf(\"Distance() L_inf = %v, want %v\", actualLInf, expectedLInf)\n\t}\n\n\t// Test other L values\n\texpectedL3 := math.Pow(96, 1.0/3.0)\n\tactualL3 := Distance(s1, t1, 3)\n\tif actualL3 != expectedL3 {\n\t\tt.Errorf(\"Distance() L3 = %v, want %v\", actualL3, expectedL3)\n\t}\n\n\t// Test empty slices\n\ts2 := []float64{}\n\tt2 := []float64{}\n\texpectedEmpty := 0.0\n\tactualEmpty := Distance(s2, t2, 2)\n\tif actualEmpty != expectedEmpty {\n\t\tt.Errorf(\"Distance() for empty slices = %v, want %v\", actualEmpty, expectedEmpty)\n\t}\n\n\t// Test unequal lengths\n\ts3 := []float64{1, 2, 3}\n\tt3 := []float64{1, 2}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic for slices of unequal length\")\n\t\t}\n\t}()\n\tDistance(s3, t3, 2)\n}\n",
    "0e04172c6c2d5d231457bf49bbcc2001": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - Slice with negative lower bound\n\t// - Slice with negative upper bound\n\t// - Slice with lower bound equal to upper bound\n\t// - Slice with NaN lower bound\n\t// - Slice with NaN upper bound\n\t// - Slice with Inf lower bound\n\t// - Slice with Inf upper bound\n\n\t// Empty slice\n\t{\n\t\ts := []float64{}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(s, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\ts := []float64{0}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with slice with one element\")\n\t\t\t}\n\t\t}()\n\t\tSpan(s, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\ts := []float64{0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with negative lower bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, -1, 1)\n\t\twant := []float64{-1, -0.5, 0, 0.5, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with negative upper bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, -1, -0.5)\n\t\twant := []float64{-1, -0.9, -0.8, -0.7, -0.5}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with lower bound equal to upper bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with NaN lower bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range s {\n\t\t\tif math.IsNaN(s[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with NaN upper bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range s {\n\t\t\tif math.IsNaN(s[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf lower bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range s {\n\t\t\tif math.IsInf(s[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf upper bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range s {\n\t\t\tif math.IsInf(s[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf lower bound and Inf upper bound\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range s {\n\t\t\tif math.IsInf(s[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", s, want)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "0e9561493f6229f9472a0d33b0425509": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBothSame\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBothDifferent\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseLEven\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() != nil {\n\t\t\t\t\tif len(tc.dst) \u003e= 2 {\n\t\t\t\t\t\tt.Errorf(\"Panicked when it should not have for case: %s\", tc.name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(tc.dst) \u003c 2 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Got %v, want %v for case: %s\", got, tc.want, tc.name)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices for equality.\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",
    "0f3a51095de34ca23f6513dd63718b5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\t// Verify panicking with short dst\n\tshort := []float64{0}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with short dst\")\n\t\t}\n\t}()\n\tLogSpan(short, 0, 10)\n\n\t// Verify parameters are OK\n\tdst := make([]float64, 3)\n\tLogSpan(dst, -1, 10)\n\tfor i := range dst {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN for negative lower bound, got %v\", dst)\n\t\t}\n\t}\n\tLogSpan(dst, 10, -1)\n\tfor i := range dst {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN for negative upper bound, got %v\", dst)\n\t\t}\n\t}\n\tLogSpan(dst, 0, 10)\n\tfor i := range dst {\n\t\tif dst[i] != 0 {\n\t\t\tt.Errorf(\"Expected 0 for 0 lower bound, got %v\", dst)\n\t\t}\n\t}\n\tLogSpan(dst, 10, 0)\n\tfor i := range dst {\n\t\tif dst[i] != 0 {\n\t\t\tt.Errorf(\"Expected 0 for 0 upper bound, got %v\", dst)\n\t\t}\n\t}\n\n\t// simple test\n\tdst = make([]float64, 3)\n\tLogSpan(dst, 1, 100)\n\texpected := []float64{1, 10, 100}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// more complex test\n\tdst = make([]float64, 10)\n\tLogSpan(dst, 0.1, 1000)\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif dst[i]/dst[i-1] \u003c 9.99 || dst[i]/dst[i-1] \u003e 10.01 {\n\t\t\tt.Errorf(\"Expected %v/%v = 10, got %v\", dst[i], dst[i-1], dst[i]/dst[i-1])\n\t\t}\n\t}\n}",
    "0fd11dba8dbc082251b5cc7acfffe5cd": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\tt           []float64\n\t\texpected    []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tname:        \"Length mismatch\",\n\t\t\tdst:         make([]float64, 2),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5, 6},\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Dst length mismatch\",\n\t\t\tdst:         make([]float64, 2),\n\t\t\ts:           []float64{1, 2},\n\t\t\tt:           []float64{4, 5},\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expectPanic {\n\t\t\t\tassert.Panics(t, func() { AddTo(tc.dst, tc.s, tc.t) })\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tc.expected, AddTo(tc.dst, tc.s, tc.t))\n\t\t\t}\n\t\t})\n\t}\n}",
    "10520592a0f56f200f0a6b8fc4e6f903": "package floats\n\nimport \"testing\"\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices and function always returns true\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2, 3},\n\t\t\t\tf:  func(a, b float64) bool { return true },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices but function returns false for one pair\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2, 3},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\tif a == 2 \u0026\u0026 b == 2 {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2},\n\t\t\t\tf:  func(a, b float64) bool { return true },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "11f572eb365996ad3a7cf07e62825761": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 6},                                 // L1 norm\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},                     // L2 norm\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},             // L3 norm\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},                     // L-infinity norm\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},                    // L-infinity norm with negative values\n\t\t{[]float64{1.0, 2.5, 3.7}, 2.5, math.Pow(22.59222, 1/2.5)}, // Fractional L-norm\n\t\t{[]float64{}, 2, 0},                                        // Empty slice\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "1233b208bd7b9681685f0e7a71169e0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{5, -5, 5, 0, 2},\n\t\t{5, -5, 5, -6, 0},\n\t\t{5, -5, 5, 6, 4},\n\t\t{11, -5, 5, 0, 5},\n\t\t{11, -5, 5, -6, 0},\n\t\t{11, -5, 5, 6, 10},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.75, 7},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf values.\n\tnanInfCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.NaN(), 0, 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 5, 5},\n\t\t{11, math.Inf(1), math.Inf(-1), 5, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(-1), 10},\n\t\t{10, math.Inf(1), 0, 5, 0},\n\t\t{10, 0, math.Inf(1), 5, 9},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), 0, math.Inf(-1), 0},\n\t}\n\n\tfor _, tc := range nanInfCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tpanicCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 10, 5},\n\t\t{0, 0, 10, 5},\n\t\t{-1, 0, 10, 5},\n\t}\n\n\tfor _, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "128299297328105251c94c426bd401ac": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{10, 0, 1, 0.5, 5},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\n\t\t// Cases with l \u003e u\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expectedIdx, actualIdx, \"For n=%v, l=%v, u=%v, v=%v\", tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "156e9026367d2431fbba36241809755c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l == u\n\t// - l \u003e u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 0) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, NaN, NaN) = %v, want all NaN\", dst, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(want[i]) {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif dst[i] != want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(want[i]) {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif dst[i] != want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span(%v, Inf, Inf) = %v, want all Inf\", dst, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(want[i], 1) {\n\t\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, Inf, 1) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif dst[i] != want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, Inf, 1) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(want[i], 1) {\n\t\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, Inf) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif dst[i] != want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, Inf) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "16389cca552661e959b771ae10933bd1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Single element slice\n\t// - Multiple element slice with unique values\n\t// - Multiple element slice with duplicate values\n\t// - NaN values in slice\n\t// - Inf values in slice\n\t// - NaN value as target\n\t// - Inf values as target\n\n\t// Empty slice\n\tt.Run(\"EmptySlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 0)\n\t})\n\n\t// Single element slice\n\tt.Run(\"SingleElementSlice\", func(t *testing.T) {\n\t\ts := []float64{1.0}\n\t\tv := 0.5\n\t\texpected := 0\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n\n\t// Multiple element slice with unique values\n\tt.Run(\"MultipleUniqueValues\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := 2.2\n\t\texpected := 1\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n\n\t// Multiple element slice with duplicate values\n\tt.Run(\"MultipleDuplicateValues\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := 2.2\n\t\texpected := 1\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n\n\t// NaN values in slice\n\tt.Run(\"NaNValuesInSlice\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, math.NaN(), 3.0, 4.0, 5.0}\n\t\tv := 2.2\n\t\texpected := 1\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n\n\t// Inf values in slice\n\tt.Run(\"InfValuesInSlice\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, math.Inf(1), 3.0, 4.0, 5.0}\n\t\tv := 2.2\n\t\texpected := 1\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n\n\t// NaN value as target\n\tt.Run(\"NaNTarget\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := math.NaN()\n\t\texpected := 0\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n\n\t// Inf values as target\n\tt.Run(\"InfTarget\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := math.Inf(1)\n\t\texpected := 4\n\t\tactual := NearestIdx(s, v)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"Expected %d, but got %d\", expected, actual)\n\t\t}\n\t})\n}\n",
    "16b961141bad023dbcab537e8956f070": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Parallel()\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 3, []float64{0, 1, 2, 3}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0}, -5, -1, []float64{-5, -3, -1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tif !Equal(got, c.ans) {\n\t\t\tt.Errorf(\"Test %d: Input: (dst=%v, l=%v, u=%v), got %v, want %v\", i, c.dst, c.l, c.u, got, c.ans)\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tt.Parallel()\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tif !Equal(got, c.ans) {\n\t\t\tt.Errorf(\"Test %d: Input: (dst=%v, l=%v, u=%v), got %v, want %v\", i, c.dst, c.l, c.u, got, c.ans)\n\t\t}\n\t}\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\tt.Parallel()\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 0, []float64{math.NaN(), 0}},\n\t\t{[]float64{0, 0}, 0, math.NaN(), []float64{0, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 0, []float64{math.NaN(), math.NaN(), 0}},\n\t\t{[]float64{0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tif !Equal(got, c.ans) {\n\t\t\tt.Errorf(\"Test %d: Input: (dst=%v, l=%v, u=%v), got %v, want %v\", i, c.dst, c.l, c.u, got, c.ans)\n\t\t}\n\t}\n}\n",
    "175bec1e74ac88c0ebf6618319ad2aea": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that Span panics with less than two points.\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test some simple cases.\n\tfor _, c := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t}{\n\t\t{5, 0, 1},\n\t\t{10, -1, 1},\n\t\t{3, -10, -9},\n\t} {\n\t\tdst := make([]float64, c.n)\n\t\tSpan(dst, c.l, c.u)\n\t\tif dst[0] != c.l {\n\t\t\tt.Errorf(\"Span(%v,%v,%v)[0] = %v, want %v\", c.n, c.l, c.u, dst[0], c.l)\n\t\t}\n\t\tif dst[c.n-1] != c.u {\n\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, c.n-1, dst[c.n-1], c.u)\n\t\t}\n\t\t// Check that the spacing is correct.\n\t\tstep := (c.u - c.l) / float64(c.n-1)\n\t\tfor i := 1; i \u003c c.n; i++ {\n\t\t\twant := c.l + step*float64(i)\n\t\t\tif dst[i] != want {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, dst[i], want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases with infinity.\n\tfor _, c := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\twant []float64\n\t}{\n\t\t{5, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{5, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{5, math.Inf(1), 0, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}},\n\t\t{5, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{5, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}},\n\t\t{5, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}},\n\t\t{6, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{6, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t} {\n\t\tdst := make([]float64, c.n)\n\t\tSpan(dst, c.l, c.u)\n\t\tfor i, v := range dst {\n\t\t\tif math.IsInf(v, 0) \u0026\u0026 !math.IsInf(c.want[i], 0) {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, v, c.want[i])\n\t\t\t}\n\t\t\tif !math.IsInf(v, 0) \u0026\u0026 math.IsInf(c.want[i], 0) {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, v, c.want[i])\n\t\t\t}\n\t\t\tif v != c.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, v, c.want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases with NaN.\n\tnan := math.NaN()\n\tfor _, c := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\twant []float64\n\t}{\n\t\t{5, nan, 0, []float64{nan, nan, nan, nan, 0}},\n\t\t{5, 0, nan, []float64{0, nan, nan, nan, nan}},\n\t\t{5, nan, nan, []float64{nan, nan, nan, nan, nan}},\n\t} {\n\t\tdst := make([]float64, c.n)\n\t\tSpan(dst, c.l, c.u)\n\t\tfor i, v := range dst {\n\t\t\tif math.IsNaN(v) \u0026\u0026 !math.IsNaN(c.want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, v, c.want[i])\n\t\t\t}\n\t\t\tif !math.IsNaN(v) \u0026\u0026 math.IsNaN(c.want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, v, c.want[i])\n\t\t\t}\n\t\t\tif v != c.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", c.n, c.l, c.u, i, v, c.want[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "178631791ebe40ac3e37a083dbafcaf0": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{-3, -3, -3}\n\tgot := SubTo(dst, s, t)\n\tassert.Equal(t, want, got)\n}",
    "17b48362ee126933a53c1a193c164509": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst  []float64\n\t\ty    []float64\n\t\talpha float64\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  []float64{2, 3, 1, 4},\n\t\t\ty:    []float64{1, 1, 1, 1},\n\t\t\talpha: 2,\n\t\t\ts:    []float64{1, 2, 0, 3},\n\t\t\twant: []float64{3, 5, 1, 7},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\ty:    []float64{1, 2, 3},\n\t\t\talpha: 0,\n\t\t\ts:    []float64{-1, 5, 2},\n\t\t\twant: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\ty:    []float64{-1, -2, -3, -4},\n\t\t\talpha: 2,\n\t\t\ts:    []float64{-1, -2, -3, -4},\n\t\t\twant: []float64{-3, -6, -9, -12},\n\t\t},\n\t} {\n\t\t// Test panics.\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"Test %v: did not panic with mismatched lengths\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAddScaledTo(test.dst, test.y[:len(test.y)-1], test.alpha, test.s)\n\t\t}()\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"Test %v: did not panic with mismatched lengths\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s[:len(test.s)-1])\n\t\t}()\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"Test %v: did not panic with mismatched lengths\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAddScaledTo(test.dst[:len(test.dst)-1], test.y, test.alpha, test.s)\n\t\t}()\n\n\t\t// Test normal operation.\n\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tif !testlapack.EqualApprox(test.dst, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Test %v: want %v, got %v\", i, test.want, test.dst)\n\t\t}\n\t}\n}",
    "1830f8f917008a5af3ab25c87b2ae2dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 1},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{10, -5, 5, 0, 5},\n\n\t\t// Edge cases\n\t\t{2, 0, 10, 0, 0},\n\t\t{2, 0, 10, 10, 1},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "18f63684bb35c6121ee813332812b6fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for Norm function\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over the test cases and compare the expected output with the actual output\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "1968ed211494d5115fccc7fbe0d9b841": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l is Inf\n\t// - u is Inf\n\t// - Normal cases\n\n\t// len(dst) \u003c 2\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaN endpoints\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"Inf endpoints\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i, v := range dst {\n\t\t\tif i == len(dst)/2 {\n\t\t\t\tif v != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", v)\n\t\t\t\t}\n\t\t\t} else if i \u003c len(dst)/2 {\n\t\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\t\tt.Errorf(\"Expected Inf, got %v\", v)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsInf(v, -1) {\n\t\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf\n\tt.Run(\"Inf start\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i, v := range dst {\n\t\t\tif i == len(dst)-1 {\n\t\t\t\tif v != 1 {\n\t\t\t\t\tt.Errorf(\"Expected 1, got %v\", v)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\t\tt.Errorf(\"Expected Inf, got %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// u is Inf\n\tt.Run(\"Inf end\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tfor i, v := range dst {\n\t\t\tif i == 0 {\n\t\t\t\tif v != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", v)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\t\tt.Errorf(\"Expected Inf, got %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// Normal cases\n\tt.Run(\"Normal cases\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\tdst []float64\n\t\t\tl   float64\n\t\t\tu   float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t\t{[]float64{0, 0, 0, 0}, 0, 3, []float64{0, 1, 2, 3}},\n\t\t}\n\t\tfor i, tc := range testCases {\n\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t\tfor j := range tc.dst {\n\t\t\t\tif tc.dst[j] != tc.want[j] {\n\t\t\t\t\tt.Errorf(\"Test case %v, index %v: Expected %v, got %v\", i, j, tc.want[j], tc.dst[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}",
    "19b2aa9741f579897b5c9a00dec4d507": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{1, 0.5, 1.0 / 3.0}},\n\t\t{[]float64{-1, 2, -3}, []float64{1, 1, 1}, []float64{-1, 0.5, -1.0 / 3.0}},\n\t} {\n\t\tcpy := make([]float64, len(test.dst))\n\t\tcopy(cpy, test.dst)\n\t\tMul(cpy, test.s)\n\t\tfor j := range cpy {\n\t\t\tif !closeEnough(cpy[j], test.want[j]) {\n\t\t\t\tt.Errorf(\"Test %d: Want %v but got %v\", i, test.want, cpy)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check that dst was modified in place.\n\t\tfor j := range cpy {\n\t\t\tif cpy[j] != test.dst[j] {\n\t\t\t\tt.Errorf(\"Test %d: dst modified in place\", i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc closeEnough(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-5\n}",
    "1ad9c3bf09c1a9d8050c0ee5abf9560b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\ts          []float64\n\t\twant       []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:       \"Equal length slices\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\ts:          []float64{4, 5, 6},\n\t\t\twant:       []float64{5, 7, 9},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Different length slices\",\n\t\t\tdst:        []float64{1, 2},\n\t\t\ts:          []float64{4, 5, 6},\n\t\t\twant:       nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif test.shouldPanic \u0026\u0026 r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t\tif !test.shouldPanic \u0026\u0026 r != nil {\n\t\t\t\t\tt.Errorf(\"The code paniced when it should not\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tAdd(test.dst, test.s)\n\n\t\t\tif !test.shouldPanic {\n\t\t\t\tfor i := range test.want {\n\t\t\t\t\tif test.dst[i] != test.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Different values at index %v, got %v, want %v\", i, test.dst[i], test.want[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c4cb9f8a7e88f9578abe483cfc61f88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx.\n\ttype testCase struct {\n\t\tinput []float64\n\t\twant  int\n\t}\n\n\tcases := []testCase{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{1, 2, 3, 4, 5, 5}, 4},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{-5, -4, -3, -2, -1}, 4},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0},\n\t\t{[]float64{1, math.NaN(), 3}, 0},\n\t\t{[]float64{math.NaN(), 1, 3}, 1},\n\t\t{[]float64{1, 3, math.NaN()}, 1},\n\t}\n\n\tfor i, c := range cases {\n\t\tgot := MaxIdx(c.input)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Test case %d failed: input = %v, want = %v, got = %v\", i+1, c.input, c.want, got)\n\t\t}\n\t}\n\n\t// Test case for panic when input slice is empty.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when the input slice was empty.\")\n\t\t}\n\t}()\n\n\tMaxIdx([]float64{})\n}",
    "1c5f72f2d5979de07ba7baa8000ca229": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"golang.org/x/exp/slices\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{[]float64{0, 0}, -1, 1, []float64{-1, 1}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t} {\n\t\tSpan(c.dst, c.l, c.u)\n\t\tif !slices.Equal(c.dst, c.want) {\n\t\t\tt.Errorf(\"Test %d - Got %v, want %v\", i, c.dst, c.want)\n\t\t}\n\t}\n\n\t// NaN cases\n\tnanCases := []float64{math.NaN(), -math.NaN()}\n\tfor _, nan := range nanCases {\n\t\tfor i, c := range []struct {\n\t\t\tdst []float64\n\t\t\tl   float64\n\t\t\tu   float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{[]float64{0, 0}, nan, 1, []float64{math.NaN(), 1}},\n\t\t\t{[]float64{0, 0, 0}, nan, 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t\t{[]float64{0, 0}, 0, nan, []float64{0, math.NaN()}},\n\t\t\t{[]float64{0, 0, 0}, 0, nan, []float64{0, math.NaN(), math.NaN()}},\n\t\t} {\n\t\t\tSpan(c.dst, c.l, c.u)\n\t\t\tfor j := range c.dst {\n\t\t\t\tgot := c.dst[j]\n\t\t\t\twant := c.want[j]\n\t\t\t\tif ! (math.IsNaN(got) \u0026\u0026 math.IsNaN(want))  {\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"Test %d.%d - Got %v, want %v\", i, j, c.dst, c.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Inf cases\n\tinfCases := []float64{math.Inf(1), math.Inf(-1)}\n\tfor _, inf := range infCases {\n\t\tfor i, c := range []struct {\n\t\t\tdst []float64\n\t\t\tl   float64\n\t\t\tu   float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{[]float64{0, 0}, inf, 1, []float64{inf, 1}},\n\t\t\t{[]float64{0, 0, 0}, inf, 1, []float64{inf, inf, 1}},\n\t\t\t{[]float64{0, 0}, 0, inf, []float64{0, inf}},\n\t\t\t{[]float64{0, 0, 0}, 0, inf, []float64{0, inf, inf}},\n\t\t\t{[]float64{0, 0}, inf, inf, []float64{inf, inf}},\n\t\t\t{[]float64{0, 0, 0}, inf, inf, []float64{inf, inf, inf}},\n\t\t} {\n\t\t\tSpan(c.dst, c.l, c.u)\n\t\t\tfor j := range c.dst {\n\t\t\t\tgot := c.dst[j]\n\t\t\t\twant := c.want[j]\n\t\t\t\tif ! (math.IsInf(got, 0) \u0026\u0026 math.IsInf(want, 0))  {\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"Test %d.%d - Got %v, want %v\", i, j, c.dst, c.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "1ca3cc76bc3280f4036eb5e02262113a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\texp []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0}, 1, -1, []float64{1, 0, -1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, -1, []float64{1, 0.5, 0, -0.5, -1}},\n\t}\n\tfor i, tc := range testCases {\n\t\tSpan(tc.dst, tc.l, tc.u)\n\t\tfor j := 0; j \u003c len(tc.dst); j++ {\n\t\t\tif tc.dst[j] != tc.exp[j] {\n\t\t\t\tt.Errorf(\"Test case %v failed: got %v, want %v\", i, tc.dst, tc.exp)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\texp []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 1, math.NaN(), []float64{1, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, 1, math.NaN(), []float64{1, math.NaN(), math.NaN()}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}},\n\t}\n\tfor i, tc := range nanCases {\n\t\tSpan(tc.dst, tc.l, tc.u)\n\t\tfor j := 0; j \u003c len(tc.dst); j++ {\n\t\t\tif tc.dst[j] != tc.exp[j] {\n\t\t\t\tt.Errorf(\"Test case %v failed: got %v, want %v\", i, tc.dst, tc.exp)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}",
    "1d6ce67971a15d6b9f8427cb2884ae20": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1e10, 1, -1e10}, 1},\n\t}\n\n\t// Iterate through test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within acceptable tolerance\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "1fdd45a9c18c7c68f389281bb34338b8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{10, 0, 10, 0.1, 1},\n\t\t{10, 0, 10, 9.9, 9},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\n\t\t// Cases with l \u003e u\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "1fe92cb8cfb822ebbb0cb855c24a048d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, math.NaN(), 0},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, math.NaN(), 0},\n\t} {\n\t\tgot := NearestIdx(c.s, c.v)\n\t\tif got != c.i {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v, want %v\", c.s, c.v, got, c.i)\n\t\t}\n\t}\n}",
    "200507033a4953d93b579d69ed390e88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{0, 1, 2, 3}, wantIdx: 3},\n\t\t{s: []float64{3, 2, 1, 0}, wantIdx: 0},\n\t\t{s: []float64{0, 1, 1, 0}, wantIdx: 1},\n\t\t{s: []float64{0, 1, 2, math.NaN()}, wantIdx: 2},\n\t\t{s: []float64{math.NaN(), 0, 1, 2}, wantIdx: 2},\n\t\t{s: []float64{}, wantPanic: true},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != c.wantPanic {\n\t\t\t\t\tt.Errorf(\"Got panic=%v, want panic=%v\", gotPanic, c.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MaxIdx(c.s)\n\t\t\tif gotIdx != c.wantIdx {\n\t\t\t\tt.Errorf(\"Got: %v, want: %v\", gotIdx, c.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n}",
    "20b1c7750ca546302f3faea997b5b38d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.9, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.4, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.6, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 0.9, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 0.9, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.1, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.4, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.6, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 0.9, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 100, l: -1, u: 1, v: -1.1, want: 0},\n\t\t{n: 100, l: -1, u: 1, v: 1.1, want: 99},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"unexpected index for test %d: got: %d want: %d\", i, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanSpecial(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 1, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), want: 1},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 1},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 2},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, want: 1},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: 0, want: 2},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"unexpected index for test %d: got: %d want: %d\", i, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{-1, 0, 1} {\n\t\ttest.Panic(t, \"NearestIdxForSpan\", func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t}\n}",
    "210f3b2cc25d3852c35a761e34477c91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Normal case: l \u003c u, len(dst) \u003e 2\n\t// 2. Edge case: l == u\n\t// 3. Edge case: len(dst) = 2\n\t// 4. Special case: l is NaN\n\t// 5. Special case: u is NaN\n\t// 6. Special case: both l and u are +Inf\n\t// 7. Special case: both l and u are -Inf\n\t// 8. Special case: l is +Inf\n\t// 9. Special case: u is +Inf\n\t// 10. Special case: l is -Inf\n\t// 11. Special case: u is -Inf\n\n\t// Test case 1: Normal case: l \u003c u, len(dst) \u003e 2\n\tdst := make([]float64, 5)\n\tl := 0.0\n\tu := 10.0\n\texpected := []float64{0.0, 2.5, 5.0, 7.5, 10.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 1 failed: expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 2: Edge case: l == u\n\tdst = make([]float64, 5)\n\tl = 1.0\n\tu = 1.0\n\texpected = []float64{1.0, 1.0, 1.0, 1.0, 1.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 2 failed: expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 3: Edge case: len(dst) = 2\n\tdst = make([]float64, 2)\n\tl = 0.0\n\tu = 1.0\n\texpected = []float64{0.0, 1.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 3 failed: expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 4: Special case: l is NaN\n\tdst = make([]float64, 5)\n\tl = math.NaN()\n\tu = 1.0\n\tSpan(dst, l, u)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Test case 4 failed: expected NaN at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != u {\n\t\tt.Errorf(\"Test case 4 failed: expected %v at last index, got %v\", u, dst[len(dst)-1])\n\t}\n\n\t// Test case 5: Special case: u is NaN\n\tdst = make([]float64, 5)\n\tl = 0.0\n\tu = math.NaN()\n\tSpan(dst, l, u)\n\tif dst[0] != l {\n\t\tt.Errorf(\"Test case 5 failed: expected %v at first index, got %v\", l, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Test case 5 failed: expected NaN at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 6: Special case: both l and u are +Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(1)\n\tu = math.Inf(1)\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 6 failed: expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 7: Special case: both l and u are -Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(-1)\n\tu = math.Inf(-1)\n\texpected = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 7 failed: expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 8: Special case: l is +Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(1)\n\tu = 0.0\n\tSpan(dst, l, u)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Test case 8 failed: expected +Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != u {\n\t\tt.Errorf(\"Test case 8 failed: expected %v at last index, got %v\", u, dst[len(dst)-1])\n\t}\n\n\t// Test case 9: Special case: u is +Inf\n\tdst = make([]float64, 5)\n\tl = 0.0\n\tu = math.Inf(1)\n\tSpan(dst, l, u)\n\tif dst[0] != l {\n\t\tt.Errorf(\"Test case 9 failed: expected %v at first index, got %v\", l, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Test case 9 failed: expected +Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 10: Special case: l is -Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(-1)\n\tu = 0.0\n\tSpan(dst, l, u)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Test case 10 failed: expected -Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != u {\n\t\tt.Errorf(\"Test case 10 failed: expected %v at last index, got %v\", u, dst[len(dst)-1])\n\t}\n\n\t// Test case 11: Special case: u is -Inf\n\tdst = make([]float64, 5)\n\tl = 0.0\n\tu = math.Inf(-1)\n\tSpan(dst, l, u)\n\tif dst[0] != l {\n\t\tt.Errorf(\"Test case 11 failed: expected %v at first index, got %v\", l, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Test case 11 failed: expected -Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n}\n",
    "213b596d12483bcacb7cf3ba03419666": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-10, -1, 0, 1, 3, 10}\n\tn := len(s)\n\tfor i := 1; i \u003c n; i++ {\n\t\tv := 0.5 * (s[i-1] + s[i])\n\t\tj := Within(s, v)\n\t\tif j != i-1 {\n\t\t\tt.Errorf(\"Index mismatch: %d != %d\", j, i-1)\n\t\t}\n\t}\n\t// Test edges\n\tj := Within(s, s[0]+tol)\n\tif j != 0 {\n\t\tt.Errorf(\"Edge case: %d != %d\", j, 0)\n\t}\n\tj = Within(s, s[n-1]-tol)\n\tif j != n-2 {\n\t\tt.Errorf(\"Edge case: %d != %d\", j, n-2)\n\t}\n\t// Test out of bounds\n\tj = Within(s, s[0]-1)\n\tif j != -1 {\n\t\tt.Errorf(\"Out of bounds: %d != %d\", j, -1)\n\t}\n\tj = Within(s, s[n-1]+1)\n\tif j != -1 {\n\t\tt.Errorf(\"Out of bounds: %d != %d\", j, -1)\n\t}\n\t// Test NaN\n\tj = Within(s, math.NaN())\n\tif j != -1 {\n\t\tt.Errorf(\"NaN: %d != %d\", j, -1)\n\t}\n}",
    "226111ab2928dc905e44814f6f9015be": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slice contents\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 1},\n\t\t{[]float64{}, 2, 1},\n\t\t{[]float64{}, math.Inf(1), 1},\n\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3}, 2, 3.7416573867739413},\n\t\t{[]float64{-1, -2, -3}, 2, 3.7416573867739413},\n\t\t{[]float64{1, -2, 3}, 2, 3.7416573867739413},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\n\t\t// Other L values\n\t\t{[]float64{1, 2, 3}, 3, 3.3019272488946265},\n\t\t{[]float64{1, 2, 3}, 4, 3.140817739325432},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the norm using the function\n\t\tactual := Norm(tc.s, tc.L)\n\n\t\t// Check if the result is within a small tolerance of the expected value\n\t\tif !close(actual, tc.expected) {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}\n\n// close checks if two float64 values are close to each other within a small tolerance\nfunc close(a, b float64) bool {\n\ttol := 1e-10\n\treturn math.Abs(a-b) \u003c tol\n}",
    "22bd207af381f87686834da5d600c1ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Single element slice\n\t// - Multiple elements, nearest at beginning\n\t// - Multiple elements, nearest at end\n\t// - Multiple elements, nearest in middle\n\t// - Multiple nearest with same value, return first\n\t// - NaN values in slice\n\t// - NaN as target value\n\t// - Infinite target values\n\n\tt.Run(\"Empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\ts := []float64{}\n\t\tNearestIdx(s, 0)\n\t})\n\n\tt.Run(\"Single element slice\", func(t *testing.T) {\n\t\ts := []float64{1.0}\n\t\tgot := NearestIdx(s, 2.0)\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 2.0) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Multiple elements, nearest at beginning\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, 0.5)\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 0.5) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Multiple elements, nearest at end\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, 3.5)\n\t\twant := 2\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 3.5) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Multiple elements, nearest in middle\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, 2.2)\n\t\twant := 1\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 2.2) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Multiple nearest with same value, return first\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, 2.0)\n\t\twant := 1\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 2.0) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NaN values in slice\", func(t *testing.T) {\n\t\ts := []float64{1.0, math.NaN(), 3.0}\n\t\tgot := NearestIdx(s, 2.0)\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 2.0) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NaN as target value\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, math.NaN())\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, NaN) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Infinite target value\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, math.Inf(1))\n\t\twant := 2\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, Inf(1)) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Negative infinite target value\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tgot := NearestIdx(s, math.Inf(-1))\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, Inf(-1)) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n}",
    "252ed22fd9f5304c94adacddc06a1137": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"No NaNs\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Single NaN\",\n\t\t\ts:    []float64{1, 2, math.NaN(), 4},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple NaNs\",\n\t\t\ts:    []float64{math.NaN(), 2, math.NaN(), 4},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "253f0b1f1c4b549501d40eca15d5eced": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{10, -5, 5, 2.5, 7},\n\t\t{11, -5, 5, -2.5, 3},\n\t\t{11, -5, 5, 2.5, 8},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.want, got, \"For n = %d, l = %f, u = %f, and v = %f\", tc.n, tc.l, tc.u, tc.v)\n\t}\n\n\t// Test cases for v outside (l, u) and (u, l).\n\ttestCasesOutside := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor _, tc := range testCasesOutside {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.want, got, \"For n = %d, l = %f, u = %f, and v = %f (outside)\", tc.n, tc.l, tc.u, tc.v)\n\t}\n\n\t// Test cases for special values of v (Inf, -Inf, NaN).\n\ttestCasesSpecialV := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t}\n\n\tfor _, tc := range testCasesSpecialV {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.want, got, \"For n = %d, l = %f, u = %f, and v = %f (special v)\", tc.n, tc.l, tc.u, tc.v)\n\t}\n\n\t// Test cases for special values of l and u (Inf, -Inf, NaN).\n\ttestCasesSpecialLU := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 5, 0},\n\t\t{11, math.Inf(1), math.Inf(-1), 5, 5},\n\t\t{10, math.NaN(), 5, 5, 9},\n\t\t{10, 5, math.NaN(), 5, 0},\n\t}\n\n\tfor _, tc := range testCasesSpecialLU {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.want, got, \"For n = %d, l = %f, u = %f, and v = %f (special l/u)\", tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "25ce682804023f9a12509c8ac3f9216a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are very large\n\t// - l \u003e u\n\t// - l == u\n\t// - l or u is NaN\n\t// - l or u is Inf\n\n\t// len(dst) \u003c 2\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic when len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}()\n\n\t// l and u are regular\n\tdst := make([]float64, 10)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, expected %v\", dst, dst[i], expected[i])\n\t\t}\n\t}\n\n\t// l and u are very large\n\tdst = make([]float64, 10)\n\tSpan(dst, -1e10, 1e10)\n\texpected = []float64{-1e10, -8e9, -6e9, -4e9, -2e9, 0, 2e9, 4e9, 6e9, 8e9}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, -1e10, 1e10) = %v, expected %v\", dst, dst[i], expected[i])\n\t\t}\n\t}\n\n\t// l \u003e u\n\tdst = make([]float64, 10)\n\tSpan(dst, 1, 0)\n\texpected = []float64{1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, 1, 0) = %v, expected %v\", dst, dst[i], expected[i])\n\t\t}\n\t}\n\n\t// l == u\n\tdst = make([]float64, 10)\n\tSpan(dst, 1, 1)\n\texpected = []float64{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, 1, 1) = %v, expected %v\", dst, dst[i], expected[i])\n\t\t}\n\t}\n\n\t// l or u is NaN\n\tdst = make([]float64, 10)\n\tSpan(dst, math.NaN(), 1)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, expected NaN\", dst, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, expected 1\", dst, dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 10)\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, expected 0\", dst, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, expected NaN\", dst, dst[i])\n\t\t}\n\t}\n\n\t// l or u is Inf\n\tdst = make([]float64, 10)\n\tSpan(dst, math.Inf(-1), math.Inf(0))\n\texpected = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, Inf(-1), Inf(0)) = %v, expected %v\", dst, dst[i], expected[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 10)\n\tSpan(dst, math.Inf(0), 1)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsInf(dst[i], 0) {\n\t\t\tt.Errorf(\"Span(%v, Inf(0), 1) = %v, expected Inf(0)\", dst, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Span(%v, Inf(0), 1) = %v, expected 1\", dst, dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 10)\n\tSpan(dst, 0, math.Inf(0))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Span(%v, 0, Inf(0)) = %v, expected 0\", dst, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsInf(dst[i], 0) {\n\t\t\tt.Errorf(\"Span(%v, 0, Inf(0)) = %v, expected Inf(0)\", dst, dst[i])\n\t\t}\n\t}\n}\n",
    "26a35a13561a9794e4226386d82986f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tr := []float64{5, 6, 7, 8}\n\n\ttol := 1e-14\n\n\tif got, want := Distance(s, r, 1), 16.0; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L1 norm incorrect. Want %v, got %v\", want, got)\n\t}\n\tif got, want := Distance(s, r, 2), math.Sqrt(32); math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L2 norm incorrect. Want %v, got %v\", want, got)\n\t}\n\tif got, want := Distance(s, r, math.Inf(1)), 4.0; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L-inf norm incorrect. Want %v, got %v\", want, got)\n\t}\n}\n",
    "273f0a878b8e6f3562e9f28f044dc394": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases for SumCompensated.\n\t// Each test case consists of a slice of float64 values and the expected sum.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1e10, 1, -1e10}, 1},\n\t}\n\n\t// Iterate over the test cases.\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the calculated sum is within the acceptable tolerance.\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "275967bd3d165d6f5e107ac14d6101cc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// expected: the expected index\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%v, u=%v, v=%v\", i, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "27980de3e3145bbf91a6bce006ce4d0c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 4, 2, 3}, 0},\n\t\t{[]float64{1, 2, 3, 1}, 0},\n\t\t{[]float64{1, math.NaN(), 2, 3}, 0},\n\t\t{[]float64{math.NaN(), 1, 2, 3}, 1},\n\t\t{[]float64{1, 2, math.NaN(), 3}, 0},\n\t\t{[]float64{1, 2, 3, math.NaN()}, 0},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: Input %v, want %v, got %v\", i, test.s, test.want, got)\n\t\t}\n\t}\n}",
    "2799b7f6d5b93f89992e821705bebff0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of points in the span\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "28520fc1a5692c9c87d9da5daba3a32d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 2, 1, 0}, 3},\n\t\t{[]float64{1, math.NaN(), 2, 3}, 1},\n\t\t{[]float64{math.NaN(), 1, 2, 3}, 0},\n\t\t{[]float64{1, 2, math.NaN(), math.NaN()}, 2},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: got %v, want %v\", i, got, test.want)\n\t\t}\n\t}\n}",
    "288f617c62576d3f1a88038094c17195": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 4, 2, 3}, 0},\n\t\t{[]float64{1, math.NaN(), 2, 3}, 0},\n\t\t{[]float64{math.NaN(), 1, 2, 3}, 1},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"case %d: got:%d want:%d\", i, got, test.want)\n\t\t}\n\t}\n}",
    "28ebcdc9ba99fb1af3edf4495a630a68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 2, 1, 0}, 3},\n\t\t{[]float64{1, math.NaN(), 2, 1}, 0},\n\t\t{[]float64{math.NaN(), 1, math.NaN(), 2, 1}, 1},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: got %v, want %v\", i, got, test.want)\n\t\t}\n\t}\n}",
    "28f9800a7a4182bbc7af30b587ca4260": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 1, 15},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 0},\n\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3, 4, 5}, 2, math.Sqrt(55)},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 2, math.Sqrt(55)},\n\t\t{[]float64{0, 0, 0, 0, 0}, 2, 0},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t{[]float64{-1, -2, -3, -4, -5}, math.Inf(1), 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(1), 0},\n\n\t\t// L = 3\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif !closeEnough(actual, tc.expected, 1e-10) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare floats for equality within a tolerance\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}",
    "29038392105c5bc234f760656fcb22e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{1, 2, 3, 4, 5, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{math.NaN(), 4, 3, 2, 1}, 1},\n\t\t{[]float64{4, 3, math.NaN(), 2, 1}, 0},\n\t\t{[]float64{4, 3, 2, 1, math.NaN()}, 0},\n\t} {\n\t\tgot := MaxIdx(c.s)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", c.s, got, c.want)\n\t\t}\n\t}\n}",
    "2912766f5fa08aadae1282284cedee38": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with two elements\n\t// 4. Slice with odd number of elements\n\t// 5. Slice with even number of elements\n\t// 6. l \u003e u\n\t// 7. l = u\n\t// 8. l = NaN\n\t// 9. u = NaN\n\t// 10. l = Inf\n\t// 11. u = Inf\n\t// 12. l = -Inf\n\t// 13. u = -Inf\n\n\t// Test case 1: Empty slice\n\t{\n\t\tvar dst []float64\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 7: l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 8: l = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// Test case 9: u = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i+1]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 10: l = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// Test case 11: u = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i+1], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 12: l = -Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// Test case 13: u = -Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i+1], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "29321ecf0482984dd39ea3b7ce875e3b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with one element (should panic)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l or u is Inf\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with slice with one element\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 0) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 0) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 0) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "29360998acd13b342952710bb8afacf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with NaN values\n\t// - Slice with Inf values\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tassertPanic(t, \"Span(dst, 0, 1)\", func() { Span(dst, 0, 1) })\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tassertPanic(t, \"Span(dst, 0, 1)\", func() { Span(dst, 0, 1) })\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\tassertFloatsEqual(t, dst, []float64{0, 1})\n\t}\n\n\t// Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\tassertFloatsEqual(t, dst, []float64{0, 0.25, 0.5, 0.75, 1})\n\t}\n\n\t// Slice with NaN values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tassertFloatsEqual(t, dst, []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1})\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tassertFloatsEqual(t, dst, []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()})\n\t}\n\n\t// Slice with Inf values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tassertFloatsEqual(t, dst, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)})\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\tassertFloatsEqual(t, dst, []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)})\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tassertFloatsEqual(t, dst, []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)})\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), 0)\n\t\tassertFloatsEqual(t, dst, []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0})\n\t}\n}\n\nfunc assertPanic(t *testing.T, name string, f func()) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"%s: did not panic\", name)\n\t\t}\n\t}()\n\tf()\n}\n\nfunc assertFloatsEqual(t *testing.T, a, b []float64) {\n\tif len(a) != len(b) {\n\t\tt.Errorf(\"Floats slices have different lengths: %d != %d\", len(a), len(b))\n\t\treturn\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\tt.Errorf(\"Floats differ at index %d: %v != %v\", i, a[i], b[i])\n\t\t\treturn\n\t\t}\n\t}\n}\n",
    "295ed50fd8578a673bb2e3fcc8350d9c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, multiple elements.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e100, 1, -1e100}, 1.0}, // Test case for cancellation error\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "29b9b1c0f0123acdc4bd5a5dcb577350": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx function\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{-5, -4, -3, -2, -1}, 4},\n\t\t{[]float64{1, 2, 3, math.NaN(), 4, 5}, 3},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5, 3}, 2},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, tc := range testCases {\n\t\t// Call the MaxIdx function\n\t\tactual := MaxIdx(tc.input)\n\n\t\t// Check if the result is as expected\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n\n\t// Test case for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MaxIdx([]float64{}) did not panic for empty slice\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}\n",
    "2a86c48c0b34e51f7e81c07ad226cfc8": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\tt           []float64\n\t\twant        []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:        \"length mismatch\",\n\t\t\tdst:         []float64{0},\n\t\t\ts:           []float64{0, 1},\n\t\t\tt:           []float64{0, 1},\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"dst length mismatch\",\n\t\t\tdst:         []float64{0, 1},\n\t\t\ts:           []float64{0, 1},\n\t\t\tt:           []float64{0, 1},\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"basic subtraction\",\n\t\t\tdst:         make([]float64, 3),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5, 6},\n\t\t\twant:        []float64{-3, -3, -3},\n\t\t\tshouldPanic: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.shouldPanic {\n\t\t\t\tassert.Panics(t, func() { SubTo(tt.dst, tt.s, tt.t) })\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tt.want, SubTo(tt.dst, tt.s, tt.t))\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "2adf7865b18d991dea53dc6df7a87df3": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty slice\", args{[]float64{}}, 1},\n\t\t{\"one element\", args{[]float64{2}}, 0.5},\n\t\t{\"multiple elements\", args{[]float64{2, 2, 2}}, 0.125},\n\t\t{\"zero element\", args{[]float64{2, 0, 2}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c01766532bd63aa2abc38cc94eb14e6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"LIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"UIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"LandUAreBothInfWithSameSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf\n\tt.Run(\"LIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is Inf\n\tt.Run(\"UIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"LEqualsU\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 1.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != l {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "2c0b11a375fc921998c1c9c945a1e821": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "2d185405319948d8cbedc6a6a50ab7fc": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\ts          []float64\n\t\tt          []float64\n\t\twant       []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:       \"DivTo_Panic_LengthMismatch1\",\n\t\t\tdst:        []float64{0, 0},\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{1, 2, 3},\n\t\t\twant:       nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"DivTo_Panic_LengthMismatch2\",\n\t\t\tdst:        []float64{0, 0, 0},\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{1, 2},\n\t\t\twant:       nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"DivTo_Success\",\n\t\t\tdst:        make([]float64, 3),\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{1, 2, 3},\n\t\t\twant:       []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"DivTo_Success_DifferentValues\",\n\t\t\tdst:        make([]float64, 3),\n\t\t\ts:          []float64{2, 4, 6},\n\t\t\tt:          []float64{1, 2, 3},\n\t\t\twant:       []float64{2, 2, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.expectPanic {\n\t\t\t\tassert.Panics(t, func() { DivTo(test.dst, test.s, test.t) })\n\t\t\t} else {\n\t\t\t\tgot := DivTo(test.dst, test.s, test.t)\n\t\t\t\tassert.Equal(t, test.want, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d9592ac59a1a355ee03def9ab0094c3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.75, 3},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0.5, 7},\n\t\t{10, 1, -1, -0.5, 7},\n\t\t{10, 1, -1, 0.5, 2},\n\t\t{10, -1, -1, -1, 0},\n\t\t{10, 1, 1, 1, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for Inf and NaN.\n\tinfCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, math.Inf(1), 0, 0, 9},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), 0, 0, 0},\n\t\t{10, 0, math.Inf(-1), 0, 9},\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t}\n\n\tfor _, tc := range infCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "2e64769798a5cc94d729f8d90e29adfd": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\tc := 2.0\n\ts := []float64{1, 2, 3}\n\texpected := []float64{2, 4, 6}\n\tScaleTo(dst, c, s)\n\tassert.Equal(t, expected, dst)\n}\n\nfunc TestScaleToPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 2)\n\tc := 2.0\n\ts := []float64{1, 2, 3}\n\tScaleTo(dst, c, s)\n}",
    "2e8f04b46a7cc612ea38ffd806e2eb04": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    2.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{2.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-3.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSame\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseDifferent\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0.0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseLSame\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseUSame\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{-3.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-10) {\n\t\t\t\t\tt.Errorf(\"Mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\nfunc closeEnough(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c tol\n}",
    "2f1a12d46d26c88d281ab17f5d43f813": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.2,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive Infinity Value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Infinity Value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Normal Case\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.3,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Duplicate Values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 2, 3, 4, 5},\n\t\t\t\tv: 2.3,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tt.args.s == nil {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "3089a094a99d51ef78034874e78c9a53": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Log(math.Exp(1)+math.Exp(2)+math.Exp(3)+math.Exp(4)+math.Exp(5))},\n\t\t{[]float64{100, 100, 100}, 100 + math.Log(3)},\n\t\t{[]float64{-100, -100, -100}, -100 + math.Log(3)},\n\t\t{[]float64{1, 1e10, 1, 1}, 1e10 + math.Log(3+math.Exp(-9999))},\n\t\t{[]float64{math.Inf(1), 1, 2, 3}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), 1, 2, 3}, math.Log(math.Exp(1)+math.Exp(2)+math.Exp(3))},\n\t} {\n\t\tactual := LogSumExp(test.s)\n\t\tif !EqualApprox([]float64{actual}, []float64{test.expected}, tol) {\n\t\t\tt.Errorf(\"Test %d: Expected %v, but got %v\", i, test.expected, actual)\n\t\t}\n\t}\n}",
    "30dee26f57fa90a8a53794231ce2c69e": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases.\n\ttestCases := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{nil, true},\n\t\t{[][]float64{}, true},\n\t\t{[][]float64{{}}, true},\n\t\t{[][]float64{{1, 2, 3}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{[][]float64{{}, {}}, true},\n\t\t{[][]float64{{1}, {2}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5}}, false},\n\t\t{[][]float64{{1, 2}, {3, 4, 5}}, false},\n\t\t{[][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}}, false},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := EqualLengths(tc.slices...)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: EqualLengths(%v) == %v, want %v\", i, tc.slices, got, tc.want)\n\t\t}\n\t}\n}",
    "310cb20bedefcc5ffc221258026fc89f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroSpan\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-15) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LeftInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"RightInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) \u0026\u0026 !math.IsNaN(tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t} else if !EqualApprox(got, tc.want, 1e-15) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2\n\tt.Run(\"PanicShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n",
    "315d479ff232fd65956f9b3da7e0e12b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 1, 0, 0, 1},\n\t\t{2, 1, 0, 1, 0},\n\n\t\t// Cases with NaN\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\n\t\t// Cases with Inf\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\n\t\t// Odd vs. even n with infinite bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 5, 2},\n\t\t{6, math.Inf(-1), math.Inf(1), 5, 3},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) returned %d, expected %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, idx, tc.expectedIdx)\n\t\t}\n\t}\n}",
    "31da813b746c7eabd381b135198484d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "32bb0402b219e3687bbce36b83414407": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -1.1, -1},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -1, 0},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -0.6, 0},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -0.4, 1},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 1.1, -1},\n\t} {\n\t\ti := Within(c.s, c.v)\n\t\tif i != c.i {\n\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", c.s, c.v, i, c.i)\n\t\t}\n\t}\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{0, 1}, math.NaN(), -1},\n\t\t{[]float64{0, math.NaN()}, 0.5, 0},\n\t} {\n\t\ti := Within(c.s, c.v)\n\t\tif i != c.i {\n\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", c.s, c.v, i, c.i)\n\t\t}\n\t}\n\n\t// Test that the original slice is not modified.\n\ts := []float64{0, 1}\n\tWithin(s, 0.5)\n\tif !sort.Float64sAreSorted(s) || len(s) != 2 || s[0] != 0 || s[1] != 1 {\n\t\tt.Errorf(\"Within modified the input slice\")\n\t}\n}\n\nfunc TestWithinPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1, 0}, 0.5)\n}",
    "345c9a3be0ead2a6bb443889e1480273": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with Inf values\n\t// - Slice with NaN values\n\n\t// Test case 1: Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\twant := []float64{0, 1}\n\t\tSpan(dst, 0, 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", []float64{}, 0, 1, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tSpan(dst, 0, 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", []float64{}, 0, 1, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with Inf values\n\t{\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", []float64{}, math.Inf(1), math.Inf(1), dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: Slice with NaN values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", []float64{}, math.NaN(), math.NaN(), dst, []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()})\n\t\t\t}\n\t\t}\n\t}\n}",
    "34830695dc149b4a5cc409e9b2a8f053": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1e100, 1, -1e100}, 1},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t}\n\n\t// Iterate through test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within acceptable tolerance\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}",
    "34c0d99226cdf4b4227be15a1f145e68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// First, test all the panicky conditions\n\n\t// n \u003c 2 should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n\t// Test cases where l == u\n\tfor _, n := range []int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11} {\n\t\tfor _, l := range []float64{-1, 0, 1, 2} {\n\t\t\ttestNearestIdxForSpan(t, n, l, l, -1, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, l, 0, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, l, 0.5, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, l, 1, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, l, 2, 0, tol)\n\t\t}\n\t}\n\n\t// Test cases where l \u003c u\n\tfor _, n := range []int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11} {\n\t\tfor _, l := range []float64{-1, 0, 1, 2} {\n\t\t\tu := l + 1\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -2, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -1, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, 0, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, 0.5, n/2, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, 1, n - 1, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, 2, n - 1, tol)\n\t\t}\n\t}\n\n\t// Test cases where l \u003e u\n\tfor _, n := range []int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11} {\n\t\tfor _, l := range []float64{-1, 0, 1, 2} {\n\t\t\tu := l - 1\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -2, n - 1, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -1, n - 1, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, 0, n - 1, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -0.5, n/2, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -1, 0, tol)\n\t\t\ttestNearestIdxForSpan(t, n, l, u, -2, 0, tol)\n\t\t}\n\t}\n\n\t// Test some edge cases around infinity\n\ttestNearestIdxForSpan(t, 2, math.Inf(-1), math.Inf(1), 0, 0, tol)\n\ttestNearestIdxForSpan(t, 2, math.Inf(1), math.Inf(-1), 0, 1, tol)\n\ttestNearestIdxForSpan(t, 3, math.Inf(-1), math.Inf(1), 0, 1, tol)\n\ttestNearestIdxForSpan(t, 3, math.Inf(1), math.Inf(-1), 0, 0, tol)\n\n}\n\nfunc testNearestIdxForSpan(t *testing.T, n int, l, u, v float64, truth int, tol float64) {\n\tnidx := NearestIdxForSpan(n, l, u, v)\n\tif nidx != truth {\n\t\tt.Errorf(\"Nearest element for n = %v, l = %v, u = %v and v = %v should be %v but got %v\",\n\t\t\tn, l, u, v, truth, nidx)\n\t}\n}\n",
    "34ff38c1847746783a7293319ecf85f8": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases for Find function.\n\ttestCases := []struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:      \"EmptySlice\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{},\n\t\t\tk:         1,\n\t\t\twantInds:  nil,\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:      \"ZeroElementsRequested\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"AllElementsSatisfy\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{0, 1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"SomeElementsSatisfy\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(f float64) bool { return f \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{2, 3},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"KGreaterThanFound\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(f float64) bool { return f \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         3,\n\t\t\twantInds:  nil,\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:      \"KLessThanFound\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(f float64) bool { return f \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         1,\n\t\t\twantInds:  []int{2},\n\t\t\twantErr:   nil,\n\t\t},\n\t}\n\n\t// Run test cases.\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\t// Check error.\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Find() returned unexpected error: %v\", gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"Find() did not return expected error: %v\", tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Find() returned wrong error: got %v, want %v\", gotErr, tc.wantErr)\n\t\t\t}\n\n\t\t\t// Check indices.\n\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find() returned indices of incorrect length: got %d, want %d\", len(gotInds), len(tc.wantInds))\n\t\t\t} else {\n\t\t\t\tfor i := range gotInds {\n\t\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\t\tt.Errorf(\"Find() returned incorrect index at position %d: got %d, want %d\", i, gotInds[i], tc.wantInds[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "356d6aedd0b043c46f7fcf7e3ff1cbc9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// L1 norm\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 1, 15},\n\t\t{[]float64{1, -2, 3, -4, 5}, 1, 15},\n\n\t\t// L2 norm\n\t\t{[]float64{1, 2, 3, 4, 5}, 2, math.Sqrt(55)},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 2, math.Sqrt(55)},\n\t\t{[]float64{1, -2, 3, -4, 5}, 2, math.Sqrt(55)},\n\n\t\t// L-infinity norm\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t{[]float64{-1, -2, -3, -4, -5}, math.Inf(1), 5},\n\t\t{[]float64{1, -2, 3, -4, 5}, math.Inf(1), 5},\n\n\t\t// Other L-norms\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{1, 2, 3, 4}, 4, math.Pow(354, 1.0/4.0)},\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif math.Abs(got-tc.want) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Test case %d failed: Norm(%v, %v) = %v, want %v\", i, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "358cb99636fbb9e701ee9e0d5a0edac1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 10, 9},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, -1, 9},\n\t\t{10, 1, 0, 10, 0},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, 1, 1, 1, 0},\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.NaN(), 0, 0, 9},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), 0, math.Inf(1), 0},\n\t\t{10, 0, math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, math.Inf(-1), 0, 0, 9},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, math.Inf(1), 0, 0, 0},\n\t\t{10, 0, math.Inf(-1), 0, 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Case %d - Want: %v, Have %v\\n\", i, test.want, have)\n\t\t}\n\t}\n\t// Test for equidistant.\n\tfor n := 2; n \u003c= 10; n++ {\n\t\tfor i := 0; i \u003c n; i++ {\n\t\t\tv := float64(i) / float64(n-1)\n\t\t\thave := NearestIdxForSpan(n, 0, 1, v)\n\t\t\tif i != have {\n\t\t\t\tt.Errorf(\"n = %v, Want %v, Have %v\\n\", n, i, have)\n\t\t\t}\n\t\t}\n\t}\n\t// Test near boundaries.\n\tfor n := 2; n \u003c= 10; n++ {\n\t\tfor _, delta := range []float64{1e-14, 1e-15, 1e-16} {\n\t\t\tfor i := 0; i \u003c n; i++ {\n\t\t\t\tv := float64(i)/float64(n-1) + delta\n\t\t\t\thave := NearestIdxForSpan(n, 0, 1, v)\n\t\t\t\twant := i\n\t\t\t\tif i \u003e 0 \u0026\u0026 i \u003c n-1 {\n\t\t\t\t\twant += 1\n\t\t\t\t}\n\t\t\t\tif want != have {\n\t\t\t\t\tt.Errorf(\"n = %v, delta = %v, Want %v, Have %v\\n\", n, delta, want, have)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "35e4e0a40afe6a5e168783bb39d5cb1d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 3, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.6, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, 3, 1},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, math.NaN(), 0},\n\t\t{[]float64{math.Inf(-1), -1, 1, math.Inf(1)}, math.Inf(1), 3},\n\t\t{[]float64{math.Inf(-1), -1, 1, math.Inf(1)}, math.Inf(-1), 0},\n\t} {\n\t\tgot := NearestIdx(c.s, c.v)\n\t\tif got != c.i {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v, want %v\", c.s, c.v, got, c.i)\n\t\t}\n\t}\n\n\t// Test panicking on zero length slice.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0)\n}",
    "36b46310cb1e47d0cbd345cbb5e97feb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{5, 1, 5, 3, 2},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Can't guarantee exact halfway\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "3777da618e67948fe1f0988381d359df": "package floats\n\nimport \"testing\"\n\nfunc TestSumCompensated(t *testing.T) {\n\t// TODO: Add test cases for SumCompensated.\n}",
    "382421897ddac293a7eaf5803663f8ba": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestSub(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\ts:    []float64{1, 3, 5, 7, 9},\n\t\t\tt:    []float64{2, 4, 6, 8, 10},\n\t\t\twant: []float64{-1, -1, -1, -1, -1},\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, -3, 5, -7, 9},\n\t\t\tt:    []float64{2, -4, 6, -8, 10},\n\t\t\twant: []float64{-1, 1, -1, 1, -1},\n\t\t},\n\t\t{\n\t\t\ts:    []float64{0, 0, 0, 0, 0},\n\t\t\tt:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: []float64{-1, -2, -3, -4, -5},\n\t\t},\n\t} {\n\t\tdst := make([]float64, len(test.s))\n\t\tcopy(dst, test.s)\n\t\tSub(dst, test.t)\n\t\tif !testlapack.EqualApprox(dst, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Case %v: unexpected result. Want %v, got %v\", i, test.want, dst)\n\t\t}\n\t}\n}",
    "3843bad289f379e1a739b632988424fb": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantIndsN int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"NilInds\",\n\t\t\tinds:      nil,\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"EmptyInds\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"KZero\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"KLessZero\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{0, 1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 4,\n\t\t},\n\t\t{\n\t\t\tname:      \"KPositive\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"KPositiveTooMany\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         5,\n\t\t\twantInds:  nil,\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsN: 0,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (err != nil \u0026\u0026 tc.wantErr == nil) || (err == nil \u0026\u0026 tc.wantErr != nil) || (err != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 err.Error() != tc.wantErr.Error()) {\n\t\t\t\tt.Fatalf(\"error = %v, wantErr = %v\", err, tc.wantErr)\n\t\t\t}\n\t\t\tif len(got) != tc.wantIndsN {\n\t\t\t\tt.Fatalf(\"returned slice length = %v, want %v\", len(got), tc.wantIndsN)\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Errorf(\"got[%d] = %v, want %v\", i, got[i], tc.wantInds[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "39db05dc4a24eb9227f51017d3d973fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: for n = %d, l = %v, u = %v, v = %v, got %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "3a76d4dd149871d67008d88252023be3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tfor _, c := range []struct {\n\t\tin  []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{4, 3, 1, 2, 1}, 2},\n\t\t{[]float64{math.NaN(), 2, 3, 4}, 1},\n\t\t{[]float64{4, 3, math.NaN(), 2, 1}, 3},\n\t\t{[]float64{4, math.NaN(), 1, 2, 1, math.NaN()}, 2},\n\t} {\n\t\tgot := MinIdx(c.in)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", c.in, got, c.want)\n\t\t}\n\t}\n}",
    "3adb71339e22f88f256492a10f5ad403": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, want\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 1},\n\t\t{5, 0, 10, 7.5, 4},\n\t\t{5, 0, 10, -1, 0},\n\t\t{5, 0, 10, 11, 4},\n\n\t\t// Edge cases\n\t\t{2, 0, 10, 0, 0},\n\t\t{2, 0, 10, 10, 1},\n\t\t{2, 0, 0, 0, 0},\n\n\t\t// Reversed bounds\n\t\t{5, 10, 0, 2.5, 4},\n\t\t{5, 10, 0, 7.5, 1},\n\n\t\t// Infinities\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, 0, math.Inf(1), 100, 4},\n\t\t{5, math.Inf(-1), 0, -100, 4},\n\n\t\t// NaNs\n\t\t{5, math.NaN(), 10, 5, 0},\n\t\t{5, 0, math.NaN(), 5, 4},\n\t\t{5, 0, 10, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: got %d, want %d for n=%d, l=%v, u=%v, v=%v\", i, got, tc.want, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "3bddc91a49dd0c307d9de0e1281590c7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "3d239a05153f127756cc4206cf13ce2f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases for SumCompensated.\n\t// Each test case consists of a slice of float64 values and the expected sum.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10, 1e-10}, 5e-10},\n\t\t{[]float64{1e10, 1, -1e10}, 1},\n\t\t{[]float64{math.MaxFloat64, 1, 1, 1}, math.MaxFloat64},\n\t}\n\n\t// Iterate over the test cases.\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the calculated sum matches the expected sum.\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "3f1fcb2afc428a0210f30e3b742123c1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    4,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\tv:    3.5,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite same sign\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign odd n finite value matching lower\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign odd n finite value matching upper\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign even n\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign even n finite value matching lower\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign even n finite value matching upper\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\tv:    -1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound matching value\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite upper bound\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite upper bound matching value\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinite value increasing\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinite value decreasing\",\n\t\t\tn:    4,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinite value increasing\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinite value decreasing\",\n\t\t\tn:    4,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than lower bound increasing\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than upper bound increasing\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    5,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than upper bound decreasing\",\n\t\t\tn:    4,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    -1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than lower bound decreasing\",\n\t\t\tn:    4,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general increasing\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"general decreasing\",\n\t\t\tn:    4,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index: got: %d want: %d\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\ttest.Panic(t, \"shortSpan\", func() {\n\t\tNearestIdxForSpan(1, 0, 1, 0.5)\n\t})\n}\n",
    "3fa7e3b95f5c707b1cf62da5c1bdb6f4": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\tname string\n\t\tc    float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tc:    1.0,\n\t\t\tdst:  []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"add_one\",\n\t\t\tc:    1.0,\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\twant: []float64{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"add_negative\",\n\t\t\tc:    -1.0,\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\twant: []float64{0, 1, 2},\n\t\t},\n\t} {\n\t\tc := c\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tAddConst(c.c, c.dst)\n\t\t\tassert.Equal(t, c.want, c.dst)\n\t\t})\n\t}\n}\n",
    "402da2b0239a95cd0ad9382497c83698": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with one element (should panic)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 2.0 / 3.0, 1.0 / 3.0, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "408bf5d6763678341e7519c97944b765": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"LIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"UIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"BothInfSameSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf\n\tt.Run(\"LIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is Inf\n\tt.Run(\"UIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"EqualBounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != 1 {\n\t\t\t\tt.Errorf(\"Expected 1, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "4171fcb628d4c71d3830d56fe113e994": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, -5, 5, 0, 5},\n\t\t{9, -5, 5, 0, 4},\n\t\t{11, -5, 5, 0, 5},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 0},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, math.NaN(), 0, 0, 9},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\t// Check if the function panics when n \u003c 2.\n\t\tif tc.n \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan did not panic with n \u003c 2\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\n\t\t// Calculate the actual result.\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\n\t\t// Compare the actual result with the expected result.\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, expected %d\", i, tc.n, tc.l, tc.u, tc.v, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "425513ae8a69a98a714e8b3f95e333d2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct{\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 0, 10, 5.5, 6},\n\t\t{10, 0, 10, 4.5, 5},\n\t\t{10, -5, 5, 0, 5},\n\t\t{9, -5, 5, 0, 4},\n\t\t{9, -5, 5, -1, 4},\n\t\t{9, -5, 5, 1, 5},\n\t\t{10, -5, 5, -5, 0},\n\t\t{10, -5, 5, 5, 9},\n\t\t{10, -5, 5, -math.MaxFloat64, 0},\n\t\t{10, -5, 5, math.MaxFloat64, 9},\n\t\t{10, -math.MaxFloat64, math.MaxFloat64, 0, 5},\n\t\t{10, -math.MaxFloat64, math.MaxFloat64, -math.MaxFloat64, 0},\n\t\t{10, -math.MaxFloat64, math.MaxFloat64, math.MaxFloat64, 9},\n\t\t{10, math.NaN(), 5, 0, 0},\n\t\t{10, 5, math.NaN(), 0, 9},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}",
    "4255a92f176f4d91698166bcd5e8c176": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\t// Test cases for Mul function\n\ttestCases := []struct {\n\t\tdst  []float64\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{2, 3, 4}, []float64{2, 6, 12}},\n\t\t{[]float64{-1, -2, -3}, []float64{2, 3, 4}, []float64{-2, -6, -12}},\n\t\t{[]float64{1.0, 2.5, 3.5}, []float64{2.0, 3.0, 4.0}, []float64{2.0, 7.5, 14.0}},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Create a copy of the destination slice to avoid modifying the original\n\t\tdst := make([]float64, len(tc.dst))\n\t\tcopy(dst, tc.dst)\n\n\t\t// Call the Mul function\n\t\tMul(dst, tc.s)\n\n\t\t// Check if the result matches the expected output\n\t\tfor j := range dst {\n\t\t\tif dst[j] != tc.want[j] {\n\t\t\t\tt.Errorf(\"Test case %d failed: got %v, want %v\", i, dst, tc.want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic when argument lengths do not match\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Mul function did not panic when argument lengths do not match\")\n\t\t}\n\t}()\n\tMul([]float64{1, 2, 3}, []float64{1, 2})\n}",
    "427a068f7b9d98292d45ba8f0298d820": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are finite\n\t// - l is NaN\n\t// - u is NaN\n\t// - l and u are both +Inf\n\t// - l and u are both -Inf\n\t// - l is +Inf\n\t// - u is +Inf\n\t// - l is -Inf\n\t// - u is -Inf\n\n\tt.Run(\"short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short dst\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"finite l and u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"u is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are both +Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are both -Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(-1), math.Inf(-1))\n\t\twant := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is +Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(1), 0)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"u is +Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is -Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(-1), 0)\n\t\twant := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"u is -Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.Inf(-1))\n\t\twant := []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "437c902372f0d98605b3971c25a238e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.1,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    1.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"first element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"last element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds low\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds high\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\tv:    100,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d, %v, %v, %v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\ttest.Panics(t, \"short span\", func() { NearestIdxForSpan(1, 0, 1, 0) })\n}\n",
    "43b37766db5973e6b66d2f8e975f0b50": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with no matching elements\n\t// - Slice with one matching element\n\t// - Slice with multiple matching elements\n\t// - k = 0\n\t// - k \u003c 0\n\t// - k \u003e 0 and fewer than k elements found\n\n\t// Empty slice\n\t{\n\t\ts := []float64{}\n\t\tinds := make([]int, 0)\n\t\tk := 2\n\t\tf := func(v float64) bool { return v \u003e 2.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Find() on empty slice should have returned an error\")\n\t\t}\n\t\tif len(inds) != 0 {\n\t\t\tt.Errorf(\"Find() on empty slice returned an inds slice with non-zero length\")\n\t\t}\n\t}\n\n\t// Slice with no matching elements\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tinds := make([]int, 0)\n\t\tk := 2\n\t\tf := func(v float64) bool { return v \u003e 10.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Find() should have returned an error\")\n\t\t}\n\t\tif len(inds) != 0 {\n\t\t\tt.Errorf(\"Find() returned an inds slice with non-zero length\")\n\t\t}\n\t}\n\n\t// Slice with one matching element\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tinds := make([]int, 0)\n\t\tk := 2\n\t\tf := func(v float64) bool { return v == 3.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Find() should have returned an error\")\n\t\t}\n\t\tif len(inds) != 1 {\n\t\t\tt.Errorf(\"Find() returned an inds slice with incorrect length\")\n\t\t}\n\t\tif inds[0] != 2 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t}\n\n\t// Slice with multiple matching elements\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0, 3.0}\n\t\tinds := make([]int, 0)\n\t\tk := 2\n\t\tf := func(v float64) bool { return v == 3.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Find() returned an error: %v\", err)\n\t\t}\n\t\tif len(inds) != 2 {\n\t\t\tt.Errorf(\"Find() returned an inds slice with incorrect length\")\n\t\t}\n\t\tif inds[0] != 2 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t\tif inds[1] != 5 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t}\n\n\t// k = 0\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tinds := make([]int, 0)\n\t\tk := 0\n\t\tf := func(v float64) bool { return v \u003e 2.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Find() returned an error: %v\", err)\n\t\t}\n\t\tif len(inds) != 0 {\n\t\t\tt.Errorf(\"Find() returned an inds slice with non-zero length\")\n\t\t}\n\t}\n\n\t// k \u003c 0\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tinds := make([]int, 0)\n\t\tk := -1\n\t\tf := func(v float64) bool { return v \u003e 2.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Find() returned an error: %v\", err)\n\t\t}\n\t\tif len(inds) != 3 {\n\t\t\tt.Errorf(\"Find() returned an inds slice with incorrect length\")\n\t\t}\n\t\tif inds[0] != 2 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t\tif inds[1] != 3 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t\tif inds[2] != 4 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t}\n\n\t// k \u003e 0 and fewer than k elements found\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tinds := make([]int, 0)\n\t\tk := 4\n\t\tf := func(v float64) bool { return v \u003e 2.0 }\n\t\tinds, err := Find(inds, f, s, k)\n\t\tif !errors.Is(err, errors.New(\"floats: insufficient elements found\")) {\n\t\t\tt.Errorf(\"Find() did not return insufficient elements error\")\n\t\t}\n\t\tif len(inds) != 3 {\n\t\t\tt.Errorf(\"Find() returned an inds slice with incorrect length\")\n\t\t}\n\t\tif inds[0] != 2 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t\tif inds[1] != 3 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t\tif inds[2] != 4 {\n\t\t\tt.Errorf(\"Find() returned incorrect index\")\n\t\t}\n\t}\n}\n",
    "43da2b9b629e14fe67c3831d7c5be202": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 10, 9},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, -1, 9},\n\t\t{10, 1, 0, 10, 0},\n\t\t{10, -1, 1, 0, 4},\n\t\t{10, -1, 1, -10, 0},\n\t\t{10, -1, 1, 10, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), -10, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, 0, math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), 0, -10, 9},\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tpanicCases := []struct {\n\t\tn int\n\t}{\n\t\t{0},\n\t\t{1},\n\t}\n\n\tfor i, pc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, 0, 1, 0) did not panic\", i, pc.n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(pc.n, 0, 1, 0)\n\t}\n}\n",
    "448e96e64dc8a814b9196333c8e74a69": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{5, -5, 5, 0, 2},\n\t\t{5, -5, 5, -6, 0},\n\t\t{5, -5, 5, 6, 4},\n\t\t{11, -5, 5, 0, 5},\n\t\t{11, -5, 5, -6, 0},\n\t\t{11, -5, 5, 6, 10},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.1, 1},\n\t\t{10, 0, 1, 0.9, 9},\n\t\t{10, -1, 0, -0.5, 5},\n\t\t{10, -1, 0, -0.1, 9},\n\t\t{10, -1, 0, -0.9, 1},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf values.\n\tnan := math.NaN()\n\tinf := math.Inf(1)\n\tnegInf := math.Inf(-1)\n\ttestCasesNaNInf := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, nan, 5, 0},\n\t\t{10, nan, 0, 5, 9},\n\t\t{10, nan, nan, 5, 0},\n\t\t{10, 0, inf, 5, 9},\n\t\t{10, negInf, 0, 5, 0},\n\t\t{10, negInf, inf, 5, 5},\n\t\t{10, negInf, inf, inf, 9},\n\t\t{10, negInf, inf, negInf, 0},\n\t\t{10, 0, 10, nan, 0},\n\t\t{10, 0, 10, inf, 9},\n\t\t{10, 0, 10, negInf, 0},\n\t}\n\n\tfor _, tc := range testCasesNaNInf {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "44b252eb7d64662d0890dd69335bcff7": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\ts        []float64\n\t\tf        func(float64) bool\n\t\tk        int\n\t\twantInds []int\n\t\twantErr  error\n\t}\n\ttestCases := []testCase{\n\t\t// Find nothing in an empty slice.\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        -1,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Find everything in an empty slice.\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        2,\n\t\t\twantInds: nil,\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Find first element.\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        1,\n\t\t\twantInds: []int{0},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Find first two elements.\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        2,\n\t\t\twantInds: []int{0, 1},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Find first three elements.\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        3,\n\t\t\twantInds: []int{0, 1, 2},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Find too many elements.\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        6,\n\t\t\twantInds: nil,\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Find all elements.\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        -1,\n\t\t\twantInds: []int{0, 1, 2, 3, 4},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Find no elements.\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tf:        func(v float64) bool { return v \u003c 0 },\n\t\t\tk:        -1,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tgotInds, gotErr := Find(nil, tc.f, tc.s, tc.k)\n\t\tif !errorEqual(gotErr, tc.wantErr) {\n\t\t\tt.Errorf(\"Test %d: input = %v, wantErr = %v, gotErr = %v\", i, tc.s, tc.wantErr, gotErr)\n\t\t\tcontinue\n\t\t}\n\t\tif !intSliceEqual(gotInds, tc.wantInds) {\n\t\t\tt.Errorf(\"Test %d: input = %v, wantInds = %v, gotInds = %v\", i, tc.s, tc.wantInds, gotInds)\n\t\t}\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n\nfunc intSliceEqual(s1, s2 []int) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "4511cbb301b7d8bfcf0b0dedbc359aa4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for normal input.\n\tfor _, c := range []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -0.3333333333333333, 0.3333333333333333, 1}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tif !EqualApprox(got, c.want, 1e-15) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", c.dst, c.l, c.u, got, c.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN.\n\tnan := math.NaN()\n\tfor _, c := range []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, nan, 1, []float64{nan, 1}},\n\t\t{[]float64{0, 0, 0}, nan, 1, []float64{nan, nan, 1}},\n\t\t{[]float64{0, 0}, 0, nan, []float64{0, nan}},\n\t\t{[]float64{0, 0, 0}, 0, nan, []float64{0, nan, nan}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tfor i := range got {\n\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want NaN\", c.dst, c.l, c.u, i, got[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for Inf.\n\tfor _, c := range []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), 1, []float64{math.Inf(1), 1}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 1, []float64{math.Inf(1), math.Inf(1), 1}},\n\t\t{[]float64{0, 0}, 0, math.Inf(-1), []float64{0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(-1), []float64{0, math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tfor i := range got {\n\t\t\tif got[i] != c.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", c.dst, c.l, c.u, i, got[i], c.want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for panicking.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 1)\n}\n",
    "453441fed479c6b931c95d8e6a2dc624": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, want: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, want: 0},\n\t\t{n: 2, l: -1, u: 1, v: 2, want: 1},\n\n\t\t{n: 3, l: -1, u: 1, v: -2, want: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, want: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, want: 2},\n\n\t\t{n: 4, l: -1, u: 1, v: -2, want: 0},\n\t\t{n: 4, l: -1, u: 1, v: -1, want: 0},\n\t\t{n: 4, l: -1, u: 1, v: 0, want: 1},\n\t\t{n: 4, l: -1, u: 1, v: 1, want: 3},\n\t\t{n: 4, l: -1, u: 1, v: 2, want: 3},\n\n\t\t{n: 10, l: 0, u: 10, v: -1, want: 0},\n\t\t{n: 10, l: 0, u: 10, v: 0, want: 0},\n\t\t{n: 10, l: 0, u: 10, v: 1, want: 1},\n\t\t{n: 10, l: 0, u: 10, v: 2, want: 2},\n\t\t{n: 10, l: 0, u: 10, v: 9, want: 9},\n\t\t{n: 10, l: 0, u: 10, v: 10, want: 9},\n\t\t{n: 10, l: 0, u: 10, v: 11, want: 9},\n\n\t\t{n: 2, l: 1, u: -1, v: -2, want: 1},\n\t\t{n: 2, l: 1, u: -1, v: 0, want: 0},\n\t\t{n: 2, l: 1, u: -1, v: 2, want: 0},\n\n\t\t{n: 3, l: 1, u: -1, v: -2, want: 2},\n\t\t{n: 3, l: 1, u: -1, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: -1, v: 0, want: 1},\n\t\t{n: 3, l: 1, u: -1, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: -1, v: 2, want: 0},\n\n\t\t{n: 4, l: 1, u: -1, v: -2, want: 3},\n\t\t{n: 4, l: 1, u: -1, v: -1, want: 2},\n\t\t{n: 4, l: 1, u: -1, v: 0, want: 1},\n\t\t{n: 4, l: 1, u: -1, v: 1, want: 0},\n\t\t{n: 4, l: 1, u: -1, v: 2, want: 0},\n\n\t\t{n: 10, l: 10, u: 0, v: -1, want: 9},\n\t\t{n: 10, l: 10, u: 0, v: 0, want: 9},\n\t\t{n: 10, l: 10, u: 0, v: 1, want: 8},\n\t\t{n: 10, l: 10, u: 0, v: 2, want: 7},\n\t\t{n: 10, l: 10, u: 0, v: 9, want: 1},\n\t\t{n: 10, l: 10, u: 0, v: 10, want: 0},\n\t\t{n: 10, l: 10, u: 0, v: 11, want: 0},\n\n\t\t{n: 2, l: -math.Inf(1), u: math.Inf(1), v: -math.Inf(1), want: 0},\n\t\t{n: 2, l: -math.Inf(1), u: math.Inf(1), v: math.Inf(1), want: 1},\n\t\t{n: 2, l: math.Inf(1), u: -math.Inf(1), v: -math.Inf(1), want: 1},\n\t\t{n: 2, l: math.Inf(1), u: -math.Inf(1), v: math.Inf(1), want: 0},\n\n\t\t{n: 3, l: -math.Inf(1), u: math.Inf(1), v: -math.Inf(1), want: 0},\n\t\t{n: 3, l: -math.Inf(1), u: math.Inf(1), v: math.Inf(1), want: 2},\n\t\t{n: 3, l: math.Inf(1), u: -math.Inf(1), v: -math.Inf(1), want: 2},\n\t\t{n: 3, l: math.Inf(1), u: -math.Inf(1), v: math.Inf(1), want: 0},\n\n\t\t{n: 4, l: -math.Inf(1), u: math.Inf(1), v: -math.Inf(1), want: 0},\n\t\t{n: 4, l: -math.Inf(1), u: math.Inf(1), v: math.Inf(1), want: 3},\n\t\t{n: 4, l: math.Inf(1), u: -math.Inf(1), v: -math.Inf(1), want: 3},\n\t\t{n: 4, l: math.Inf(1), u: -math.Inf(1), v: math.Inf(1), want: 0},\n\n\t\t{n: 2, l: -math.Inf(1), u: 0, v: -math.Inf(1), want: 0},\n\t\t{n: 2, l: -math.Inf(1), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 0, u: -math.Inf(1), v: -math.Inf(1), want: 1},\n\t\t{n: 2, l: 0, u: -math.Inf(1), v: 0, want: 0},\n\n\t\t{n: 3, l: -math.Inf(1), u: 0, v: -math.Inf(1), want: 0},\n\t\t{n: 3, l: -math.Inf(1), u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 0, u: -math.Inf(1), v: -math.Inf(1), want: 2},\n\t\t{n: 3, l: 0, u: -math.Inf(1), v: 0, want: 0},\n\n\t\t{n: 4, l: -math.Inf(1), u: 0, v: -math.Inf(1), want: 0},\n\t\t{n: 4, l: -math.Inf(1), u: 0, v: 0, want: 3},\n\t\t{n: 4, l: 0, u: -math.Inf(1), v: -math.Inf(1), want: 3},\n\t\t{n: 4, l: 0, u: -math.Inf(1), v: 0, want: 0},\n\n\t\t{n: 2, l: math.NaN(), u: math.Inf(1), v: math.NaN(), want: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.NaN(), v: math.NaN(), want: 1},\n\t\t{n: 2, l: 0, u: math.NaN(), v: math.NaN(), want: 0},\n\t\t{n: 2, l: math.NaN(), u: 0, v: math.NaN(), want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, got, test.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1, -1} {\n\t\tpanicked := testlapack.Panics(func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t\tif !panicked {\n\t\t\tt.Errorf(\"Did not panic for n = %d\", n)\n\t\t}\n\t}\n}\n",
    "45a30c5828885a89ba83eb56d93bcb68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"EdgeCaseLower\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"EdgeCaseUpper\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    10,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"OutsideRangeLower\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"OutsideRangeUpper\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"ReverseRange\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNValue\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"InfValueLower\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"InfValueUpper\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tassert.Equal(t, tt.want, got)\n\t\t})\n\t}\n}",
    "4627622097568676db1c4bb86f0f6c45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.25, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.75, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.25, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.75, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 10, l: 0, u: 1, v: 0.9, want: 9},\n\t\t{n: 10, l: 1, u: 0, v: 0.9, want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d mismatch. Want %v, got %v\", i, tc.want, got)\n\t\t}\n\t}\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twants []int\n\t}{\n\t\t{n: 2, l: 0, u: 0, v: 0, wants: []int{0, 1}},\n\t\t{n: 3, l: 0, u: 0, v: 0, wants: []int{1, 2}},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tvar want bool\n\t\tfor _, w := range tc.wants {\n\t\t\tif got == w {\n\t\t\t\twant = true\n\t\t\t}\n\t\t}\n\t\tif !want {\n\t\t\tt.Errorf(\"Case %d mismatch. Want one of %v, got %v\", i, tc.wants, got)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanNaNInf(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// NaN input\n\t\t{n: 2, l: 0, u: 1, v: math.NaN(), want: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.NaN(), want: 0},\n\t\t{n: 2, l: 1, u: 0, v: math.NaN(), want: 0},\n\t\t{n: 3, l: 1, u: 0, v: math.NaN(), want: 0},\n\n\t\t// NaN endpoints\n\t\t{n: 2, l: math.NaN(), u: 0, v: 0, want: 0},\n\t\t{n: 2, l: math.NaN(), u: 0, v: 1, want: 0},\n\t\t{n: 3, l: math.NaN(), u: 0, v: 0, want: 0},\n\t\t{n: 3, l: math.NaN(), u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, want: 1},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 1, want: 1},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 0, want: 2},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 1, want: 2},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, want: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 1, want: 0},\n\t\t{n: 3, l: math.NaN(), u: math.NaN(), v: 0, want: 0},\n\t\t{n: 3, l: math.NaN(), u: math.NaN(), v: 1, want: 0},\n\n\t\t// Inf endpoints\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, want: 1},\n\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, want: 2},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, want: 0},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: 0, want: 0},\n\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: 0, want: 2},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, want: 0},\n\n\t\t{n: 2, l: 0, u: 0, v: math.Inf(-1), want: 0},\n\t\t{n: 3, l: 0, u: 0, v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(-1), want: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(-1), want: 1},\n\t\t{n: 3, l: 1, u: 0, v: math.Inf(-1), want: 2},\n\n\t\t{n: 2, l: 0, u: 0, v: math.Inf(1), want: 1},\n\t\t{n: 3, l: 0, u: 0, v: math.Inf(1), want: 2},\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(1), want: 1},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(1), want: 2},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(1), want: 0},\n\t\t{n: 3, l: 1, u: 0, v: math.Inf(1), want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d mismatch. Want %v, got %v\", i, tc.want, got)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{-1, 0, 1} {\n\t\ttest.Panic(t, \"NearestIdxForSpan\", func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t}\n}",
    "4779c1536b5e5170e27ec9a3d10c39ae": "",
    "47f60ea89af4f421e1d95c0dab96a75e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx function\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{1, 2, 3, 4, 4}, 3},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{math.NaN(), 2, 3, 4, 5}, 1},\n\t\t{[]float64{1, math.NaN(), 3, 4, 5}, 0},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, 0},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Call the MaxIdx function with the input slice\n\t\tactual := MaxIdx(tc.input)\n\n\t\t// Check if the actual output matches the expected output\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n\n\t// Test case for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with an empty slice\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}",
    "485f3f9430a5c1ee9fe363f2c8c5ca6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1, 2, 3, 4}, wantIdx: 0},\n\t\t{s: []float64{4, 3, 2, 1}, wantIdx: 3},\n\t\t{s: []float64{1, 4, 2, 3}, wantIdx: 0},\n\t\t{s: []float64{1, 1, 1, 1}, wantIdx: 0},\n\t\t{s: []float64{1, 2, 1, 1}, wantIdx: 0},\n\t\t{s: []float64{math.NaN(), 2, 1, 1}, wantIdx: 2},\n\t\t{s: []float64{2, math.NaN(), 1, 1}, wantIdx: 2},\n\t\t{s: []float64{2, 2, math.NaN(), 1}, wantIdx: 3},\n\t\t{s: []float64{2, 2, 1, math.NaN()}, wantIdx: 2},\n\t\t{s: []float64{}, wantPanic: true},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != c.wantPanic {\n\t\t\t\t\tt.Errorf(\"Got panic=%v, want panic=%v\", gotPanic, c.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MinIdx(c.s)\n\t\t\tif gotIdx != c.wantIdx {\n\t\t\t\tt.Errorf(\"Got MinIdx=%v, want %v\", gotIdx, c.wantIdx)\n\t\t\t}\n\n\t\t})\n\t}\n\n}",
    "4902acfcc99189c581fc8a8766675600": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\tout int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, out: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, out: 0},\n\t\t{n: 2, l: -1, u: 1, v: 2, out: 1},\n\t\t{n: 3, l: -1, u: 1, v: -2, out: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, out: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, out: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, out: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, out: 2},\n\t\t{n: 100, l: -1, u: 1, v: -2, out: 0},\n\t\t{n: 100, l: -1, u: 1, v: -1, out: 0},\n\t\t{n: 100, l: -1, u: 1, v: -0.9, out: 5},\n\t\t{n: 100, l: -1, u: 1, v: 0, out: 50},\n\t\t{n: 100, l: -1, u: 1, v: 0.9, out: 95},\n\t\t{n: 100, l: -1, u: 1, v: 1, out: 99},\n\t\t{n: 100, l: -1, u: 1, v: 2, out: 99},\n\n\t\t{n: 2, l: 1, u: -1, v: -2, out: 1},\n\t\t{n: 2, l: 1, u: -1, v: 0, out: 1},\n\t\t{n: 2, l: 1, u: -1, v: 2, out: 0},\n\t\t{n: 3, l: 1, u: -1, v: -2, out: 2},\n\t\t{n: 3, l: 1, u: -1, v: -1, out: 2},\n\t\t{n: 3, l: 1, u: -1, v: 0, out: 1},\n\t\t{n: 3, l: 1, u: -1, v: 1, out: 0},\n\t\t{n: 3, l: 1, u: -1, v: 2, out: 0},\n\t\t{n: 100, l: 1, u: -1, v: -2, out: 99},\n\t\t{n: 100, l: 1, u: -1, v: -1, out: 99},\n\t\t{n: 100, l: 1, u: -1, v: -0.9, out: 95},\n\t\t{n: 100, l: 1, u: -1, v: 0, out: 50},\n\t\t{n: 100, l: 1, u: -1, v: 0.9, out: 5},\n\t\t{n: 100, l: 1, u: -1, v: 1, out: 0},\n\t\t{n: 100, l: 1, u: -1, v: 2, out: 0},\n\n\t\t{n: 2, l: -1, u: -1, v: -2, out: 0},\n\t\t{n: 2, l: -1, u: -1, v: -1, out: 0},\n\t\t{n: 2, l: -1, u: -1, v: 0, out: 0},\n\t\t{n: 2, l: 1, u: 1, v: -2, out: 0},\n\t\t{n: 2, l: 1, u: 1, v: -1, out: 0},\n\t\t{n: 2, l: 1, u: 1, v: 0, out: 0},\n\n\t\t{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1), out: 1},\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, out: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), out: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, out: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), out: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, out: 1},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: math.Inf(-1), out: 0},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, out: 1},\n\n\t\t{n: 3, l: math.Inf(1), u: 0, v: math.Inf(1), out: 2},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: 0, out: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1), out: 2},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, out: 0},\n\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: math.Inf(-1), out: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, out: 2},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: math.Inf(-1), out: 0},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: 0, out: 2},\n\n\t\t{n: 2, l: math.NaN(), u: 0, v: 0, out: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, out: 1},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, out: 0},\n\t\t{n: 2, l: 0, u: 0, v: math.NaN(), out: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.out {\n\t\t\tt.Errorf(\"Case %d mismatch. Got %v, want %v\", i, got, test.out)\n\t\t}\n\t}\n\n\t// NaN tests\n\tn := 10\n\tfor i := 0; i \u003c n; i++ {\n\t\tl := float64(i)\n\t\tfor j := 0; j \u003c n; j++ {\n\t\t\tu := float64(j)\n\t\t\tgot := NearestIdxForSpan(n, l, u, math.NaN())\n\t\t\tif got != 0 {\n\t\t\t\tt.Errorf(\"NaN value should return index 0\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1, -1} {\n\t\tdefer func() {\n\t\t\tr := recover()\n\t\t\tif r == nil {\n\t\t\t\tt.Errorf(\"Did not panic with short span\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t}\n}\n\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\trng := test.NewRand()\n\ts := make([]float64, 100)\n\tfor i := range s {\n\t\ts[i] = rng.Float64()\n\t}\n\ts = append(s, math.Inf(-1), math.Inf(1))\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tNearestIdxForSpan(len(s), -1, 1, rng.Float64())\n\t}\n}",
    "498646d911c3405408999849c323ca03": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for Norm function\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4}, 3, 5.382581709537259},\n\t\t{[]float64{}, 1, 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif math.Abs(got-tc.want) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, want %v\", tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "49ba2faa968d0b16296a65774ac0301a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, math.NaN(), 1, 0.5, 0},\n\t\t{10, 0, math.NaN(), 0.5, 9},\n\t\t{10, math.NaN(), math.NaN(), 0.5, 0},\n\t\t{10, 0, 1, math.NaN(), 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Test case %d: Expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "49f1f6060a6fe1ef71ebca94b2d03f19": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, -1, 1, -0.5, 3},\n\t\t{10, -1, 1, 0.5, 6},\n\t\t{10, 1, -1, -0.5, 6},\n\t\t{10, 1, -1, 0.5, 3},\n\t\t{11, -1, 1, -0.5, 4},\n\t\t{11, -1, 1, 0.5, 7},\n\t\t{11, 1, -1, -0.5, 7},\n\t\t{11, 1, -1, 0.5, 4},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf values.\n\tnanInfCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\t\t{10, math.NaN(), 0, 100, 0},\n\t\t{10, 0, math.NaN(), 100, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 100, 9},\n\t\t{10, math.Inf(1), math.Inf(-1), 100, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 100, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 100, 9},\n\t}\n\n\tfor i, tc := range nanInfCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case for panic when n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "4a76c915a614c1a32e928870371d7c11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.25, 0},\n\t\t{3, 0, 1, 0.75, 2},\n\t\t{4, 0, 1, 0.33, 1},\n\t\t{4, 0, 1, 0.66, 2},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0.5, 7},\n\t\t{10, 1, -1, -0.5, 7},\n\t\t{10, 1, -1, 0.5, 2},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for v outside (l, u) and (u, l).\n\ttestCasesOutside := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 1, 0, -1, 2},\n\t\t{3, 1, 0, 2, 0},\n\t}\n\tfor i, tc := range testCasesOutside {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for special values of l, u, and v (Inf, NaN).\n\ttestCasesSpecial := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{3, math.NaN(), 1, 0.5, 0},\n\t\t{3, 0, math.NaN(), 0.5, 2},\n\t\t{3, math.Inf(1), math.Inf(-1), 0.5, 1},\n\t\t{4, math.Inf(1), math.Inf(-1), 0.5, 2},\n\t\t{3, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{3, math.Inf(-1), math.Inf(-1), 0.5, 0},\n\t\t{3, math.Inf(1), 0, math.Inf(1), 2},\n\t\t{3, 0, math.Inf(1), math.Inf(1), 2},\n\t\t{3, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{3, 0, math.Inf(-1), math.Inf(-1), 0},\n\t\t{3, 0, 1, math.Inf(1), 2},\n\t\t{3, 0, 1, math.Inf(-1), 0},\n\t\t{3, 1, 0, math.Inf(1), 0},\n\t\t{3, 1, 0, math.Inf(-1), 2},\n\t}\n\tfor i, tc := range testCasesSpecial {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "4b1a23c141eedc527eec4c3fbbbf89e3": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\texpect := []float64{-3, -3, -3}\n\n\tgot := SubTo(dst, s, t)\n\tassert.Equal(t, expect, got)\n}",
    "4ba005c9cdfe22faa8fc506e95a25089": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t//   - n \u003c 2\n\t//   - v is NaN\n\t//   - l or u is NaN\n\t//   - l and u are Inf\n\t//   - l or u is Inf\n\t//   - v is Inf\n\t//   - v is outside (l, u)\n\t//   - v is inside (l, u)\n\t//   - v is exactly halfway between two elements\n\t//   - v is almost halfway between two elements\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, 0) did not panic\", n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t}\n\n\t// v is NaN\n\tfor _, v := range []float64{math.NaN()} {\n\t\tassertNearestIdxForSpan(t, 10, 0, 1, v, 0)\n\t}\n\n\t// l or u is NaN\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, math.NaN(), 1, 0, 9},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// l and u are Inf\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{11, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(-1), 10},\n\t\t{10, math.Inf(1), math.Inf(-1), 1, 4},\n\t\t{10, math.Inf(1), math.Inf(-1), -1, 5},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// l or u is Inf\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, math.Inf(1), 0, 0, 9},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), 0, 0, 9},\n\t\t{10, 0, math.Inf(-1), 0, 0},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// v is Inf\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// v is outside (l, u)\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, 2, 0},\n\t\t{10, 1, 0, -1, 9},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// v is inside (l, u)\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 1, 0, 0.5, 4},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// v is exactly halfway between two elements\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{10, 0, 1, 0.1, 1},\n\t\t{10, 1, 0, 0.9, 0},\n\t} {\n\t\tassertNearestIdxForSpan(t, c.n, c.l, c.u, c.v, c.i)\n\t}\n\n\t// v is almost halfway between two elements\n\tassertNearestIdxForSpan(t, 10, 0, 1, 0.10000000000000001, 1)\n\tassertNearestIdxForSpan(t, 10, 0, 1, 0.09999999999999999, 1)\n}\n\nfunc assertNearestIdxForSpan(t *testing.T, n int, l, u, v float64, want int) {\n\thave := NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, have, want)\n\t}\n}\n",
    "4c6cdb436525f21ceeedad76790926b9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\n\tt.Run(\"L=1\", func(t *testing.T) {\n\t\twant := 16.0\n\t\tgot := Distance(s1, s2, 1)\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance mismatch. Want %v, got %v\", want, got)\n\t\t}\n\t})\n\n\tt.Run(\"L=2\", func(t *testing.T) {\n\t\twant := 8.0\n\t\tgot := Distance(s1, s2, 2)\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance mismatch. Want %v, got %v\", want, got)\n\t\t}\n\t})\n\n\tt.Run(\"L=math.Inf(1)\", func(t *testing.T) {\n\t\twant := 4.0\n\t\tgot := Distance(s1, s2, math.Inf(1))\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance mismatch. Want %v, got %v\", want, got)\n\t\t}\n\t})\n\n\tt.Run(\"L=3\", func(t *testing.T) {\n\t\twant := math.Pow(72, 1.0/3.0)\n\t\tgot := Distance(s1, s2, 3)\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance mismatch. Want %v, got %v\", want, got)\n\t\t}\n\t})\n}",
    "4cbcd075e4543798c309fb6ee26e85d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"simple case 2\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5.1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"v \u003c l\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v \u003e u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd, v is inf\",\n\t\t\tn:    11,\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 10,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even, v is inf\",\n\t\t\tn:    10,\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd, v is -inf\",\n\t\t\tn:    11,\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even, v is -inf\",\n\t\t\tn:    10,\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd, l = u\",\n\t\t\tn:    11,\n\t\t\tl:    5,\n\t\t\tu:    5,\n\t\t\tv:    4,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even, l = u\",\n\t\t\tn:    10,\n\t\t\tl:    5,\n\t\t\tu:    5,\n\t\t\tv:    4,\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d, %v, %v, %v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\ttest.Panics(t, \"short span\", func() { NearestIdxForSpan(1, 0, 1, 0) })\n}\n",
    "4e1af0d7b8ed5d716b99fd19e75c5557": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tdst:  []float64{1, 1, 1, 1},\n\t\t\twant: []float64{2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\ts:    []float64{0, -1, 2, 3},\n\t\t\tdst:  []float64{1, 1, 1, 1},\n\t\t\twant: []float64{1, 0, 3, 4},\n\t\t},\n\t} {\n\t\tAdd(test.dst, test.s)\n\t\tif !testlapack.EqualApprox(test.dst, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Test %v: mismatch. Want %v, got %v.\", i, test.want, test.dst)\n\t\t}\n\t}\n\n\tpanics := []struct {\n\t\ts    []float64\n\t\tdst  []float64\n\t\tname string\n\t}{\n\t\t{\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tdst:  []float64{1, 1, 1},\n\t\t\tname: \"len(s) != len(dst)\",\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tdst:  []float64{1, 1, 1, 1},\n\t\t\tname: \"len(s) != len(dst)\",\n\t\t},\n\t}\n\tfor _, test := range panics {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"Test %q: Add did not panic\", test.name)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAdd(test.dst, test.s)\n\t\t}()\n\t}\n}",
    "4eb979ccf40b8e4948c951fe71f3192c": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{4.0 / 1.0, 5.0 / 2.0, 6.0 / 3.0}\n\tgot := MulTo(dst, s, t)\n\tassert.Equal(t, want, got)\n}",
    "4ee2b8620a8d952f91ac91175e990d11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0, 5},\n\t\t{10, -1, 1, 0.5, 7},\n\t\t{10, 1, -1, -0.5, 7},\n\t\t{10, 1, -1, 0, 5},\n\t\t{10, 1, -1, 0.5, 2},\n\t\t{10, -1, -1, 0, 0},\n\t\t{10, 1, 1, 0, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for Inf and NaN.\n\tinfCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, math.Inf(1), 0, 0, 1},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), 0, 0, 0},\n\t\t{2, 0, math.Inf(-1), 0, 1},\n\t\t{2, math.NaN(), 0, 0, 1},\n\t\t{2, 0, math.NaN(), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t}\n\n\tfor i, tc := range infCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "50a644966ebeb9b5f9f075ffe29701a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are very large\n\t// - l and u are very small\n\t// - l and u are Inf\n\t// - l and u are NaN\n\t// - l and u are a mixture of the above\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular\n\tt.Run(\"Regular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very large\n\tt.Run(\"VeryLarge\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1e10, 1e11)\n\t\texpected := []float64{1e10, 3.25e10, 5.5e10, 7.75e10, 1e11}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very small\n\tt.Run(\"VerySmall\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1e-10, 1e-9)\n\t\texpected := []float64{1e-10, 3.25e-10, 5.5e-10, 7.75e-10, 1e-9}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are a mixture of the above\n\tt.Run(\"Mixed\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.NaN())\n\t\texpected := []float64{math.Inf(-1), math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}",
    "50bf89e11cdfc6a5f67944e93b69ded7": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantIndsN int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"NilInds\",\n\t\t\tinds:      nil,\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"EmptyInds\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"KZero\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"KOne\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         1,\n\t\t\twantInds:  []int{0},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 1,\n\t\t},\n\t\t{\n\t\t\tname:      \"KNegative\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 3,\n\t\t},\n\t\t{\n\t\t\tname:      \"KPositive\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"KPositiveTooMany\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         3,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsN: 3,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned unexpected error %v\", tc.inds, tc.f, tc.s, tc.k, gotErr)\n\t\t\t}\n\t\t\tif gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) did not return expected error %v\", tc.inds, tc.f, tc.s, tc.k, tc.wantErr)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 !errors.Is(gotErr, tc.wantErr) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned wrong error %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotErr, tc.wantErr)\n\t\t\t}\n\t\t\tif len(gotInds) != tc.wantIndsN {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned slice with length %v, want %v\", tc.inds, tc.f, tc.s, tc.k, len(gotInds), tc.wantIndsN)\n\t\t\t}\n\t\t\tfor i := 0; i \u003c len(gotInds) \u0026\u0026 i \u003c len(tc.wantInds); i++ {\n\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned slice %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotInds, tc.wantInds)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5100393d9c20179d1f466df07560df26": "package floats\n\nimport \"testing\"\n\nfunc TestAddScaled(t *testing.T) {\n\tdst := make([]float64, 3)\n\talpha := 2.0\n\ts := []float64{1, 2, 3}\n\texpected := []float64{2, 4, 6}\n\tAddScaled(dst, alpha, s)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"AddScaled() mismatch at index %d, got %v, want %v\", i, dst, expected)\n\t\t}\n\t}\n\n\t// Test panic case\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddScaled() did not panic with unequal lengths\")\n\t\t}\n\t}()\n\tAddScaled(dst, alpha, []float64{1, 2})\n}",
    "513e0f7a072d293d0d8efdd905153883": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\tt           []float64\n\t\texpected    []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Subtracts elements correctly\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panics when lengths don't match\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.shouldPanic {\n\t\t\t\tassert.Panics(t, func() { SubTo(test.dst, test.s, test.t) })\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, test.expected, SubTo(test.dst, test.s, test.t))\n\t\t\t}\n\t\t})\n\t}\n}",
    "51de97e964a1fffb9b422eb59da5400d": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDiv(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 2}\n\texpected := []float64{2 / 1, 4 / 2, 6 / 2}\n\tDiv(dst, s)\n\tassert.Equal(t, expected, dst)\n}",
    "51e62d3003c1cef2b289488bb49642bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// n = 2\n\t\t{\"n=2, l\u003cu, v\u003cl\", 2, 0, 1, -1, 0},\n\t\t{\"n=2, l\u003cu, v=l\", 2, 0, 1, 0, 0},\n\t\t{\"n=2, l\u003cu, l\u003cv\u003cu\", 2, 0, 1, 0.5, 0},\n\t\t{\"n=2, l\u003cu, v=u\", 2, 0, 1, 1, 1},\n\t\t{\"n=2, l\u003cu, u\u003cv\", 2, 0, 1, 2, 1},\n\t\t{\"n=2, l\u003eu, v\u003el\", 2, 1, 0, 2, 0},\n\t\t{\"n=2, l\u003eu, v=l\", 2, 1, 0, 1, 0},\n\t\t{\"n=2, l\u003eu, u\u003cv\u003cl\", 2, 1, 0, 0.5, 1},\n\t\t{\"n=2, l\u003eu, v=u\", 2, 1, 0, 0, 1},\n\t\t{\"n=2, l\u003eu, v\u003cu\", 2, 1, 0, -1, 1},\n\n\t\t// n = 3\n\t\t{\"n=3, l\u003cu, v\u003cl\", 3, 0, 1, -1, 0},\n\t\t{\"n=3, l\u003cu, v=l\", 3, 0, 1, 0, 0},\n\t\t{\"n=3, l\u003cu, l\u003cv\u003cu\", 3, 0, 1, 0.3, 0},\n\t\t{\"n=3, l\u003cu, l\u003cv\u003cu\", 3, 0, 1, 0.6, 1},\n\t\t{\"n=3, l\u003cu, v=u\", 3, 0, 1, 1, 2},\n\t\t{\"n=3, l\u003cu, u\u003cv\", 3, 0, 1, 2, 2},\n\t\t{\"n=3, l\u003eu, v\u003el\", 3, 1, 0, 2, 0},\n\t\t{\"n=3, l\u003eu, v=l\", 3, 1, 0, 1, 0},\n\t\t{\"n=3, l\u003eu, u\u003cv\u003cl\", 3, 1, 0, 0.7, 0},\n\t\t{\"n=3, l\u003eu, u\u003cv\u003cl\", 3, 1, 0, 0.4, 1},\n\t\t{\"n=3, l\u003eu, v=u\", 3, 1, 0, 0, 2},\n\t\t{\"n=3, l\u003eu, v\u003cu\", 3, 1, 0, -1, 2},\n\n\t\t// Special cases for Inf and NaN\n\t\t{\"n=3, l=NaN, u=0, v=0\", 3, math.NaN(), 0, 0, 0},\n\t\t{\"n=3, l=0, u=NaN, v=0\", 3, 0, math.NaN(), 0, 2},\n\t\t{\"n=3, l=+Inf, u=+Inf, v=0\", 3, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{\"n=3, l=+Inf, u=+Inf, v=+Inf\", 3, math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t{\"n=3, l=-Inf, u=-Inf, v=0\", 3, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{\"n=3, l=-Inf, u=-Inf, v=-Inf\", 3, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{\"n=3, l=+Inf, u=-Inf, v=0\", 3, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{\"n=3, l=+Inf, u=-Inf, v=+Inf\", 3, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{\"n=3, l=+Inf, u=-Inf, v=-Inf\", 3, math.Inf(1), math.Inf(-1), math.Inf(-1), 2},\n\t\t{\"n=3, l=-Inf, u=+Inf, v=0\", 3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{\"n=3, l=-Inf, u=+Inf, v=+Inf\", 3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},\n\t\t{\"n=3, l=-Inf, u=+Inf, v=-Inf\", 3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"n=3, l=0, u=+Inf, v=1\", 3, 0, math.Inf(1), 1, 0},\n\t\t{\"n=3, l=0, u=+Inf, v=-1\", 3, 0, math.Inf(1), -1, 0},\n\t\t{\"n=3, l=-Inf, u=0, v=1\", 3, math.Inf(-1), 0, 1, 2},\n\t\t{\"n=3, l=-Inf, u=0, v=-1\", 3, math.Inf(-1), 0, -1, 2},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}",
    "51e6755e7f508768bca93b584325caa1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\t\t{2, -1, 1, 0, 1},\n\t\t{2, -1, 1, -10, 0},\n\t\t{2, -1, 1, 10, 1},\n\n\t\t// n = 3\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{3, 1, 0, 0.3, 0},\n\t\t{3, 1, 0, 0.7, 1},\n\n\t\t// n = 4\n\t\t{4, 0, 1, 0.2, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{4, 1, 0, 0.2, 0},\n\t\t{4, 1, 0, 0.5, 1},\n\t\t{4, 1, 0, 0.8, 2},\n\n\t\t// Special cases for Inf and NaN.\n\t\t{4, math.Inf(1), 0, 0, 3},\n\t\t{4, 0, math.Inf(1), 0, 0},\n\t\t{4, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{4, math.NaN(), 0, 0, 2},\n\t\t{4, 0, math.NaN(), 0, 0},\n\n\t\t// Special cases for v outside (l, u) and (u, l).\n\t\t{4, 0, 1, -1, 0},\n\t\t{4, 0, 1, 2, 3},\n\t\t{4, 1, 0, 2, 0},\n\t\t{4, 1, 0, -1, 3},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "51f37ea8b340d88b86dd6365594f823f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\t// Test cases: empty slice, slice with infinity, regular slice\n\tt.Run(\"Empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"LogSumExp did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tLogSumExp([]float64{})\n\t})\n\n\tt.Run(\"Slice with infinity\", func(t *testing.T) {\n\t\tgot := LogSumExp([]float64{1.0, math.Inf(1)})\n\t\tif !math.IsInf(got, 1) {\n\t\t\tt.Errorf(\"LogSumExp with infinity = %v, want infinity\", got)\n\t\t}\n\t})\n\n\tt.Run(\"Regular slice\", func(t *testing.T) {\n\t\tgot := LogSumExp([]float64{1.0, 2.0, 3.0})\n\t\twant := 3.4076059573070544\n\t\tif math.Abs(got-want) \u003e 1e-15 {\n\t\t\tt.Errorf(\"LogSumExp = %v, want %v\", got, want)\n\t\t}\n\t})\n}",
    "535e683dd7462e2c87fae6b37215e513": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\tt1 := []float64{5, 6, 7, 8}\n\n\t// Test L = 1\n\texpected1 := 16.0\n\tresult1 := Distance(s1, t1, 1)\n\tif result1 != expected1 {\n\t\tt.Errorf(\"Distance() L=1: expected %v, got %v\", expected1, result1)\n\t}\n\n\t// Test L = 2\n\texpected2 := math.Sqrt(64)\n\tresult2 := Distance(s1, t1, 2)\n\tif result2 != expected2 {\n\t\tt.Errorf(\"Distance() L=2: expected %v, got %v\", expected2, result2)\n\t}\n\n\t// Test L = math.Inf(1)\n\texpected3 := 4.0\n\tresult3 := Distance(s1, t1, math.Inf(1))\n\tif result3 != expected3 {\n\t\tt.Errorf(\"Distance() L=Inf: expected %v, got %v\", expected3, result3)\n\t}\n\n\t// Test empty slices\n\ts2 := []float64{}\n\tt2 := []float64{}\n\texpected4 := 0.0\n\tresult4 := Distance(s2, t2, 2)\n\tif result4 != expected4 {\n\t\tt.Errorf(\"Distance() empty slices: expected %v, got %v\", expected4, result4)\n\t}\n\n\t// Test unequal lengths\n\ts3 := []float64{1, 2, 3}\n\tt3 := []float64{1, 2}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() unequal lengths: expected panic, got no panic\")\n\t\t}\n\t}()\n\tDistance(s3, t3, 2)\n}\n",
    "54cf5f7fc12931717650aaf61a9e1990": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, math.NaN(), 1, 0, 0},\n\t\t{10, 0, math.NaN(), 1, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\n\t\t// Odd vs even length\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, expected %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, idx, tc.expectedIdx)\n\t\t}\n\t}\n}",
    "5510c4a37a65894d6414bbbb693794cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 1, 0, 0, 1},\n\t\t{2, 1, 0, 1, 0},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\n\t\t// Cases with large n\n\t\t{1000, 0, 1000, 500, 500},\n\t\t{1000, -500, 500, 0, 500},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d\", i, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "553492048d9a895e0c7a6480f8a52aa9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases: slice length, lower bound, upper bound, expected slice\n\ttestCases := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\texp []float64\n\t}{\n\t\t{2, 0, 1, []float64{0, 1}},\n\t\t{3, 0, 1, []float64{0, 0.5, 1}},\n\t\t{4, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{10, -1, 1, []float64{-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8}},\n\t\t{5, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tdst := make([]float64, tc.n)\n\t\tSpan(dst, tc.l, tc.u)\n\t\tfor j := 0; j \u003c tc.n; j++ {\n\t\t\tif math.Abs(dst[j]-tc.exp[j]) \u003e 1e-14 {\n\t\t\t\tt.Errorf(\"Test case %d failed: element %d is %v, expected %v\", i, j, dst[j], tc.exp[j])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panicking with n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with n \u003c 2\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n}",
    "557c377cf77cfee5862a9c9ac824624d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, positive numbers, negative numbers, mixed numbers.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{[]float64{-1.0, 2.0, -3.0, 4.0}, 2.0},\n\t\t{[]float64{1e100, 1, -1e100}, 1},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}",
    "566741d6f8a87aed21ab7e8ff5149d73": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 1},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 1},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 1, 0, 0, 1},\n\t\t{2, 1, 0, 1, 0},\n\n\t\t// Inf cases\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, 0, math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), 0, -10, 0},\n\n\t\t// NaN cases\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "585b7ac09a3b8d7ae48ddfa3fb2ed341": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2,\n\t\t\tu:    0,\n\t\t\twant: []float64{-2, -1, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"FloatSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0.5,\n\t\t\tu:    1.5,\n\t\t\twant: []float64{0.5, 0.75, 1, 1.25},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf\n\tt.Run(\"NaN cases\", func(t *testing.T) {\n\t\tnanCases := []struct {\n\t\t\tname string\n\t\t\tdst  []float64\n\t\t\tl    float64\n\t\t\tu    float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"NaN low\",\n\t\t\t\tdst:  make([]float64, 4),\n\t\t\t\tl:    math.NaN(),\n\t\t\t\tu:    2,\n\t\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 2},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"NaN high\",\n\t\t\t\tdst:  make([]float64, 4),\n\t\t\t\tl:    0,\n\t\t\t\tu:    math.NaN(),\n\t\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range nanCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif len(got) != len(tc.want) {\n\t\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t\t}\n\t\t\t\tfor i := range got {\n\t\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif !math.IsNaN(got[i]) || !math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"Inf cases\", func(t *testing.T) {\n\t\tinfCases := []struct {\n\t\t\tname string\n\t\t\tdst  []float64\n\t\t\tl    float64\n\t\t\tu    float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"Inf low\",\n\t\t\t\tdst:  make([]float64, 4),\n\t\t\t\tl:    math.Inf(1),\n\t\t\t\tu:    2,\n\t\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 2},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf high\",\n\t\t\t\tdst:  make([]float64, 4),\n\t\t\t\tl:    0,\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Both Inf same sign\",\n\t\t\t\tdst:  make([]float64, 4),\n\t\t\t\tl:    math.Inf(1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Both Inf diff sign\",\n\t\t\t\tdst:  make([]float64, 4),\n\t\t\t\tl:    math.Inf(1),\n\t\t\t\tu:    math.Inf(-1),\n\t\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Both Inf diff sign odd\",\n\t\t\t\tdst:  make([]float64, 5),\n\t\t\t\tl:    math.Inf(1),\n\t\t\t\tu:    math.Inf(-1),\n\t\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range infCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif len(got) != len(tc.want) {\n\t\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t\t}\n\t\t\t\tfor i := range got {\n\t\t\t\t\tif math.IsInf(got[i], 0) != math.IsInf(tc.want[i], 0) {\n\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\t// Test case for panicking when len(dst) \u003c 2\n\tt.Run(\"Panics on short slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "58c241954b2664727c41d7721efab838": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tt.Parallel()\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\twant := []float64{1, 2, 3}\n\n\tAdd(dst, s)\n\tassert.Equal(t, want, dst)\n\n\tdst = []float64{0, 0, 0}\n\ts = []float64{-1, -2, -3}\n\twant = []float64{-1, -2, -3}\n\tAdd(dst, s)\n\tassert.Equal(t, want, dst)\n\n\tassert.Panics(t, func() { Add([]float64{1, 2, 3}, []float64{1, 2}) })\n}",
    "596038e104a8cfd0669b4e0ae9d834d2": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantInds2 []int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"k=0\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantInds2: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:      \"k\u003c0\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t\twantInds2: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:      \"k\u003e0, all elements satisfy\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantInds2: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:      \"k\u003e0, insufficient elements\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         3,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantInds2: []int{1, 2, 3},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (err == nil \u0026\u0026 tc.wantErr != nil) || (err != nil \u0026\u0026 tc.wantErr == nil) || (err != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 err.Error() != tc.wantErr.Error()) {\n\t\t\t\tt.Fatalf(\"Got err %v, want %v\", err, tc.wantErr)\n\t\t\t}\n\t\t\tif len(got) != len(tc.wantInds) {\n\t\t\t\tt.Fatalf(\"Got inds %v, want %v\", got, tc.wantInds)\n\t\t\t}\n\t\t\tfor i := 0; i \u003c len(got); i++ {\n\t\t\t\tif got[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Fatalf(\"Got inds %v, want %v\", got, tc.wantInds)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(tc.inds) != len(tc.wantInds2) {\n\t\t\t\tt.Fatalf(\"Input slice changed: got %v, want %v\", tc.inds, tc.wantInds2)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59cfb0df3d116931d8ef233f5c4d4ba1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-3.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSame\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseDifferent\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0.0, 0.0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-3.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-10) {\n\t\t\t\t\tt.Errorf(\"Got %v, want %v\", got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"PanicsOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\t_ = Span(make([]float64, 1), 0, 1)\n\t})\n}\n\nfunc closeEnough(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c tol\n}",
    "59e9807e410b3b1e42476d1626350de1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/scalar\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    1,\n\t\t\tu:    10,\n\t\t\twant: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, -0.5, 0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    3,\n\t\t\tu:    3,\n\t\t\twant: []float64{3, 3, 3},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    1,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    -1,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), -1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 9),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    -10,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-10, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t} {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tif !scalar.EqualSliceTol(got, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Case %d, unexpected output for Span(%v, %v, %v):\\ngot: %v\\nwant:%v\", i, test.dst, test.l, test.u, got, test.want)\n\t\t}\n\t}\n\n\tpanics := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{\n\t\t\tdst: make([]float64, 1),\n\t\t\tl:   1,\n\t\t\tu:   2,\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 0),\n\t\t\tl:   1,\n\t\t\tu:   2,\n\t\t},\n\t}\n\tfor i, test := range panics {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"Case %d: Span(%v, %v, %v) did not panic\", i, test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tSpan(test.dst, test.l, test.u)\n\t\t}()\n\t}\n}",
    "5a067b714f12586ffcf7e6ed3a76e094": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, testCase := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1, 2, 3, 4}, wantIdx: 0},\n\t\t{s: []float64{4, 3, 2, 1}, wantIdx: 3},\n\t\t{s: []float64{2, 1, 3, 4}, wantIdx: 1},\n\t\t{s: []float64{1, 2, 1, 0}, wantIdx: 3},\n\t\t{s: []float64{1, 0, 1, 0}, wantIdx: 1},\n\t\t{s: []float64{1, math.NaN(), 2}, wantIdx: 0},\n\t\t{s: []float64{math.NaN(), 1, 2}, wantIdx: 1},\n\t\t{s: []float64{1, 2, math.NaN()}, wantIdx: 0},\n\t\t{s: []float64{}, wantPanic: true},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != testCase.wantPanic {\n\t\t\t\t\tt.Errorf(\"Case %d: input array %v - panic mismatch. Want panic: %v, got panic: %v\\n\",\n\t\t\t\t\t\ti, testCase.s, testCase.wantPanic, gotPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MinIdx(testCase.s)\n\t\t\tif testCase.wantPanic {\n\t\t\t\tt.Errorf(\"Case %d: input array %v - should have panicked but did not. Returned index: %d\\n\",\n\t\t\t\t\ti, testCase.s, gotIdx)\n\t\t\t}\n\t\t\tif gotIdx != testCase.wantIdx {\n\t\t\t\tt.Errorf(\"Case %d: input array %v - index mismatch. Want index: %d, got index: %d\\n\",\n\t\t\t\t\ti, testCase.s, testCase.wantIdx, gotIdx)\n\t\t\t}\n\t\t}()\n\t}\n}",
    "5aa15949cd7c6551c734080cf1d8b245": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{0, 1, 2}, -1, -1},\n\t\t{[]float64{0, 1, 2}, 0, 0},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{0, 1, 2}, 2, -1},\n\t\t{[]float64{0, 1, 2}, 3, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1e11, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1.0001, 0},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1, 0},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -0.9999, 1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 0, 1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 0.9999, 2},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1, 2},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1.0001, 3},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1e10, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1e11, -1},\n\t} {\n\t\thave := Within(test.s, test.v)\n\t\tif have != test.want {\n\t\t\tt.Errorf(\"Test %d: input s = %v and v = %v: have %v, want %v\",\n\t\t\t\ti, test.s, test.v, have, test.want)\n\t\t}\n\t}\n\n\t// NaN cases\n\tfor i, v := range []float64{math.NaN(), -math.NaN()} {\n\t\thave := Within([]float64{0, 1}, v)\n\t\tif have != -1 {\n\t\t\tt.Errorf(\"Test %d: input v = %v: have %v, want -1\", i, v, have)\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{0, 1}, math.NaN())\n}",
    "5cab14684e3236374aff22310a463d29": "package floats\n\nimport \"testing\"\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{1, 2, 5, 3, 4}, 2},\n\t\t{[]float64{-1, -2, -3, -5, -4}, 3},\n\t} {\n\t\tgot := MaxIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d:  Got %d, want %d\", i, got, test.want)\n\t\t}\n\t}\n}",
    "5cfd5efc057e14d6f915e2f0e3a7a4e1": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !Equal(s1, s2) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be true\", s1, s2)\n\t}\n\n\tif Equal(s1, s3) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s3)\n\t}\n\n\tif Equal(s1, s4) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s4)\n\t}\n}",
    "5db0ca7cc9e199b358e4086356bd249f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, 3, 4.641588833612778},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, 3, 4.641588833612778},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, 3, 4.641588833612778},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, 3, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "5e5b494cf15f876e881c448b70eb2381": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\t// Test case 1: Basic subtraction\n\tdst1 := make([]float64, 3)\n\ts1 := []float64{1, 2, 3}\n\tt1 := []float64{4, 5, 6}\n\texpected1 := []float64{-3, -3, -3}\n\tSubTo(dst1, s1, t1)\n\tassert.Equal(t, expected1, dst1, \"Subtraction result is incorrect\")\n\n\t// Test case 2: Empty slices\n\tdst2 := make([]float64, 0)\n\ts2 := []float64{}\n\tt2 := []float64{}\n\tSubTo(dst2, s2, t2)\n\tassert.Equal(t, 0, len(dst2), \"Resulting slice should be empty\")\n\n\t// Test case 3: Panics with different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"SubTo should have panicked with different slice lengths\")\n\t\t}\n\t}()\n\tdst3 := make([]float64, 2)\n\ts3 := []float64{1, 2, 3}\n\tt3 := []float64{4, 5}\n\tSubTo(dst3, s3, t3)\n}",
    "5ec0328f90a34d616e3b204f7b27312c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// First test the panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n\t// Test some simple cases.\n\tfor i := 2; i \u003c 10; i++ {\n\t\tfor j := 0; j \u003c i; j++ {\n\t\t\tv := float64(j)/float64(i-1)\n\t\t\tk := NearestIdxForSpan(i, 0, 1, v)\n\t\t\tif k != j {\n\t\t\t\tt.Errorf(\"Nearest index is wrong. i = %v, j = %v, v = %v, k = %v\", i, j, v, k)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test some edge cases.\n\tn := 10\n\tif k := NearestIdxForSpan(n, 0, 1, -1); k != 0 {\n\t\tt.Errorf(\"Nearest index is wrong. Expected %v, got %v\", 0, k)\n\t}\n\tif k := NearestIdxForSpan(n, 0, 1, 1.1); k != n-1 {\n\t\tt.Errorf(\"Nearest index is wrong. Expected %v, got %v\", n-1, k)\n\t}\n\tif k := NearestIdxForSpan(n, 0, 1, 0); k != 0 {\n\t\tt.Errorf(\"Nearest index is wrong. Expected %v, got %v\", 0, k)\n\t}\n\tif k := NearestIdxForSpan(n, 0, 1, 1); k != n-1 {\n\t\tt.Errorf(\"Nearest index is wrong. Expected %v, got %v\", n-1, k)\n\t}\n\n\t// Test some random cases.\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := 10 + i\n\t\tl := -1.0 + 2*rand.Float64()\n\t\tu := -1.0 + 2*rand.Float64()\n\t\tv := -10 + 20*rand.Float64()\n\t\tk := NearestIdxForSpan(n, l, u, v)\n\t\tw := Span(make([]float64, n), l, u)[k]\n\t\td := math.Abs(v - w)\n\t\tfor j := 0; j \u003c n; j++ {\n\t\t\tww := Span(make([]float64, n), l, u)[j]\n\t\t\tdd := math.Abs(v - ww)\n\t\t\tif dd \u003c d-tol {\n\t\t\t\tt.Errorf(\"Nearest index is wrong. n = %v, l = %v, u = %v, v = %v, k = %v, w = %v, j = %v, ww = %v\", n, l, u, v, k, w, j, ww)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "61372161edf3c9defd238b1135cd48bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -10,\n\t\t\tu:    0,\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds negative infinite\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound infinite\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound infinite\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different signs, even length\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different signs, odd length\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"short span\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with dst length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\nconst eps = 1e-15\n\nfunc closeEnough(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c eps\n}",
    "619b5b88adc14dd5e12b4896a2e60292": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 3},\n\t\t{[]float64{1, 4, 3, 2}, 1},\n\t\t{[]float64{4, 4, 3, 4}, 0},\n\t\t{[]float64{1, 2, math.NaN(), 4}, 3},\n\t\t{[]float64{1, 2, math.NaN(), 4, math.NaN()}, 3},\n\t} {\n\t\tgot := MaxIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: MaxIdx(%v) = %v, want %v\", i, test.s, got, test.want)\n\t\t}\n\t}\n}",
    "63eb0a38dfc2724cfeb1f978ccfde92a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// First test the case where l \u003c u.\n\tn := 10\n\tl := 0.0\n\tu := 1.0\n\t// Test the endpoints and several points in between.\n\ttestCases := []struct {\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{-1.0, 0},\n\t\t{-0.1, 0},\n\t\t{0.0, 0},\n\t\t{0.1, 1},\n\t\t{0.2, 2},\n\t\t{0.5, 5},\n\t\t{0.7, 7},\n\t\t{0.9, 9},\n\t\t{1.0, 9},\n\t\t{1.1, 9},\n\t\t{2.0, 9},\n\t}\n\tfor i, tc := range testCases {\n\t\thave := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif have != tc.want {\n\t\t\tt.Errorf(\"Test case %d: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\t\ti, n, l, u, tc.v, tc.want, have)\n\t\t}\n\t}\n\t// Now test the case where l \u003e u.\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\ttestCases = []struct {\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{-1.0, 9},\n\t\t{-0.1, 9},\n\t\t{0.0, 9},\n\t\t{0.1, 8},\n\t\t{0.2, 7},\n\t\t{0.5, 4},\n\t\t{0.7, 2},\n\t\t{0.9, 0},\n\t\t{1.0, 0},\n\t\t{1.1, 0},\n\t\t{2.0, 0},\n\t}\n\tfor i, tc := range testCases {\n\t\thave := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif have != tc.want {\n\t\t\tt.Errorf(\"Test case %d: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\t\ti, n, l, u, tc.v, tc.want, have)\n\t\t}\n\t}\n\t// Test some of the special cases.\n\t// First, test when v is NaN\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv := math.NaN()\n\twant := 0\n\thave := NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for v=NaN: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l is NaN and u is not.\n\tn = 10\n\tl = math.NaN()\n\tu = 1.0\n\tv = 0.5\n\twant = 9\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=NaN: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when u is NaN and l is not.\n\tn = 10\n\tl = 0.0\n\tu = math.NaN()\n\tv = 0.5\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for u=NaN: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l = u.\n\tn = 10\n\tl = 0.0\n\tu = 0.0\n\tv = 0.5\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=u: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf.\n\tn = 10\n\tl = math.Inf(1)\n\tu = math.Inf(1)\n\tv = 0.5\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=u=Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both -inf.\n\tn = 10\n\tl = math.Inf(-1)\n\tu = math.Inf(-1)\n\tv = 0.5\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=u=-Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf but have opposite signs and n is even.\n\tn = 10\n\tl = math.Inf(1)\n\tu = math.Inf(-1)\n\tv = 0.5\n\twant = 5\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf, u=-Inf, n even: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf but have opposite signs, n is even, and v is inf.\n\tn = 10\n\tl = math.Inf(1)\n\tu = math.Inf(-1)\n\tv = math.Inf(1)\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf, u=-Inf, n even, v=Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf but have opposite signs, n is even, and v is -inf.\n\tn = 10\n\tl = math.Inf(1)\n\tu = math.Inf(-1)\n\tv = math.Inf(-1)\n\twant = 6\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf, u=-Inf, n even, v=-Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf but have opposite signs and n is odd.\n\tn = 9\n\tl = math.Inf(1)\n\tu = math.Inf(-1)\n\tv = 0.5\n\twant = 4\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf, u=-Inf, n odd: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf but have opposite signs, n is odd, and v is inf.\n\tn = 9\n\tl = math.Inf(1)\n\tu = math.Inf(-1)\n\tv = math.Inf(1)\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf, u=-Inf, n odd, v=Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l and u are both inf but have opposite signs, n is odd, and v is -inf.\n\tn = 9\n\tl = math.Inf(1)\n\tu = math.Inf(-1)\n\tv = math.Inf(-1)\n\twant = 4\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf, u=-Inf, n odd, v=-Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l is inf and u is not.\n\tn = 10\n\tl = math.Inf(1)\n\tu = 0.0\n\tv = 0.5\n\twant = 9\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when l is -inf and u is not.\n\tn = 10\n\tl = math.Inf(-1)\n\tu = 0.0\n\tv = 0.5\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for l=-Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when u is inf and l is not.\n\tn = 10\n\tl = 0.0\n\tu = math.Inf(1)\n\tv = 0.5\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for u=Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when u is -inf and l is not.\n\tn = 10\n\tl = 0.0\n\tu = math.Inf(-1)\n\tv = 0.5\n\twant = 9\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for u=-Inf: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when v is inf and l \u003c u.\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(1)\n\twant = 9\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for v=Inf, l \u003c u: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when v is -inf and l \u003c u.\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(-1)\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for v=-Inf, l \u003c u: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when v is inf and l \u003e u.\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = math.Inf(1)\n\twant = 0\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for v=Inf, l \u003e u: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\t// Test when v is -inf and l \u003e u.\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = math.Inf(-1)\n\twant = 9\n\thave = NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"Test case for v=-Inf, l \u003e u: input (n, l, u, v) = (%v, %v, %v, %v).  Want %v, have %v\",\n\t\t\tn, l, u, v, want, have)\n\t}\n\n\t// Test a bunch of random cases for l \u003c u and l \u003e u.\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tn := 2 + int(rng.Float64()*100)\n\t\tl := -rng.Float64() * 10\n\t\tu := l + (rng.Float64()*10 + 1)\n\t\tv := (rng.Float64() - 0.5) * 20\n\t\thave := NearestIdxForSpan(n, l, u, v)\n\t\t// Make sure the answer is in bounds.\n\t\tif have \u003c 0 || have \u003e= n {\n\t\t\tt.Errorf(\"Test case %d: input (n, l, u, v) = (%v, %v, %v, %v).  Result %v is out of bounds\",\n\t\t\t\ti, n, l, u, v, have)\n\t\t}\n\t\t// Make sure the answer is correct to within a tolerance.\n\t\tx := l + float64(have)/(float64(n)-1)*(u-l)\n\t\tif math.Abs(x-v) \u003e tol*math.Max(math.Abs(x), math.Abs(v)) {\n\t\t\tt.Errorf(\"Test case %d: input (n, l, u, v) = (%v, %v, %v, %v).  Got %v, want %v\",\n\t\t\t\ti, n, l, u, v, have, x)\n\t\t}\n\t\t// Now swap l and u and try again.\n\t\tl, u = u, l\n\t\thave = NearestIdxForSpan(n, l, u, v)\n\t\t// Make sure the answer is in bounds.\n\t\tif have \u003c 0 || have \u003e= n {\n\t\t\tt.Errorf(\"Test case %d: input (n, l, u, v) = (%v, %v, %v, %v).  Result %v is out of bounds\",\n\t\t\t\ti, n, l, u, v, have)\n\t\t}\n\t\t// Make sure the answer is correct to within a tolerance.\n\t\tx = l + float64(have)/(float64(n)-1)*(u-l)\n\t\tif math.Abs(x-v) \u003e tol*math.Max(math.Abs(x), math.Abs(v)) {\n\t\t\tt.Errorf(\"Test case %d: input (n, l, u, v) = (%v, %v, %v, %v).  Got %v, want %v\",\n\t\t\t\ti, n, l, u, v, have, x)\n\t\t}\n\t}\n}\n",
    "63fa0b8a84228ec317cfed7688363a0a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various input lengths and bounds.\n\ttestCases := []struct {\n\t\tdstLen int\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t}{\n\t\t{2, 0, 1, []float64{0, 1}},\n\t\t{3, 0, 1, []float64{0, 0.5, 1}},\n\t\t{4, -1, 1, []float64{-1, -0.3333333333333333, 0.3333333333333333, 1}},\n\t\t{5, 10, 20, []float64{10, 12.5, 15, 17.5, 20}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdst := make([]float64, tc.dstLen)\n\t\tgot := Span(dst, tc.l, tc.u)\n\n\t\tif len(got) != tc.dstLen {\n\t\t\tt.Errorf(\"Span(dst, %v, %v) returned slice of length %v, want %v\", tc.l, tc.u, len(got), tc.dstLen)\n\t\t}\n\n\t\tfor i := range got {\n\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\tt.Errorf(\"Span(dst, %v, %v)[%v] = %v, want %v\", tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf bounds.\n\tnanCases := []struct {\n\t\tdstLen int\n\t\tl      float64\n\t\tu      float64\n\t}{\n\t\t{3, math.NaN(), 1},\n\t\t{3, 0, math.NaN()},\n\t\t{3, math.Inf(1), math.Inf(1)},\n\t\t{3, math.Inf(-1), math.Inf(-1)},\n\t\t{4, math.Inf(1), math.Inf(1)},\n\t\t{4, math.Inf(-1), math.Inf(-1)},\n\t\t{3, math.Inf(1), 0},\n\t\t{3, 0, math.Inf(-1)},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tdst := make([]float64, tc.dstLen)\n\t\tSpan(dst, tc.l, tc.u)\n\n\t\t// Check for expected NaN or Inf values.\n\t\tif tc.l == math.NaN() {\n\t\t\tfor i := 0; i \u003c tc.dstLen-1; i++ {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Span(dst, NaN, %v)[%v] = %v, want NaN\", tc.u, i, dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif dst[tc.dstLen-1] != tc.u {\n\t\t\t\tt.Errorf(\"Span(dst, NaN, %v)[%v] = %v, want %v\", tc.u, tc.dstLen-1, dst[tc.dstLen-1], tc.u)\n\t\t\t}\n\t\t} else if tc.u == math.NaN() {\n\t\t\tif dst[0] != tc.l {\n\t\t\t\tt.Errorf(\"Span(dst, %v, NaN)[0] = %v, want %v\", tc.l, dst[0], tc.l)\n\t\t\t}\n\t\t\tfor i := 1; i \u003c tc.dstLen; i++ {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Span(dst, %v, NaN)[%v] = %v, want NaN\", tc.l, i, dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} else if math.IsInf(tc.l, 0) || math.IsInf(tc.u, 0) {\n\t\t\t// Check for expected Inf values.\n\t\t\tfor i := range dst {\n\t\t\t\tif !math.IsInf(dst[i], 0) {\n\t\t\t\t\tt.Errorf(\"Span(dst, %v, %v)[%v] = %v, want Inf\", tc.l, tc.u, i, dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case for panicking when dst length is less than 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span(dst, 0, 1) did not panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n}\n",
    "6413829de65ffe830657a47656e35ce0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - math.IsNaN(v)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\t// - math.IsInf(l, 0)\n\t// - math.IsInf(u, 0)\n\t// - math.IsInf(v, -1)\n\t// - math.IsInf(v, 1)\n\t// - l \u003c u\n\t// - l \u003e u\n\t// - l == u\n\t// - v outside (l, u) and (u, l)\n\t// - v inside (l, u) and (u, l)\n\t// - v on l or u\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, 0) did not panic\", n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t\t}()\n\t}\n\n\t// math.IsNaN(v)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tgot := NearestIdxForSpan(n, 0, 1, math.NaN())\n\t\tif got != 0 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, NaN) = %v, want 0\", n, got)\n\t\t}\n\t}\n\n\t// math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tgot := NearestIdxForSpan(n, math.NaN(), 1, 0)\n\t\tif got != n-1 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, NaN, 1, 0) = %v, want %v\", n, got, n-1)\n\t\t}\n\t}\n\n\t// math.IsNaN(u)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tgot := NearestIdxForSpan(n, 0, math.NaN(), 0)\n\t\tif got != 0 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, NaN, 0) = %v, want 0\", n, got)\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, l := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\tfor _, u := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif l == u {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t} else if n%2 == 1 {\n\t\t\t\t\t\tif !math.IsInf(v, 0) {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t} else if math.Copysign(1, v) == math.Copysign(1, l) {\n\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n/2 + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif math.Copysign(1, v) == math.Copysign(1, l) {\n\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1)} {\n\t\t\twant := n - 1\n\t\t\tif v == math.Inf(-1) {\n\t\t\t\twant = 0\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(n, math.Inf(-1), 0, v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, Inf(-1), 0, %v) = %v, want %v\", n, v, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(1)} {\n\t\t\twant := 0\n\t\t\tif v == math.Inf(1) {\n\t\t\t\twant = n - 1\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(n, 0, math.Inf(1), v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, Inf(1), %v) = %v, want %v\", n, v, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(v, -1)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\twant := 0\n\t\t\t\tif l \u003e u {\n\t\t\t\t\twant = n - 1\n\t\t\t\t}\n\t\t\t\tgot := NearestIdxForSpan(n, l, u, math.Inf(-1))\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, Inf(-1)) = %v, want %v\", n, l, u, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(v, 1)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\twant := 0\n\t\t\t\tif u \u003e l {\n\t\t\t\t\twant = n - 1\n\t\t\t\t}\n\t\t\t\tgot := NearestIdxForSpan(n, l, u, math.Inf(1))\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, Inf(1)) = %v, want %v\", n, l, u, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003c u\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, v := range []float64{-2, -1, 0, 1, 2} {\n\t\t\twant := 0\n\t\t\tif v \u003e= 1 {\n\t\t\t\twant = n - 1\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(n, -1, 1, v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, -1, 1, %v) = %v, want %v\", n, v, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, v := range []float64{-2, -1, 0, 1, 2} {\n\t\t\twant := 0\n\t\t\tif v \u003c= -1 {\n\t\t\t\twant = n - 1\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(n, 1, -1, v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 1, -1, %v) = %v, want %v\", n, v, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, v := range []float64{-2, -1, 0, 1, 2} {\n\t\t\tgot := NearestIdxForSpan(n, 0, 0, v)\n\t\t\tif got != 0 {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 0, %v) = %v, want 0\", n, v, got)\n\t\t\t}\n\t\t}\n\t}\n\n\t// v outside (l, u) and (u, l)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tfor _, u := range []float64{-1, 1} {\n\t\t\t\tfor _, v := range []float64{-2, 2} {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif v \u003c l \u0026\u0026 l \u003c u {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t} else if v \u003e u \u0026\u0026 u \u003e l {\n\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t} else if v \u003e l \u0026\u0026 l \u003e u {\n\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t} else if v \u003c u \u0026\u0026 u \u003c l {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t}\n\t\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// v inside (l, u) and (u, l)\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tfor _, u := range []float64{-1, 1} {\n\t\t\t\tfor _, v := range []float64{-0.5, 0, 0.5} {\n\t\t\t\t\twant := int((float64(n)-1)/(u-l)*(v-l) + 0.5)\n\t\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// v on l or u\n\tfor n := 2; n \u003c 5; n++ {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tfor _, u := range []float64{-1, 1} {\n\t\t\t\tfor _, v := range []float64{-1, 1} {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif v == u \u0026\u0026 u \u003e l {\n\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t} else if v == l \u0026\u0026 l \u003e u {\n\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t}\n\t\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "656d8243e7ab61dd1b5d5d4c0a1c2a51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic test\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1,\n\t\t\tu:    3,\n\t\t\twant: []float64{-1, 0, 1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"Small slice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds -Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Different infinities\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), -1, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range got {\n\t\t\t\tif i \u003e= len(tt.want) {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) returned slice longer than expected %v\", tt.dst, tt.l, tt.u, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif !equalWithinTol(v, tt.want[i], 1e-14) {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%d] = %v, want %v\", tt.dst, tt.l, tt.u, i, v, tt.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc equalWithinTol(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c= tol\n}",
    "65a07e02fcce872028436f8a915909a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"EmptySlice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaNValue\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"PositiveInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"NegativeInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"SingleElementSlice\", args{[]float64{5}, 3}, 0},\n\t\t{\"ClosestElementInTheMiddle\", args{[]float64{1, 2, 3, 4, 5}, 3.2}, 2},\n\t\t{\"ClosestElementAtTheBeginning\", args{[]float64{1, 2, 3, 4, 5}, 0.8}, 0},\n\t\t{\"ClosestElementAtTheEnd\", args{[]float64{1, 2, 3, 4, 5}, 4.9}, 4},\n\t\t{\"MultipleClosestElements\", args{[]float64{1, 2, 3, 3, 4, 5}, 3}, 2},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tt.name == \"EmptySlice\" {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fd8ad4512dfef4102fe3bfb9270a4f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with one element (should panic)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "6614f0f640bed3219f6edca88d44dd37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, math.NaN(), 1, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}\n",
    "662f2e407358b89be4281a5a18880939": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 2, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 2, 8},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 1, 20},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 3.14, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 3.14, math.Pow(256, 1/3.14)},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 2)\n}",
    "66d292c1ce226e5c8864cc13fe05bc21": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, -1},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "67dd6295b47259e6fb279f0555c34da2": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\tSlices [][]float64\n\t\tWant   bool\n\t}{\n\t\t{nil, true},\n\t\t{[][]float64{{}}, true},\n\t\t{[][]float64{{1}, {2}}, true},\n\t\t{[][]float64{{1, 2}, {3, 4}}, true},\n\t\t{[][]float64{{}, {1}}, false},\n\t\t{[][]float64{{1}, {2, 3}}, false},\n\t\t{[][]float64{{1, 2}, {3, 4, 5}}, false},\n\t} {\n\t\tgot := EqualLengths(test.Slices...)\n\t\tif got != test.Want {\n\t\t\tt.Errorf(\"case %d: got %v, want %v\", i, got, test.Want)\n\t\t}\n\t}\n}",
    "68474e5a72e61670a6cb46b5ac1305bf": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}}, 1},\n\t\t{\"One Element\", args{[]float64{2}}, 1},\n\t\t{\"Multiple Elements\", args{[]float64{2, 3, 4}}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68899a430ddf4f6f239e756b66bbbffb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\t// Test cases for Same function\n\ttests := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\twant bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, 3}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t}\n\n\tfor i, tc := range tests {\n\t\tgot := Same(tc.s, tc.t)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: Same(%v, %v) = %v, want %v\", i, tc.s, tc.t, got, tc.want)\n\t\t}\n\t}\n}",
    "68e0afb435fbddde65eef21993523abe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twant     int\n\t\twantPanic bool\n\t}{\n\t\t{[]float64{1, 2, 3}, 1.5, 0, false},\n\t\t{[]float64{1, 2, 3}, 0.5, -1, false},\n\t\t{[]float64{1, 2, 3}, 3.5, -1, false},\n\t\t{[]float64{1, 2, 3}, 1, 0, false},\n\t\t{[]float64{1, 2, 3}, 3, -1, false},\n\t\t{[]float64{1, 2, math.NaN()}, 2.5, 1, false},\n\t\t{[]float64{1, 2, math.NaN()}, math.NaN(), -1, false},\n\t\t{[]float64{1}, 1, 0, true},\n\t\t{[]float64{2, 1}, 1.5, 0, true},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tif !test.wantPanic \u0026\u0026 err != nil {\n\t\t\t\t\tt.Errorf(\"Test %d: unexpected panic: %v\", i, err)\n\t\t\t\t}\n\t\t\t\tif test.wantPanic \u0026\u0026 err == nil {\n\t\t\t\t\tt.Errorf(\"Test %d: expected panic but didn't get one\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\thave := Within(test.s, test.v)\n\t\t\tif have != test.want {\n\t\t\t\tt.Errorf(\"Test %d: input array = %v, value = %v, want = %v, have = %v\", i, test.s, test.v, test.want, have)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "690866bf0f92f2e1f2a6c438c10bc8eb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n = 2\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, -1))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 0.5))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 1))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 2))\n\n\t// n = 3\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, 1, -0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, 1, 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(3, 0, 1, 0.5))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, 1, 1))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, 1, 1.5))\n\n\t// n = 4\n\tassert.Equal(t, 0, NearestIdxForSpan(4, 0, 1, -0.33))\n\tassert.Equal(t, 1, NearestIdxForSpan(4, 0, 1, 0.33))\n\tassert.Equal(t, 2, NearestIdxForSpan(4, 0, 1, 0.66))\n\tassert.Equal(t, 3, NearestIdxForSpan(4, 0, 1, 1.33))\n\n\t// l \u003e u\n\tassert.Equal(t, 3, NearestIdxForSpan(4, 1, 0, -0.33))\n\tassert.Equal(t, 2, NearestIdxForSpan(4, 1, 0, 0.33))\n\tassert.Equal(t, 1, NearestIdxForSpan(4, 1, 0, 0.66))\n\tassert.Equal(t, 0, NearestIdxForSpan(4, 1, 0, 1.33))\n\n\t// Inf cases\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0))\n\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.Inf(1), 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.Inf(1), 1))\n\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(-1), 0, 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), 0, -1))\n\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.NaN(), 0, 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.NaN(), 0))\n}\n",
    "6930d616072f2ca90b31519426117788": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.451914395937593},\n\t\t{[]float64{100, 100, 100}, 103.61938514234754},\n\t\t{[]float64{-100, -100, -100}, -96.38061485765246},\n\t\t{[]float64{-100, -100, 100}, 100},\n\t} {\n\t\tactual := LogSumExp(test.s)\n\t\tif math.Abs(actual-test.expected) \u003e tol {\n\t\t\tt.Errorf(\"Test %d: Expected %v, but got %v\", i, test.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestLogSumExpPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n",
    "69897caeb65fe72f7aa78c474973b3a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0.5, 7},\n\t\t{100, -10, 10, -5, 25},\n\t\t{100, -10, 10, 5, 75},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for special values like Inf, -Inf, and NaN.\n\tspecialCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, math.Inf(1), 1, 1},\n\t\t{10, math.Inf(-1), 0, -1, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, math.NaN(), 0, 0, 0},\n\t}\n\n\tfor _, tc := range specialCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "6aede9c09c69006b852dd6e16ffad905": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and/or u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tl = 1.0\n\t\tu = math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"InfValuesSameSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tl = math.Inf(-1)\n\t\tu = math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u is Inf\n\tt.Run(\"InfValuesDifferentSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tl = 1.0\n\t\tu = math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"EqualValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 3.0\n\t\tu := 3.0\n\t\tSpan(dst, l, u)\n\t\tfor _, v := range dst {\n\t\t\tif v != l {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", l, v)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "6af629ddd937cab703589d0bb7a8abe6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 1, i: 1},\n\t\t{n: 2, l: -1, u: 1, v: 2, i: 1},\n\n\t\t{n: 3, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, i: 2},\n\n\t\t{n: 4, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: -0.5, i: 1},\n\t\t{n: 4, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 4, l: -1, u: 1, v: 0.5, i: 2},\n\t\t{n: 4, l: -1, u: 1, v: 1, i: 3},\n\t\t{n: 4, l: -1, u: 1, v: 2, i: 3},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: index mismatch. Want %v, got %v.\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.i, i)\n\t\t}\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t}{\n\t\t{n: 2, l: -1, u: 1},\n\t\t{n: 3, l: -1, u: 1},\n\t\t{n: 4, l: -1, u: 1},\n\t\t{n: 10, l: -1, u: 1},\n\t\t{n: 11, l: -1, u: 1},\n\t} {\n\t\ts := make([]float64, test.n)\n\t\tSpan(s, test.l, test.u)\n\t\tfor iv := 0; iv \u003c 10; iv++ {\n\t\t\tv := float64(iv)/10*2*(test.u-test.l) + test.l - (test.u - test.l)\n\t\t\ti := NearestIdxForSpan(test.n, test.l, test.u, v)\n\t\t\tj := NearestIdx(s, v)\n\t\t\tif i != j {\n\t\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: index mismatch. Want %v, got %v.\",\n\t\t\t\t\ttest.n, test.l, test.u, v, j, i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanSpecial(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 1, v: 0, i: 0},\n\t\t{n: 2, l: -1, u: math.NaN(), v: 0, i: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, i: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, i: 1},\n\t\t{n: 2, l: -1, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: -1, u: math.Inf(1), v: math.Inf(1), i: 1},\n\n\t\t{n: 2, l: 0, u: 0, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: 0, u: 0, v: math.Inf(1), i: 0},\n\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 2},\n\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 2},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 3},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: index mismatch. Want %v, got %v.\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.i, i)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1, -1} {\n\t\tpanicked := testlapack.Panics(func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t\tif !panicked {\n\t\t\tt.Errorf(\"Did not panic for n = %v\", n)\n\t\t}\n\t}\n}\n",
    "6bfc7b9f97ba65b7653d66b1e69f0b80": "package floats\n\nimport \"testing\"\n\nfunc TestEqualFunc(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !EqualFunc(s1, s2, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be true\", s1, s2)\n\t}\n\n\tif EqualFunc(s1, s3, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be false\", s1, s3)\n\t}\n\n\tif EqualFunc(s1, s4, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be false\", s1, s4)\n\t}\n}",
    "6c7c9566e0529939e343a754e38af8a8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with Inf values\n\t// - Slice with NaN values\n\n\t// Test case 1: Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with Inf values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: Slice with NaN values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "6d06d0759e4be25c7b630ad5ceb5bc13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of elements in the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, 0, math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), 0, -10, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "6d21515f8125323eb177cf800f931b07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SmallSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, -2.5, 0, 2.5, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -5,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-5, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -5,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-5, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !equal(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Test case %s failed: got %v, want %v\", tc.name, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equal compares two float64 values for equality, considering NaN values\n// as equal.\nfunc equal(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}",
    "6deba74db0b90460246258ff700fb465": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Evenly spaced values\n\t// 2. l \u003e u\n\t// 3. l == u\n\t// 4. NaN cases\n\t// 5. Inf cases\n\n\t// 1. Evenly spaced values\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"TestSpan: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// 2. l \u003e u\n\tdst = make([]float64, 5)\n\tSpan(dst, 1, 0)\n\texpected = []float64{1, 0.75, 0.5, 0.25, 0}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"TestSpan: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// 3. l == u\n\tdst = make([]float64, 5)\n\tSpan(dst, 1, 1)\n\texpected = []float64{1, 1, 1, 1, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"TestSpan: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// 4. NaN cases\n\tdst = make([]float64, 5)\n\tSpan(dst, math.NaN(), 1)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"TestSpan: Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"TestSpan: Expected 1, got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"TestSpan: Expected 0, got %v\", dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"TestSpan: Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\n\t// 5. Inf cases\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := range dst[:len(dst)/2] {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"TestSpan: Expected +Inf, got %v\", dst[i])\n\t\t}\n\t\tif !math.IsInf(dst[len(dst)-i-1], -1) {\n\t\t\tt.Errorf(\"TestSpan: Expected -Inf, got %v\", dst[len(dst)-i-1])\n\t\t}\n\t}\n\tif dst[len(dst)/2] != 0 {\n\t\tt.Errorf(\"TestSpan: Expected 0, got %v\", dst[len(dst)/2])\n\t}\n\n\tdst = make([]float64, 4)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := range dst[:len(dst)/2] {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"TestSpan: Expected +Inf, got %v\", dst[i])\n\t\t}\n\t\tif !math.IsInf(dst[len(dst)-i-1], -1) {\n\t\t\tt.Errorf(\"TestSpan: Expected -Inf, got %v\", dst[len(dst)-i-1])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := range dst {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"TestSpan: Expected +Inf, got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), 0)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"TestSpan: Expected +Inf, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"TestSpan: Expected 0, got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"TestSpan: Expected 0, got %v\", dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"TestSpan: Expected +Inf, got %v\", dst[i])\n\t\t}\n\t}\n}\n",
    "6f60e11c27d167cc98a6c777b2ed309f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - math.IsNaN(v)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\t// - math.IsInf(l, 0)\n\t// - math.IsInf(u, 0)\n\t// - math.IsInf(v, -1)\n\t// - math.IsInf(v, 1)\n\t// - l \u003c u\n\t// - l \u003e u\n\t// - l == u\n\t// - v inside (l, u)\n\t// - v outside (l, u)\n\t// - v on the boundary of (l, u)\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with n = %d\", n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0.5)\n\t}\n\n\t// math.IsNaN(v)\n\tn := 10\n\tl := 0.0\n\tu := 1.0\n\tv := math.NaN()\n\tgot := NearestIdxForSpan(n, l, u, v)\n\twant := 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\tn = 10\n\tl = math.NaN()\n\tu = 1.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = n - 1\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsNaN(u)\n\tn = 10\n\tl = 0.0\n\tu = math.NaN()\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\tn = 10\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsInf(l, 0)\n\tn = 10\n\tl = math.Inf(0)\n\tu = 1.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = n - 1\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsInf(u, 0)\n\tn = 10\n\tl = 0.0\n\tu = math.Inf(0)\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsInf(v, -1)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(-1)\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// math.IsInf(v, 1)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(1)\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = n - 1\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// l \u003c u\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 5\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// l \u003e u\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 4\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// l == u\n\tn = 10\n\tl = 0.0\n\tu = 0.0\n\tv = 0.5\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 0\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// v inside (l, u)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = 0.25\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 2\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// v outside (l, u)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = 1.25\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 9\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n\n\t// v on the boundary of (l, u)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = 1.0\n\tgot = NearestIdxForSpan(n, l, u, v)\n\twant = 9\n\tif got != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", n, l, u, v, got, want)\n\t}\n}\n",
    "6f8f0cf089b9296b93c93e650fdcf0f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty slice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaN value\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"+Inf value\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"-Inf value\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"single element\", args{[]float64{1}, 1}, 0},\n\t\t{\"two elements, closer to first\", args{[]float64{1, 2}, 0.6}, 0},\n\t\t{\"two elements, closer to second\", args{[]float64{1, 2}, 1.6}, 1},\n\t\t{\"multiple elements, closest to middle\", args{[]float64{1, 2, 3, 4, 5}, 3.1}, 2},\n\t\t{\"multiple elements, tie, return lowest index\", args{[]float64{1, 2, 3, 4, 5}, 3}, 2},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"empty slice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "705779804a0d6e416d989d33e5d71d2c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/scalar\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.3, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.7, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\t\t{n: 10, l: -1, u: 1, v: -2, want: 0},\n\t\t{n: 10, l: -1, u: 1, v: -1, want: 0},\n\t\t{n: 10, l: -1, u: 1, v: 0, want: 5},\n\t\t{n: 10, l: -1, u: 1, v: 1, want: 9},\n\t\t{n: 10, l: -1, u: 1, v: 2, want: 9},\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.3, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.7, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\t\t{n: 10, l: 1, u: -1, v: -2, want: 9},\n\t\t{n: 10, l: 1, u: -1, v: -1, want: 9},\n\t\t{n: 10, l: 1, u: -1, v: 0, want: 4},\n\t\t{n: 10, l: 1, u: -1, v: 1, want: 0},\n\t\t{n: 10, l: 1, u: -1, v: 2, want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Case %v: got %v, want %v\", test, got, test.want)\n\t\t}\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t}{\n\t\t{n: 2, l: 0, u: 1},\n\t\t{n: 3, l: 0, u: 1},\n\t\t{n: 10, l: -1, u: 1},\n\t\t{n: 10, l: 1, u: -1},\n\t} {\n\t\tt.Run(\"NaN\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, math.NaN())\n\t\t\tif got != 0 {\n\t\t\t\tt.Errorf(\"Case %v: got %v, want 0\", test, got)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Inf\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, math.Inf(1))\n\t\t\twant := test.n - 1\n\t\t\tif test.u \u003c test.l {\n\t\t\t\twant = 0\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"Case %v: got %v, want %v\", test, got, want)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"-Inf\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, math.Inf(-1))\n\t\t\twant := 0\n\t\t\tif test.u \u003c test.l {\n\t\t\t\twant = test.n - 1\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"Case %v: got %v, want %v\", test, got, want)\n\t\t\t}\n\t\t})\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tu float64\n\t}{\n\t\t{n: 2, u: 1},\n\t\t{n: 3, u: 1},\n\t\t{n: 10, u: 1},\n\t\t{n: 10, u: -1},\n\t} {\n\t\tl := math.NaN()\n\t\tt.Run(\"NaNLeft\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, l, test.u, 0.5)\n\t\t\tif got != 0 {\n\t\t\t\tt.Errorf(\"Case %v: got %v, want 0\", test, got)\n\t\t\t}\n\t\t})\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t}{\n\t\t{n: 2, l: 0},\n\t\t{n: 3, l: 0},\n\t\t{n: 10, l: -1},\n\t\t{n: 10, l: 1},\n\t} {\n\t\tu := math.NaN()\n\t\tt.Run(\"NaNRight\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, u, 0.5)\n\t\t\tif got != test.n-1 {\n\t\t\t\tt.Errorf(\"Case %v: got %v, want %v\", test, got, test.n-1)\n\t\t\t}\n\t\t})\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t}{\n\t\t{n: 2},\n\t\t{n: 3},\n\t\t{n: 4},\n\t\t{n: 5},\n\t\t{n: 10},\n\t} {\n\t\tinf := math.Inf(1)\n\t\tt.Run(\"InfBothSame\", func(t *testing.T) {\n\t\t\tfor _, v := range []float64{-2, -1, 0, 1, 2} {\n\t\t\t\tgot := NearestIdxForSpan(test.n, inf, inf, v)\n\t\t\t\tif got != 0 {\n\t\t\t\t\tt.Errorf(\"Case %v: got %v, want 0\", test, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"InfBothDifferent\", func(t *testing.T) {\n\t\t\tfor _, testv := range []struct {\n\t\t\t\tv float64\n\t\t\t\twant int\n\t\t\t}{\n\t\t\t\t{v: -2, want: 0},\n\t\t\t\t{v: -1, want: 0},\n\t\t\t\t{v: 0, want: test.n/2},\n\t\t\t\t{v: 1, want: test.n/2 + test.n%2},\n\t\t\t\t{v: 2, want: test.n/2 + test.n%2},\n\t\t\t} {\n\t\t\t\tgot := NearestIdxForSpan(test.n, -inf, inf, testv.v)\n\t\t\t\tif got != testv.want {\n\t\t\t\t\tt.Errorf(\"Case n=%v v=%v: got %v, want %v\", test.n, testv.v, got, testv.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tu float64\n\t}{\n\t\t{n: 2, u: 1},\n\t\t{n: 3, u: 1},\n\t\t{n: 10, u: 1},\n\t\t{n: 10, u: -1},\n\t} {\n\t\tl := math.Inf(-1)\n\t\tt.Run(\"InfLeft\", func(t *testing.T) {\n\t\t\tfor _, testv := range []struct {\n\t\t\t\tv float64\n\t\t\t\twant int\n\t\t\t}{\n\t\t\t\t{v: math.Inf(-1), want: 0},\n\t\t\t\t{v: -1, want: test.n - 2},\n\t\t\t\t{v: 0, want: test.n - 2},\n\t\t\t\t{v: 1, want: test.n - 2},\n\t\t\t\t{v: math.Inf(1), want: test.n - 2},\n\t\t\t} {\n\t\t\t\tgot := NearestIdxForSpan(test.n, l, test.u, testv.v)\n\t\t\t\tif got != testv.want {\n\t\t\t\t\tt.Errorf(\"Case n=%v v=%v: got %v, want %v\", test.n, testv.v, got, testv.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t}{\n\t\t{n: 2, l: 0},\n\t\t{n: 3, l: 0},\n\t\t{n: 10, l: -1},\n\t\t{n: 10, l: 1},\n\t} {\n\t\tu := math.Inf(1)\n\t\tt.Run(\"InfRight\", func(t *testing.T) {\n\t\t\tfor _, testv := range []struct {\n\t\t\t\tv float64\n\t\t\t\twant int\n\t\t\t}{\n\t\t\t\t{v: math.Inf(-1), want: 0},\n\t\t\t\t{v: -1, want: 0},\n\t\t\t\t{v: 0, want: 0},\n\t\t\t\t{v: 1, want: 0},\n\t\t\t\t{v: math.Inf(1), want: test.n - 1},\n\t\t\t} {\n\t\t\t\tgot := NearestIdxForSpan(test.n, test.l, u, testv.v)\n\t\t\t\tif got != testv.want {\n\t\t\t\t\tt.Errorf(\"Case n=%v v=%v: got %v, want %v\", test.n, testv.v, got, testv.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1} {\n\t\tfor _, test := range []struct {\n\t\t\tl float64\n\t\t\tu float64\n\t\t\tv float64\n\t\t}{\n\t\t\t{l: 0, u: 1, v: 0.5},\n\t\t\t{l: 1, u: 0, v: 0.5},\n\t\t\t{l: 0, u: 0, v: 0.5},\n\t\t\t{l: math.NaN(), u: 1, v: 0.5},\n\t\t\t{l: 0, u: math.NaN(), v: 0.5},\n\t\t\t{l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t} {\n\t\t\tpanicked := func() bool {\n\t\t\t\tdefer func() {\n\t\t\t\t\trecover()\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(n, test.l, test.u, test.v)\n\t\t\t\treturn false\n\t\t\t}()\n\t\t\tif !panicked {\n\t\t\t\tt.Errorf(\"Case n=%v: did not panic\", n)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\tfor _, n := range []int{2, 4, 10, 1000} {\n\t\tl := 0.0\n\t\tu := 1.0\n\t\ts := Span(make([]float64, n), l, u)\n\t\tb.Run(\n\t\t\t\"Span\",\n\t\t\tfunc(b *testing.B) {\n\t\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\t\tfor _, v := range s {\n\t\t\t\t\t\tNearestIdxForSpan(n, l, u, v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t\tb.Run(\n\t\t\t\"Direct\",\n\t\t\tfunc(b *testing.B) {\n\t\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\t\tfor _, v := range s {\n\t\t\t\t\t\tNearestIdx(s, v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestNearestIdxForSpanContains(t *testing.T) {\n\tconst tol = 1e-15\n\trnd := rand.New(rand.NewSource(1))\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tn := rnd.Intn(1000) + 2\n\t\tl := 10 * rnd.Float64()\n\t\tu := 10 * rnd.Float64()\n\t\tif i%2 == 0 {\n\t\t\tl, u = u, l\n\t\t}\n\t\ts := Span(make([]float64, n), l, u)\n\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\tv := l + rnd.Float64()*(u-l)\n\t\t\tidx := NearestIdxForSpan(n, l, u, v)\n\t\t\tif idx \u003c 0 || idx \u003e= n {\n\t\t\t\tt.Errorf(\"Index out of bounds: n=%v, l=%v, u=%v, v=%v, idx=%v\", n, l, u, v, idx)\n\t\t\t}\n\t\t\t// Check that the returned index is indeed the closest.\n\t\t\tdist := math.Abs(s[idx] - v)\n\t\t\tfor k := 0; k \u003c n; k++ {\n\t\t\t\tif k == idx {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif math.Abs(s[k]-v) \u003c dist-tol {\n\t\t\t\t\tt.Errorf(\"Wrong index returned: n=%v, l=%v, u=%v, v=%v, idx=%v, k=%v, s[idx]=%v, s[k]=%v\", n, l, u, v, idx, k, s[idx], s[k])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanEdgeCases(t *testing.T) {\n\t// Test cases where v is exactly between two elements of the span.\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.25, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.75, want: 2},\n\t\t{n: 4, l: 0, u: 1, v: 0.25, want: 1},\n\t\t{n: 4, l: 0, u: 1, v: 0.75, want: 2},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Case %v: got %v, want %v\", test, got, test.want)\n\t\t}\n\t}\n\n\t// Test cases where l == u.\n\tfor _, n := range []int{2, 3, 4, 10} {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, v := range []float64{-2, -1, 0, 1, 2} {\n\t\t\t\tgot := NearestIdxForSpan(n, l, l, v)\n\t\t\t\tif got != 0 {\n\t\t\t\t\tt.Errorf(\"Case n=%v, l=%v, v=%v: got %v, want 0\", n, l, v, got)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanRandom(t *testing.T) {\n\tconst tol = 1e-14\n\trnd := rand.New(rand.NewSource(1))\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tn := rnd.Intn(1000) + 2\n\t\tl := 100 * rnd.Float64()\n\t\tu := 100 * rnd.Float64()\n\t\tif rnd.Intn(2) == 0 {\n\t\t\tl, u = u, l\n\t\t}\n\t\tv := 100 * rnd.Float64()\n\n\t\tgot := NearestIdxForSpan(n, l, u, v)\n\n\t\t// Compare with the result of NearestIdx.\n\t\ts := Span(make([]float64, n), l, u)\n\t\twant := NearestIdx(s, v)\n\n\t\tif got != want {\n\t\t\tdiff := scalar.Abs(s[got] - v)\n\t\t\twantDiff := scalar.Abs(s[want] - v)\n\t\t\tif diff \u003e wantDiff+tol \u0026\u0026 wantDiff \u003e diff+tol {\n\t\t\t\tt.Errorf(\"Case %d: n=%d, l=%v, u=%v, v=%v: got %d (diff=%v), want %d (diff=%v)\", i, n, l, u, v, got, diff, want, wantDiff)\n\t\t\t}\n\t\t}\n\t}\n}",
    "70ef5cf162ccbbbeaffa61109d9d5327": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.75, 7},\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, 1, 0, 0.75, 2},\n\t\t{10, 1, 0, -1, 9},\n\t\t{10, 1, 0, 2, 0},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t\t{2, -5, 5, -6, 0},\n\t\t{2, -5, 5, 6, 1},\n\t\t{2, -5, 5, 0, 0},\n\t\t{3, -5, 5, -6, 0},\n\t\t{3, -5, 5, 6, 2},\n\t\t{3, -5, 5, 0, 1},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, 1, 1, 1, 0},\n\t\t{10, -1, -1, -1, 0},\n\t\t{10, math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{10, math.Inf(1), 0, math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(-1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{9, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.NaN(), 0, math.NaN(), 0},\n\t\t{10, 0, math.NaN(), math.NaN(), 0},\n\t\t{10, 0, 0, math.NaN(), 0},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Case %d: n = %d, l = %v, u = %v, v = %v\\nwant %d\\nhave %d\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, test.want, have,\n\t\t\t)\n\t\t}\n\t}\n}",
    "719fbaed10eb9f84af07d905fd6dc8b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, multiple elements.\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e100, 1, -1e100}, 1.0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := SumCompensated(tc.input)\n\t\tif math.Abs(got-tc.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "72080191d1a0f6a037ea1ba79b729034": "package floats\n\nimport \"testing\"\n\nfunc TestDot(t *testing.T) {\n\ts1 := []float64{1, 2, 3}\n\ts2 := []float64{4, 5, 6}\n\texpected := 32.0\n\tactual := Dot(s1, s2)\n\tif actual != expected {\n\t\tt.Errorf(\"Dot(%v, %v) = %v, expected %v\", s1, s2, actual, expected)\n\t}\n\n\t// Test case: empty slices\n\ts1 = []float64{}\n\ts2 = []float64{}\n\texpected = 0.0\n\tactual = Dot(s1, s2)\n\tif actual != expected {\n\t\tt.Errorf(\"Dot(%v, %v) = %v, expected %v\", s1, s2, actual, expected)\n\t}\n\n\t// Test case: slices with different lengths\n\ts1 = []float64{1, 2, 3}\n\ts2 = []float64{4, 5}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Dot(%v, %v) did not panic\", s1, s2)\n\t\t}\n\t}()\n\tDot(s1, s2)\n}",
    "731ef9c1650a0835b8d91c3e5645ea3d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with one element (should panic)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "7342be149dca4d93bbc1c7058fc4b165": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\t// Test cases for Same function\n\ttestCases := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\twant bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, 3}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := Same(tc.s, tc.t)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: Same(%v, %v) = %v, want %v\", i, tc.s, tc.t, got, tc.want)\n\t\t}\n\t}\n}",
    "735adf687a18e301fe773c3aa12dfa6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v, expected index %v, got %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc sf(format string, args ...interface{}) string {\n\treturn fmt.Sprintf(format, args...)\n}",
    "742c3a0e60b52275548045f9937128ed": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\t// Test case 1: Basic test\n\tdst := []float64{3, 1, 4, 1, 5, 9, 2, 6}\n\tinds := make([]int, len(dst))\n\tArgsortStable(dst, inds)\n\texpectedDst := []float64{1, 1, 2, 3, 4, 5, 6, 9}\n\texpectedInds := []int{1, 3, 6, 0, 2, 4, 7, 5}\n\tfor i := range dst {\n\t\tif dst[i] != expectedDst[i] {\n\t\t\tt.Errorf(\"TestArgsortStable Case 1: dst[%v] = %v, want %v\", i, dst[i], expectedDst[i])\n\t\t}\n\t\tif inds[i] != expectedInds[i] {\n\t\t\tt.Errorf(\"TestArgsortStable Case 1: inds[%v] = %v, want %v\", i, inds[i], expectedInds[i])\n\t\t}\n\t}\n\n\t// Test case 2: Already sorted\n\tdst = []float64{1, 2, 3, 4, 5}\n\tinds = make([]int, len(dst))\n\tArgsortStable(dst, inds)\n\texpectedDst = []float64{1, 2, 3, 4, 5}\n\texpectedInds = []int{0, 1, 2, 3, 4}\n\tfor i := range dst {\n\t\tif dst[i] != expectedDst[i] {\n\t\t\tt.Errorf(\"TestArgsortStable Case 2: dst[%v] = %v, want %v\", i, dst[i], expectedDst[i])\n\t\t}\n\t\tif inds[i] != expectedInds[i] {\n\t\t\tt.Errorf(\"TestArgsortStable Case 2: inds[%v] = %v, want %v\", i, inds[i], expectedInds[i])\n\t\t}\n\t}\n\n\t// Test case 3: Reverse sorted\n\tdst = []float64{5, 4, 3, 2, 1}\n\tinds = make([]int, len(dst))\n\tArgsortStable(dst, inds)\n\texpectedDst = []float64{1, 2, 3, 4, 5}\n\texpectedInds = []int{4, 3, 2, 1, 0}\n\tfor i := range dst {\n\t\tif dst[i] != expectedDst[i] {\n\t\t\tt.Errorf(\"TestArgsortStable Case 3: dst[%v] = %v, want %v\", i, dst[i], expectedDst[i])\n\t\t}\n\t\tif inds[i] != expectedInds[i] {\n\t\t\tt.Errorf(\"TestArgsortStable Case 3: inds[%v] = %v, want %v\", i, inds[i], expectedInds[i])\n\t\t}\n\t}\n}\n",
    "74b6c2682cd0091c2b1d38011061c6ec": "package floats\n\nimport \"testing\"\n\nfunc TestAddTo(t *testing.T) {\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\tdst := make([]float64, 3)\n\tAddTo(dst, s, t)\n\texpected := []float64{5, 7, 9}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"AddTo() mismatch at index %d, got %f, want %f\", i, dst[i], expected[i])\n\t\t}\n\t}\n}",
    "7531e22078872885620137b8f10e36fa": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/internal/floats\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst: []float64{2, 3, 4},\n\t\t\ts:   []float64{1, 1, 1},\n\t\t\tt:   []float64{1, 2, 3},\n\t\t\twant: []float64{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 4),\n\t\t\ts:   []float64{1, -1, 2, -2},\n\t\t\tt:   []float64{-1, 1, -2, 2},\n\t\t\twant: []float64{0, 0, 0, 0},\n\t\t},\n\t} {\n\t\tgot := AddTo(test.dst, test.s, test.t)\n\t\tif !floats.Equal(got, test.want) {\n\t\t\tt.Errorf(\"unexpected result for case %d: got=%v want=%v\", i, got, test.want)\n\t\t}\n\t}\n\n\t// Test that panics with unequal lengths.\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"did not panic with unequal lengths\")\n\t\t}\n\t}()\n\tAddTo([]float64{1}, []float64{1, 2}, []float64{1})\n}",
    "75568582d0db1dd3b3d9aaadf9b871d7": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{0, 1, 2}, -1, -1},\n\t\t{[]float64{0, 1, 2}, 0, 0},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{0, 1, 2}, 2, -1},\n\t\t{[]float64{0, 1, 2}, 3, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1e11, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1.0001, 0},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1, 1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -0.9999, 1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 0, 2},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 0.9999, 2},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1, 3},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1.0001, 3},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1e10, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1e11, -1},\n\t} {\n\t\tvar got int\n\t\tif !panics(t, \"test %d: %v\", i, test.s, func() { got = Within(test.s, test.v) }) {\n\t\t\tcontinue\n\t\t}\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"test %d: different: got %v != expected %v\", i, got, test.expected)\n\t\t}\n\t}\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{0, 1}, math.NaN(), -1},\n\t\t{[]float64{0, 1, 2}, math.NaN(), -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, math.NaN(), -1},\n\t} {\n\t\tvar got int\n\t\tif !panics(t, \"test %d: %v\", i, test.s, func() { got = Within(test.s, test.v) }) {\n\t\t\tcontinue\n\t\t}\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"test %d: different: got %v != expected %v\", i, got, test.expected)\n\t\t}\n\t}\n\n\tfor i, test := range []struct {\n\t\ts []float64\n\t}{\n\t\t{nil},\n\t\t{[]float64{0}},\n\t\t{[]float64{1, 0}},\n\t} {\n\t\tif !panics(t, \"test %d: %v\", i, test.s, func() { Within(test.s, 0) }) {\n\t\t\tt.Errorf(\"Test %d: Within should have panicked\", i)\n\t\t}\n\t}\n}\n\nfunc panics(t *testing.T, format string, args ...interface{}) (panicked bool) {\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tt.Logf(format, args...)\n\t\t\tt.Logf(\"Panicked: %v\", r)\n\t\t\tpanicked = true\n\t\t}\n\t}()\n\targs = append([]interface{}{}, args...)\n\tformat = format + \"\\ndoes not panic\"\n\tt.Errorf(format, args...)\n\treturn false\n}\n",
    "764003bc0b16664630dab25d0a7361f9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{2, 3, 2, 4}, []float64{3, 2, 4, 1}, 1, 6},\n\t\t{[]float64{2, 3, 2, 4}, []float64{3, 2, 4, 1}, 2, math.Sqrt(11)},\n\t\t{[]float64{2, 3, 2, 4}, []float64{3, 2, 4, 1}, 3, math.Cbrt(27)},\n\t\t{[]float64{2, 3, 2, 4}, []float64{3, 2, 4, 1}, math.Inf(1), 3},\n\t\t{[]float64{2, -3, 2, 4}, []float64{-3, 2, -4, 1}, math.Inf(1), 7},\n\t\t{[]float64{}, []float64{}, 2, 0},\n\t} {\n\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\tif !test.EqualWithinAbsOrRel(got, tc.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: got %v, want %v\", tc.s, tc.t, tc.L, got, tc.want)\n\t\t}\n\t}\n\n\tpanics := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, 2},\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, 2},\n\t}\n\tfor _, tc := range panics {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: didn't panic\", tc.s, tc.t, tc.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tDistance(tc.s, tc.t, tc.L)\n\t\t}()\n\t}\n}",
    "7775eae90044d2b83c4ba237a18e6524": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\ttype testCase struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}\n\ttestCases := []testCase{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 0, 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, 6, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -1, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, math.NaN(), 0},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, 4, 4},\n\t\t{[]float64{math.NaN(), 2, 3, 4, 5}, 4, 3},\n\t\t{[]float64{1, 2, 2, 4, 5}, 2.1, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(-1), 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdx(tc.s, tc.v)\n\t\tif tc.expected != got {\n\t\t\tt.Errorf(\"Test case %v: expected %v got %v\", i, tc.expected, got)\n\t\t}\n\t}\n}\n",
    "77b93326ee7c291bfa127d16988aa7d8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with slice with one element\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want all NaN\", dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsNaN(dst[i]) \u0026\u0026 math.IsNaN(want[i])) \u0026\u0026 dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsNaN(dst[i]) \u0026\u0026 math.IsNaN(want[i])) \u0026\u0026 dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want all +Inf\", dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsInf(dst[i], 1) \u0026\u0026 math.IsInf(want[i], 1)) \u0026\u0026 dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsInf(dst[i], 1) \u0026\u0026 math.IsInf(want[i], 1)) \u0026\u0026 dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span failed: got %v, want %v\", dst, want)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "79104be89c9c1a79798d2bc6dce60d34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various lengths and ranges.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 3\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    2,\n\t\t\twant: []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 5\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 10\",\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 1.8, 2.6, 3.4, 4.2, 5, 5.8, 6.6, 7.4, 8.2},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tt.Run(\"NaN and Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1 at last index, got %v\", dst[len(dst)-1])\n\t\t}\n\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0 at first index, got %v\", dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\n\t\tSpan(dst, math.Inf(1), 0)\n\t\tfor i := 0; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\tfor i := 0; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at index %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// Test case for panic when len(dst) \u003c 2.\n\tt.Run(\"Panic on short slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Span did not panic on short slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "79ba96a414ec58600a22cf4d6a65c7d9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: (n, l, u, v, expectedIndex)\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 1, 0.5, 2},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, -5, 5, 0, 5},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, -0.1, 0},\n\t\t{2, 0, 1, 1.1, 1},\n\t\t{10, 0, 1, 0, 0},\n\t\t{10, 0, 1, 1, 9},\n\n\t\t// Cases with NaN and Inf\n\t\t{5, 0, 1, math.NaN(), 0},\n\t\t{5, math.NaN(), 1, 0.5, 6},\n\t\t{5, 0, math.NaN(), 0.5, 0},\n\t\t{5, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3},\n\t\t{6, math.Inf(-1), math.Inf(1), math.Inf(1), 5},\n\t\t{6, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, 0, 1, math.Inf(1), 4},\n\t\t{5, 0, 1, math.Inf(-1), 0},\n\t\t{5, 1, 0, math.Inf(1), 0},\n\t\t{5, 1, 0, math.Inf(-1), 4},\n\n\t\t// Reverse span\n\t\t{5, 1, -1, 0.5, 2},\n\t\t{10, 10, 0, 5, 5},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v got index %d, expected %d\",\n\t\t\t\ti+1, tc.n, tc.l, tc.u, tc.v, actualIdx, tc.expectedIdx)\n\t\t}\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "79f3aca3977491f8d5f9776daa658477": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l and u are NaN\n\t// - l or u is Inf\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 0)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf, different sign\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif i != 2 \u0026\u0026 !math.IsInf(dst[i], int(expected[i])) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t} else if i == 2 \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf, different sign, even length\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], int(expected[i])) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "7ae0b412168e3741e885695e100e10dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{0.0, 0.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBoundInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBoundInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif math.IsNaN(got[i]) != math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"NaN mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2.\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n",
    "7ba6c1a9d9cfc826feb1c6cc29a7d1d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1e10, 1, 1e10}, 2e10 + 1},\n\t\t{[]float64{math.Inf(1), 1, 2, 3}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), 1, 2, 3}, math.Inf(-1)},\n\t}\n\n\t// Iterate through test cases.\n\tfor i, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Compare the actual and expected results.\n\t\tif math.IsNaN(tc.expected) {\n\t\t\tif !math.IsNaN(actual) {\n\t\t\t\tt.Errorf(\"Test case %d failed: expected NaN, got %v\", i, actual)\n\t\t\t}\n\t\t} else if actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "7be2cfa5773f77e57f0b52a902a37906": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v, expected index %v, got %v\", tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\nfunc sf(format string, a ...any) string {\n\treturn fmt.Sprintf(format, a...)\n}",
    "7ce7e0ff5d5a26e4ace3cfba39e5cd75": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantIndsC []int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"EmptySlice\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"AllMatchKLessZero\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{0, 1, 2, 3, 4},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"SomeMatchKLessZero\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(f float64) bool { return f \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{2, 3, 4},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"NoneMatchKLessZero\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(f float64) bool { return f \u003e 5 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"AllMatchKGreaterThanZero\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         3,\n\t\t\twantInds:  []int{0, 1, 2},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"SomeMatchKGreaterThanZero\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(f float64) bool { return f \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         3,\n\t\t\twantInds:  []int{2, 3, 4},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"NotEnoughMatchKGreaterThanZero\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(f float64) bool { return f \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         4,\n\t\t\twantInds:  []int{2, 3, 4},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsC: []int{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinds := make([]int, len(tc.inds))\n\t\t\tcopy(inds, tc.inds)\n\t\t\tgot, err := Find(inds, tc.f, tc.s, tc.k)\n\t\t\tif !errors.Is(err, tc.wantErr) {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !sameIntSlice(got, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find() got = %v, want %v\", got, tc.wantInds)\n\t\t\t}\n\t\t\tif !sameIntSlice(inds, tc.wantIndsC) {\n\t\t\t\tt.Errorf(\"Find() inds = %v, want %v\", inds, tc.wantIndsC)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc sameIntSlice(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "7dbdc50dd0c7ca092a6eb33c2b115cb4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases:\n\t// - Empty input\n\t// - Single slice\n\t// - Multiple slices with equal lengths\n\t// - Multiple slices with unequal lengths\n\n\t// Empty input\n\tif !EqualLengths() {\n\t\tt.Error(\"EqualLengths() with empty input should return true\")\n\t}\n\n\t// Single slice\n\tif !EqualLengths([]float64{1, 2, 3}) {\n\t\tt.Error(\"EqualLengths() with a single slice should return true\")\n\t}\n\n\t// Multiple slices with equal lengths\n\tif !EqualLengths([]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}) {\n\t\tt.Error(\"EqualLengths() with multiple slices of equal length should return true\")\n\t}\n\n\t// Multiple slices with unequal lengths\n\tif EqualLengths([]float64{1, 2, 3}, []float64{4, 5}, []float64{7, 8, 9}) {\n\t\tt.Error(\"EqualLengths() with multiple slices of unequal length should return false\")\n\t}\n}",
    "7dee733e37d1cd403fa43e560561b44b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various lengths and ranges.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 5\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, -0.5, 0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 10\",\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    10,\n\t\t\tu:    20,\n\t\t\twant: []float64{10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tt.Run(\"NaN cases\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\t// NaN for l.\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0}\n\t\tgot := Span(dst, math.NaN(), 1.0)\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, NaN, 1.0) = %v, want %v\", dst, got, want)\n\t\t}\n\n\t\t// NaN for u.\n\t\twant = []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tgot = Span(dst, 0.0, math.NaN())\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, 0.0, NaN) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Inf cases\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\n\t\t// Both Inf.\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tgot := Span(dst, math.Inf(1), math.Inf(-1))\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf(1), Inf(-1)) = %v, want %v\", dst, got, want)\n\t\t}\n\n\t\t// l is Inf.\n\t\twant = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1.0}\n\t\tgot = Span(dst, math.Inf(1), 1.0)\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf(1), 1.0) = %v, want %v\", dst, got, want)\n\t\t}\n\n\t\t// u is Inf.\n\t\twant = []float64{0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tgot = Span(dst, 0.0, math.Inf(-1))\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, 0.0, Inf(-1)) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tt.Run(\"Panic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "7e067ec2eec8c0ce92a797561684a201": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of elements in the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// expected: the expected index\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{5, 1, 5, 3, 2},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Can't guarantee anything about exactly halfway between\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\", i+1, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "7e0e584ee99bb04f534bf4a061567134": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with no matching elements\n\t// - Slice with one matching element\n\t// - Slice with multiple matching elements\n\t// - k = 0\n\t// - k \u003c 0\n\t// - k \u003e 0 and fewer than k elements found\n\n\t// Empty slice\n\t{\n\t\ts := []float64{}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v \u003e 0 }\n\t\tk := 2\n\t\texpectedInds := []int{}\n\t\texpectedErr := errors.New(\"floats: insufficient elements found\")\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for empty slice case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n\n\t// Slice with no matching elements\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v \u003e 10 }\n\t\tk := 2\n\t\texpectedInds := []int{}\n\t\texpectedErr := errors.New(\"floats: insufficient elements found\")\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for no matching elements case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n\n\t// Slice with one matching element\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v == 3 }\n\t\tk := 2\n\t\texpectedInds := []int{2}\n\t\texpectedErr := errors.New(\"floats: insufficient elements found\")\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for one matching element case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n\n\t// Slice with multiple matching elements\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v \u003e 2 }\n\t\tk := 2\n\t\texpectedInds := []int{2, 3}\n\t\texpectedErr := error(nil)\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for multiple matching elements case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n\n\t// k = 0\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v \u003e 2 }\n\t\tk := 0\n\t\texpectedInds := []int{}\n\t\texpectedErr := error(nil)\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for k = 0 case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n\n\t// k \u003c 0\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v \u003e 2 }\n\t\tk := -1\n\t\texpectedInds := []int{2, 3, 4}\n\t\texpectedErr := error(nil)\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for k \u003c 0 case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n\n\t// k \u003e 0 and fewer than k elements found\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tinds := make([]int, 0)\n\t\tf := func(v float64) bool { return v \u003e 2 }\n\t\tk := 4\n\t\texpectedInds := []int{2, 3, 4}\n\t\texpectedErr := errors.New(\"floats: insufficient elements found\")\n\t\tgotInds, gotErr := Find(inds, f, s, k)\n\t\tif !equalIntSlices(gotInds, expectedInds) || !errorEqual(gotErr, expectedErr) {\n\t\t\tt.Errorf(\"Find() failed for k \u003e 0 and fewer than k elements found case. Expected: %v, %v, Got: %v, %v\", expectedInds, expectedErr, gotInds, gotErr)\n\t\t}\n\t}\n}\n\nfunc equalIntSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc errorEqual(a, b error) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.Error() == b.Error()\n}",
    "7e338ea1edf5d53d16546d7262adfbf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t\t{9, 0, 10, 5, 4},\n\t\t{9, 0, 10, -1, 0},\n\t\t{9, 0, 10, 11, 8},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanInfCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 5, 4},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, math.Inf(1), 10, math.Inf(1), 0},\n\t\t{10, math.Inf(1), 10, 5, 9},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), 5, 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t}\n\n\tfor i, tc := range nanInfCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tpanicCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 10, 5},\n\t\t{0, 0, 10, 5},\n\t\t{-1, 0, 10, 5},\n\t}\n\n\tfor i, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) did not panic\",\n\t\t\t\t\ti, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}\n",
    "7f25d22513ef6e04b64a192ed3cfc5b0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 2, i: 1},\n\n\t\t{n: 3, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, i: 2},\n\n\t\t{n: 4, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 4, l: -1, u: 1, v: 1, i: 3},\n\t\t{n: 4, l: -1, u: 1, v: 2, i: 3},\n\n\t\t{n: 10, l: 0, u: 10, v: -1, i: 0},\n\t\t{n: 10, l: 0, u: 10, v: 0, i: 0},\n\t\t{n: 10, l: 0, u: 10, v: 1, i: 1},\n\t\t{n: 10, l: 0, u: 10, v: 2, i: 2},\n\t\t{n: 10, l: 0, u: 10, v: 3, i: 3},\n\t\t{n: 10, l: 0, u: 10, v: 4, i: 4},\n\t\t{n: 10, l: 0, u: 10, v: 5, i: 5},\n\t\t{n: 10, l: 0, u: 10, v: 6, i: 6},\n\t\t{n: 10, l: 0, u: 10, v: 7, i: 7},\n\t\t{n: 10, l: 0, u: 10, v: 8, i: 8},\n\t\t{n: 10, l: 0, u: 10, v: 9, i: 9},\n\t\t{n: 10, l: 0, u: 10, v: 10, i: 9},\n\t\t{n: 10, l: 0, u: 10, v: 11, i: 9},\n\n\t\t{n: 2, l: 1, u: -1, v: -2, i: 1},\n\t\t{n: 2, l: 1, u: -1, v: 0, i: 1},\n\t\t{n: 2, l: 1, u: -1, v: 2, i: 0},\n\n\t\t{n: 3, l: 1, u: -1, v: -2, i: 2},\n\t\t{n: 3, l: 1, u: -1, v: -1, i: 2},\n\t\t{n: 3, l: 1, u: -1, v: 0, i: 1},\n\t\t{n: 3, l: 1, u: -1, v: 1, i: 0},\n\t\t{n: 3, l: 1, u: -1, v: 2, i: 0},\n\n\t\t{n: 4, l: 1, u: -1, v: -2, i: 3},\n\t\t{n: 4, l: 1, u: -1, v: -1, i: 2},\n\t\t{n: 4, l: 1, u: -1, v: 0, i: 1},\n\t\t{n: 4, l: 1, u: -1, v: 1, i: 0},\n\t\t{n: 4, l: 1, u: -1, v: 2, i: 0},\n\n\t\t{n: 10, l: 10, u: 0, v: -1, i: 9},\n\t\t{n: 10, l: 10, u: 0, v: 0, i: 9},\n\t\t{n: 10, l: 10, u: 0, v: 1, i: 8},\n\t\t{n: 10, l: 10, u: 0, v: 2, i: 7},\n\t\t{n: 10, l: 10, u: 0, v: 3, i: 6},\n\t\t{n: 10, l: 10, u: 0, v: 4, i: 5},\n\t\t{n: 10, l: 10, u: 0, v: 5, i: 4},\n\t\t{n: 10, l: 10, u: 0, v: 6, i: 3},\n\t\t{n: 10, l: 10, u: 0, v: 7, i: 2},\n\t\t{n: 10, l: 10, u: 0, v: 8, i: 1},\n\t\t{n: 10, l: 10, u: 0, v: 9, i: 0},\n\t\t{n: 10, l: 10, u: 0, v: 10, i: 0},\n\t\t{n: 10, l: 10, u: 0, v: 11, i: 0},\n\n\t\t{n: 2, l: -math.Inf(1), u: math.Inf(1), v: -math.Inf(1), i: 0},\n\t\t{n: 2, l: -math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 3, l: -math.Inf(1), u: math.Inf(1), v: -math.Inf(1), i: 0},\n\t\t{n: 3, l: -math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 4, l: -math.Inf(1), u: math.Inf(1), v: -math.Inf(1), i: 0},\n\t\t{n: 4, l: -math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 3},\n\n\t\t{n: 2, l: math.Inf(1), u: -math.Inf(1), v: -math.Inf(1), i: 1},\n\t\t{n: 2, l: math.Inf(1), u: -math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 3, l: math.Inf(1), u: -math.Inf(1), v: -math.Inf(1), i: 2},\n\t\t{n: 3, l: math.Inf(1), u: -math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 4, l: math.Inf(1), u: -math.Inf(1), v: -math.Inf(1), i: 3},\n\t\t{n: 4, l: math.Inf(1), u: -math.Inf(1), v: math.Inf(1), i: 0},\n\n\t\t{n: 2, l: math.NaN(), u: 1, v: 2, i: 1},\n\t\t{n: 3, l: math.NaN(), u: 1, v: 2, i: 2},\n\t\t{n: 4, l: math.NaN(), u: 1, v: 2, i: 3},\n\t\t{n: 2, l: 1, u: math.NaN(), v: 2, i: 0},\n\t\t{n: 3, l: 1, u: math.NaN(), v: 2, i: 0},\n\t\t{n: 4, l: 1, u: math.NaN(), v: 2, i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: index mismatch. Want %v, got %v.\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.i, i)\n\t\t}\n\t}\n\t// NaN input returns first index.\n\tfor _, n := range []int{2, 3, 4, 10} {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\ti := NearestIdxForSpan(n, l, u, math.NaN())\n\t\t\t\tif i != 0 {\n\t\t\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = NaN: index mismatch. Want 0, got %v.\",\n\t\t\t\t\t\tn, l, u, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1} {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\tfor _, v := range []float64{-1, 0, 1} {\n\t\t\t\t\tpanicked := testlapack.Panics(func() { NearestIdxForSpan(n, l, u, v) })\n\t\t\t\t\tif !panicked {\n\t\t\t\t\t\tt.Errorf(\"Case n = %v: did not panic\", n)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "7f3a126a386b9ed26bfb0769fd5122a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with one element\n\t// - Slice with multiple elements, max at beginning\n\t// - Slice with multiple elements, max in middle\n\t// - Slice with multiple elements, max at end\n\t// - Slice with multiple max values\n\t// - Slice with NaN values\n\n\t// Empty slice\n\tt.Run(\"Empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tMaxIdx([]float64{})\n\t})\n\n\t// Slice with one element\n\tt.Run(\"One element\", func(t *testing.T) {\n\t\ts := []float64{1.0}\n\t\texpected := 0\n\t\tresult := MaxIdx(s)\n\t\tif result != expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s, result, expected)\n\t\t}\n\t})\n\n\t// Slice with multiple elements, max at beginning\n\tt.Run(\"Max at beginning\", func(t *testing.T) {\n\t\ts := []float64{3.0, 1.0, 2.0}\n\t\texpected := 0\n\t\tresult := MaxIdx(s)\n\t\tif result != expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s, result, expected)\n\t\t}\n\t})\n\n\t// Slice with multiple elements, max in middle\n\tt.Run(\"Max in middle\", func(t *testing.T) {\n\t\ts := []float64{1.0, 3.0, 2.0}\n\t\texpected := 1\n\t\tresult := MaxIdx(s)\n\t\tif result != expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s, result, expected)\n\t\t}\n\t})\n\n\t// Slice with multiple elements, max at end\n\tt.Run(\"Max at end\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\texpected := 2\n\t\tresult := MaxIdx(s)\n\t\tif result != expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s, result, expected)\n\t\t}\n\t})\n\n\t// Slice with multiple max values\n\tt.Run(\"Multiple max values\", func(t *testing.T) {\n\t\ts := []float64{3.0, 1.0, 3.0, 2.0}\n\t\texpected := 0\n\t\tresult := MaxIdx(s)\n\t\tif result != expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s, result, expected)\n\t\t}\n\t})\n\n\t// Slice with NaN values\n\tt.Run(\"NaN values\", func(t *testing.T) {\n\t\ts := []float64{1.0, math.NaN(), 3.0, 2.0, math.NaN()}\n\t\texpected := 2\n\t\tresult := MaxIdx(s)\n\t\tif result != expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s, result, expected)\n\t\t}\n\t})\n}",
    "7f6810e613aee48e70477e69512564f4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases.\n\ttcs := []struct {\n\t\tname  string\n\t\ts     [][]float64\n\t\tequal bool\n\t}{\n\t\t{\"Empty slice\", [][]float64{}, true},\n\t\t{\"Single slice\", [][]float64{{1, 2, 3}}, true},\n\t\t{\"Equal lengths\", [][]float64{{1, 2}, {3, 4}}, true},\n\t\t{\"Unequal lengths\", [][]float64{{1, 2}, {3, 4, 5}}, false},\n\t}\n\n\t// Run test cases.\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.s...)\n\t\t\tif got != tc.equal {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.s, got, tc.equal)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f69ce5884584bab680bef849c1ae2aa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Zero length input\n\t// - Input length of 1\n\t// - Evenly spaced values\n\t// - Unevenly spaced values\n\t// - Infinite values\n\t// - NaN values\n\n\t// Zero length input\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with dst length = 0\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Input length of 1\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with dst length = 1\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Evenly spaced values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\texpected := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Unevenly spaced values\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Infinite values\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 0) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// NaN values\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "806936f5d9d784f8306b0ac2a5943872": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\tt.Parallel()\n\tfor i, c := range []struct {\n\t\tinput [][]float64\n\t\twant  bool\n\t}{\n\t\t{nil, true},\n\t\t{[][]float64{{}}, true},\n\t\t{[][]float64{{1}, {2}}, true},\n\t\t{[][]float64{{1, 2}, {2, 3}}, true},\n\t\t{[][]float64{{}, {1}}, false},\n\t\t{[][]float64{{1}, {2, 3}}, false},\n\t\t{[][]float64{{1, 2}, {2, 3, 4}}, false},\n\t} {\n\t\tgot := EqualLengths(c.input...)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"case %d: got %v, want %v\", i, got, c.want)\n\t\t}\n\t}\n}",
    "809daefdfb910db4c42b0f1b1277fcbe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with negative start and end values\n\t// - Slice with start value greater than end value\n\t// - Slice with NaN start or end value\n\t// - Slice with Inf start or end value\n\n\t// Test case 1: Empty slice\n\tdst := []float64{}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 2: Slice with one element\n\tdst = []float64{0}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 3: Slice with two elements\n\tdst = make([]float64, 2)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 4: Slice with multiple elements\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpected = []float64{0, 0.25, 0.5, 0.75, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 5: Slice with negative start and end values\n\tdst = make([]float64, 5)\n\tSpan(dst, -1, 1)\n\texpected = []float64{-1, -0.5, 0, 0.5, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 6: Slice with start value greater than end value\n\tdst = make([]float64, 5)\n\tSpan(dst, 1, -1)\n\texpected = []float64{1, 0.5, 0, -0.5, -1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 7: Slice with NaN start value\n\tdst = make([]float64, 5)\n\tSpan(dst, math.NaN(), 1)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected 1 at last index, got %v\", dst[len(dst)-1])\n\t}\n\n\t// Test case 8: Slice with NaN end value\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected 0 at first index, got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 9: Slice with Inf start value\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), 1)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected 1 at last index, got %v\", dst[len(dst)-1])\n\t}\n\n\t// Test case 10: Slice with Inf end value\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected 0 at first index, got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 11: Slice with both Inf start and end values\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := 0; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 12: Slice with both -Inf start and end values\n\tdst = make([]float64, 6)\n\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\tfor i := 0; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Expected -Inf at index %v, got %v\", i, dst[i])\n\t\t}\n\t}\n}\n",
    "80ffe1ef1dc80434c8321ba0d2fb1c7c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with negative start and end values\n\t// - Slice with start value greater than end value\n\t// - Slice with NaN values\n\t// - Slice with Inf values\n\n\t// Test case 1: Empty slice\n\tdst := []float64{}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 2: Slice with one element\n\tdst = []float64{0}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 3: Slice with two elements\n\tdst = make([]float64, 2)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 4: Slice with multiple elements\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpected = []float64{0, 0.25, 0.5, 0.75, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 5: Slice with negative start and end values\n\tdst = make([]float64, 5)\n\tSpan(dst, -1, -0.5)\n\texpected = []float64{-1, -0.8, -0.6, -0.4, -0.5}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 6: Slice with start value greater than end value\n\tdst = make([]float64, 5)\n\tSpan(dst, 1, 0)\n\texpected = []float64{1, 0.75, 0.5, 0.25, 0}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 7: Slice with NaN values\n\tdst = make([]float64, 5)\n\tSpan(dst, math.NaN(), 1)\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.NaN())\n\texpected = []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 8: Slice with Inf values\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), 1)\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.Inf(1))\n\texpected = []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\texpected = []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], -1) != math.IsInf(expected[i], -1) || math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n}\n",
    "8164f904edbace0e687a6eb1a01a3af5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"L=1\", args{s, t, 1}, 16},\n\t\t{\"L=2\", args{s, t, 2}, 8},\n\t\t{\"L=3\", args{s, t, 3}, 6.349604207872797},\n\t\t{\"L=inf\", args{s, t, math.Inf(1)}, 4},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "820e22f4df79d99e681e83421197f3ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slices\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, -1},\n\t\t{[]float64{}, 2, -1},\n\t\t{[]float64{}, math.Inf(1), -1},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the norm using the function being tested\n\t\tactual := Norm(tc.s, tc.L)\n\n\t\t// Compare the actual result with the expected result\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Norm(%v, %v): expected %v, actual %v\", tc.s, tc.L, tc.expected, actual)\n\t\t}\n\t}\n}",
    "8237b765f07159af3926d27949397523": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l is +Inf\n\t// - u is -Inf\n\t// - l is NaN\n\t// - u is NaN\n\t// - l and u are both +Inf\n\t// - l and u are both -Inf\n\t// - l = +Inf, u is regular\n\t// - l is regular, u = -Inf\n\n\tt.Run(\"Panics if len(dst) \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"Regular l and u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\twant := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 4) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is +Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 4)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), 4) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"u is -Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\twant := []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, Inf(-1)) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 4)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, NaN(), 4) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"u is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, 0, NaN()) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are both +Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), Inf(1)) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are both -Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\t\twant := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(-1), Inf(-1)) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l = +Inf, u is regular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 0)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), 0) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is regular, u = -Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\twant := []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range want {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, Inf(-1)) returned %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "82cfd02b37e335e4d6d30fe85596f5fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for Norm function\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over the test cases and compare the expected output\n\t// with the actual output of the Norm function\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "8316756719bd266dc16a02ec38ac71fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.9,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    2.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"first\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"last\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"at upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\tv:    3,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds different sign, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds different sign, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds different sign, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds different sign, even n\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds different sign, even n\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite bounds different sign, even n\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\tv:    -1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\tv:    -math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite value, increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite value, increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite value, decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite value, decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d, %v, %v, %v). got=%d want=%d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\tpanics := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t}{\n\t\t{\n\t\t\tname: \"zero length\",\n\t\t\tn:    0,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t\t{\n\t\t\tname: \"one length\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t}\n\tfor _, tc := range panics {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest.Panics(t, func() { NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v) })\n\t\t})\n\t}\n}\n",
    "833b21a0075c577fde94c189898f66a9": "package floats\n\nimport \"testing\"\n\nfunc TestArgsort_Swap(t *testing.T) {\n\t// Example usage\n\ta := argsort{\n\t\ts:    []float64{3, 1, 4, 2},\n\t\tinds: []int{0, 1, 2, 3},\n\t}\n\n\ta.Swap(1, 2)\n\n\t// Assertions\n\twantS := []float64{3, 4, 1, 2}\n\tfor i, v := range wantS {\n\t\tif a.s[i] != v {\n\t\t\tt.Errorf(\"a.s[%d] = %v, want %v\", i, a.s[i], v)\n\t\t}\n\t}\n\n\twantInds := []int{0, 2, 1, 3}\n\tfor i, v := range wantInds {\n\t\tif a.inds[i] != v {\n\t\t\tt.Errorf(\"a.inds[%d] = %v, want %v\", i, a.inds[i], v)\n\t\t}\n\t}\n}",
    "84cba209de73be9fc8a65c3115cd478d": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases for Find.\n\t// Each test case consists of:\n\t//   - input slice s\n\t//   - input function f\n\t//   - input k\n\t//   - expected output indices\n\t//   - expected error\n\ttestCases := []struct {\n\t\ts        []float64\n\t\tf        func(float64) bool\n\t\tk        int\n\t\twantInds []int\n\t\twantErr  error\n\t}{\n\t\t// Test case 1: Find the first 2 even numbers.\n\t\t{[]float64{1, 2, 3, 4, 5},\n\t\t\tfunc(v float64) bool { return int(v)%2 == 0 },\n\t\t\t2,\n\t\t\t[]int{1, 3},\n\t\t\tnil,\n\t\t},\n\t\t// Test case 2: Find the first 3 numbers greater than 2.\n\t\t{[]float64{1, 2, 3, 4, 5},\n\t\t\tfunc(v float64) bool { return v \u003e 2 },\n\t\t\t3,\n\t\t\t[]int{2, 3, 4},\n\t\t\tnil,\n\t\t},\n\t\t// Test case 3: Find all even numbers.\n\t\t{[]float64{1, 2, 3, 4, 5},\n\t\t\tfunc(v float64) bool { return int(v)%2 == 0 },\n\t\t\t-1,\n\t\t\t[]int{1, 3},\n\t\t\tnil,\n\t\t},\n\t\t// Test case 4: Find all numbers greater than 2.\n\t\t{[]float64{1, 2, 3, 4, 5},\n\t\t\tfunc(v float64) bool { return v \u003e 2 },\n\t\t\t-1,\n\t\t\t[]int{2, 3, 4},\n\t\t\tnil,\n\t\t},\n\t\t// Test case 5: Find the first 3 even numbers, but there are only 2.\n\t\t{[]float64{1, 2, 3, 4, 5},\n\t\t\tfunc(v float64) bool { return int(v)%2 == 0 },\n\t\t\t3,\n\t\t\t[]int{1, 3},\n\t\t\terrors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Test case 6: Find the first 0 numbers.\n\t\t{[]float64{1, 2, 3, 4, 5},\n\t\t\tfunc(v float64) bool { return int(v)%2 == 0 },\n\t\t\t0,\n\t\t\t[]int{},\n\t\t\tnil,\n\t\t},\n\t}\n\n\t// Iterate over the test cases.\n\tfor i, tc := range testCases {\n\t\t// Run the Find function.\n\t\tgotInds, gotErr := Find(nil, tc.f, tc.s, tc.k)\n\n\t\t// Check the error.\n\t\tif gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\tt.Errorf(\"Test case %d: unexpected error: %v\", i+1, gotErr)\n\t\t} else if gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\tt.Errorf(\"Test case %d: expected error but got nil\", i+1)\n\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\tt.Errorf(\"Test case %d: error mismatch: got %v, want %v\", i+1, gotErr, tc.wantErr)\n\t\t}\n\n\t\t// Check the indices.\n\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\tt.Errorf(\"Test case %d: length mismatch: got %d, want %d\", i+1, len(gotInds), len(tc.wantInds))\n\t\t} else {\n\t\t\tfor j := 0; j \u003c len(gotInds); j++ {\n\t\t\t\tif gotInds[j] != tc.wantInds[j] {\n\t\t\t\t\tt.Errorf(\"Test case %d: index mismatch at position %d: got %d, want %d\", i+1, j, gotInds[j], tc.wantInds[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "84cf1db0881ba9374d11a631125e887c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: {n, l, u, v, expected index}\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 1, 0.5, 2},\n\t\t{5, 0, 1, -0.1, 0},\n\t\t{5, 0, 1, 1.1, 4},\n\t\t{10, 0, 1, 0.25, 2},\n\n\t\t// Cases with NaN and Inf\n\t\t{5, 0, math.NaN(), 0.5, 0},\n\t\t{5, math.NaN(), 1, 0.5, 4},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, 0, 1, math.Inf(-1), 0},\n\t\t{5, 0, 1, math.Inf(1), 4},\n\t\t{5, 1, 0, math.Inf(-1), 4},\n\t\t{5, 1, 0, math.Inf(1), 0},\n\n\t\t// Cases with equal bounds\n\t\t{5, 0, 0, 0.5, 0},\n\t\t{5, math.Inf(1), math.Inf(1), 0.5, 0},\n\n\t\t// Cases with v outside (l, u) or (u, l)\n\t\t{5, 0, 1, -1, 0},\n\t\t{5, 0, 1, 2, 4},\n\t\t{5, 1, 0, -1, 4},\n\t\t{5, 1, 0, 2, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, actualIdx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}\n",
    "84fc49945a232770c24f21a053cee5a1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// expected: the expected index\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "8660c16f640958be268b424125fc3fec": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3, 4}, 2, math.Sqrt(30)},\n\t\t{[]float64{-1, -2, -3, -4}, 2, math.Sqrt(30)},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over test cases\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "876a136b2371b18a843f206bffeb3c2a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n\n\t// Test panicking for n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "88a0193ded84b9e893d23ff426b1843c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\tt1 := []float64{5, 6, 7, 8}\n\n\t// Test cases for different L values\n\ttestCases := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{s1, t1, 1, 16.0},\n\t\t{s1, t1, 2, math.Sqrt(64)},\n\t\t{s1, t1, math.Inf(1), 4.0},\n\t\t{s1, t1, 3, math.Pow(96, 1.0/3.0)},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := Distance(tc.s, tc.t, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, expected %v\", tc.s, tc.t, tc.L, actual, tc.expected)\n\t\t}\n\t}\n\n\t// Test case for empty slices\n\ts2 := []float64{}\n\tt2 := []float64{}\n\texpected2 := -1.0\n\tactual2 := Distance(s2, t2, 2)\n\tif actual2 != expected2 {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s2, t2, actual2, expected2)\n\t}\n\n\t// Test case for slices with different lengths\n\ts3 := []float64{1, 2, 3}\n\tt3 := []float64{4, 5}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance(%v, %v, 2) did not panic\", s3, t3)\n\t\t}\n\t}()\n\tDistance(s3, t3, 2)\n}",
    "8900aa68771056c6d140df5d1c575cfa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-3.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInfinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-3.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-10) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\n// Helper function to compare floats for equality within a tolerance\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}\n",
    "8957cbfb628c000e6a23a0af86dc0e6d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\tfor _, test := range []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L2Distance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    2,\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"L1Distance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    1,\n\t\t\twant: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"LInfDistance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"L3Distance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    3,\n\t\t\twant: f64.Pow(96, 1.0/3.0),\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := Distance(test.s, test.t, test.L)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"Distance mismatch. Got %v, want %v\", got, test.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics\n\tt.Run(\"PanicDifferentLengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tDistance(s, []float64{1, 2, 3}, 2)\n\t})\n}\n",
    "8a268a807febdd1589044723d42783f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t// Basic cases.\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases.\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\n\t\t// Infinities.\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, 0, math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), 0, 10, 0},\n\n\t\t// NaNs.\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "8d7bf8dcb492c4994dab8bf626b97ed0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLengthSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-15) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak // No need to report multiple errors\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 1.0)\n}\n\n// Helper function to compare floats for equality within a tolerance\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}\n",
    "8db84bf8b529bb0fc69aa47c2d3ac7c6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{1, 2, 3, 4, 5, 4, 3, 2, 1}\n\ttype testCase struct {\n\t\tv      float64\n\t\twant   int\n\t\twantOK bool\n\t}\n\ttestCases := []testCase{\n\t\t{v: -1, want: 0, wantOK: true},\n\t\t{v: 0, want: 0, wantOK: true},\n\t\t{v: 0.5, want: 0, wantOK: true},\n\t\t{v: 1, want: 0, wantOK: true},\n\t\t{v: 1.1, want: 0, wantOK: true},\n\t\t{v: 1.5, want: 1, wantOK: true},\n\t\t{v: 2, want: 1, wantOK: true},\n\t\t{v: 2.5, want: 2, wantOK: true},\n\t\t{v: 3, want: 2, wantOK: true},\n\t\t{v: 3.5, want: 3, wantOK: true},\n\t\t{v: 4, want: 3, wantOK: true},\n\t\t{v: 4.5, want: 4, wantOK: true},\n\t\t{v: 5, want: 4, wantOK: true},\n\t\t{v: 5.5, want: 4, wantOK: true},\n\t\t{v: 6, want: 4, wantOK: true},\n\t\t{v: math.Inf(1), want: 4, wantOK: true},\n\t\t{v: math.Inf(-1), want: 0, wantOK: true},\n\t\t{v: math.NaN(), want: 0, wantOK: true},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdx(s, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: input=%v, got index %d, want %d\", i, tc.v, got, tc.want)\n\t\t}\n\t}\n\t// Test case for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0)\n}\n",
    "8f9e9416d8c0aaecb379aacadcf67c50": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: {n, l, u, v, expected index}\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 1},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{10, 1, 10, 5.5, 4},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{10, 0, 1, 0.5, 5},\n\n\t\t// Cases with NaN and Inf\n\t\t{5, 0, 10, math.NaN(), 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2},\n\t\t{5, math.Inf(-1), 10, 5, 4},\n\t\t{5, 0, math.Inf(1), 5, 2},\n\t\t{5, 0, 10, math.Inf(-1), 0},\n\t\t{5, 0, 10, math.Inf(1), 4},\n\n\t\t// Cases with l \u003e u\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 5, -5, 0, 5},\n\t\t{10, 10, 1, 5, 5},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(f\"TestCase_%d\", i)\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v, expected index %v, but got %v\", tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, actualIdx)\n\t\t}\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "9012a9920bb033f073d1054b802c5912": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases for Find function.\n\ttestCases := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twantInds []int\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname:    \"EmptySlice\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(f float64) bool { return f \u003e 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       1,\n\t\t\twantInds: nil,\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"KGreaterThanSliceLength\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(f float64) bool { return f \u003e 0 },\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tk:       4,\n\t\t\twantInds: nil,\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"KLessThanZero\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(f float64) bool { return f \u003e 0 },\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twantInds: []int{0, 1, 2},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"KZero\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(f float64) bool { return f \u003e 0 },\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tk:       0,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"PositiveKFindsElements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(f float64) bool { return f \u003e 1 },\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tk:       2,\n\t\t\twantInds: []int{1, 2},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"PositiveKDoesNotFindEnoughElements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(f float64) bool { return f \u003e 1 },\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tk:       3,\n\t\t\twantInds: nil,\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\t// Check if the error matches the expected error.\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tif gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", gotErr, tc.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if gotErr != tc.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", gotErr, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check if the returned indices match the expected indices.\n\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find() gotInds = %v, wantInds %v\", gotInds, tc.wantInds)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := range gotInds {\n\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Errorf(\"Find() gotInds = %v, wantInds %v\", gotInds, tc.wantInds)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "90eda1a8282de7144480b0cef156e607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, tc := range []struct {\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{s: []float64{1, 2, 3, 4, 5}, want: 4},\n\t\t{s: []float64{5, 4, 3, 2, 1}, want: 0},\n\t\t{s: []float64{1, 5, 3, 2, 4}, want: 1},\n\t\t{s: []float64{1, 2, 5, 4, 3}, want: 2},\n\t\t{s: []float64{-1, -2, -3, -5, -4}, want: 0},\n\t\t{s: []float64{-1, -5, -3, -4, -2}, want: 0},\n\t\t{s: []float64{1, math.NaN(), 3}, want: 2},\n\t\t{s: []float64{1, 3, math.NaN()}, want: 1},\n\t\t{s: []float64{math.NaN(), 1, 3}, want: 1},\n\t} {\n\t\tgot := MaxIdx(tc.s)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t}\n\t}\n}",
    "9303356005fcdaa7752836a212c96a6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for Norm function\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %v: Norm(%v, %v) = %v, want %v\", i+1, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "930bfa10b6dc4b7a361ff5e9c117915b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with a single element\n\t// - Slice with all elements equal\n\t// - Slice with positive and negative elements\n\t// - Slice with very large and very small elements\n\n\t// Test case 1: Empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp([]float64{}) did not panic\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n\n\t// Test case 2: Slice with a single element\n\tgot := LogSumExp([]float64{1.0})\n\twant := 1.0\n\tif got != want {\n\t\tt.Errorf(\"LogSumExp([]float64{1.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 3: Slice with all elements equal\n\tgot = LogSumExp([]float64{2.0, 2.0, 2.0})\n\twant = math.Log(3) + 2.0\n\tif got != want {\n\t\tt.Errorf(\"LogSumExp([]float64{2.0, 2.0, 2.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 4: Slice with positive and negative elements\n\tgot = LogSumExp([]float64{1.0, -1.0, 2.0, -2.0})\n\twant = 2.1269280110429722\n\tif math.Abs(got-want) \u003e 1e-15 {\n\t\tt.Errorf(\"LogSumExp([]float64{1.0, -1.0, 2.0, -2.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 5: Slice with very large and very small elements\n\tgot = LogSumExp([]float64{1000.0, -1000.0, 500.0, -500.0})\n\twant = 1000.0\n\tif math.Abs(got-want) \u003e 1e-15 {\n\t\tt.Errorf(\"LogSumExp([]float64{1000.0, -1000.0, 500.0, -500.0}) = %v, want %v\", got, want)\n\t}\n}\n",
    "93bb65f0c24933e8c6e5822ca34a87d6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, []float64{5, 4, 3, 2, 1}},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, []float64{5.5, 4.4, 3.3, 2.2, 1.1}},\n\t\t{[]float64{-1, -2, -3, -4, -5}, []float64{-5, -4, -3, -2, -1}},\n\t\t{[]float64{}, []float64{}},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, test := range tests {\n\t\t// Run the function being tested\n\t\tReverse(test.input)\n\n\t\t// Check if the result matches the expected output\n\t\tfor i := range test.input {\n\t\t\tif test.input[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Input: %v, Expected: %v, Got: %v\", test.input, test.expected, test.input)\n\t\t\t}\n\t\t}\n\t}\n}",
    "95db695f7002f97cfcc763d5f131bde2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Can't guarantee exact halfway\n\n\t\t// Infinities\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 100, 9},\n\t\t{11, math.Inf(-1), math.Inf(1), 100, 10},\n\t\t{10, math.Inf(-1), math.Inf(1), -100, 0},\n\t\t{11, math.Inf(-1), math.Inf(1), -100, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "971cdb9966ab10f3b6a66f22cf666530": "package floats\n\nimport \"testing\"\n\nfunc TestEqualApprox(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3, 5}\n\ts4 := []float64{1, 2, 3}\n\n\tif !EqualApprox(s1, s2, 1e-6) {\n\t\tt.Errorf(\"Expected s1 and s2 to be equal within tolerance.\")\n\t}\n\n\tif EqualApprox(s1, s3, 1e-6) {\n\t\tt.Errorf(\"Expected s1 and s3 to be different within tolerance.\")\n\t}\n\n\tif EqualApprox(s1, s4, 1e-6) {\n\t\tt.Errorf(\"Expected s1 and s4 to be different.\")\n\t}\n}",
    "97f6a508a005bcc949f1573f054387f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various spans and values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t}\n\t// Iterate over the test cases and check the results.\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\t// Test cases for edge cases.\n\tedgeCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 0, 0, 0},\n\t\t{3, 0, 0, 0, 0},\n\t\t{2, 1, 1, 1, 0},\n\t\t{3, 1, 1, 1, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\t// Iterate over the edge cases and check the results.\n\tfor _, ec := range edgeCases {\n\t\tgot := NearestIdxForSpan(ec.n, ec.l, ec.u, ec.v)\n\t\tif got != ec.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", ec.n, ec.l, ec.u, ec.v, got, ec.want)\n\t\t}\n\t}\n\t// Test case for panic when n is less than 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}",
    "98455f52f62b2e50bb908d3d0ed0a1ec": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty\", args{[]float64{}}, 1},\n\t\t{\"single element\", args{[]float64{2}}, 2},\n\t\t{\"multiple elements\", args{[]float64{2, 3, 4}}, 24},\n\t\t{\"zero in the middle\", args{[]float64{2, 0, 4}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9968eecfdf30082706212c97588e7293": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tS        []float64\n\t\tExpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.451914395937592},\n\t\t{[]float64{-1, -2, -3, -4, -5}, -0.5480856040624078},\n\t\t{[]float64{100, 100, 100}, 103.61211238422232},\n\t\t{[]float64{-100, -100, -100}, -96.38788761577768},\n\t\t{[]float64{1, 1e10, 1e-10}, 1e10},\n\t} {\n\t\tactual := LogSumExp(test.S)\n\t\tif math.Abs(actual-test.Expected) \u003e tol {\n\t\t\tt.Errorf(\"Test %d: Expected %v, but got %v\", i, test.Expected, actual)\n\t\t}\n\t}\n}",
    "99d6db2036d4ac3edc0116983f0e560d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 2, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 2, 8},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 1, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 1, 16},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 3, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 3, math.Pow(192, 1.0/3.0)},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3}, 2},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3, 4}, 2},\n\t} {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: did not panic\", test.s, test.t, test.L)\n\t\t\t}\n\t\t}()\n\t\tDistance(test.s, test.t, test.L)\n\t}\n}",
    "9a496ba17ec527d8f006609f6f843ff6": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestDiv(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tans []float64\n\t}{\n\t\t{\n\t\t\t[]float64{2, 4, 9, 16},\n\t\t\t[]float64{2, 2, 3, 4},\n\t\t\t[]float64{1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\t[]float64{2, 4, 9, 16, 25},\n\t\t\t[]float64{2, 2, 3, 4, 5},\n\t\t\t[]float64{1, 2, 3, 4, 5},\n\t\t},\n\t} {\n\t\tDiv(test.dst, test.s)\n\t\tfor j := range test.dst {\n\t\t\tif !testlapack.EqualApprox(test.dst[j], test.ans[j], 0) {\n\t\t\t\tt.Errorf(\"Test %v:%v\\nWant: %v\\nGot: %v\", i, j, test.ans, test.dst)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\tpanics := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{\n\t\t\t[]float64{2, 4, 9, 16},\n\t\t\t[]float64{2, 2, 3},\n\t\t},\n\t\t{\n\t\t\t[]float64{2, 4, 9},\n\t\t\t[]float64{2, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor i, test := range panics {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Test %d did not panic\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tDiv(test.dst, test.s)\n\t\t}()\n\t}\n}",
    "9a6f496faafe107e1f1f8261c46d7bf1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaN Value\", args{[]float64{1, 2, 3}, math.NaN()}, 1},\n\t\t{\"Positive Infinity\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"Negative Infinity\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"Single Element\", args{[]float64{5}, 3}, 0},\n\t\t{\"Multiple Elements, Nearest at Beginning\", args{[]float64{2, 4, 6, 8}, 3}, 0},\n\t\t{\"Multiple Elements, Nearest at End\", args{[]float64{2, 4, 6, 8}, 7}, 3},\n\t\t{\"Multiple Elements, Nearest in Middle\", args{[]float64{2, 4, 6, 8}, 5}, 2},\n\t\t{\"Multiple Nearest, Return Lowest Index\", args{[]float64{2, 4, 4, 6, 8}, 4}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"Empty Slice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "9a98ff29fee4e9f72e766486242fbc11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.5, 0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0}, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries2\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries\",\n\t\t\tdst:  make([]float64, 6),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries2\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries3\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.name == \"ShortSpan\" {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic with dst length less than 2\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tt.Errorf(\"Span paniced unexpectedly: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-5) {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floats for equality within a tolerance\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}",
    "9ab1d4dcd4e6e4dd07be351879e21a61": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, -5, 5, 0, 5},\n\t\t{9, -5, 5, 0, 4},\n\t\t{11, -5, 5, 0, 5},\n\t\t{10, -5, 5, -5, 0},\n\t\t{10, -5, 5, 5, 9},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, 1, 1, 0, 0},\n\t\t{10, -1, -1, 0, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "9b77ccabddafb9d8dc5b4b9224996375": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ty := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\talpha := 2.0\n\tans := []float64{9, 12, 15}\n\n\tAddScaledTo(dst, y, alpha, s)\n\tassert.Equal(t, ans, dst)\n}",
    "9c55932632ea7107edec31327f638aa7": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twant     int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1}, v: 0, wantPanic: true},\n\t\t{s: []float64{1, 2}, v: 0.5, want: 0},\n\t\t{s: []float64{1, 2}, v: 1, want: 0},\n\t\t{s: []float64{1, 2}, v: 1.5, want: 0},\n\t\t{s: []float64{1, 2}, v: 2, want: 0},\n\t\t{s: []float64{1, 2}, v: -1, want: -0},\n\t\t{s: []float64{1, 2}, v: 3, want: -0},\n\t\t{s: []float64{1, 2, 3}, v: 1.5, want: 0},\n\t\t{s: []float64{1, 2, 3}, v: 2, want: 1},\n\t\t{s: []float64{1, 2, 3}, v: 2.5, want: 1},\n\t\t{s: []float64{-3, -2, -1}, v: -1.5, want: 1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -1.5, want: 1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: 1.5, want: 4},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: 1, want: 4},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -1, want: 2},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: 3, want: -0},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -3, want: 0},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: 4, want: -0},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -4, want: -0},\n\t\t{s: []float64{1, 1, 2, 2, 3, 3}, v: 1.5, want: 1},\n\t\t{s: []float64{1, 1, 2, 2, 3, 3}, v: 2, want: 2},\n\t\t{s: []float64{1, 1, 2, 2, 3, 3}, v: 2.5, want: 3},\n\t\t{s: []float64{1, 2, math.NaN()}, v: 0, want: -0},\n\t\t{s: []float64{1, 2, math.NaN()}, v: 1.5, want: 0},\n\t\t{s: []float64{1, 2, math.NaN()}, v: 2, want: 1},\n\t\t{s: []float64{1, 2, math.NaN()}, v: 3, want: -0},\n\t\t{s: []float64{1, math.NaN(), 3}, v: 0, want: -0},\n\t\t{s: []float64{1, math.NaN(), 3}, v: 1.5, want: 0},\n\t\t{s: []float64{1, math.NaN(), 3}, v: 2, want: 0},\n\t\t{s: []float64{1, math.NaN(), 3}, v: 3, want: -0},\n\t\t{s: []float64{1, math.NaN(), 3}, v: math.NaN(), want: -0},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != test.wantPanic {\n\t\t\t\t\tt.Errorf(\"Test %d - %v - panic mismatch: got %v, want %v\", i, test.s, gotPanic, test.wantPanic)\n\t\t\t\t}\n\t\t\t\tif gotPanic {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Within(test.s, test.v)\n\t\t\tif !test.wantPanic \u0026\u0026 got != test.want {\n\t\t\t\tt.Errorf(\"Test %d - %v - value mismatch: got %v, want %v\", i, test.s, got, test.want)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "9cb0d360d85ad376bf2194447eafd178": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\"empty\", args{[]float64{}}, false},\n\t\t{\"noNaN\", args{[]float64{1, 2, 3}}, false},\n\t\t{\"oneNaN\", args{[]float64{1, math.NaN(), 3}}, true},\n\t\t{\"allNaN\", args{[]float64{math.NaN(), math.NaN()}}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d291a0a7219e71f1248386c72c4ebdd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ts := []float64{1, 2, 3, 4, 5}\n\ttol := 1e-14\n\n\tif got, want := Norm(s, 1), 15.0; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"Norm(s, 1) = %v, want %v\", got, want)\n\t}\n\n\tif got, want := Norm(s, 2), 7.416198487095663; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"Norm(s, 2) = %v, want %v\", got, want)\n\t}\n\n\tif got, want := Norm(s, 3), 5.228123735792795; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"Norm(s, 3) = %v, want %v\", got, want)\n\t}\n\n\tif got, want := Norm(s, math.Inf(1)), 5.0; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"Norm(s, math.Inf(1)) = %v, want %v\", got, want)\n\t}\n\n\tif got, want := Norm([]float64{}, 2), 0.0; got != want {\n\t\tt.Errorf(\"Norm([]float64{}, 2) = %v, want %v\", got, want)\n\t}\n}\n",
    "9d4ab18a2d3be262fae27fe7439bf295": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with no matching elements\n\t// - Slice with one matching element\n\t// - Slice with multiple matching elements\n\t// - k = 0\n\t// - k \u003c 0\n\t// - k \u003e 0 and fewer than k elements found\n\n\t// Empty slice\n\t{\n\t\ts := []float64{}\n\t\tf := func(x float64) bool { return x \u003e 0 }\n\t\tinds, err := Find(nil, f, s, -1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif len(inds) != 0 {\n\t\t\tt.Errorf(\"Expected empty slice, got %v\", inds)\n\t\t}\n\t}\n\n\t// Slice with no matching elements\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tf := func(x float64) bool { return x \u003e 10 }\n\t\tinds, err := Find(nil, f, s, -1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif len(inds) != 0 {\n\t\t\tt.Errorf(\"Expected empty slice, got %v\", inds)\n\t\t}\n\t}\n\n\t// Slice with one matching element\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tf := func(x float64) bool { return x == 3 }\n\t\tinds, err := Find(nil, f, s, -1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif len(inds) != 1 || inds[0] != 2 {\n\t\t\tt.Errorf(\"Expected [2], got %v\", inds)\n\t\t}\n\t}\n\n\t// Slice with multiple matching elements\n\t{\n\t\ts := []float64{1, 2, 3, 4, 3, 5}\n\t\tf := func(x float64) bool { return x == 3 }\n\t\tinds, err := Find(nil, f, s, -1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif len(inds) != 2 || inds[0] != 2 || inds[1] != 4 {\n\t\t\tt.Errorf(\"Expected [2 4], got %v\", inds)\n\t\t}\n\t}\n\n\t// k = 0\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tf := func(x float64) bool { return x \u003e 0 }\n\t\tinds, err := Find(nil, f, s, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif len(inds) != 0 {\n\t\t\tt.Errorf(\"Expected empty slice, got %v\", inds)\n\t\t}\n\t}\n\n\t// k \u003c 0\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tf := func(x float64) bool { return x \u003e 2 }\n\t\tinds, err := Find(nil, f, s, -1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t}\n\t\tif len(inds) != 3 || inds[0] != 2 || inds[1] != 3 || inds[2] != 4 {\n\t\t\tt.Errorf(\"Expected [2 3 4], got %v\", inds)\n\t\t}\n\t}\n\n\t// k \u003e 0 and fewer than k elements found\n\t{\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tf := func(x float64) bool { return x \u003e 2 }\n\t\tinds, err := Find(nil, f, s, 4)\n\t\tif !errors.Is(err, errors.New(\"floats: insufficient elements found\")) {\n\t\t\tt.Errorf(\"Expected 'floats: insufficient elements found' error, got %v\", err)\n\t\t}\n\t\tif len(inds) != 3 || inds[0] != 2 || inds[1] != 3 || inds[2] != 4 {\n\t\t\tt.Errorf(\"Expected [2 3 4], got %v\", inds)\n\t\t}\n\t}\n}\n",
    "9e6b0f9dd9f49f75a5ba370e3a417163": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\n\t// Test L = 2\n\texpected := math.Sqrt(27)\n\tactual := Distance(s, t, 2)\n\tif !close(actual, expected) {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test L = 1\n\texpected = 9\n\tactual = Distance(s, t, 1)\n\tif !close(actual, expected) {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test L = math.Inf(1)\n\texpected = 3\n\tactual = Distance(s, t, math.Inf(1))\n\tif !close(actual, expected) {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test other L\n\texpected = math.Pow(math.Pow(3, 3)+math.Pow(3, 3)+math.Pow(3, 3), 1/3.0)\n\tactual = Distance(s, t, 3)\n\tif !close(actual, expected) {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, expected %v\", s, t, actual, expected)\n\t}\n}\n\nfunc close(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-10\n}",
    "a016dbc2f0d6caf11e2cb0a3b863ab48": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// Basic cases.\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN.\n\t\t{2, 0, math.NaN(), 0.5, 0},\n\t\t{2, math.NaN(), 0, 0.5, 1},\n\t\t{2, math.NaN(), math.NaN(), 0.5, 0},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf.\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, math.Inf(-1), 0, 0.5, 1},\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{2, 0, 1, math.Inf(1), 1},\n\t\t{2, 0, 1, math.Inf(-1), 0},\n\n\t\t// Cases with v outside (l, u) or (u, l).\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 2, 1},\n\t\t{2, 1, 0, -1, 1},\n\t\t{2, 1, 0, 2, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: got %d, want %d for n = %d, l = %f, u = %f, v = %f\", i, got, tc.want, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "a27f6a53f7ef837c6a2016083242e078": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that Span panics with less than two elements\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with less than two elements\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 10)\n}\n\nfunc TestSpanTwoElements(t *testing.T) {\n\tdst := make([]float64, 2)\n\tSpan(dst, 0, 10)\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"The first element should be 0, but got %v\", dst[0])\n\t}\n\tif dst[1] != 10 {\n\t\tt.Errorf(\"The second element should be 10, but got %v\", dst[1])\n\t}\n}\n\nfunc TestSpanThreeElements(t *testing.T) {\n\tdst := make([]float64, 3)\n\tSpan(dst, 0, 10)\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"The first element should be 0, but got %v\", dst[0])\n\t}\n\tif dst[1] != 5 {\n\t\tt.Errorf(\"The second element should be 5, but got %v\", dst[1])\n\t}\n\tif dst[2] != 10 {\n\t\tt.Errorf(\"The third element should be 10, but got %v\", dst[2])\n\t}\n}\n\nfunc TestSpanWithInf(t *testing.T) {\n\t// Test cases with Inf and NaN\n\tdst := make([]float64, 3)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := range dst {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"The %v-th element should be Inf, but got %v\", i, dst[i])\n\t\t}\n\t}\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\tfor i := range dst {\n\t\tif i == len(dst)/2 {\n\t\t\tif dst[i] != 0 {\n\t\t\t\tt.Errorf(\"The middle element should be 0, but got %v\", dst[i])\n\t\t\t}\n\t\t} else if i \u003c len(dst)/2 {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"The %v-th element should be -Inf, but got %v\", i, dst[i])\n\t\t\t}\n\t\t} else {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"The %v-th element should be Inf, but got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"The first element should be 0, but got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"The %v-th element should be Inf, but got %v\", i, dst[i])\n\t\t}\n\t}\n\tSpan(dst, math.Inf(-1), 0)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"The %v-th element should be -Inf, but got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"The last element should be 0, but got %v\", dst[len(dst)-1])\n\t}\n}\n\nfunc TestSpanWithNaN(t *testing.T) {\n\tdst := make([]float64, 3)\n\tSpan(dst, math.NaN(), 0)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"The %v-th element should be NaN, but got %v\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"The last element should be 0, but got %v\", dst[len(dst)-1])\n\t}\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"The first element should be 0, but got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"The %v-th element should be NaN, but got %v\", i, dst[i])\n\t\t}\n\t}\n}\n",
    "a2bf07ba250a0365f9ac0b0f63d41c94": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tu := []float64{5, 6, 7, 8}\n\n\ttol := 1e-14\n\tif got, want := Distance(s, u, 1), 16.0; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L1 distance: got %v, want %v\", got, want)\n\t}\n\tif got, want := Distance(s, u, 2), math.Sqrt(32); math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L2 distance: got %v, want %v\", got, want)\n\t}\n\tif got, want := Distance(s, u, math.Inf(1)), 4.0; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"Linf distance: got %v, want %v\", got, want)\n\t}\n}\n",
    "a3fe2ed40acd3b91aacc802c7c7b7333": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaN Value\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"Positive Infinity\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"Negative Infinity\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"Exact Match\", args{[]float64{1, 2, 3}, 2}, 1},\n\t\t{\"Nearest Value\", args{[]float64{1, 2, 3}, 2.5}, 1},\n\t\t{\"Multiple Nearest Values\", args{[]float64{1, 2, 2, 3}, 2.5}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"Empty Slice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a41f57f74af72aeefcd635aa831db8f0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: 4,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want != -1 {\n\t\t\t\t\t\tt.Errorf(\"Within() panicked, but want = %v\", tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWithinPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t}\n\t}()\n\ts := []float64{3, 2, 1}\n\tWithin(s, 2.5)\n}\n",
    "a47dd1cdc3dc83bbdb439193cd64f607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Cases with NaN and Inf\n\t\t{2, math.NaN(), 1, 0.5, 1},\n\t\t{2, 0, math.NaN(), 0.5, 0},\n\t\t{2, math.Inf(1), 1, 0.5, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), 1, 0.5, 1},\n\t\t{2, 0, math.Inf(-1), 0.5, 0},\n\t\t{2, math.NaN(), math.NaN(), 0.5, 0},\n\t\t{2, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), math.Inf(-1), 0.5, 0},\n\n\t\t// Cases with v outside (l, u)\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\n\t\t// Cases with l \u003e u\n\t\t{3, 1, 0, 0.5, 2},\n\t\t{3, 1, 0, 1.5, 0},\n\t\t{3, 1, 0, -0.5, 2},\n\n\t\t// Cases with large n\n\t\t{1000, 0, 1, 0.5, 500},\n\t\t{1000, 0, 1, 0.25, 250},\n\t\t{1000, 0, 1, 0.75, 750},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, actualIdx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "a497dd8b46bc2c813c600319f2b295de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-10, -1, 0, 1, 2, 3, 10}\n\n\t// Test cases where v is within the bounds of s\n\ttestCases := []float64{-5, -0.5, 0.5, 1.5, 2.5, 9}\n\texpectedIndices := []int{0, 1, 2, 3, 4, 6}\n\n\tfor i, v := range testCases {\n\t\tidx := Within(s, v)\n\t\tif idx != expectedIndices[i] {\n\t\t\tt.Errorf(\"For v = %v, expected index %v but got %v\", v, expectedIndices[i], idx)\n\t\t}\n\t}\n\n\t// Test cases where v is outside the bounds of s\n\toutOfBounds := []float64{-11, 11, math.NaN()}\n\texpectedIdx := -1\n\tfor _, v := range outOfBounds {\n\t\tidx := Within(s, v)\n\t\tif idx != expectedIdx {\n\t\t\tt.Errorf(\"For v = %v, expected index %v but got %v\", v, expectedIdx, idx)\n\t\t}\n\t}\n}",
    "a4b60974e46bfdf6e006c7d82aaa379c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 2},\n\t\t{5, 0, 10, -1, 0},\n\t\t{5, 0, 10, 11, 4},\n\n\t\t// Edge cases\n\t\t{2, 0, 10, 0, 0},\n\t\t{2, 0, 10, 10, 1},\n\t\t{2, 0, 10, 5, 0}, // Tiebreaker: lower index\n\n\t\t// Infinities\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, 0, math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{5, 0, 10, math.NaN(), 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "a4d1d307540cd4a4d2ac0b2fb9d31721": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases: slice, L value, expected norm\n\ttestCases := []struct {\n\t\ts      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\n\t\t// Other L values\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{1, 2, 3}, 4, math.Pow(98, 1.0/4.0)},\n\t}\n\n\tfor i, tc := range testCases {\n\t\t// Calculate the norm using the function being tested\n\t\tnorm := Norm(tc.s, tc.L)\n\n\t\t// Check if the calculated norm matches the expected norm\n\t\tif math.Abs(norm-tc.expect) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Test case %d failed: expected norm for s=%v, L=%v to be %v, but got %v\", i+1, tc.s, tc.L, tc.expect, norm)\n\t\t}\n\t}\n}\n",
    "a521218401b9b8dba09f0819080b73d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\ts3 := []float64{1, 2}\n\ts4 := []float64{}\n\n\t// Test L=1\n\texpected := 16.0\n\tactual := Distance(s1, s2, 1)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, expected %v\", s1, s2, actual, expected)\n\t}\n\n\t// Test L=2\n\texpected = math.Sqrt(64)\n\tactual = Distance(s1, s2, 2)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s1, s2, actual, expected)\n\t}\n\n\t// Test L=Inf\n\texpected = 4.0\n\tactual = Distance(s1, s2, math.Inf(1))\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, expected %v\", s1, s2, actual, expected)\n\t}\n\n\t// Test L=3\n\texpected = math.Pow(392, 1.0/3.0)\n\tactual = Distance(s1, s2, 3)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, expected %v\", s1, s2, actual, expected)\n\t}\n\n\t// Test empty slices\n\texpected = 0.0\n\tactual = Distance(s4, s4, 2)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s4, s4, actual, expected)\n\t}\n\n\t// Test panic on different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic with different length slices\")\n\t\t}\n\t}()\n\tDistance(s1, s3, 2)\n}\n",
    "a54d54664865f2c31b2989b19aa1f707": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666666, -0.3333333333333333, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds infinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound infinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound infinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\t// Iterate through test cases\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Call Span function\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\t// Check if the returned slice is the same as the input slice\n\t\t\tif got != tc.dst {\n\t\t\t\tt.Errorf(\"Expected Span to modify the input slice, but it did not.\")\n\t\t\t}\n\n\t\t\t// Check if the generated slice matches the expected slice\n\t\t\tfor i := range tc.want {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-15) {\n\t\t\t\t\tt.Errorf(\"For l = %v, u = %v, want[%d] = %v, got %v\", tc.l, tc.u, i, tc.want[i], got[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2\n\tt.Run(\"Panics on short slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n\n// Helper function to compare floats for equality within a tolerance\nfunc closeEnough(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c= tol\n}\n",
    "a5e41a7195939f58c03fbd26820a8ba7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{[]float64{1,2,3,4,5,4,3,2,1}, 3.1, 2},\n\t\t{[]float64{1,2,3,4,5,6,7,8,9}, 5.1, 5},\n\t\t{[]float64{1,2,3,4,5,6,7,8,9}, 4.9, 4},\n\t\t{[]float64{1,2,3,4,4,6,7,8,9}, 4.1, 3},\n\t\t{[]float64{1,2,3,4,4,6,7,8,9}, math.NaN(), 0},\n\t\t{[]float64{1,2,3,4,4,6,7,8,9}, math.Inf(1), 8},\n\t\t{[]float64{1,2,3,4,4,6,7,8,9}, math.Inf(-1), 0},\n\t} {\n\t\thave := NearestIdx(test.s, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Case %d: Expected %v, got %v.\", i, test.want, have)\n\t\t}\n\t}\n}",
    "a69b30c54f2b14f26c3f18c8767573b0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\ttol := 1e-14\n\tif got, want := Distance(s, t, 2), 8; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L2 distance: got %v, want %v\", got, want)\n\t}\n\tif got, want := Distance(s, t, 1), 16; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L1 distance: got %v, want %v\", got, want)\n\t}\n\tif got, want := Distance(s, t, math.Inf(1)), 4; math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L-inf distance: got %v, want %v\", got, want)\n\t}\n\tif got, want := Distance(s, t, 3), math.Pow(32, 1.0/3); math.Abs(got-want) \u003e tol {\n\t\tt.Errorf(\"L3 distance: got %v, want %v\", got, want)\n\t}\n\n\t// panic checks\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance(s, []float64{1, 2, 3}, 2)\n}\n",
    "a7d15f2cc559aa317134a3b5cf5abf3b": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestSub(t *testing.T) {\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := rand.Intn(100)\n\t\ta := make([]float64, n)\n\t\tb := make([]float64, n)\n\t\tfor i := range a {\n\t\t\ta[i] = rand.Float64()\n\t\t\tb[i] = rand.Float64()\n\t\t}\n\t\tc := make([]float64, n)\n\t\tcopy(c, a)\n\t\tSub(c, b)\n\t\tfor i := range c {\n\t\t\tif c[i] != a[i]-b[i] {\n\t\t\t\tt.Errorf(\"Sub() mismatch at index %d: %v != %v\", i, c[i], a[i]-b[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\ta := []float64{1, 2, 3}\n\tb := []float64{1, 2}\n\tSub(a, b)\n}",
    "a9d4441a857e403200ecd0cceab9906d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    4.0,\n\t\t\twant: []float64{0.0, 1.0, 2.0, 3.0, 4.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2.0,\n\t\t\tu:    2.0,\n\t\t\twant: []float64{-2.0, -0.6666666666666666, 0.6666666666666666, 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    1.0,\n\t\t\tu:    2.0,\n\t\t\twant: []float64{1.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    2.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBothSame\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBothDifferent\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBeginning\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseEnd\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{-3.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-10) {\n\t\t\t\t\tt.Errorf(\"Mismatch at index %d: got %v, want %v\", i, got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking with short dst\n\tt.Run(\"ShortSpanPanic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with dst of length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n\n// Helper function to compare floats for approximate equality\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}",
    "aaf32cd17c4604ddafa4458bb47ea3c4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l is Inf, u is regular\n\t// - l is regular, u is Inf\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif i \u003c len(dst)/2 {\n\t\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t} else if i \u003e len(dst)/2 {\n\t\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif dst[i] != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf, u is regular\n\tt.Run(\"LInfURegular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst {\n\t\t\tif i \u003c len(dst)-1 {\n\t\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif dst[i] != 1 {\n\t\t\t\t\tt.Errorf(\"Expected 1, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is regular, u is Inf\n\tt.Run(\"LRegularUInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif i == 0 {\n\t\t\t\tif dst[i] != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}",
    "ab7dc606c0b084ab5d94a2ed91fc6c4b": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{0.25, 0.4, 0.5}\n\n\tgot := DivTo(dst, s, t)\n\tassert.Equal(t, want, got)\n}",
    "abb812288b8de738509d66c3ec95412e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twant     int\n\t\twantDist float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1, 0.2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2, 0.2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4, 5},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0, 11},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1, 0.5}, // Tie goes to lower index\n\t\t{[]float64{1, math.NaN(), 3}, 2, 0, math.NaN()},\n\t\t{[]float64{1, 2, math.NaN()}, 2, 1, 0},\n\t\t{[]float64{math.NaN(), 2, 3}, 2, 1, 0},\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 2, math.Inf(1)},\n\t\t{[]float64{1, 2, 3}, math.Inf(-1), 0, math.Inf(1)},\n\t} {\n\t\thave := NearestIdx(test.s, test.v)\n\t\thaveDist := math.Abs(test.s[have] - test.v)\n\t\tif have != test.want || math.Abs(haveDist-test.wantDist) \u003e tol {\n\t\t\tt.Errorf(\"Test %d: NearestIdx(%v,%v) = %d, %v Want %d, %v\", i, test.s, test.v, have, haveDist, test.want, test.wantDist)\n\t\t}\n\t}\n}",
    "adc5acf237e9d9e0b0eaa3cab7609c7a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort_Swap(t *testing.T) {\n\t// Test cases:\n\t// - Swap elements in the middle\n\t// - Swap first and last elements\n\t// - Swap elements with the same value\n\t// - Swap elements with different values\n\n\ttestCases := []struct {\n\t\tname  string\n\t\tinds  []int\n\t\ti     int\n\t\tj     int\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname:  \"Swap elements in the middle\",\n\t\t\tinds:  []int{0, 1, 2, 3, 4},\n\t\t\ti:     1,\n\t\t\tj:     3,\n\t\t\twant: []int{0, 3, 2, 1, 4},\n\t\t},\n\t\t{\n\t\t\tname:  \"Swap first and last elements\",\n\t\t\tinds:  []int{0, 1, 2, 3, 4},\n\t\t\ti:     0,\n\t\t\tj:     4,\n\t\t\twant: []int{4, 1, 2, 3, 0},\n\t\t},\n\t\t{\n\t\t\tname:  \"Swap elements with the same value\",\n\t\t\tinds:  []int{0, 1, 2, 2, 4},\n\t\t\ti:     2,\n\t\t\tj:     3,\n\t\t\twant: []int{0, 1, 2, 2, 4},\n\t\t},\n\t\t{\n\t\t\tname:  \"Swap elements with different values\",\n\t\t\tinds:  []int{0, 1, 2, 3, 4},\n\t\t\ti:     0,\n\t\t\tj:     1,\n\t\t\twant: []int{1, 0, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ta := argsort{\n\t\t\t\tinds: tc.inds,\n\t\t\t}\n\t\t\ta.Swap(tc.i, tc.j)\n\n\t\t\tif !Equal(a.inds, tc.want) {\n\t\t\t\tt.Errorf(\"Swap() failed. Want %v, got %v\", tc.want, a.inds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af54b607219a486ffb62bfa2478b3568": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases for EqualLengths function.\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice list\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Single slice\",\n\t\t\tslices:   [][]float64{{1, 2, 3}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal length slices\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal length slices\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple equal length slices\",\n\t\t\tslices:   [][]float64{{1, 2}, {3, 4}, {5, 6}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple unequal length slices\",\n\t\t\tslices:   [][]float64{{1, 2}, {3, 4, 5}, {6}},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\t// Iterate over the test cases and execute the tests.\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := EqualLengths(tc.slices...)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af91ec866fc2f872635e8cfdd90e66fa": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !Equal(s1, s2) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be true.\", s1, s2)\n\t}\n\n\tif Equal(s1, s3) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false.\", s1, s3)\n\t}\n\n\tif Equal(s1, s4) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false.\", s1, s4)\n\t}\n}",
    "afb6691cc094d2b363d8525e14a19ac8": "",
    "afc5e1b592f391571a48959e2f9e490f": "package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{func(v float64) bool { return v \u003e 0 }, []float64{}}, 0},\n\t\t{\"all true\", args{func(v float64) bool { return v \u003e 0 }, []float64{1, 2, 3}}, 3},\n\t\t{\"some true\", args{func(v float64) bool { return v \u003e 1 }, []float64{1, 2, 3}}, 2},\n\t\t{\"none true\", args{func(v float64) bool { return v \u003e 3 }, []float64{1, 2, 3}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b023a706762e4bc46743e63893e9d4ca": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{4, 10, 18}\n\n\tgot := MulTo(dst, s, t)\n\tassert.Equal(t, want, got, \"they should be equal\")\n}",
    "b057253b10925d31efe70b9b96fdeb78": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-3, -2, -1, 0, 1, 2, 3}\n\tfor i, v := range s {\n\t\tif j := Within(s, v); i != j {\n\t\t\tt.Errorf(\"Expected Within(s, %v) = %v, got %v\", v, i, j)\n\t\t}\n\t}\n\t// Test values in between slice elements\n\tfor i := range s[:len(s)-1] {\n\t\tv := (s[i] + s[i+1]) / 2\n\t\tif j := Within(s, v); i != j {\n\t\t\tt.Errorf(\"Expected Within(s, %v) = %v, got %v\", v, i, j)\n\t\t}\n\t}\n\t// Test boundary conditions\n\tif i := Within(s, s[0]-tol); i != -1 {\n\t\tt.Errorf(\"Expected Within(s, %v) = -1, got %v\", s[0]-tol, i)\n\t}\n\tif i := Within(s, s[len(s)-1]); i != len(s)-2 {\n\t\tt.Errorf(\"Expected Within(s, %v) = %v, got %v\", s[len(s)-1], len(s)-2, i)\n\t}\n\tif i := Within(s, s[len(s)-1]+tol); i != -1 {\n\t\tt.Errorf(\"Expected Within(s, %v) = -1, got %v\", s[len(s)-1]+tol, i)\n\t}\n\t// Test NaN\n\tif i := Within(s, math.NaN()); i != -1 {\n\t\tt.Errorf(\"Expected Within(s, NaN) = -1, got %v\", i)\n\t}\n}",
    "b0f9a3504d61dd97d7d30c129c71d603": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-3, -2, -1, -0.5, 0, 0.5, 1, 2, 3}\n\tfor i, v := range s {\n\t\tif math.Abs(float64(Within(s, v))-float64(i)) \u003e tol {\n\t\t\tt.Errorf(\"Index returned by Within is not as expected\")\n\t\t}\n\t}\n\tif Within(s, 1e6) != -1 {\n\t\tt.Errorf(\"Expected -1 for out of bounds value, got %v\", Within(s, 1e6))\n\t}\n\tif Within(s, -1e6) != -1 {\n\t\tt.Errorf(\"Expected -1 for out of bounds value, got %v\", Within(s, -1e6))\n\t}\n\tif Within(s, math.NaN()) != -1 {\n\t\tt.Errorf(\"Expected -1 for NaN input, got %v\", Within(s, math.NaN()))\n\t}\n}\n",
    "b1237c007a154e7551e96e4abef395ac": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaN Value\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"Positive Infinity\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"Negative Infinity\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"Exact Match\", args{[]float64{1, 2, 3}, 2}, 1},\n\t\t{\"Nearest Value\", args{[]float64{1, 2, 3}, 2.5}, 1},\n\t\t{\"Multiple Nearest Values\", args{[]float64{1, 2, 2, 3}, 2.5}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"Empty Slice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b171a68a65a0482c47261417a55b4971": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 10, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\t\t{11, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(1), 10},\n\t\t{11, 0, 10, math.Inf(-1), 0},\n\t\t{11, 0, 10, math.Inf(1), 10},\n\t\t{11, 10, 0, math.Inf(-1), 10},\n\t\t{11, 10, 0, math.Inf(1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, got)\n\t\t}\n\t}\n\n\t// Test case for panicking when n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "b19603c719cd669e4b4e7417b1673a44": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-10, -1, 0, 1, 2, 3, 10}\n\ttype testCase struct {\n\t\tv        float64\n\t\texpected int\n\t}\n\ttests := []testCase{\n\t\t{-10 - tol, -1},\n\t\t{-10, 0},\n\t\t{-5, 0},\n\t\t{-1 - tol, 0},\n\t\t{-1, 1},\n\t\t{-0.5, 1},\n\t\t{0, 2},\n\t\t{0.5, 2},\n\t\t{1, 3},\n\t\t{1.5, 3},\n\t\t{2, 4},\n\t\t{9, 6},\n\t\t{10, -1},\n\t\t{10 + tol, -1},\n\t\t{math.NaN(), -1},\n\t}\n\tfor i, test := range tests {\n\t\tgot := Within(s, test.v)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"Test %d: input slice %v, value %v: expected %d, got %d\", i, s, test.v, test.expected, got)\n\t\t}\n\t}\n}",
    "b1c211d15e5b97db52c1164cf02ab259": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{4, 0, 10, 5, 2},\n\t\t{10, -5, 5, -5, 0},\n\t\t{10, -5, 5, 5, 9},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, 5, -5, -5, 9},\n\t\t{10, 5, -5, 5, 0},\n\t\t{10, 5, -5, 0, 5},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\",\n\t\t\t\ti, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanInfCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{4, math.NaN(), 1, 0, 3},\n\t\t{4, 0, math.NaN(), 0, 0},\n\t\t{4, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{5, math.Inf(1), math.Inf(1), 0, 2},\n\t\t{4, math.Inf(1), 0, 0, 3},\n\t\t{4, 0, math.Inf(1), 0, 0},\n\t\t{4, 0, 1, math.Inf(-1), 0},\n\t\t{4, 1, 0, math.Inf(-1), 3},\n\t\t{4, 0, 1, math.Inf(1), 3},\n\t\t{4, 1, 0, math.Inf(1), 0},\n\t}\n\n\tfor i, tc := range nanInfCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\",\n\t\t\t\ti, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test case for panic when n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "b213bf54d996e0039fda47719746bfab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with positive numbers\n\t// 4. Slice with negative numbers\n\t// 5. Slice with mixed positive and negative numbers\n\t// 6. Slice with numbers that can cause significant rounding errors\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"One element\",\n\t\t\tinput:    []float64{1.0},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Positive numbers\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative numbers\",\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\texpected: -15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed numbers\",\n\t\t\tinput:    []float64{-1.0, 2.0, -3.0, 4.0, -5.0},\n\t\t\texpected: -3.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Numbers with potential rounding errors\",\n\t\t\tinput:    []float64{10000.0, 0.0001, 10000.0, 0.0001, 10000.0},\n\t\t\texpected: 30000.0003,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := SumCompensated(tc.input)\n\t\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b24730c325c23f8e9cf5a440666a54cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l is Inf, u is regular\n\t// - l is regular, u is Inf\n\n\tt.Run(\"Panics if len(dst) \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"Regular l and u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"u is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is Inf, u is regular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"l is regular, u is Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "b247c18384f0d8daf42cbf9e1815e8cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1e10, 1, -1e10}, 1},\n\t\t{[]float64{}, 0},\n\t}\n\n\t// Iterate through test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result matches the expected value\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}",
    "b274b8c757536346f03da55ed0a60c98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: 0, u: 2, v: -1, i: 0},\n\t\t{n: 2, l: 0, u: 2, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: 2, v: 0.5, i: 0},\n\t\t{n: 2, l: 0, u: 2, v: 1, i: 0},\n\t\t{n: 2, l: 0, u: 2, v: 1.5, i: 1},\n\t\t{n: 2, l: 0, u: 2, v: 2, i: 1},\n\t\t{n: 2, l: 0, u: 2, v: 3, i: 1},\n\n\t\t{n: 2, l: 2, u: 0, v: 3, i: 0},\n\t\t{n: 2, l: 2, u: 0, v: 2, i: 0},\n\t\t{n: 2, l: 2, u: 0, v: 1.5, i: 0},\n\t\t{n: 2, l: 2, u: 0, v: 1, i: 1},\n\t\t{n: 2, l: 2, u: 0, v: 0.5, i: 1},\n\t\t{n: 2, l: 2, u: 0, v: 0, i: 1},\n\t\t{n: 2, l: 2, u: 0, v: -1, i: 1},\n\n\t\t{n: 3, l: 0, u: 2, v: -1, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: 0, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: 0.5, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: 1, i: 1},\n\t\t{n: 3, l: 0, u: 2, v: 1.5, i: 1},\n\t\t{n: 3, l: 0, u: 2, v: 2, i: 2},\n\t\t{n: 3, l: 0, u: 2, v: 3, i: 2},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Unexpected index returned for n = %v, l = %v, u = %v, v = %v. Want %v, got %v.\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.i, i)\n\t\t}\n\t}\n\tfor _, n := range []int{2, 3, 4, 5, 10, 20} {\n\t\tfor _, l := range []float64{-5, -1, 0, 1, 5} {\n\t\t\tfor _, u := range []float64{-5, -1, 0, 1, 5} {\n\t\t\t\tif l == u {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ts := make([]float64, n)\n\t\t\t\tSpan(s, l, u)\n\t\t\t\tfor _, v := range []float64{-10, -1, -0.1, 0, 0.1, 1, 10} {\n\t\t\t\t\twant := NearestIdx(s, v)\n\t\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"Unexpected result for n = %v, l = %v, u = %v, v = %v. Want %v, got %v.\",\n\t\t\t\t\t\t\tn, l, u, v, want, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanSpecial(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t// l or u is NaN\n\t\t{n: 2, l: math.NaN(), u: 1, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, i: 0},\n\t\t{n: 3, l: math.NaN(), u: 1, v: 0, i: 2},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 0, i: 0},\n\n\t\t// l or u is Inf\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, i: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: 0, i: 2},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, i: 0},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: 0, i: 2},\n\n\t\t// v is NaN\n\t\t{n: 2, l: 0, u: 1, v: math.NaN(), i: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.NaN(), i: 0},\n\n\t\t// v is Inf\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(1), i: 1},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(1), i: 0},\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(-1), i: 1},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(1), i: 2},\n\t\t{n: 3, l: 1, u: 0, v: math.Inf(1), i: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: 1, u: 0, v: math.Inf(-1), i: 2},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Unexpected index returned for n = %v, l = %v, u = %v, v = %v. Want %v, got %v.\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.i, i)\n\t\t}\n\t}\n\n\t// Test cases where both l and u are Inf.\n\tfor _, n := range []int{2, 3, 4, 5} {\n\t\tfor _, signl := range []float64{-1, 1} {\n\t\t\tfor _, signu := range []float64{-1, 1} {\n\t\t\t\tfor _, signv := range []float64{-1, 1} {\n\t\t\t\t\tl := math.Inf(int(signl))\n\t\t\t\t\tu := math.Inf(int(signu))\n\t\t\t\t\tv := math.Inf(int(signv))\n\t\t\t\t\tvar want int\n\t\t\t\t\tif signl != signu {\n\t\t\t\t\t\tif n%2 == 0 {\n\t\t\t\t\t\t\tif signv == signl {\n\t\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif signv == signl {\n\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n - 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"Unexpected result for n = %v, l = %v, u = %v, v = %v. Want %v, got %v.\",\n\t\t\t\t\t\t\tn, l, u, v, want, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1} {\n\t\tpanicked := testlapack.Panics(func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t\tif !panicked {\n\t\t\tt.Errorf(\"Did not panic for n = %v\", n)\n\t\t}\n\t}\n}",
    "b2b41c0984a6fc130569c29ce9ac8aed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Zero length input\n\t// - Input length of 1\n\t// - Evenly spaced values\n\t// - Unevenly spaced values\n\t// - Infinite values\n\t// - NaN values\n\n\t// Zero length input\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with zero length input\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Input length of 1\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with input length of 1\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Evenly spaced values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\texpected := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Evenly spaced values: Expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Unevenly spaced values\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Unevenly spaced values: Expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Infinite values\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif i \u003c len(dst)/2 {\n\t\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\t\tt.Errorf(\"Infinite values: Expected +Inf, got %v\", dst)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\t\tt.Errorf(\"Infinite values: Expected -Inf, got %v\", dst)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// NaN values\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"NaN values: Expected NaN, got %v\", dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "b39b4e92d68ff04931e1f9c49dce0d52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{2, 3, 4}, []float64{3, 4, 5}, 2, math.Sqrt(3)},\n\t\t{[]float64{2, 3, 4}, []float64{3, 4, 5}, 1, 3},\n\t\t{[]float64{2, 3, 4}, []float64{3, 4, 5}, math.Inf(1), 3},\n\t\t{[]float64{-2, -3, -4}, []float64{-3, -4, -5}, 1, 3},\n\t\t{[]float64{-2, -3, -4}, []float64{-3, -4, -5}, 2, math.Sqrt(3)},\n\t\t{[]float64{-2, -3, -4}, []float64{-3, -4, -5}, math.Inf(1), 3},\n\t\t{[]float64{2, 3, 4}, []float64{3, 4, 5}, 0.5, math.Pow(math.Pow(1, 0.5)+math.Pow(1, 0.5)+math.Pow(1, 0.5), 2)},\n\t\t{[]float64{2, 3, 4}, []float64{2, 3, 4}, 2, 0},\n\t\t{[]float64{2, 3, 4}, []float64{2, 3, 4}, 1, 0},\n\t\t{[]float64{2, 3, 4}, []float64{2, 3, 4}, 0.5, 0},\n\t\t{[]float64{2, 3, 4}, []float64{2, 3, 4}, math.Inf(1), 0},\n\t\t{[]float64{}, []float64{}, 2, 0},\n\t\t{[]float64{}, []float64{}, 1, 0},\n\t\t{[]float64{}, []float64{}, 0.5, 0},\n\t\t{[]float64{}, []float64{}, math.Inf(1), 0},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Case %v: Mismatch. Want %v, got %v\", test, test.want, got)\n\t\t}\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{2, 3, 4}, []float64{2, 4}, 2)\n}\n",
    "b40f3129f28d9f1eeaeb9805d894b2d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\tfor _, test := range []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"test same slice\",\n\t\t\ts:    s,\n\t\t\tt:    s,\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices with L = 2\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    2,\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices with L = 1\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    1,\n\t\t\twant: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices with L = infinity\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices with L = 3\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    3,\n\t\t\twant: 6.349604207872797,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := Distance(test.s, test.t, test.L)\n\t\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics\n\tt.Run(\"test different lengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tDistance(s, []float64{1, 2, 3}, 2)\n\t})\n}\n",
    "b453eeefaf291a83ffcb9e4516aac460": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{4, 0, 1, 0.25, 1},\n\t\t{4, 0, 1, 0.75, 3},\n\t\t{10, 0, 1, 0.1, 1},\n\t\t{10, 0, 1, 0.9, 9},\n\t\t{10, 0, 1, 0.0, 0},\n\t\t{10, 0, 1, 1.0, 9},\n\t\t{10, 1, 0, 0.1, 9},\n\t\t{10, 1, 0, 0.9, 1},\n\t\t{10, -1, 1, -1.1, 0},\n\t\t{10, -1, 1, 1.1, 9},\n\t\t{10, -1, 1, 0, 5},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n=%v, l=%v, u=%v, v=%v\", tc.n, tc.l, tc.u, tc.v)\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanInfCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, math.NaN(), 1, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 0},\n\t\t{2, math.Inf(1), 0, 0, 1},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), 0, 0, 0},\n\t\t{2, 0, math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 0},\n\t}\n\n\tfor _, tc := range nanInfCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n=%v, l=%v, u=%v, v=%v\", tc.n, tc.l, tc.u, tc.v)\n\t}\n\n\t// Test panics for n \u003c 2.\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) }, \"Should panic for n \u003c 2\")\n\tassert.Panics(t, func() { NearestIdxForSpan(0, 0, 1, 0.5) }, \"Should panic for n \u003c 2\")\n}\n",
    "b4b092207079221ea52e0eecea53fb6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 2, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 2, 8},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 1, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 1, 16},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 3.5, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 3.5, math.Pow(256, 1.0/3.5)},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 2)\n}",
    "b517facd54cabc2f4032e18bd4d107cd": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{2, 2, 2}, []float64{2, 4, 6}},\n\t\t{[]float64{-1, -2, -3}, []float64{2, 2, 2}, []float64{-2, -4, -6}},\n\t\t{[]float64{1.1, 2.2, 3.3}, []float64{2, 2, 2}, []float64{2.2, 4.4, 6.6}},\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range tests {\n\t\t// Run Mul function\n\t\tMul(tc.dst, tc.s)\n\n\t\t// Check if the result is as expected\n\t\tfor j := range tc.dst {\n\t\t\tif tc.dst[j] != tc.want[j] {\n\t\t\t\tt.Errorf(\"Test case %d failed: Expected %v, got %v\", i, tc.want, tc.dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "b62580acc0fe992fad3b01981ef69e94": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{5, 7, 9}\n\n\tgot := AddTo(dst, s, t)\n\tassert.Equal(t, want, got)\n}",
    "b62c0496f8758e4bda8819180b790391": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\tfor _, test := range []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L2Distance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    2,\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"L1Distance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    1,\n\t\t\twant: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"L3Distance\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    3,\n\t\t\twant: math.Pow(96, 1.0/3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Test %s: got %v, want %v\", test.name, got, test.want)\n\t\t}\n\t}\n\n\t// Test panic case\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance(s, []float64{1, 2, 3}, 2)\n}\n",
    "b7f2edbdc613f82d19b5b99c215ff5f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are very large values\n\t// - l and u are Inf\n\t// - l and u are NaN\n\t// - l or u is Inf\n\t// - l or u is NaN\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very large values\n\tt.Run(\"LargeValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, -1e10, 1e10)\n\t\texpected := []float64{-1e10, -5e9, 0, 5e9, 1e10}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u is Inf\n\tt.Run(\"OneInfValue\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 0)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u is NaN\n\tt.Run(\"OneNaNValue\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 0)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "b89f9f1089868798b9e02bcd5e68794b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"DecimalSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    1.5,\n\t\t\tu:    2.5,\n\t\t\twant: []float64{1.5, 1.75, 2, 2.25},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf\n\tnan := math.NaN()\n\tinf := math.Inf(1)\n\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    nan,\n\t\t\tu:    2,\n\t\t\twant: []float64{nan, nan, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    nan,\n\t\t\twant: []float64{-1, nan, nan},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    inf,\n\t\t\tu:    2,\n\t\t\twant: []float64{inf, inf, inf, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1,\n\t\t\tu:    inf,\n\t\t\twant: []float64{-1, inf, inf, inf},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    inf,\n\t\t\tu:    inf,\n\t\t\twant: []float64{inf, inf, inf, inf, inf},\n\t\t},\n\t\t{\n\t\t\tname: \"BothNegativeInf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -inf,\n\t\t\tu:    -inf,\n\t\t\twant: []float64{-inf, -inf, -inf, -inf, -inf},\n\t\t},\n\t\t{\n\t\t\tname: \"InfInfDifferentSign\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -inf,\n\t\t\tu:    inf,\n\t\t\twant: []float64{-inf, -inf, 0, inf, inf},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\t// Handle NaN comparison\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif !(math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tc.want[i]) || got[i] == tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on a slice with length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "b8a05ba3a712e311a1d2e9009147f26b": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ttype testCase struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}\n\ttestCases := []testCase{\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 0.0, 0},\n\t\t{[]float64{0, 1}, 1.0, -1},\n\t\t{[]float64{-1, 0, 1}, -0.5, 0},\n\t\t{[]float64{-1, 0, 1}, 0.5, 1},\n\t\t{[]float64{-1, 0, 1}, 1.5, -1},\n\t}\n\tfor i, tc := range testCases {\n\t\tvar got int\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"TestWithin %d: panicked on %v\", i, tc)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot = Within(tc.s, tc.v)\n\t\t}()\n\t\tif got != tc.expected {\n\t\t\tt.Errorf(\"TestWithin %d: mismatch. got %v, want %v\", i, got, tc.expected)\n\t\t}\n\t}\n\t// NaN cases\n\tnanCases := []testCase{\n\t\t{[]float64{0, 1}, math.NaN(), -1},\n\t\t{[]float64{-1, 0, 1}, math.NaN(), -1},\n\t}\n\tfor i, tc := range nanCases {\n\t\tvar got int\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"TestWithin %d (NaN): panicked on %v\", i, tc)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot = Within(tc.s, tc.v)\n\t\t}()\n\t\tif got != tc.expected {\n\t\t\tt.Errorf(\"TestWithin %d (NaN): mismatch. got %v, want %v\", i, got, tc.expected)\n\t\t}\n\t}\n\t// Edge cases with large slices\n\tlargeSlice := make([]float64, 1e6)\n\tfor i := range largeSlice {\n\t\tlargeSlice[i] = float64(i) / float64(len(largeSlice)-1)\n\t}\n\tlargeCases := []testCase{\n\t\t{largeSlice, -1e-16, -1},\n\t\t{largeSlice, 0.0, 0},\n\t\t{largeSlice, 0.5, 5e5 - 1},\n\t\t{largeSlice, 1.0, -1},\n\t\t{largeSlice, 1 + 1e-16, -1},\n\t}\n\tfor i, tc := range largeCases {\n\t\tvar got int\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"TestWithin %d (large slice): panicked on %v\", i, tc)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot = Within(tc.s, tc.v)\n\t\t}()\n\t\tif got != tc.expected {\n\t\t\tt.Errorf(\"TestWithin %d (large slice): mismatch. got %v, want %v\", i, got, tc.expected)\n\t\t}\n\t}\n}\n",
    "b90b25d30caac34e602553815fe2c041": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, multiple elements,\n\t// and cases where Kahan summation provides more accuracy.\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t}\n\n\tfor i, test := range tests {\n\t\tactual := SumCompensated(test.input)\n\t\tif math.Abs(actual-test.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, test.expected, actual)\n\t\t}\n\t}\n}\n",
    "ba6c5492461668b1361d8b51e520bf52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are very large values\n\t// - l and u are Inf\n\t// - l and u are NaN\n\t// - l and u are a mix of the above\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very large values\n\tt.Run(\"LargeValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, -1e10, 1e10)\n\t\texpected := []float64{-1e10, -5e9, 0, 5e9, 1e10}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are a mix of the above\n\tt.Run(\"MixedValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "bd09c4b3139e4799017cb559fa235589": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases: slice length, lower bound, upper bound, expected slice\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{2, 0, 1, []float64{0, 1}},\n\t\t{3, 0, 1, []float64{0, 0.5, 1}},\n\t\t{4, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{5, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{10, -1, 1, []float64{-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdst := make([]float64, tc.n)\n\t\tSpan(dst, tc.l, tc.u)\n\t\tfor i := range dst {\n\t\t\tif math.Abs(dst[i]-tc.expected[i]) \u003e 1e-14 {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, dst, tc.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\t// Test cases: slice length, lower bound, upper bound, expected slice\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{4, math.NaN(), 1, []float64{math.NaN(), math.NaN(), math.NaN(), 1}},\n\t\t{4, 0, math.NaN(), []float64{0, math.NaN(), math.NaN(), math.NaN()}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdst := make([]float64, tc.n)\n\t\tSpan(dst, tc.l, tc.u)\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(tc.expected[i]) {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, dst, tc.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if dst[i] != tc.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, dst, tc.expected)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\t// Test cases: slice length, lower bound, upper bound, expected slice\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{4, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{4, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t\t{5, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}},\n\t\t{4, math.Inf(1), 1, []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1}},\n\t\t{4, 0, math.Inf(-1), []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdst := make([]float64, tc.n)\n\t\tSpan(dst, tc.l, tc.u)\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(tc.expected[i], 0) {\n\t\t\t\tif !math.IsInf(dst[i], 0) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, dst, tc.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if dst[i] != tc.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, dst, tc.expected)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n}",
    "bd0baf941d695935d5dc6dc476aff106": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, -0.25, 0},\n\t\t{10, 0, 1, 1.25, 9},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, -0.25, 0},\n\t\t{10, 1, 0, 1.25, 0},\n\t\t{10, -1, 1, 0, 5},\n\t\t{10, -1, -0.5, 0, 0},\n\t\t{10, -1, -0.5, -1, 0},\n\t\t{10, -1, -0.5, -0.5, 9},\n\t\t{10, -1, -0.5, -0.75, 5},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanInfCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, math.NaN(), 1, 0.5, 0},\n\t\t{10, 0, math.NaN(), 0.5, 9},\n\t\t{10, math.Inf(1), 0, 0.5, 0},\n\t\t{10, 0, math.Inf(1), 0.5, 9},\n\t\t{10, math.Inf(-1), 0, 0.5, 0},\n\t\t{10, 0, math.Inf(-1), 0.5, 0},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t}\n\n\tfor i, tc := range nanInfCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case for panic when n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"NearestIdxForSpan did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "bdbac0eb9fce9bd1874ee7d0e7ca5d5a": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := i*10 + 1\n\t\tdst := make([]float64, n)\n\t\ts := make([]float64, n)\n\t\tfor j := range dst {\n\t\t\tdst[j] = rand.Float64()\n\t\t\ts[j] = rand.Float64()\n\t\t}\n\t\talpha := rand.Float64()\n\t\texpect := make([]float64, n)\n\t\tfor j := range expect {\n\t\t\texpect[j] = dst[j] + alpha*s[j]\n\t\t}\n\t\tAddScaled(dst, alpha, s)\n\t\tfor j := range dst {\n\t\t\tif dst[j] != expect[j] {\n\t\t\t\tt.Errorf(\"AddScaled mismatch at element %v, expected %v, got: %v\\n\", j, expect[j], dst[j])\n\t\t\t}\n\t\t}\n\n\t\t// Test that it panics\n\t\tdefer func() {\n\t\t\tr := recover()\n\t\t\tif r == nil {\n\t\t\t\tt.Errorf(\"AddScaled did not panic with mismatched lengths\")\n\t\t\t}\n\t\t}()\n\t\tAddScaled(dst, alpha, s[1:])\n\t}\n}",
    "bf076eed918d7c3223f67e7e25518cf2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ts1 := []float64{1, 2, 3, math.NaN()}\n\ts2 := []float64{1, 2, 3, math.NaN()}\n\ts3 := []float64{1, 2, 3, 4}\n\ts4 := []float64{1, 2, 3}\n\n\tif !Same(s1, s2) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be true\", s1, s2)\n\t}\n\n\tif Same(s1, s3) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s1, s3)\n\t}\n\n\tif Same(s1, s4) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s1, s4)\n\t}\n}",
    "bfda35f3c18a5baeca503393dbab6526": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 1, 0, []float64{1, 2.0 / 3.0, 1.0 / 3.0, 0}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, math.NaN(), 0, []float64{math.NaN(), math.NaN(), math.NaN(), 0}},\n\t\t{[]float64{0, 0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN(), math.NaN()}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), 0, []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tif !EqualApprox(test.dst, have, tol) {\n\t\t\tt.Errorf(\"Test %d: Input %v: Expected %v, got %v\", i, test.dst, test.want, have)\n\t\t}\n\t}\n}",
    "c0ec03dca8cd07a84c9284fb4860376c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// First just test a bunch of random values\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tn := 2 + i\n\t\tl := rand.NormFloat64()\n\t\tu := l + (rand.ExpFloat64()+1e-15)*rand.Float64()\n\t\tv := l + rand.Float64()*(u-l)\n\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\twant := Nearest(Span(make([]float64, n), l, u), v)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v,%v,%v,%v) = %v, want %v\", n, l, u, v, got, want)\n\t\t}\n\t}\n\t// Test some edge cases\n\t// n = 2\n\tif NearestIdxForSpan(2, 0, 1, -1) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,0,1,-1) != 0\")\n\t}\n\tif NearestIdxForSpan(2, 0, 1, 2) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,0,1,2) != 1\")\n\t}\n\t// Big numbers\n\tif NearestIdxForSpan(2, 1e300, 1e301, 1e300-1) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,1e300,1e301,1e300-1) != 0\")\n\t}\n\tif NearestIdxForSpan(2, 1e300, 1e301, 1e301+1) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,1e300,1e301,1e301+1) != 1\")\n\t}\n\t// Small numbers\n\tif NearestIdxForSpan(2, 1e-300, 1e-299, 1e-300-1e-301) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,1e-300,1e-299,1e-300-1e-301) != 0\")\n\t}\n\tif NearestIdxForSpan(2, 1e-300, 1e-299, 1e-299+1e-300) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,1e-300,1e-299,1e-299+1e-300) != 1\")\n\t}\n\n\t// Test cases with NaN\n\tif NearestIdxForSpan(2, 0, 1, math.NaN()) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,0,1,NaN) != 0\")\n\t}\n\tif NearestIdxForSpan(2, math.NaN(), 1, 0) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,NaN,1,0) != 1\")\n\t}\n\tif NearestIdxForSpan(2, 0, math.NaN(), 0) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,0,NaN,0) != 0\")\n\t}\n\tif NearestIdxForSpan(2, math.NaN(), math.NaN(), 0) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,NaN,NaN,0) != 0\")\n\t}\n\n\t// Test cases with Inf\n\tif NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 0) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,-Inf,Inf,0) != 0\")\n\t}\n\tif NearestIdxForSpan(2, math.Inf(1), math.Inf(-1), 0) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,Inf,-Inf,0) != 1\")\n\t}\n\tif NearestIdxForSpan(2, 0, math.Inf(1), 0) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,0,Inf,0) != 0\")\n\t}\n\tif NearestIdxForSpan(2, math.Inf(-1), 0, 0) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,-Inf,0,0) != 1\")\n\t}\n\tif NearestIdxForSpan(2, 0, math.Inf(-1), 0) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(2,0,-Inf,0) != 1\")\n\t}\n\tif NearestIdxForSpan(2, math.Inf(1), 0, 0) != 0 {\n\t\tt.Error(\"NearestIdxForSpan(2,Inf,0,0) != 0\")\n\t}\n\n\t// Test cases with very close values\n\tif NearestIdxForSpan(10, 0, 1, 0.1+tol) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(10,0,1,0.1+tol) != 1\")\n\t}\n\tif NearestIdxForSpan(10, 0, 1, 0.1-tol) != 1 {\n\t\tt.Error(\"NearestIdxForSpan(10,0,1,0.1-tol) != 1\")\n\t}\n}\n",
    "c0edc28b0bb8ad039cd83dc2899be0c1": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{4, 10, 18}\n\tgot := MulTo(dst, s, t)\n\tassert.Equal(t, want, got)\n}",
    "c219c9759b2b913ab17a36a30c8a5282": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases:\n\t// - Empty input\n\t// - Single slice\n\t// - Multiple slices with equal lengths\n\t// - Multiple slices with unequal lengths\n\n\t// Empty input\n\tif !EqualLengths() {\n\t\tt.Error(\"EqualLengths() with empty input should return true\")\n\t}\n\n\t// Single slice\n\tif !EqualLengths([]float64{1, 2, 3}) {\n\t\tt.Error(\"EqualLengths() with single slice should return true\")\n\t}\n\n\t// Multiple slices with equal lengths\n\tif !EqualLengths([]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}) {\n\t\tt.Error(\"EqualLengths() with multiple slices of equal length should return true\")\n\t}\n\n\t// Multiple slices with unequal lengths\n\tif EqualLengths([]float64{1, 2, 3}, []float64{4, 5}, []float64{7, 8, 9}) {\n\t\tt.Error(\"EqualLengths() with multiple slices of unequal length should return false\")\n\t}\n}",
    "c245931e3d9384bd8814b85c1d7c28c5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 3.1, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 3.6, 3},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5000000001, 2},\n\t\t{[]float64{1, math.NaN(), 3}, 2, 0},\n\t\t{[]float64{1, math.NaN(), 3}, math.NaN(), 1},\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 2},\n\t\t{[]float64{1, 2, 3}, math.Inf(-1), 0},\n\t} {\n\t\tgot := NearestIdx(c.s, c.v)\n\t\tif got != c.i {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v, want %v\", c.s, c.v, got, c.i)\n\t\t}\n\t}\n}\n",
    "c319c9163393d0f1a232cc36990f80f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInfinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.want == nil {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic, want panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif tc.want == nil {\n\t\t\t\treturn // Successful panic\n\t\t\t}\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) returned slice with length %v, want %v\", tc.dst, tc.l, tc.u, len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want NaN\", tc.dst, tc.l, tc.u, i, got[i])\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "c36fad062905512cad6644b00bea6fb9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\n\t\t// Fractional values\n\t\t{10, 0, 10, 2.5, 2},\n\t\t{10, 0, 10, 7.5, 7},\n\n\t\t// Negative ranges\n\t\t{10, -10, 0, -5, 5},\n\t\t{10, -10, 0, -11, 0},\n\t\t{10, -10, 0, 1, 9},\n\n\t\t// Infinities\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v, expected index %v, got %v\", tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// sf is a helper function to format strings.\nfunc sf(format string, a ...any) string {\n\treturn fmt.Sprintf(format, a...)\n}",
    "c424d8a35f7c8b05e45733b34ada50f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.1,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    1.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"first element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"last element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds low\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds high\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\tv:    100,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite different sign odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite different sign even\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound infinite, matching value\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound infinite, finite value\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    4,\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound infinite, matching value\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound infinite, finite value\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value negative infinity, increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value negative infinity, decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"value positive infinity, increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"value positive infinity, decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for v = %v: got: %d want: %d\", tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\ttest.Panic(t, \"short span\", func() {\n\t\tNearestIdxForSpan(1, 0, 1, 0)\n\t})\n}\n",
    "c4347345bb3b757aabbc440dd959adf5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{0, 1, 2, 3}, wantIdx: 3},\n\t\t{s: []float64{3, 2, 1, 0}, wantIdx: 0},\n\t\t{s: []float64{0, 1, 2, 3, 3}, wantIdx: 3},\n\t\t{s: []float64{math.NaN(), 1, 2, 3}, wantIdx: 3},\n\t\t{s: []float64{0, math.NaN(), 2, 3}, wantIdx: 3},\n\t\t{s: []float64{0, 1, math.NaN(), 3}, wantIdx: 3},\n\t\t{s: []float64{0, 1, 2, math.NaN()}, wantIdx: 2},\n\t\t{s: []float64{math.NaN(), math.NaN(), math.NaN()}, wantIdx: 0},\n\t\t{s: []float64{}, wantPanic: true},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != c.wantPanic {\n\t\t\t\t\tt.Errorf(\"Got panic=%v, want panic=%v\", gotPanic, c.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MaxIdx(c.s)\n\t\t\tif gotIdx != c.wantIdx {\n\t\t\t\tt.Errorf(\"Got: %v, want: %v\", gotIdx, c.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n}",
    "c44e095c6325fd9ca41dd7c3957a9234": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype testCase struct {\n\t\ts        [][]float64\n\t\texpected bool\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\ts:        [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\ts: [][]float64{\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{4, 5, 6},\n\t\t\t},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\ts: [][]float64{\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{4, 5, 6, 7},\n\t\t\t},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\ts: [][]float64{\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{4, 5, 6},\n\t\t\t\t{7, 8, 9},\n\t\t\t},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\ts: [][]float64{\n\t\t\t\t{1, 2, 3},\n\t\t\t\t{4, 5, 6},\n\t\t\t\t{7, 8},\n\t\t\t},\n\t\t\texpected: false,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := EqualLengths(tc.s...)\n\t\tif got != tc.expected {\n\t\t\tt.Errorf(\"Test case %d: Expected %v, got %v\", i, tc.expected, got)\n\t\t}\n\t}\n}",
    "c50cc8843b4580e570dbf84f66a3386f": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantIndsC []int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"k=0\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003c0\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0, all elements found\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0, insufficient elements found\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         3,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif err != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned unexpected error %v\", tc.inds, tc.f, tc.s, tc.k, err)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) did not return expected error %v\", tc.inds, tc.f, tc.s, tc.k, tc.wantErr)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 err.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned unexpected error %v, want %v\", tc.inds, tc.f, tc.s, tc.k, err, tc.wantErr)\n\t\t\t}\n\t\t\tif !equal(got, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) = %v, want %v\", tc.inds, tc.f, tc.s, tc.k, got, tc.wantInds)\n\t\t\t}\n\t\t\tif !equal(tc.inds, tc.wantIndsC) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) unexpectedly modified the input slice: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, tc.inds, tc.wantIndsC)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(s1, s2 []int) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i, v := range s1 {\n\t\tif v != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "c5390b0747a0390f595f5a93fd3be797": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, -0.3333333333333333, 0.3333333333333333, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroSpan\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\twant: []float64{0, 0, 0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"InfRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfSame\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfDifferent\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif !math.IsNaN(got[i]) \u0026\u0026 !math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif !math.IsNaN(got[i]) || !math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2\n\tt.Run(\"PanicShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "c63de35547795507c7e26f34c81f2123": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestSub(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\twant: []float64{-1, -2, -3, -4},\n\t\t},\n\t\t{\n\t\t\ts:    []float64{0, -1, -1e-10, 1e-10},\n\t\t\twant: []float64{0, 1, 1e-10, -1e-10},\n\t\t},\n\t} {\n\t\tdst := make([]float64, len(test.s))\n\t\tfor j := range dst {\n\t\t\tdst[j] = 1\n\t\t}\n\t\tSub(dst, test.s)\n\t\tfor j, v := range dst {\n\t\t\tif !testlapack.Same(v, test.want[j]) {\n\t\t\t\tt.Errorf(\"Test %d: dst[%d] = %v, want %v\", i, j, v, test.want[j])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// Test panic\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Error(\"Did not panic\")\n\t\t}\n\t}()\n\ts1 := make([]float64, 2)\n\ts2 := make([]float64, 3)\n\tSub(s1, s2)\n}\n",
    "c66f332326724bc488067fc1ae2dee45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\t// Test case 1: Check basic functionality\n\tdst := make([]float64, 5)\n\tl := 1.0\n\tu := 100.0\n\texpected := []float64{1.0, 2.718281828459045, 7.38905609893065, 20.085536923187668, 100.0}\n\tLogSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.Abs(dst[i]-expected[i]) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Test case 1 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 2: Check for negative input\n\tl = -1.0\n\tu = 10.0\n\tLogSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Test case 2 failed: Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\n\t// Test case 3: Check for zero input\n\tl = 0.0\n\tu = 10.0\n\tLogSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != 0.0 {\n\t\t\tt.Errorf(\"Test case 3 failed: Expected 0.0, got %v\", dst[i])\n\t\t}\n\t}\n\n\t// Test case 4: Check for slice length less than 2\n\tdst = make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case 4 failed: The code did not panic\")\n\t\t}\n\t}()\n\tLogSpan(dst, l, u)\n}\n",
    "c67238fc1cdc7f32abd6e8a9759afd8f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 10)\n}\n\nfunc TestSpanSimple(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, 10)\n\t// For this and other tests, verify the final result\n\t// rather than testing the implementation details.\n\twant := []float64{0, 2.5, 5, 7.5, 10}\n\tfor i := range dst {\n\t\tif dst[i] != want[i] {\n\t\t\tt.Errorf(\"Error in Span, dst[%d]=%v, want %v\", i, dst[i], want[i])\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\t// Test cases where l or u are Inf.\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{make([]float64, 5), math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 5), math.Inf(1), 0, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}},\n\t\t{make([]float64, 5), 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 5), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)}},\n\t\t{make([]float64, 5), math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t} {\n\t\tSpan(test.dst, test.l, test.u)\n\t\tfor j := range test.dst {\n\t\t\tif test.dst[j] != test.want[j] {\n\t\t\t\tt.Errorf(\"Error in Span test %d.  dst[%d]=%v, want %v\", i, j, test.dst[j], test.want[j])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\t// Test cases where l or u are NaN.\n\tdst := make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, math.NaN(), 0)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Error in Span, dst[%d]=%v, want NaN\", i, dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"Error in Span, dst[%d]=%v, want 0\", len(dst)-1, dst[len(dst)-1])\n\t}\n\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Error in Span, dst[%d]=%v, want 0\", 0, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Error in Span, dst[%d]=%v, want NaN\", i, dst[i])\n\t\t}\n\t}\n}",
    "c68f0eeab1152e158103052b21dc3f6f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\twant := []float64{1, 2, 3}\n\n\tMul(dst, s)\n\tfor i := range dst {\n\t\tif dst[i] != want[i] {\n\t\t\tt.Errorf(\"Mul error: got %v for dst[%v], want %v\", dst[i], i, want[i])\n\t\t}\n\t}\n\n\t// Test panicking\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tMul(dst, []float64{1, 2})\n}",
    "c6e905e1ad53e35ccd01273d9f1d7878": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Cases with NaN\n\t\t{2, math.NaN(), 1, 0.5, 1},\n\t\t{2, 0, math.NaN(), 0.5, 0},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf\n\t\t{2, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0.5, 1},\n\t\t{2, math.Inf(-1), math.Inf(1), 0.5, 1},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// Cases with v outside (l, u)\n\t\t{2, 0, 1, -0.5, 0},\n\t\t{2, 0, 1, 1.5, 1},\n\t\t{2, 1, 0, -0.5, 1},\n\t\t{2, 1, 0, 1.5, 0},\n\n\t\t// Cases with l == u\n\t\t{2, 0, 0, 0.5, 0},\n\t\t{3, 1, 1, 0.5, 1},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v, expected index %d, got %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, actualIdx)\n\t\t}\n\t}\n}\n",
    "c70bd4226e4382659ab756194d226ddb": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-3, -2, -1, -0.1, 0, 0.1, 1, 2, 3}\n\tfor i, v := range s {\n\t\tj := Within(s, v)\n\t\tif j != i {\n\t\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, v, i, j)\n\t\t}\n\t}\n\t// Test values in between elements of s\n\tfor i := 0; i \u003c len(s)-1; i++ {\n\t\tv := (s[i] + s[i+1]) / 2\n\t\tj := Within(s, v)\n\t\tif j != i {\n\t\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, v, i, j)\n\t\t}\n\t}\n\t// Test values outside of s\n\tj := Within(s, -4)\n\tif j != -1 {\n\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, -4, -1, j)\n\t}\n\tj = Within(s, 4)\n\tif j != -1 {\n\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, 4, -1, j)\n\t}\n\t// Test NaN\n\tj = Within(s, math.NaN())\n\tif j != -1 {\n\t\tt.Errorf(\"Expected Within(%v, NaN) = %v, got %v\", s, -1, j)\n\t}\n\n\t// Test edge cases\n\ts = []float64{1, 2}\n\tif Within(s, 1) != 0 {\n\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, 1, 0, j)\n\t}\n\tif Within(s, 1.5) != 0 {\n\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, 1.5, 0, j)\n\t}\n\tif Within(s, 2-tol) != 0 {\n\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, 2-tol, 0, j)\n\t}\n\tif Within(s, 2) != -1 {\n\t\tt.Errorf(\"Expected Within(%v, %v) = %v, got %v\", s, 2, -1, j)\n\t}\n}\n",
    "c84004bbf3a69183c622f48e660f5b13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\ttol := 1e-14\n\n\tif math.Abs(Distance(s, t, 1)-16) \u003e tol {\n\t\tt.Errorf(\"Sum of absolute differences not correct\")\n\t}\n\tif math.Abs(Distance(s, t, 2)-8) \u003e tol {\n\t\tt.Errorf(\"Euclidean distance not correct\")\n\t}\n\tif math.Abs(Distance(s, t, math.Inf(1))-4) \u003e tol {\n\t\tt.Errorf(\"Infinity norm not correct\")\n\t}\n\tif math.Abs(Distance(s, t, 3)-math.Pow(32, 1.0/3)) \u003e tol {\n\t\tt.Errorf(\"General L-norm not correct\")\n\t}\n}\n",
    "c9072aa3fc2774f4553a579a976d9871": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and/or u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %v, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v at last index, got %v\", u, dst[len(dst)-1])\n\t\t}\n\n\t\tl = 1.0\n\t\tu = math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v at first index, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %v, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"InfValuesSameSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %v, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\n\t\tl = math.Inf(-1)\n\t\tu = math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at index %v, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u is Inf\n\tt.Run(\"InfValuesDifferentSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %v, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v at last index, got %v\", u, dst[len(dst)-1])\n\t\t}\n\n\t\tl = 1.0\n\t\tu = math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v at first index, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at index %v, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"EqualValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 3.14\n\t\tu := 3.14\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != l {\n\t\t\t\tt.Errorf(\"Expected %v at index %v, got %v\", l, i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "c9a488ed3661683813cdc9acf0983fe4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - l == u\n\t// - l \u003e u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, 0, 1, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, 0, 1, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, 1, 1, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, 1, 0, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.NaN(), math.NaN())\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, math.NaN(), math.NaN(), got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, math.NaN(), 1, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, 0, math.NaN(), got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif math.IsInf(got[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, math.Inf(1), math.Inf(1), got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range want {\n\t\t\tif math.IsInf(got[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, math.Inf(1), 1, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif math.IsInf(got[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, 0, math.Inf(1), got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "ca0939efcf7f3a8da4f08dbb68580e05": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\ts5 := []float64{1, math.NaN(), 3}\n\n\tif !Same(nil, nil) {\n\t\tt.Errorf(\"Failed to compare nil slices\")\n\t}\n\n\tif !Same(s1, s2) {\n\t\tt.Errorf(\"Failed to compare slices with same values\")\n\t}\n\n\tif Same(s1, s3) {\n\t\tt.Errorf(\"Failed to compare slices with different lengths\")\n\t}\n\n\tif Same(s1, s4) {\n\t\tt.Errorf(\"Failed to compare slices with different values\")\n\t}\n\n\tif !Same(s5, s5) {\n\t\tt.Errorf(\"Failed to compare slices with NaN values\")\n\t}\n}\n",
    "ca5c8d4320f117c218de35798e287ba6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// n = 2\n\tif NearestIdxForSpan(2, 0, 1, 0.25) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, 0, 1, 0.25) = 0\")\n\t}\n\tif NearestIdxForSpan(2, 0, 1, 0.75) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, 0, 1, 0.75) = 1\")\n\t}\n\t// n = 3\n\tif NearestIdxForSpan(3, 0, 1, 0.1) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(3, 0, 1, 0.1) = 0\")\n\t}\n\tif NearestIdxForSpan(3, 0, 1, 0.4) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(3, 0, 1, 0.4) = 1\")\n\t}\n\tif NearestIdxForSpan(3, 0, 1, 0.9) != 2 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(3, 0, 1, 0.9) = 2\")\n\t}\n\t// n = 4\n\tif NearestIdxForSpan(4, 0, 1, 0.125) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0.125) = 0\")\n\t}\n\tif NearestIdxForSpan(4, 0, 1, 0.375) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0.375) = 1\")\n\t}\n\tif NearestIdxForSpan(4, 0, 1, 0.625) != 2 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0.625) = 2\")\n\t}\n\tif NearestIdxForSpan(4, 0, 1, 0.875) != 3 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0.875) = 3\")\n\t}\n\t// Test cases with l \u003e u\n\tif NearestIdxForSpan(2, 1, 0, 0.25) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, 1, 0, 0.25) = 1\")\n\t}\n\tif NearestIdxForSpan(2, 1, 0, 0.75) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, 1, 0, 0.75) = 0\")\n\t}\n\tif NearestIdxForSpan(3, 1, 0, 0.1) != 2 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(3, 1, 0, 0.1) = 2\")\n\t}\n\tif NearestIdxForSpan(3, 1, 0, 0.4) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(3, 1, 0, 0.4) = 1\")\n\t}\n\tif NearestIdxForSpan(3, 1, 0, 0.9) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(3, 1, 0, 0.9) = 0\")\n\t}\n\t// Test cases with NaN\n\tif NearestIdxForSpan(2, 0, math.NaN(), 0.5) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, 0, NaN, 0.5) = 0\")\n\t}\n\tif NearestIdxForSpan(2, math.NaN(), 1, 0.5) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, NaN, 1, 0.5) = 1\")\n\t}\n\t// Test cases with Inf\n\tif NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 0.5) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, -Inf, Inf, 0.5) = 0\")\n\t}\n\tif NearestIdxForSpan(2, 0, math.Inf(1), math.Inf(1)) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, 0, Inf, Inf) = 1\")\n\t}\n\tif NearestIdxForSpan(2, math.Inf(-1), 0, math.Inf(-1)) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(2, -Inf, 0, -Inf) = 0\")\n\t}\n\t// Test cases with v outside (l, u)\n\tif NearestIdxForSpan(4, 0, 1, -0.5) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, -0.5) = 0\")\n\t}\n\tif NearestIdxForSpan(4, 0, 1, 1.5) != 3 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 1.5) = 3\")\n\t}\n\t// Test cases with v outside (u, l)\n\tif NearestIdxForSpan(4, 1, 0, -0.5) != 3 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 1, 0, -0.5) = 3\")\n\t}\n\tif NearestIdxForSpan(4, 1, 0, 1.5) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 1, 0, 1.5) = 0\")\n\t}\n\t// Test cases with large n\n\tif NearestIdxForSpan(1000, 0, 1, 0.5) != 499 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(1000, 0, 1, 0.5) = 499\")\n\t}\n\tif NearestIdxForSpan(1000, 0, 1, 0.2345) != 234 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(1000, 0, 1, 0.2345) = 234\")\n\t}\n\t// Test cases with negative l and u\n\tif NearestIdxForSpan(4, -1, -0.5, -0.75) != 1 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, -1, -0.5, -0.75) = 1\")\n\t}\n\t// Test cases with large l and u\n\tif NearestIdxForSpan(4, 100, 101, 100.25) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 100, 101, 100.25) = 0\")\n\t}\n\t// Test cases with v equal to l or u\n\tif NearestIdxForSpan(4, 0, 1, 0) != 0 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0) = 0\")\n\t}\n\tif NearestIdxForSpan(4, 0, 1, 1) != 3 {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 1) = 3\")\n\t}\n\t// Test cases with v very close to l or u\n\tif math.Abs(float64(NearestIdxForSpan(4, 0, 1, 0.000000001))-0) \u003e tol {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0.000000001) to be close to 0\")\n\t}\n\tif math.Abs(float64(NearestIdxForSpan(4, 0, 1, 0.999999999))-3) \u003e tol {\n\t\tt.Errorf(\"Expected NearestIdxForSpan(4, 0, 1, 0.999999999) to be close to 3\")\n\t}\n}\n",
    "cad7b02fd7a43024f9e31aaa000ba4d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, expected %d\", i, tc.n, tc.l, tc.u, tc.v, idx, tc.expectedIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb2f4ecce6f8ce30d05a1cb5dedc4149": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-14\n\ts := []float64{-1, -0.1, 0, 1, 1.1, 10}\n\ttype testCase struct {\n\t\tv        float64\n\t\texpected int\n\t}\n\tcases := []testCase{\n\t\t{v: -1 - tol, expected: -1},\n\t\t{v: -1, expected: 0},\n\t\t{v: -1 + tol, expected: 0},\n\t\t{v: -0.1 - tol, expected: 0},\n\t\t{v: -0.1, expected: 1},\n\t\t{v: -0.1 + tol, expected: 1},\n\t\t{v: 0 - tol, expected: 1},\n\t\t{v: 0, expected: 2},\n\t\t{v: 0 + tol, expected: 2},\n\t\t{v: 1 - tol, expected: 3},\n\t\t{v: 1, expected: 4},\n\t\t{v: 1 + tol, expected: 4},\n\t\t{v: 1.1 - tol, expected: 4},\n\t\t{v: 1.1, expected: 5},\n\t\t{v: 1.1 + tol, expected: 5},\n\t\t{v: 10 - tol, expected: 5},\n\t\t{v: 10, expected: -1},\n\t\t{v: 10 + tol, expected: -1},\n\t\t{v: math.NaN(), expected: -1},\n\t}\n\n\tfor i, c := range cases {\n\t\tvar got int\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tgot = -2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot = Within(s, c.v)\n\t\t}()\n\t\tif got != c.expected {\n\t\t\tt.Errorf(\"case %d failed: Within(%v, %v) = %v, want %v\", i, s, c.v, got, c.expected)\n\t\t}\n\t}\n}",
    "cb50929c3d31ad17a3f460bf88000ad7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, multiple elements.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e100, 1.0, -1e100}, 1.0}, // Test case for cancellation error\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "cb535218c3f70cf84aad141358af65fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\ts3 := []float64{1, 2}\n\ts4 := []float64{}\n\n\t// Test cases for L = 2\n\tif got, want := Distance(s1, s2, 2), 8; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = 1\n\tif got, want := Distance(s1, s2, 1), 16; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = infinity\n\tif got, want := Distance(s1, s2, math.Inf(1)), 4; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for other L values\n\tif got, want := Distance(s1, s2, 3), math.Pow(96, 1.0/3.0); got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for empty slices\n\tif got, want := Distance(s4, s4, 2), 1; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s4, s4, got, want)\n\t}\n\n\t// Test cases for panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance(s1, s3, 2)\n}\n",
    "cba9f4ddaeffe47ca5b276cb857f5a91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{1, 2, 3, 4}\n\tif math.Abs(Norm(s, 1)-10) \u003e tol {\n\t\tt.Errorf(\"Norm failed with L=1\")\n\t}\n\tif math.Abs(Norm(s, 2)-math.Sqrt(30)) \u003e tol {\n\t\tt.Errorf(\"Norm failed with L=2\")\n\t}\n\tif math.Abs(Norm(s, math.Inf(1))-4) \u003e tol {\n\t\tt.Errorf(\"Norm failed with L=Inf\")\n\t}\n\tif math.Abs(Norm(s, 3)-math.Pow(100, 1.0/3.0)) \u003e tol {\n\t\tt.Errorf(\"Norm failed with L=3\")\n\t}\n\tif math.Abs(Norm([]float64{}, 2)-0) \u003e tol {\n\t\tt.Errorf(\"Norm failed with empty slice\")\n\t}\n\n}\n",
    "cbb8d4e698be7f05734f9a6261da1335": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l == u\n\t// - l \u003e u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\ts := []float64{}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(s, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\ts := []float64{0}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(s, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\ts := []float64{0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.NaN(), math.NaN())\n\t\tfor i := range s {\n\t\t\tif !math.IsNaN(s[i]) {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want NaN\", i, s[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range s {\n\t\t\tif !math.IsNaN(s[i]) \u0026\u0026 s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range s {\n\t\t\tif !math.IsNaN(s[i]) \u0026\u0026 s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.Inf(1), math.Inf(1))\n\t\tfor i := range s {\n\t\t\tif !math.IsInf(s[i], 1) {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want Inf\", i, s[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range s {\n\t\t\tif !math.IsInf(s[i], 1) \u0026\u0026 s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range s {\n\t\t\tif !math.IsInf(s[i], 1) \u0026\u0026 s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %v, want %v\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "cd1af6b4b2cac1a9911a1fa1e5f63565": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is less than 2\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) })\n\n\t// v is NaN\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, math.NaN()))\n\n\t// l is NaN, u is not NaN\n\tassert.Equal(t, 9, NearestIdxForSpan(10, math.NaN(), 1, 0.5))\n\n\t// u is NaN\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, math.NaN(), 0.5))\n\n\t// l and u are both Inf and equal\n\tassert.Equal(t, 0, NearestIdxForSpan(10, math.Inf(1), math.Inf(1), 0.5))\n\n\t// l and u are both Inf and not equal, n is odd, v is not Inf\n\tassert.Equal(t, 5, NearestIdxForSpan(11, math.Inf(-1), math.Inf(1), 0.5))\n\n\t// l and u are both Inf and not equal, n is odd, v is Inf and has same sign as l\n\tassert.Equal(t, 0, NearestIdxForSpan(11, math.Inf(-1), math.Inf(1), math.Inf(-1)))\n\n\t// l and u are both Inf and not equal, n is odd, v is Inf and has different sign as l\n\tassert.Equal(t, 6, NearestIdxForSpan(11, math.Inf(-1), math.Inf(1), math.Inf(1)))\n\n\t// l and u are both Inf and not equal, n is even, v is Inf and has same sign as l\n\tassert.Equal(t, 0, NearestIdxForSpan(10, math.Inf(-1), math.Inf(1), math.Inf(-1)))\n\n\t// l and u are both Inf and not equal, n is even, v is Inf and has different sign as l\n\tassert.Equal(t, 5, NearestIdxForSpan(10, math.Inf(-1), math.Inf(1), math.Inf(1)))\n\n\t// l is Inf, v equals l\n\tassert.Equal(t, 0, NearestIdxForSpan(10, math.Inf(-1), 1, math.Inf(-1)))\n\n\t// l is Inf, v does not equal l\n\tassert.Equal(t, 9, NearestIdxForSpan(10, math.Inf(-1), 1, 0.5))\n\n\t// u is Inf, v equals u\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, math.Inf(1), math.Inf(1)))\n\n\t// u is Inf, v does not equal u\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, math.Inf(1), 0.5))\n\n\t// v is -Inf, l \u003c= u\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, math.Inf(-1)))\n\n\t// v is -Inf, l \u003e u\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 1, 0, math.Inf(-1)))\n\n\t// v is +Inf, u \u003c= l\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 1, 0, math.Inf(1)))\n\n\t// v is +Inf, u \u003e l\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, math.Inf(1)))\n\n\t// l \u003c u, v \u003c= l\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, -1))\n\n\t// l \u003c u, v \u003e= u\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 2))\n\n\t// l \u003e u, v \u003e= l\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 1, 0, 2))\n\n\t// l \u003e u, v \u003c= u\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 1, 0, -1))\n\n\t// l == u\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 0, 0.5))\n\n\t// regular cases\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, 0))\n\tassert.Equal(t, 5, NearestIdxForSpan(10, 0, 1, 0.5))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 1))\n}\n",
    "cd2551357bf5a4761b1d93b27199cd8e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15.0},\n\t\t{[]float64{1.e100, 1, -1.e100}, 1.0},\n\t\t{[]float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0}, 21.0},\n\t\t{[]float64{1e-16, 1e-16, 1e-16, 1e-16, 1e-16, 1e-16, 1e-16, 1e-16, 1e-16, 1e-16}, 1e-15},\n\t}\n\n\t// Iterate over the test cases.\n\tfor i, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within the acceptable tolerance.\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n}",
    "cd59b1cd0bb3ec2ddb479fb44184b611": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\tassert.Equal(t, Distance(s, t, 1), 16.0)\n\tassert.Equal(t, Distance(s, t, 2), math.Sqrt(64))\n\tassert.Equal(t, Distance(s, t, math.Inf(1)), 4.0)\n\n\t// Test case for zero length slices\n\ts = []float64{}\n\tt = []float64{}\n\tassert.Equal(t, Distance(s, t, 2), 0.0)\n\n\t// Test case for L = 0\n\ts = []float64{1, 2, 3, 4}\n\tt = []float64{5, 6, 7, 8}\n\tassert.Panics(t, func() { Distance(s, t, 0) })\n\n\t// Test case for slices with different lengths\n\ts = []float64{1, 2, 3, 4}\n\tt = []float64{5, 6, 7}\n\tassert.Panics(t, func() { Distance(s, t, 2) })\n}\n",
    "cdbdf12b54f31cf75f3fe8b5f104b1b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular float64 values\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsOnShortDst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short dst\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular float64 values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected %v\", i, dst[i], expected[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"LIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected NaN\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Span[%d] = %v, expected 1\", len(dst)-1, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"UIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Span[0] = %v, expected 0\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected NaN\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"BothInfSameSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected Inf(1)\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf\n\tt.Run(\"LIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected Inf(1)\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Span[%d] = %v, expected 1\", len(dst)-1, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is Inf\n\tt.Run(\"UIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Span[0] = %v, expected 0\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected Inf(1)\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"EqualBounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != 1 {\n\t\t\t\tt.Errorf(\"Span[%d] = %v, expected 1\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "cec8ccef0f30afa2aa52c89fdd1aaf3a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 1, 15},\n\t\t{[]float64{0, 0, 0}, 1, 0},\n\n\t\t// L = 2\n\t\t{[]float64{1, 1, 1, 1, 1}, 2, math.Sqrt(5)},\n\t\t{[]float64{3, 4}, 2, 5},\n\t\t{[]float64{0, 0, 0}, 2, 0},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t{[]float64{-5, -4, -3, -2, -1}, math.Inf(1), 5},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 0},\n\n\t\t// L = other values\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{1, 2, 3, 4}, 1.5, math.Pow(10.816653826391968, 1.0/1.5)},\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.want, got)\n\t\t}\n\t}\n}",
    "ced77cd244892a4bc6b7d487dd1b6d4a": "package floats\n\nimport \"testing\"\n\nfunc TestScaleTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\tc := 2.0\n\ts := []float64{1, 2, 3}\n\texpected := []float64{2, 4, 6}\n\tScaleTo(dst, c, s)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"ScaleTo() dst[%v] = %v, want %v\", i, dst[i], expected[i])\n\t\t}\n\t}\n\n\t// Test panicking with different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ScaleTo() did not panic with different slice lengths\")\n\t\t}\n\t}()\n\tScaleTo(dst, c, []float64{1, 2})\n}",
    "cee9aea2c702fc18ba210f59a68d56ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n}\n\nfunc TestSpanBasic(t *testing.T) {\n\tdst := make([]float64, 3)\n\tSpan(dst, 0, 2)\n\tif dst[0] != 0 || dst[1] != 1 || dst[2] != 2 {\n\t\tt.Errorf(\"Span failed for simple case: %v\", dst)\n\t}\n}\n\nfunc TestSpanLargeN(t *testing.T) {\n\tn := 10000\n\tdst := make([]float64, n)\n\tSpan(dst, 5, 10)\n\t// Check that the endpoints are correct.\n\tif dst[0] != 5 || dst[n-1] != 10 {\n\t\tt.Errorf(\"Span failed at endpoints: %v, %v\", dst[0], dst[n-1])\n\t}\n\t// Check that the interior points are consistent with the endpoints.\n\tfor i := 1; i \u003c n; i++ {\n\t\texpected := 5 + (10-5)*float64(i)/float64(n-1)\n\t\tif dst[i] != expected {\n\t\t\tt.Errorf(\"Span failed at interior point: %v, %v\", i, dst[i])\n\t\t}\n\t}\n}\n\nfunc TestSpanEdge(t *testing.T) {\n\t// Check case with n == 2\n\tdst := make([]float64, 2)\n\tSpan(dst, 0, 10)\n\tif dst[0] != 0 || dst[1] != 10 {\n\t\tt.Errorf(\"Span failed for n = 2: %v\", dst)\n\t}\n\n\t// Check cases with infinities\n\tdst = make([]float64, 3)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tif dst[0] != math.Inf(1) || dst[1] != math.Inf(1) || dst[2] != math.Inf(1) {\n\t\tt.Errorf(\"Span failed for +Inf: %v\", dst)\n\t}\n\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\tif dst[0] != math.Inf(-1) || dst[1] != math.Inf(-1) || dst[2] != math.Inf(-1) {\n\t\tt.Errorf(\"Span failed for -Inf: %v\", dst)\n\t}\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 || dst[1] != math.Inf(1) || dst[2] != math.Inf(1) {\n\t\tt.Errorf(\"Span failed for (0, +Inf): %v\", dst)\n\t}\n\tSpan(dst, math.Inf(-1), 0)\n\tif dst[0] != math.Inf(-1) || dst[1] != math.Inf(-1) || dst[2] != 0 {\n\t\tt.Errorf(\"Span failed for (-Inf, 0): %v\", dst)\n\t}\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\tif dst[0] != math.Inf(-1) || dst[2] != math.Inf(1) {\n\t\tt.Errorf(\"Span failed for (-Inf, +Inf): %v\", dst)\n\t}\n\n\t// Check cases with NaNs\n\tdst = make([]float64, 3)\n\tSpan(dst, math.NaN(), 0)\n\tif !math.IsNaN(dst[0]) || !math.IsNaN(dst[1]) || dst[2] != 0 {\n\t\tt.Errorf(\"Span failed for (NaN, 0): %v\", dst)\n\t}\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 || !math.IsNaN(dst[1]) || !math.IsNaN(dst[2]) {\n\t\tt.Errorf(\"Span failed for (0, NaN): %v\", dst)\n\t}\n\tSpan(dst, math.NaN(), math.NaN())\n\tif !math.IsNaN(dst[0]) || !math.IsNaN(dst[1]) || !math.IsNaN(dst[2]) {\n\t\tt.Errorf(\"Span failed for (NaN, NaN): %v\", dst)\n\t}\n}",
    "cf3d2ac834f186c8f0097e850e7bbbbe": "package floats\n\nimport \"testing\"\n\nfunc TestEqualFunc(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\n\tif !EqualFunc(s1, s2, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be true\", s1, s2)\n\t}\n\n\tif EqualFunc(s1, s3, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be false\", s1, s3)\n\t}\n}",
    "cfbb4651815b01c03980fee9bcea668b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.1,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simple decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    1.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"simple increasing equal\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"simple decreasing equal\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"simple increasing below\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"simple decreasing below\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"simple increasing above\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"simple decreasing above\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    -1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"more increasing below\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    -1.1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"more decreasing below\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    1.1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"more increasing above\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    1.1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"more decreasing above\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    -1.1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"more increasing below nearly equal\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    -0.9,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"more decreasing below nearly equal\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    0.9,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"more increasing above nearly equal\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    0.9,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"more decreasing above nearly equal\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    -0.9,\n\t\t\twant: 9,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d,%v,%v,%v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"NaN cases\", func(t *testing.T) {\n\t\tfor _, tc := range []struct {\n\t\t\tname string\n\t\t\tn    int\n\t\t\tl    float64\n\t\t\tu    float64\n\t\t\tv    float64\n\t\t\twant int\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"NaN value\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    0,\n\t\t\t\tu:    4,\n\t\t\t\tv:    math.NaN(),\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"NaN lower bound\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.NaN(),\n\t\t\t\tu:    4,\n\t\t\t\tv:    1,\n\t\t\t\twant: 4,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"NaN upper bound\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    0,\n\t\t\t\tu:    math.NaN(),\n\t\t\t\tv:    1,\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"NaN both bounds\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.NaN(),\n\t\t\t\tu:    math.NaN(),\n\t\t\t\tv:    1,\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t} {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\t\tif got != tc.want {\n\t\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d,%v,%v,%v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"Inf cases\", func(t *testing.T) {\n\t\tfor _, tc := range []struct {\n\t\t\tname string\n\t\t\tn    int\n\t\t\tl    float64\n\t\t\tu    float64\n\t\t\tv    float64\n\t\t\twant int\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"Inf value lt\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    0,\n\t\t\t\tu:    4,\n\t\t\t\tv:    math.Inf(-1),\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf value gt\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    0,\n\t\t\t\tu:    4,\n\t\t\t\tv:    math.Inf(1),\n\t\t\t\twant: 4,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf lower bound\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    4,\n\t\t\t\tv:    1,\n\t\t\t\twant: 4,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf upper bound\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    0,\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    1,\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds equal\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(-1),\n\t\t\t\tv:    1,\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds equal v=l\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(-1),\n\t\t\t\tv:    math.Inf(-1),\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds opposite odd v=l\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    math.Inf(-1),\n\t\t\t\twant: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds opposite odd v=u\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    math.Inf(1),\n\t\t\t\twant: 3,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds opposite odd\",\n\t\t\t\tn:    5,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    1,\n\t\t\t\twant: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds opposite even v=l\",\n\t\t\t\tn:    4,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    math.Inf(-1),\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds opposite even v=u\",\n\t\t\t\tn:    4,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    math.Inf(1),\n\t\t\t\twant: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Inf both bounds opposite even\",\n\t\t\t\tn:    4,\n\t\t\t\tl:    math.Inf(-1),\n\t\t\t\tu:    math.Inf(1),\n\t\t\t\tv:    1,\n\t\t\t\twant: 2,\n\t\t\t},\n\t\t} {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\t\tif got != tc.want {\n\t\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d,%v,%v,%v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tt.Run(\"fuzz\", func(t *testing.T) {\n\t\trnd := testlapack.NewRand()\n\t\tfor i := 0; i \u003c 1000; i++ {\n\t\t\tn := rnd.Intn(100) + 2\n\t\t\tl := rnd.NormFloat64()\n\t\t\tu := rnd.NormFloat64()\n\t\t\tv := rnd.NormFloat64()\n\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\twant := bruteNearestIdxForSpan(n, l, u, v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"unexpected result for NearestIdxForSpan(%d,%v,%v,%v): got: %d want: %d\", n, l, u, v, got, want)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc bruteNearestIdxForSpan(n int, l, u, v float64) int {\n\ts := make([]float64, n)\n\tSpan(s, l, u)\n\treturn NearestIdx(s, v)\n}",
    "cfc03b5acebd84a7b4d5789bde286391": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantOk bool\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      -1,\n\t\t\twant:   []int{0, 1, 2, 3},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      2,\n\t\t\twant:   []int{0, 1},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 1 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      2,\n\t\t\twant:   []int{1, 2},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 2 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      2,\n\t\t\twant:   []int{2, 3},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 3 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      2,\n\t\t\twant:   []int{3},\n\t\t\twantOk: false,\n\t\t},\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      0,\n\t\t\twant:   nil,\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003c 0 },\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tk:      2,\n\t\t\twant:   nil,\n\t\t\twantOk: false,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot, err := Find(nil, tc.f, tc.s, tc.k)\n\t\tif tc.wantOk \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"test %d: unexpected error: %v\", i, err)\n\t\t}\n\t\tif !tc.wantOk \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"test %d: expected error, got nil\", i)\n\t\t}\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"test %d: want = %v, got = %v\", i, tc.want, got)\n\t\t}\n\t}\n}\n",
    "d00820bb1a4bd89672dcb2c82326bc12": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMul(t *testing.T) {\n\t// Test case 1: Multiplying by a scalar\n\tdst1 := []float64{1, 2, 3, 4}\n\ts1 := []float64{2, 2, 2, 2}\n\texpected1 := []float64{2, 4, 6, 8}\n\tMul(dst1, s1)\n\tassert.Equal(t, expected1, dst1, \"Test case 1 failed\")\n\n\t// Test case 2: Multiplying by different values\n\tdst2 := []float64{1, 2, 3, 4}\n\ts2 := []float64{2, 3, 4, 5}\n\texpected2 := []float64{2, 6, 12, 20}\n\tMul(dst2, s2)\n\tassert.Equal(t, expected2, dst2, \"Test case 2 failed\")\n\n\t// Test case 3: Empty slices\n\tdst3 := []float64{}\n\ts3 := []float64{}\n\tMul(dst3, s3)\n\tassert.Equal(t, 0, len(dst3), \"Test case 3 failed\")\n\n\t// Test case 4: Panics when lengths don't match\n\tdst4 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2}\n\tassert.Panics(t, func() { Mul(dst4, s4) }, \"Test case 4 failed: The code did not panic\")\n}\n",
    "d03fbbedb07ba59353ee3aa2469554c4": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\ts        []float64\n\t\tf        func(float64) bool\n\t\tk        int\n\t\twantId   []int\n\t\twantErr  error\n\t}\n\n\ttestCases := []testCase{\n\t\t// k \u003c 0\n\t\t{[]float64{1, 2, 3, 4, 5}, func(v float64) bool { return v \u003e 2 }, -1, []int{2, 3, 4}, nil},\n\t\t// k = 0\n\t\t{[]float64{1, 2, 3, 4, 5}, func(v float64) bool { return v \u003e 2 }, 0, []int{}, nil},\n\t\t// k \u003e 0, sufficient elements\n\t\t{[]float64{1, 2, 3, 4, 5}, func(v float64) bool { return v \u003e 2 }, 2, []int{2, 3}, nil},\n\t\t// k \u003e 0, insufficient elements\n\t\t{[]float64{1, 2, 3, 4, 5}, func(v float64) bool { return v \u003e 2 }, 3, []int{2, 3, 4}, errors.New(\"floats: insufficient elements found\")},\n\t\t// Empty slice\n\t\t{[]float64{}, func(v float64) bool { return v \u003e 2 }, 2, []int{}, errors.New(\"floats: insufficient elements found\")},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgotId, gotErr := Find(nil, tc.f, tc.s, tc.k)\n\t\tif !errorEqual(gotErr, tc.wantErr) {\n\t\t\tt.Errorf(\"Test %d - Error mismatch. Got %v, want %v\", i, gotErr, tc.wantErr)\n\t\t}\n\t\tif !equalIntSlice(gotId, tc.wantId) {\n\t\t\tt.Errorf(\"Test %d - Slice mismatch. Got %v, want %v\", i, gotId, tc.wantId)\n\t\t}\n\t}\n}\n\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n\nfunc equalIntSlice(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d0618cf3772a1cbdb3f414697491934f": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantIndsC []int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:     \"k=0\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003c0\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0 all elements satisfy\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0 some elements satisfy\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0, k elements satisfy\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 1.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         3,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0 not enough elements satisfy\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 2.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{2},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsC: []int{1, 2, 3},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif !errors.Is(err, tc.wantErr) {\n\t\t\t\tt.Errorf(\"Got error %v, want %v\", err, tc.wantErr)\n\t\t\t}\n\t\t\tif len(got) != len(tc.wantInds) {\n\t\t\t\tt.Errorf(\"Got inds of length %d, want %d\", len(got), len(tc.wantInds))\n\t\t\t}\n\t\t\tfor i := range tc.wantInds {\n\t\t\t\tif got[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Errorf(\"Got inds[%d] = %d, want %d\", i, got[i], tc.wantInds[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check that the original slice was not modified.\n\t\t\tif len(tc.inds) != len(tc.wantIndsC) {\n\t\t\t\tt.Errorf(\"Input slice was modified: got length %d, want %d\", len(tc.inds), len(tc.wantIndsC))\n\t\t\t}\n\t\t\tfor i := range tc.wantIndsC {\n\t\t\t\tif tc.inds[i] != tc.wantIndsC[i] {\n\t\t\t\t\tt.Errorf(\"inds[%d] = %d, want %d\", i, tc.inds[i], tc.wantIndsC[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n}",
    "d1ae84045c77da5ac561a7f186238cb5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// n = 2\n\tif g, e := NearestIdxForSpan(2, 0, 1, 0.1), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, 0, 1, 0.9), 1; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, 1, 0, 0.1), 1; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, 1, 0, 0.9), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\t// n = 3\n\tif g, e := NearestIdxForSpan(3, 0, 1, 0.1), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(3, 0, 1, 0.4), 1; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(3, 0, 1, 0.6), 1; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(3, 0, 1, 0.9), 2; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\t// n = 4\n\tif g, e := NearestIdxForSpan(4, 0, 1, 0.1), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(4, 0, 1, 0.3), 1; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(4, 0, 1, 0.4), 1; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(4, 0, 1, 0.6), 2; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(4, 0, 1, 0.7), 2; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(4, 0, 1, 0.9), 3; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\n\t// Test cases with NaN\n\tif g, e := NearestIdxForSpan(2, 0, math.NaN(), 0.5), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, math.NaN(), 0, 0.5), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, math.NaN(), math.NaN(), 0.5), 0; g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\n\t// Test cases with Inf\n\tif g, e := NearestIdxForSpan(2, math.Inf(1), 0, math.Inf(1)); g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, 0, math.Inf(1), math.Inf(1)); g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, math.Inf(-1), 0, math.Inf(-1)); g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(2, 0, math.Inf(-1), math.Inf(-1)); g != e {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\n\t// Test cases with large n\n\tn := 1000000\n\tif g, e := NearestIdxForSpan(n, 0, 1, 0.25), 249999; math.Abs(float64(g)-float64(e)) \u003e tol {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n\tif g, e := NearestIdxForSpan(n, 0, 1, 0.75), 749999; math.Abs(float64(g)-float64(e)) \u003e tol {\n\t\tt.Errorf(\"Expected %v, got %v\", e, g)\n\t}\n}\n",
    "d1e51f3ebef2601345a50316d8222b28": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\t// Test cases: empty slice, slice with infinity, regular slices\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\twant  float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"Empty slice\",\n\t\t\ts:     []float64{},\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinity\",\n\t\t\ts:     []float64{math.Inf(1), 1, 2, 3},\n\t\t\twant:  math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Regular slice\",\n\t\t\ts:     []float64{1, 2, 3, 4},\n\t\t\twant:  4.440189655172412,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative numbers\",\n\t\t\ts:     []float64{-1, -2, -3, -4},\n\t\t\twant:  -0.5413248546129177,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tc.panic {\n\t\t\t\t\tif tc.panic {\n\t\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"The code paniced when it should not\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := LogSumExp(tc.s)\n\t\t\tif !tc.panic \u0026\u0026 !closeEnough(got, tc.want, 1e-10) {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}\n",
    "d21d94f17836ef34ef6e24fe8f5c1794": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases with varying numbers of slices and lengths.\n\ttestCases := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{nil, true},\n\t\t{[][]float64{{}}, true},\n\t\t{[][]float64{{1, 2, 3}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}}, true},\n\t\t{[][]float64{{1, 2}, {4, 5, 6}}, false},\n\t\t{[][]float64{{1, 2, 3}, {4, 5}}, false},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}}, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := EqualLengths(tc.slices...)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: EqualLengths(%v) == %v, want %v\", i, tc.slices, got, tc.want)\n\t\t}\n\t}\n}\n",
    "d2d4683e15ed6c7820e9cc788de1ae6c": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\tinds   []int\n\t\texpInd []int\n\t\texpErr error\n\t}\n\ttestCases := []testCase{\n\t\t// Error, k \u003e 0, not enough elements satisfying f\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      4,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{0, 1, 2},\n\t\t\texpErr: errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// k \u003e 0, exactly k elements satisfying f\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      3,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{0, 1, 2},\n\t\t\texpErr: nil,\n\t\t},\n\t\t// k \u003e 0, more than k elements satisfying f\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      2,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{0, 1},\n\t\t\texpErr: nil,\n\t\t},\n\t\t// k \u003c 0, some elements satisfying f\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 1 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      -1,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{1, 2},\n\t\t\texpErr: nil,\n\t\t},\n\t\t// k \u003c 0, all elements satisfying f\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 0 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      -1,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{0, 1, 2},\n\t\t\texpErr: nil,\n\t\t},\n\t\t// k \u003c 0, no elements satisfying f\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 10 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      -1,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{},\n\t\t\texpErr: nil,\n\t\t},\n\t\t// k == 0\n\t\t{\n\t\t\tf:      func(v float64) bool { return v \u003e 10 },\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tk:      0,\n\t\t\tinds:   make([]int, 10),\n\t\t\texpInd: []int{},\n\t\t\texpErr: nil,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\tif err != nil \u0026\u0026 tc.expErr == nil {\n\t\t\tt.Errorf(\"Case %d: unexpected error: %v\", i, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 tc.expErr != nil {\n\t\t\tt.Errorf(\"Case %d: expected error, got nil\", i)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 tc.expErr != nil \u0026\u0026 !errors.Is(err, tc.expErr) {\n\t\t\tt.Errorf(\"Case %d: unexpected error: %v, want %v\", i, err, tc.expErr)\n\t\t\tcontinue\n\t\t}\n\t\tif len(inds) != len(tc.expInd) {\n\t\t\tt.Errorf(\"Case %d: unexpected result length: %v, want %v\", i, len(inds), len(tc.expInd))\n\t\t\tcontinue\n\t\t}\n\t\tfor j, ind := range inds {\n\t\t\tif ind != tc.expInd[j] {\n\t\t\t\tt.Errorf(\"Case %d: unexpected index: %v at %d, want %v\", i, ind, j, tc.expInd[j])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "d3f731fcec5e030b686db890c77b0152": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, math.NaN(), 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(-1), 0},\n\t} {\n\t\thave := NearestIdx(test.s, test.v)\n\t\tif have != test.want {\n\t\t\tt.Errorf(\"Test %d: NearestIdx(%v, %v) = %v, want %v\", i, test.s, test.v, have, test.want)\n\t\t}\n\t}\n}",
    "d472e2d93552a6c0dda8754ae8121fc6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are NaN\n\t// - l or u is Inf\n\t// - Regular cases\n\n\t// len(dst) \u003c 2\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaN endpoints\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tfor i, v := range dst {\n\t\t\tif i == 0 {\n\t\t\t\tif v != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", v)\n\t\t\t\t}\n\t\t\t} else if !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"Inf endpoints\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i, v := range dst {\n\t\t\tif i == 2 {\n\t\t\t\tif v != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", v)\n\t\t\t\t}\n\t\t\t} else if i \u003c 2 {\n\t\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", v)\n\t\t\t\t}\n\t\t\t} else if !math.IsInf(v, -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf\n\tt.Run(\"Inf lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i, v := range dst {\n\t\t\tif i == 4 {\n\t\t\t\tif v != 1 {\n\t\t\t\t\tt.Errorf(\"Expected 1, got %v\", v)\n\t\t\t\t}\n\t\t\t} else if !math.IsInf(v, 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// u is Inf\n\tt.Run(\"Inf upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tfor i, v := range dst {\n\t\t\tif i == 0 {\n\t\t\t\tif v != 0 {\n\t\t\t\t\tt.Errorf(\"Expected 0, got %v\", v)\n\t\t\t\t}\n\t\t\t} else if !math.IsInf(v, 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Regular cases\n\tt.Run(\"Regular endpoints\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected[i], dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "d54d5f470d5f7010a1f68fb43aacbcd4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 1},\n\t\t{5, 0, 10, 7.5, 3},\n\t\t{5, 0, 10, -1, 0},\n\t\t{5, 0, 10, 11, 4},\n\n\t\t// Edge cases\n\t\t{2, 0, 10, 0, 0},\n\t\t{2, 0, 10, 10, 1},\n\t\t{3, 0, 10, 5, 1},\n\n\t\t// Reversed bounds\n\t\t{5, 10, 0, 2.5, 3},\n\t\t{5, 10, 0, 7.5, 1},\n\n\t\t// Infinite bounds\n\t\t{5, 0, math.Inf(1), 100, 4},\n\t\t{5, math.Inf(-1), 0, -100, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\n\t\t// NaN cases\n\t\t{5, 0, 10, math.NaN(), 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.i {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d\", i, tc.i, idx)\n\t\t}\n\t}\n}",
    "d54f36e019297f6ad65085cc8a881991": "package floats\n\nimport \"testing\"\n\nfunc TestEqualApprox(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1.1, 2, 3, 4}\n\ttol := 0.1\n\n\tif !EqualApprox(s1, s2, tol) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, %v) to be true\", s1, s2, tol)\n\t}\n\n\tif EqualApprox(s1, s3, tol) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, %v) to be false\", s1, s3, tol)\n\t}\n\n\tif !EqualApprox(s1, s4, tol) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, %v) to be true\", s1, s4, tol)\n\t}\n}",
    "d7391925b9ae35074c2ad1cdf8cee8b0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !Equal(s1, s2) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be true.\", s1, s2)\n\t}\n\n\tif Equal(s1, s3) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false.\", s1, s3)\n\t}\n\n\tif Equal(s1, s4) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false.\", s1, s4)\n\t}\n}",
    "d799b91a3bd21a0eb9863753a3943661": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Can't guarantee anything about exactly halfway\n\n\t\t// Cases with NaN and Inf\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 5, 4},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "d7b6ea6bd6829ec9f86229042aa6cc5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/floats/internal/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.1, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.9, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, i: 1},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.1, i: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.4, i: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, i: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.6, i: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.9, i: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, i: 2},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.1, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 0.9, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, i: 0},\n\n\t\t{n: 3, l: 1, u: 0, v: -1, i: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.1, i: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.4, i: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, i: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.6, i: 0},\n\t\t{n: 3, l: 1, u: 0, v: 0.9, i: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, i: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, i: 0},\n\n\t\t{n: 100, l: -1, u: 1, v: -1.1, i: 0},\n\t\t{n: 100, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 100, l: -1, u: 1, v: 0, i: 49},\n\t\t{n: 100, l: -1, u: 1, v: 1, i: 99},\n\t\t{n: 100, l: -1, u: 1, v: 1.1, i: 99},\n\n\t\t{n: 101, l: -1, u: 1, v: -1.1, i: 0},\n\t\t{n: 101, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 101, l: -1, u: 1, v: 0, i: 50},\n\t\t{n: 101, l: -1, u: 1, v: 1, i: 100},\n\t\t{n: 101, l: -1, u: 1, v: 1.1, i: 100},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d, l=%v, u=%v, v=%v: got index %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\t// NaN cases\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 1, v: 0, i: 1},\n\t\t{n: 3, l: math.NaN(), u: 1, v: 0, i: 1},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, i: 1},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 0, i: 1},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, i: 0},\n\t\t{n: 3, l: math.NaN(), u: math.NaN(), v: 0, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: math.NaN(), i: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.NaN(), i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d, l=%v, u=%v, v=%v: got index %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\n\t// Inf cases\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: 0, i: 2},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, i: 0},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 2},\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(1), i: 1},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(1), i: 2},\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(-1), i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d, l=%v, u=%v, v=%v: got index %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\n\t// Equal infs\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1), i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1), i: 2},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d, l=%v, u=%v, v=%v: got index %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"Did not panic with short span\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\n// BenchmarkNearestIdxForSpan benchmarks the NearestIdxForSpan function.\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\ts := Span(make([]float64, 100), 0, 1)\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tfloats.Dummy(NearestIdxForSpan(len(s), 0, 1, 0.5))\n\t}\n}\n",
    "d8099fc547bc3e0cba409e34e0be5d49": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2 should panic\n\t// - Regular cases with different lengths and bounds\n\t// - Special cases for Inf and NaN\n\n\t// len(dst) \u003c 2 should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Regular cases\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 1, 4, []float64{1, 2, 3, 4}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tfor j := range got {\n\t\t\tif got[j] != tc.want[j] {\n\t\t\t\tt.Errorf(\"Test case %d: got %v, want %v\", i, got, tc.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Special cases for Inf and NaN\n\tinfCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 0, math.NaN(), []float64{0, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), 0, []float64{math.Inf(-1), 0, 0}},\n\t}\n\tfor i, tc := range infCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tfor j := range got {\n\t\t\tif math.IsNaN(got[j]) \u0026\u0026 !math.IsNaN(tc.want[j]) {\n\t\t\t\tt.Errorf(\"Test case %d: got %v, want %v\", i, got, tc.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif !math.IsNaN(got[j]) \u0026\u0026 got[j] != tc.want[j] {\n\t\t\t\tt.Errorf(\"Test case %d: got %v, want %v\", i, got, tc.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}",
    "d91536c4291955fa1cb968ab179e0f7a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{5, -5, 5, 0, 2},\n\t\t{5, -5, 5, -6, 0},\n\t\t{5, -5, 5, 6, 4},\n\t\t{11, -5, 5, 0, 5},\n\t\t{11, -5, 5, -6, 0},\n\t\t{11, -5, 5, 6, 10},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, -1, 0, -0.5, 5},\n\t\t{10, -1, 0, -2, 0},\n\t\t{10, -1, 0, 1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for Inf and NaN.\n\tinfCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{10, math.Inf(1), 0, math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(-1), math.Inf(-1), 0},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t\t{10, math.NaN(), 0, 0, 9},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{11, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(-1), 10},\n\t}\n\n\tfor i, tc := range infCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tpanicCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 10, 5},\n\t\t{0, 0, 10, 5},\n\t\t{-1, 0, 10, 5},\n\t}\n\n\tfor i, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %f, %f, %f) did not panic\", i, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "d9c055ec104c56718a9f735546ef9f34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\n\t\t// Inf cases\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaN cases\n\t\t{10, math.NaN(), 1, 0, 0},\n\t\t{10, 0, math.NaN(), 1, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%f, u=%f, v=%f\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}\n",
    "db0efa97eac5aa38beace3d862c72995": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - math.IsNaN(v)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\t// - math.IsInf(l, 0)\n\t// - math.IsInf(u, 0)\n\t// - math.IsInf(v, -1)\n\t// - math.IsInf(v, 1)\n\t// - l \u003c u \u0026\u0026 v \u003c= l\n\t// - l \u003c u \u0026\u0026 v \u003e= u\n\t// - l \u003e u \u0026\u0026 v \u003e= l\n\t// - l \u003e u \u0026\u0026 v \u003c= u\n\t// - General cases\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, 0, 1, 0) did not panic\", n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t}\n\n\t// math.IsNaN(v)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tif got := NearestIdxForSpan(n, 0, 1, math.NaN()); got != 0 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, 0, 1, NaN) = %v, want 0\", n, got)\n\t\t}\n\t}\n\n\t// math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tif got := NearestIdxForSpan(n, math.NaN(), 1, 0.5); got != n-1 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, NaN, 1, 0.5) = %v, want %v\", n, got, n-1)\n\t\t}\n\t}\n\n\t// math.IsNaN(u)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tif got := NearestIdxForSpan(n, 0, math.NaN(), 0.5); got != 0 {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, 0, NaN, 0.5) = %v, want 0\", n, got)\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\tfor _, u := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\t\t\twant := 0\n\t\t\t\t\tif l == u {\n\t\t\t\t\t\twant = 0\n\t\t\t\t\t} else if n%2 == 1 {\n\t\t\t\t\t\tif !math.IsInf(v, 0) {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t} else if math.Copysign(1, v) == math.Copysign(1, l) {\n\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n/2 + 1\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif math.Copysign(1, v) == math.Copysign(1, l) {\n\t\t\t\t\t\t\twant = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twant = n / 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\t\twant := 0\n\t\t\t\tif v == l {\n\t\t\t\t\twant = 0\n\t\t\t\t} else {\n\t\t\t\t\twant = n - 1\n\t\t\t\t}\n\t\t\t\tif got := NearestIdxForSpan(n, l, 0, v); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, 0, %v) = %v, want %v\", n, l, v, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, u := range []float64{math.Inf(-1), math.Inf(1)} {\n\t\t\tfor _, v := range []float64{-1, 0, 1, math.Inf(-1), math.Inf(1)} {\n\t\t\t\twant := 0\n\t\t\t\tif v == u {\n\t\t\t\t\twant = n - 1\n\t\t\t\t} else {\n\t\t\t\t\twant = 0\n\t\t\t\t}\n\t\t\t\tif got := NearestIdxForSpan(n, 0, u, v); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, 0, %v, %v) = %v, want %v\", n, u, v, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(v, -1)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\twant := 0\n\t\t\t\tif l \u003c= u {\n\t\t\t\t\twant = 0\n\t\t\t\t} else {\n\t\t\t\t\twant = n - 1\n\t\t\t\t}\n\t\t\t\tif got := NearestIdxForSpan(n, l, u, math.Inf(-1)); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, -Inf) = %v, want %v\", n, l, u, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(v, 1)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{-1, 0, 1} {\n\t\t\t\twant := 0\n\t\t\t\tif u \u003c= l {\n\t\t\t\t\twant = 0\n\t\t\t\t} else {\n\t\t\t\t\twant = n - 1\n\t\t\t\t}\n\t\t\t\tif got := NearestIdxForSpan(n, l, u, math.Inf(1)); got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, Inf) = %v, want %v\", n, l, u, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003c u \u0026\u0026 v \u003c= l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l++ {\n\t\t\tfor u := l + 1; u \u003c 10; u++ {\n\t\t\t\tfor v := l - 1; v \u003c= l; v++ {\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != 0 {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want 0\", n, l, u, v, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003c u \u0026\u0026 v \u003e= u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l++ {\n\t\t\tfor u := l + 1; u \u003c 10; u++ {\n\t\t\t\tfor v := u; v \u003c= u+1; v++ {\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != n-1 {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", n, l, u, v, got, n-1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u \u0026\u0026 v \u003e= l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l++ {\n\t\t\tfor u := l - 1; u \u003e -10; u-- {\n\t\t\t\tfor v := l; v \u003c= l+1; v++ {\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != 0 {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want 0\", n, l, u, v, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u \u0026\u0026 v \u003c= u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l++ {\n\t\t\tfor u := l - 1; u \u003e -10; u-- {\n\t\t\t\tfor v := u - 1; v \u003c= u; v++ {\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != n-1 {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", n, l, u, v, got, n-1)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// General cases\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c 10; l++ {\n\t\t\tfor u := l + 1; u \u003c 10; u++ {\n\t\t\t\tfor v := l; v \u003c= u; v += (u - l) / 10 {\n\t\t\t\t\twant := int((float64(n)-1)/(u-l)*(v-l) + 0.5)\n\t\t\t\t\tif got := NearestIdxForSpan(n, l, u, v); got != want {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "dc0c51f114dd31f4e8df118530ca14e5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t\t{11, 0, 10, 5, 5},\n\t\t{11, 0, 10, -1, 0},\n\t\t{11, 0, 10, 11, 10},\n\t\t{11, 10, 0, 5, 6},\n\t\t{11, 10, 0, -1, 10},\n\t\t{11, 10, 0, 11, 0},\n\n\t\t// Test cases for Inf and NaN.\n\t\t{10, math.Inf(1), 0, 5, 0},\n\t\t{10, 0, math.Inf(1), 5, 9},\n\t\t{10, math.Inf(-1), 0, 5, 9},\n\t\t{10, 0, math.Inf(-1), 5, 0},\n\t\t{10, math.NaN(), 0, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 5, 0},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: got %v, want %v\", i, got, test.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}",
    "dc352efe1934cd3627e87fc74681474a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx function.\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: -1, // Expecting panic, so want is irrelevant\n\t\t},\n\t\t{\n\t\t\tname: \"Single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"All elements equal\",\n\t\t\ts:    []float64{2.0, 2.0, 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Maximum at beginning\",\n\t\t\ts:    []float64{5.0, 3.0, 1.0, 2.0, 4.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Maximum at end\",\n\t\t\ts:    []float64{1.0, 3.0, 4.0, 2.0, 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Maximum in middle\",\n\t\t\ts:    []float64{1.0, 3.0, 5.0, 2.0, 4.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple maximums\",\n\t\t\ts:    []float64{1.0, 5.0, 3.0, 5.0, 2.0, 4.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN in slice\",\n\t\t\ts:    []float64{1.0, 3.0, math.NaN(), 2.0, 5.0},\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.name == \"Empty slice\" {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"MaxIdx did not panic on an empty slice\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tt.Errorf(\"MaxIdx panicked unexpectedly: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MaxIdx(tc.s)\n\t\t\tif tc.name != \"Empty slice\" \u0026\u0026 got != tc.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "dcd2c202fca790496c6f66029cca00a0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with negative start and end values\n\t// - Slice with NaN start and end values\n\t// - Slice with Inf start and end values\n\n\t// Test case 1: Empty slice\n\tdst := []float64{}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 2: Slice with one element\n\tdst = []float64{0}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 3: Slice with two elements\n\tdst = make([]float64, 2)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 4: Slice with multiple elements\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpected = []float64{0, 0.25, 0.5, 0.75, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 5: Slice with negative start and end values\n\tdst = make([]float64, 5)\n\tSpan(dst, -1, 1)\n\texpected = []float64{-1, -0.5, 0, 0.5, 1}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 6: Slice with NaN start and end values\n\tdst = make([]float64, 5)\n\tSpan(dst, math.NaN(), 1)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, -1, math.NaN())\n\tif dst[0] != -1 {\n\t\tt.Errorf(\"Expected -1, got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\n\t// Test case 7: Slice with Inf start and end values\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), 1)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, -1, math.Inf(1))\n\tif dst[0] != -1 {\n\t\tt.Errorf(\"Expected -1, got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t}\n\t}\n\tif !math.IsInf(dst[len(dst)-1], -1) {\n\t\tt.Errorf(\"Expected -Inf, got %v\", dst[len(dst)-1])\n\t}\n}\n",
    "dcfe3ecfae6fa288d7bcd0d33508722c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{[]float64{0, 0}, -1, 1, []float64{-1, 1}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t\t{[]float64{0, 0}, 1, 0, []float64{1, 0}},\n\t\t{[]float64{0, 0, 0}, 1, 0, []float64{1, 0.5, 0}},\n\t\t{[]float64{0, 0, 0, 0}, 1, 0, []float64{1, 2.0 / 3.0, 1.0 / 3.0, 0}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 0, []float64{1, 0.75, 0.5, 0.25, 0}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tif !EqualApprox(have, test.want, tol) {\n\t\t\tt.Errorf(\"Test %d: Expected %v, got %v\\n\", i, test.want, have)\n\t\t}\n\t}\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 0, math.NaN(), []float64{0, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tfor j := range have {\n\t\t\tif math.IsNaN(test.want[j]) {\n\t\t\t\tif !math.IsNaN(have[j]) {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected NaN at position %d, got %v\\n\", i, j, have[j])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif have[j] != test.want[j] {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected %v at position %d, got %v\\n\", i, test.want[j], j, have[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, 0, math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), 0, []float64{math.Inf(-1), 0}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), 0, []float64{math.Inf(-1), 0, 0}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tfor j := range have {\n\t\t\tif math.IsInf(test.want[j], 0) {\n\t\t\t\tif !math.IsInf(have[j], 0) {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected Inf at position %d, got %v\\n\", i, j, have[j])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif have[j] != test.want[j] {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected %v at position %d, got %v\\n\", i, test.want[j], j, have[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}",
    "de0f41c026a90025ceeee7a8b47d9b51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: (n, l, u, v, expectedIndex)\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 1, 0.5, 2},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{5, 0, math.NaN(), 0.5, 0},\n\t\t{5, math.NaN(), 1, 0.5, 4},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, 0, math.Inf(1), 0.5, 0},\n\t\t{5, math.Inf(-1), 0, 0.5, 4},\n\n\t\t// Cases with l \u003e u\n\t\t{5, 1, 0, 0.5, 4},\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v, expected index %d, but got %d\",\n\t\t\t\ti+1, tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, actualIdx)\n\t\t}\n\t}\n}\n",
    "df7fb887ea18e4ff6789fa276836ed07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and/or u are NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsOnShortDst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and/or u are NaN\n\tt.Run(\"NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\n\t\tl = 1.0\n\t\tu = math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf with the same sign\n\tt.Run(\"BothInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\n\t\tl = math.Inf(-1)\n\t\tu = math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u is Inf\n\tt.Run(\"OneInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t}\n\n\t\tl = 1.0\n\t\tu = math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"EqualBounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 3.14\n\t\tu := 3.14\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != l {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", l, dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "e0511d81fad1093714fcf21a2a02a933": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\t// Test cases for Prod function\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 24},\n\t\t{[]float64{-1, 2, -3, 4}, 24},\n\t\t{[]float64{0, 2, 3, 4}, 0},\n\t\t{[]float64{}, 1},\n\t}\n\n\t// Iterate over the test cases and compare the expected output\n\t// with the actual output from the Prod function\n\tfor _, tc := range testCases {\n\t\tgot := Prod(tc.input)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Prod(%v) = %v, want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "e0de08f91bb8621093aea8a6f6895828": "package floats\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := rand.Intn(100)\n\t\tdst := make([]float64, n)\n\t\tfor j := range dst {\n\t\t\tdst[j] = rand.Float64()\n\t\t}\n\t\tinds := make([]int, n)\n\t\tArgsort(dst, inds)\n\t\tif !isSorted(dst) {\n\t\t\tt.Errorf(\"floats.Argsort() resulted in unsorted dst\")\n\t\t}\n\t\tif !permutation(inds, n) {\n\t\t\tt.Errorf(\"floats.Argsort() resulted in invalid inds\")\n\t\t}\n\t\tfor j := 0; j \u003c n; j++ {\n\t\t\tif dst[j] != dst[inds[j]] {\n\t\t\t\tt.Errorf(\"floats.Argsort() resulted in inconsistent dst and inds\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isSorted(s []float64) bool {\n\tfor i := 1; i \u003c len(s); i++ {\n\t\tif s[i-1] \u003e s[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc permutation(inds []int, n int) bool {\n\tif len(inds) != n {\n\t\treturn false\n\t}\n\tseen := make([]bool, n)\n\tfor _, i := range inds {\n\t\tif i \u003c 0 || i \u003e= n || seen[i] {\n\t\t\treturn false\n\t\t}\n\t\tseen[i] = true\n\t}\n\treturn true\n}\n",
    "e23f0499b54dde9b7d452678e119f319": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: (n, l, u, v, expectedIndex)\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 5, 5},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, 5, 0},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Case %d\", i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v, expected index %v, got %v\", tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}",
    "e25ace83e9153cf53faa9bc86e8579de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.3, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.7, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.3, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.7, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 10, l: 0, u: 1, v: 0.1, want: 1},\n\t\t{n: 10, l: 0, u: 1, v: 0.9, want: 9},\n\t\t{n: 10, l: 1, u: 0, v: 0.1, want: 8},\n\t\t{n: 10, l: 1, u: 0, v: 0.9, want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d mismatch. Want %v, got %v.\", i, tc.want, got)\n\t\t}\n\t}\n\t// Explicitly test the cases at positive and negative infinity.\n\tfor i, v := range []float64{-math.Inf(-1), -math.MaxFloat64, -math.MinFloat64,\n\t\t-2, -1, 0, 1, 2, math.MinFloat64, math.MaxFloat64, math.Inf(1)} {\n\t\tfor _, tc := range []struct {\n\t\t\tn int\n\t\t\tl float64\n\t\t\tu float64\n\t\t\twant int\n\t\t}{\n\t\t\t{n: 2, l: 0, u: 1, want: 0},\n\t\t\t{n: 2, l: 1, u: 0, want: 1},\n\t\t\t{n: 3, l: 0, u: 1, want: 0},\n\t\t\t{n: 3, l: 1, u: 0, want: 2},\n\t\t\t{n: 10, l: 0, u: 1, want: 0},\n\t\t\t{n: 10, l: 1, u: 0, want: 9},\n\t\t} {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Case %d mismatch at infinity. V = %v. Want %v, got %v.\",\n\t\t\t\t\ti, v, tc.want, got)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanNaN(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 1, want: 1},\n\t\t{n: 2, l: 0, u: math.NaN(), want: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), want: 0},\n\t\t{n: 3, l: math.NaN(), u: 1, want: 2},\n\t\t{n: 3, l: 0, u: math.NaN(), want: 0},\n\t\t{n: 3, l: math.NaN(), u: math.NaN(), want: 0},\n\t\t{n: 10, l: math.NaN(), u: 1, want: 9},\n\t\t{n: 10, l: 0, u: math.NaN(), want: 0},\n\t\t{n: 10, l: math.NaN(), u: math.NaN(), want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d mismatch. Want %v, got %v.\", i, tc.want, got)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1} {\n\t\ttest.Panic(t, \"NearestIdxForSpan\", func() {\n\t\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t\t})\n\t}\n}",
    "e36e2d6500656f6ab7d05eebfb5207f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"EmptySlice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaNValue\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"PositiveInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"NegativeInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"SingleElement\", args{[]float64{1}, 1}, 0},\n\t\t{\"MultipleElements\", args{[]float64{1, 2, 3, 4, 5}, 3.2}, 2},\n\t\t{\"MultipleElementsClosestToFirst\", args{[]float64{1, 2, 3, 4, 5}, 1.2}, 0},\n\t\t{\"MultipleElementsClosestToLast\", args{[]float64{1, 2, 3, 4, 5}, 4.8}, 4},\n\t\t{\"DuplicateValues\", args{[]float64{1, 2, 2, 3, 4, 5}, 2.1}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"EmptySlice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e3d4b6f7a4af707bc819ae7f7d99fff2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slice contents\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2, math.Sqrt(55)},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 1, 15},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 2, math.Sqrt(55)},\n\t\t{[]float64{-1, -2, -3, -4, -5}, math.Inf(1), 5},\n\t\t{[]float64{1, -2, 3, -4, 5}, 1, 15},\n\t\t{[]float64{1, -2, 3, -4, 5}, 2, math.Sqrt(55)},\n\t\t{[]float64{1, -2, 3, -4, 5}, math.Inf(1), 5},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the norm using the function being tested\n\t\tactual := Norm(tc.s, tc.L)\n\n\t\t// Check if the calculated norm matches the expected value\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "e3debfe533834eb7a925993f5da8abed": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"Empty\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: make([]int, 0),\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"One element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{42},\n\t\t\t\tinds: make([]int, 1),\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3, 1, 4, 2},\n\t\t\t\tinds: make([]int, 4),\n\t\t\t},\n\t\t\twant: []int{1, 3, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3, 1, 4, 1},\n\t\t\t\tinds: make([]int, 4),\n\t\t\t},\n\t\t\twant: []int{1, 3, 0, 2},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsort(tt.args.dst, tt.args.inds)\n\t\t\tif !reflect.DeepEqual(tt.args.inds, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", tt.args.inds, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e46741c04a2ae3e8fb5d63a0dfcf1389": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twant     int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1}, v: 0, wantPanic: true},\n\t\t{s: []float64{1, 2}, v: 0.5, want: 0},\n\t\t{s: []float64{1, 2}, v: 1, want: 0},\n\t\t{s: []float64{1, 2}, v: 1.5, want: 0},\n\t\t{s: []float64{1, 2}, v: 2, want: -1},\n\t\t{s: []float64{1, 2}, v: -1, want: -1},\n\t\t{s: []float64{1, 2, 3}, v: 2.5, want: 1},\n\t\t{s: []float64{1, 2, 3}, v: 1.5, want: 0},\n\t\t{s: []float64{-3, -2, -1}, v: -1.5, want: 1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -1.5, want: 1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -3, want: -1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: 3, want: -1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: 1e6, want: -1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: -1e6, want: -1},\n\t\t{s: []float64{-3, -2, -1, 0, 1, 2, 3}, v: math.NaN(), want: -1},\n\t\t{s: []float64{1, 2, math.NaN()}, v: 2, wantPanic: true},\n\t\t{s: []float64{1, math.NaN(), 2}, v: 2, wantPanic: true},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != test.wantPanic {\n\t\t\t\t\tt.Errorf(\"Test %d: input %v, got panic %v, want panic %v\", i, test.s, gotPanic, test.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Within(test.s, test.v)\n\t\t\tif !test.wantPanic \u0026\u0026 got != test.want {\n\t\t\t\tt.Errorf(\"Test %d: input %v, got %v, want %v\", i, test.s, got, test.want)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "e4b1a35bdcaef67e0246950a70f8a28b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various combinations of n, l, u, and v.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// Basic cases.\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Cases with NaN and Inf.\n\t\t{2, math.NaN(), 1, 0.5, 0},\n\t\t{2, 0, math.NaN(), 0.5, 1},\n\t\t{2, math.Inf(1), 1, 0.5, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), 1, 0.5, 1},\n\t\t{2, 0, math.Inf(-1), 0.5, 0},\n\n\t\t// Cases with v outside (l, u) and (u, l).\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 2, 1},\n\t\t{2, 1, 0, 2, 0},\n\t\t{2, 1, 0, -1, 1},\n\n\t\t// Cases with large n.\n\t\t{1000, 0, 1, 0.5, 500},\n\t\t{1000, 0, 1, 0.333, 333},\n\t\t{1000, 0, 1, 0.999, 999},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "e551b450b466d5af6639a408ad6d1cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with one element (should panic)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l or u is Inf\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 0)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\texpected := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 5)\n\t\texpected := []float64{0, 1, 2, 3, 4, 5}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 4, 0)\n\t\texpected := []float64{4, 3, 2, 1, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// u is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// u is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf, different signs\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tfor i := range dst[len(dst)/2:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "e56decab21bda765dea786add27026fb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\tn:    10,\n\t\t\tl:    -10,\n\t\t\tu:    0,\n\t\t\tv:    -5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds low\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds high\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite same sign\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign, odd n\",\n\t\t\tn:    11,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign, even n, v same sign as l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite opposite sign, even n, v opposite sign as l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound, finite upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"finite lower bound, infinite upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003e u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003c u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003e u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d, %v, %v, %v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\ttest.Panics(t, \"short span\", func() { NearestIdxForSpan(1, 0, 1, 0) })\n}\n",
    "e5e9fa216268e609baeb416605b77cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is the length of the hypothetical vector.\n\t// l is the lower bound of the hypothetical vector.\n\t// u is the upper bound of the hypothetical vector.\n\t// v is the value to search for.\n\t// want is the expected index.\n\tfor _, c := range []struct{ n int; l, u, v float64; want int }{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 2, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{10, 0, 1, 0.55, 6},\n\t\t{10, 0, 1, 0.0, 0},\n\t\t{10, 0, 1, 1.0, 9},\n\t\t{10, 1, 0, 0.5, 4},\n\t\t{10, 1, 0, 1.0, 0},\n\t\t{10, 1, 0, 0.0, 9},\n\t\t{10, -1, 1, 0.0, 5},\n\t\t{10, -1, 1, -1.0, 0},\n\t\t{10, -1, 1, 1.0, 9},\n\t\t{11, -1, 1, 0.0, 5},\n\t\t{11, -1, 1, -1.0, 0},\n\t\t{11, -1, 1, 1.0, 10},\n\t\t{2, 0, 0, 0, 0},\n\t\t{2, 1, 1, 1, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{3, 0, math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), 0, 0, 2},\n\t\t{3, 0, math.Inf(1), math.Inf(1), 2},\n\t\t{3, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{3, math.NaN(), 0, 0, 2},\n\t\t{3, 0, math.NaN(), 0, 0},\n\t\t{3, 0, 1, math.NaN(), 0},\n\t} {\n\t\tgot := NearestIdxForSpan(c.n, c.l, c.u, c.v)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", c.n, c.l, c.u, c.v, got, c.want)\n\t\t}\n\t}\n}",
    "e7908f6ba9246e52947f0c450542ee07": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty\", args{[]float64{}}, 1},\n\t\t{\"one\", args{[]float64{2}}, 2},\n\t\t{\"many\", args{[]float64{2, 3, 4}}, 24},\n\t\t{\"zero\", args{[]float64{2, 3, 0}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7de2bec59d8d297fc181da6f481f74b": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := i*10 + 1\n\t\tdst := make([]float64, n)\n\t\ty := make([]float64, n)\n\t\ts := make([]float64, n)\n\t\tfor j := range dst {\n\t\t\tdst[j] = rand.Float64()\n\t\t\ty[j] = rand.Float64()\n\t\t\ts[j] = rand.Float64()\n\t\t}\n\t\talpha := rand.Float64()\n\t\tAddScaledTo(dst, y, alpha, s)\n\t\tfor j := range dst {\n\t\t\tif dst[j] != y[j]+alpha*s[j] {\n\t\t\t\tt.Errorf(\"got %v, want %v\", dst[j], y[j]+alpha*s[j])\n\t\t\t}\n\t\t}\n\n\t\t// Test that it panics when the slice argument lengths do not match\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAddScaledTo(dst, y, alpha, make([]float64, n/2))\n\t\t}()\n\t}\n}\n",
    "e8244b76a457320d0ab3b95b58a6c2da": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with length 1 (should panic)\n\t// - Slice with length 2\n\t// - Slice with even length\n\t// - Slice with odd length\n\t// - Slice with NaN as lower bound\n\t// - Slice with NaN as upper bound\n\t// - Slice with Inf as lower bound\n\t// - Slice with Inf as upper bound\n\t// - Slice with both bounds as Inf\n\t// - Slice with both bounds as -Inf\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with length 1\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with slice length 1\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with length 2\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even length\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, 3)\n\t\texpected := []float64{0, 1, 2, 3}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd length\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\texpected := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with NaN as lower bound\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 4)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with NaN as upper bound\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf as lower bound\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 4)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf as upper bound\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with both bounds as Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with both bounds as -Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], -1) != math.IsInf(expected[i], -1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "e846085b6c4d3e90047c324e42424143": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{s: []float64{}, v: 1.2}, -1},\n\t\t{\"singleton\", args{s: []float64{1}, v: 1.2}, -1},\n\t\t{\"below\", args{s: []float64{1, 2}, v: -1}, -1},\n\t\t{\"above\", args{s: []float64{1, 2}, v: 3}, -1},\n\t\t{\"low\", args{s: []float64{1, 2}, v: 1}, 0},\n\t\t{\"high\", args{s: []float64{1, 2}, v: 1.5}, 0},\n\t\t{\"mid\", args{s: []float64{-1, 0, 1}, v: 0.5}, 1},\n\t\t{\"NaN\", args{s: []float64{1, 2}, v: math.NaN()}, -1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want != -1 {\n\t\t\t\t\t\tt.Errorf(\"Within() did panic, but shouldn't\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e84c735c076f2f8bd8d768404cfa6161": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, 3.14, 3},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Can't guarantee exact halfway\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 1e6, 9},\n\t\t{10, math.Inf(-1), 0, -1e6, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Case %d\", i+1), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v\\nExpected index %v, got %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eaffafaa2e0ca1f7561e224cb9d3208c": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}}, 1},\n\t\t{\"Single Element\", args{[]float64{2}}, 4},\n\t\t{\"Multiple Elements\", args{[]float64{2, 3, 4}}, 48},\n\t\t{\"Zero in Slice\", args{[]float64{2, 0, 4}}, 0},\n\t\t{\"Negative Elements\", args{[]float64{-2, 3, -4}}, 48},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2979221b37e0bc94da0f2b22cd5473": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{2, -1, 1}, []float64{5, 6, 0}, 2, 7.0710678118654755},\n\t\t{[]float64{2, -1, 1}, []float64{5, 6, 0}, 1, 10},\n\t\t{[]float64{2, -1, 1}, []float64{5, 6, 0}, math.Inf(1), 7},\n\t\t{[]float64{2, -1, 1}, []float64{5, 6, 0}, 0.5, 19.14213562373095},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 3, 7.368062997280774},\n\t}{\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbs(got, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}},\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}},\n\t}{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Case s = %v, t = %v: did not panic\", test.s, test.t)\n\t\t\t}\n\t\t}()\n\t\tDistance(test.s, test.t, 2)\n\t}\n}",
    "ed4c3249384c384098afcc70d1b2cbca": "package floats\n\nimport \"testing\"\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Single element slice\n\t// - Slice with positive numbers\n\t// - Slice with negative numbers\n\t// - Slice with mixed positive and negative numbers\n\t// - Slice with numbers that could cause significant floating-point error\n\n\ttestCases := []struct {\n\t\tname  string\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{\n\t\t\tname:  \"Empty slice\",\n\t\t\tinput: []float64{},\n\t\t\twant:  0.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Single element slice\",\n\t\t\tinput: []float64{1.0},\n\t\t\twant:  1.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Slice with positive numbers\",\n\t\t\tinput: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant:  15.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Slice with negative numbers\",\n\t\t\tinput: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\twant:  -15.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Slice with mixed positive and negative numbers\",\n\t\t\tinput: []float64{-1.0, 2.0, -3.0, 4.0, -5.0},\n\t\t\twant:  -3.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Slice with numbers that could cause significant floating-point error\",\n\t\t\tinput: []float64{1e10, 1.0, -1e10, 1.0},\n\t\t\twant:  2.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.input)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "edd6222fcf0881ddecd2e6230084c628": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l is Inf\n\t// - u is Inf\n\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"LIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"UIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"LandUAreInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 0) != math.IsInf(want[i], 0) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"LIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 0)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 0) != math.IsInf(want[i], 0) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"UIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 0) != math.IsInf(want[i], 0) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "ede839d8aa21a2a990793caf464a7fa3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, math.Inf(1), 5, 0},\n\t\t{10, math.Inf(-1), 0, 5, 9},\n\t\t{10, math.NaN(), 0, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\n\t\t// Cases with v outside (l, u)\n\t\t{10, 0, 10, -5, 0},\n\t\t{10, 0, 10, 15, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "ee11c775a2b30640658618f6276f10f9": "package floats\n\nimport \"testing\"\n\nfunc TestEqualApprox(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !EqualApprox(s1, s2, 1e-5) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-5) to be true\", s1, s2)\n\t}\n\n\tif EqualApprox(s1, s3, 1e-5) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-5) to be false\", s1, s3)\n\t}\n\n\tif EqualApprox(s1, s4, 1e-5) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-5) to be false\", s1, s4)\n\t}\n}",
    "eee73366a6b12e52db5a164b7574ac06": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tinds         []int\n\t\tf            func(float64) bool\n\t\ts            []float64\n\t\tk            int\n\t\twantInds     []int\n\t\twantErr      error\n\t\twantIndsNil bool\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(v float64) bool { return v \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tk:        0,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(v float64) bool { return v \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tk:        -1,\n\t\t\twantInds: []int{5, 6, 7, 8, 9},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(v float64) bool { return v \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tk:        2,\n\t\t\twantInds: []int{5, 6},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(v float64) bool { return v \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tk:        100,\n\t\t\twantInds: nil,\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tinds:         make([]int, 2),\n\t\t\tf:            func(v float64) bool { return v \u003e 5 },\n\t\t\ts:            []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tk:            2,\n\t\t\twantInds:     []int{5, 6},\n\t\t\twantErr:      nil,\n\t\t\twantIndsNil: true,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\tif !errorEqual(gotErr, tc.wantErr) {\n\t\t\tt.Errorf(\"Test %d - Error mismatch.  Want %v, got %v\", i, tc.wantErr, gotErr)\n\t\t}\n\t\tif !intSlicesAreEqual(gotInds, tc.wantInds) {\n\t\t\tt.Errorf(\"Test %d - Slice mismatch.  Want %v, got %v\", i, tc.wantInds, gotInds)\n\t\t}\n\t\tif tc.wantIndsNil \u0026\u0026 gotInds != nil {\n\t\t\tt.Errorf(\"Test %d - Wanted nil slice, got non-nil.\", i)\n\t\t}\n\t}\n}\n\nfunc intSlicesAreEqual(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(a); i++ {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc errorEqual(a, b error) bool {\n\tif a == nil || b == nil {\n\t\treturn a == b\n\t}\n\treturn a.Error() == b.Error()\n}",
    "ef173baae917f51659bbeea6f5a88278": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{0, 1, 2}, -1, -1},\n\t\t{[]float64{0, 1, 2}, 0, 0},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{0, 1, 2}, 2, -1},\n\t\t{[]float64{0, 1, 2}, 3, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1e11, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1e10, 0},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1.5, 0},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -1, 1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, -0.5, 1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 0, 2},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 0.5, 2},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1, 3},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1.5, 3},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1e10, -1},\n\t\t{[]float64{-1e10, -1, 0, 1, 1e10}, 1e11, -1},\n\t} {\n\t\thave := Within(test.s, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Test %d: Input s = %v, v = %v, got: %v, want: %v\",\n\t\t\t\ti, test.s, test.v, have, test.want)\n\t\t}\n\t}\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, -tol, 0},\n\t\t{[]float64{0, 1}, 1 - tol, 0},\n\t\t{[]float64{0, 1, 2}, -tol, 0},\n\t\t{[]float64{0, 1, 2}, 1 - tol, 0},\n\t\t{[]float64{0, 1, 2}, 2 - tol, 1},\n\t} {\n\t\thave := Within(test.s, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Test %d: Input s = %v, v = %v, got: %v, want: %v\",\n\t\t\t\ti, test.s, test.v, have, test.want)\n\t\t}\n\t}\n\n\t// NaN handling\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, math.NaN(), -1},\n\t\t{[]float64{math.NaN(), 1}, 0, -1},\n\t\t{[]float64{0, math.NaN()}, 1, -1},\n\t} {\n\t\thave := Within(test.s, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Test %d: Input s = %v, v = %v, got: %v, want: %v\",\n\t\t\t\ti, test.s, test.v, have, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{0}, 0)\n}\n\nfunc TestWithinSorted(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1, 0}, 0.5)\n}\n",
    "f000ba2650b7d541450f4670b4290607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with negative start and end values\n\t// - Slice with NaN start or end values\n\t// - Slice with Inf start or end values\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with slice with one element\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with negative start and end values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, -1, 1)\n\t\texpected := []float64{-1, -0.5, 0, 0.5, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with NaN start value\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with NaN end value\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf start value\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with Inf end value\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with both Inf start and end values\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], -1) != math.IsInf(expected[i], -1) || math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "f0b30df2d6d93e47dff67646e0ce6c10": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{10, 0, 1, 0.5, 5},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), 0, -5, 5},\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, -1},\n\n\t\t// Cases with v outside (l, u)\n\t\t{10, 0, 10, -5, 0},\n\t\t{10, 0, 10, 15, 9},\n\t\t{10, 10, 0, -5, 9},\n\t\t{10, 10, 0, 15, 0},\n\n\t\t// Cases with l == u\n\t\t{10, 5, 5, 2, 0},\n\t\t{10, 5, 5, 8, 0},\n\n\t\t// Cases with even and odd n and Inf\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(1), 10},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(f\"TestCase_%d\", func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n = %v, l = %v, u = %v, v = %v, expected index %v, got %v\", tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f15c3362d300b641bf4f7188dbe271b2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"SingleElement\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInfinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.want == nil {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic, want panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif tc.want == nil {\n\t\t\t\treturn // Skip checking output if panic expected\n\t\t\t}\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) returned slice with length %v, want %v\", tc.dst, tc.l, tc.u, len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want NaN\", tc.dst, tc.l, tc.u, i, got[i])\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f2c99ede0b70b8c7222aa22af27455ed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 2, 1, 0}, 3},\n\t\t{[]float64{1, math.NaN(), 0, 2}, 2},\n\t\t{[]float64{math.NaN(), 1, 0, 2}, 2},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: got %v, want %v\", i, got, test.want)\n\t\t}\n\t}\n}",
    "f2d0a4e0607696b81d0f7831b78f1a69": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tt.Run(\"LengthsMatch\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\texpected := []float64{4, 10, 18}\n\t\tactual := MulTo(dst, s, t)\n\t\tassert.Equal(t, expected, actual)\n\t})\n\n\tt.Run(\"EmptySlices\", func(t *testing.T) {\n\t\tdst := make([]float64, 0)\n\t\ts := []float64{}\n\t\tt := []float64{}\n\t\texpected := []float64{}\n\t\tactual := MulTo(dst, s, t)\n\t\tassert.Equal(t, expected, actual)\n\t})\n\n\tt.Run(\"PanicsOnDifferentLengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"MulTo should have panicked due to different lengths\")\n\t\t\t}\n\t\t}()\n\n\t\tdst := make([]float64, 2)\n\t\ts := []float64{1, 2}\n\t\tt := []float64{1, 2, 3}\n\t\tMulTo(dst, s, t)\n\t})\n\n\tt.Run(\"PanicsOnDstLengthMismatch\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"MulTo should have panicked due to dst length mismatch\")\n\t\t\t}\n\t\t}()\n\n\t\tdst := make([]float64, 2)\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{1, 2, 3}\n\t\tMulTo(dst, s, t)\n\t})\n}",
    "f2f791bd017a2c0391ee414f8e34deb6": "package floats\n\nimport \"testing\"\n\nfunc TestArgsort_Less(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.a.Less(tt.args.i, tt.args.j); got != tt.want {\n\t\t\t\tt.Errorf(\"argsort.Less() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4050e94ad42ab51bda296b51cea2843": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases with different lengths and bounds.\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 3, []float64{-1, 0, 1, 3}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 10, []float64{1, 3.25, 5.5, 7.75, 10}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases with NaN and Inf.\n\tnan := math.NaN()\n\tinf := math.Inf(1)\n\tnegInf := math.Inf(-1)\n\n\ttestCasesNaNInf := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, nan, 1, []float64{nan, 1}},\n\t\t{[]float64{0, 0}, 0, nan, []float64{0, nan}},\n\t\t{[]float64{0, 0, 0}, nan, 1, []float64{nan, nan, 1}},\n\t\t{[]float64{0, 0, 0}, 0, nan, []float64{0, nan, nan}},\n\t\t{[]float64{0, 0}, inf, inf, []float64{inf, inf}},\n\t\t{[]float64{0, 0, 0}, inf, inf, []float64{inf, inf, inf}},\n\t\t{[]float64{0, 0}, negInf, negInf, []float64{negInf, negInf}},\n\t\t{[]float64{0, 0, 0}, negInf, negInf, []float64{negInf, negInf, negInf}},\n\t\t{[]float64{0, 0}, inf, 0, []float64{inf, 0}},\n\t\t{[]float64{0, 0, 0}, inf, 0, []float64{inf, inf, 0}},\n\t\t{[]float64{0, 0}, 0, inf, []float64{0, inf}},\n\t\t{[]float64{0, 0, 0}, 0, inf, []float64{0, 0, inf}},\n\t}\n\n\tfor _, tc := range testCasesNaNInf {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t}\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}",
    "f51a1aaeae1dd7bf0c8e26f89b8b78ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    10,\n\t\t\twant: []float64{1, 1.93069772888325, 3.72759372031494, 7.20048993373859, 10},\n\t\t},\n\t\t{\n\t\t\tn:    3,\n\t\t\tl:    2,\n\t\t\tu:    5,\n\t\t\twant: []float64{2, 3.16227766016838, 5},\n\t\t},\n\t\t{\n\t\t\tn:    10,\n\t\t\tl:    0.1,\n\t\t\tu:    100,\n\t\t\twant: []float64{0.1, 0.215443469003188, 0.464158883361278, 1, 2.15443469003188, 4.64158883361278, 10, 21.5443469003188, 46.4158883361277, 100},\n\t\t},\n\t} {\n\t\tdst := make([]float64, test.n)\n\t\tgot := LogSpan(dst, test.l, test.u)\n\t\tif !testlapack.EqualApprox(got, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Test %d: unexpected result for LogSpan(%v,%v,%v): got:%v want:%v\", i, dst, test.l, test.u, got, test.want)\n\t\t}\n\t}\n}",
    "f5730e5037fa3baa3a7797e3cf5e3a11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1, 2, 3, 4}, wantIdx: 0},\n\t\t{s: []float64{4, 3, 2, 1}, wantIdx: 3},\n\t\t{s: []float64{1, 4, 2, 3}, wantIdx: 0},\n\t\t{s: []float64{1, 1, 1, 1}, wantIdx: 0},\n\t\t{s: []float64{1, 2, 1, 1}, wantIdx: 0},\n\t\t{s: []float64{math.NaN(), 2, 1, 1}, wantIdx: 2},\n\t\t{s: []float64{2, math.NaN(), 1, 1}, wantIdx: 2},\n\t\t{s: []float64{2, 2, math.NaN(), 1}, wantIdx: 3},\n\t\t{s: []float64{2, 2, 1, math.NaN()}, wantIdx: 2},\n\t\t{s: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()}, wantIdx: 0},\n\t\t{s: []float64{}, wantPanic: true},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != c.wantPanic {\n\t\t\t\t\tt.Errorf(\"Got panic=%v, want panic=%v\", gotPanic, c.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MinIdx(c.s)\n\t\t\tif gotIdx != c.wantIdx {\n\t\t\t\tt.Errorf(\"Got MinIdx=%v, want %v\", gotIdx, c.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n}",
    "f5bab763ada8fe7c36081efa09724629": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tfor i := 0; i \u003c 100; i++ {\n\t\tn := rand.Intn(1000)\n\t\tdst := make([]float64, n)\n\t\ts := make([]float64, n)\n\t\tfor j := range dst {\n\t\t\tdst[j] = rand.Float64()\n\t\t\ts[j] = rand.Float64()\n\t\t}\n\t\twant := make([]float64, n)\n\t\tfor j := range want {\n\t\t\twant[j] = dst[j] + s[j]\n\t\t}\n\t\tAdd(dst, s)\n\t\tfor j := range want {\n\t\t\tif dst[j] != want[j] {\n\t\t\t\tt.Errorf(\"Add() mismatch at index %d, got %v, want %v\", j, dst, want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Test that it panics when lengths don't match\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Add() did not panic when lengths don't match\")\n\t\t\t}\n\t\t}()\n\t\tAdd(dst, s[:n/2])\n\t}\n}",
    "f609d4620b7ad1d4e4f0ba7a78ef6ae8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various spans and values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{5, -1, 1, 0, 2},\n\t\t{7, 10, 20, 15, 3},\n\t\t{4, -10, -5, -7.5, 2},\n\t\t{11, -5, 5, -2.5, 3},\n\t\t{11, -5, 5, 2.5, 7},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\", i+1, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test cases for v outside of (l, u).\n\ttestCasesOutside := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 1.1, 9},\n\t\t{5, -1, 1, -2, 0},\n\t\t{5, -1, 1, 2, 4},\n\t}\n\n\tfor i, tc := range testCasesOutside {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case (outside) %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\", i+1, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test cases for special values: Inf, -Inf, NaN.\n\ttestCasesSpecial := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCasesSpecial {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case (special) %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\", i+1, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test case for panic when n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "f6c14f0baeb9d56eb54d29effcc34ad0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{0, 1}, -1e-9, -2},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 1.1, -2},\n\t\t{[]float64{0, 1, 2}, -1e-9, -2},\n\t\t{[]float64{0, 1, 2}, 0, 0},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{0, 1, 2}, 2, -1},\n\t\t{[]float64{0, 1, 2}, 2.1, -2},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -1.1, -2},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -1, 0},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -0.75, 0},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -0.5, 1},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -0.25, 1},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 0, 2},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 0.25, 2},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 0.5, 3},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 0.75, 3},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 1, -1},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 1.1, -2},\n\t} {\n\t\tgot := Within(c.s, c.v)\n\t\tif got != c.i {\n\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", c.s, c.v, got, c.i)\n\t\t}\n\t}\n}\n\nfunc TestWithinPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1}, 0)\n}\n\nfunc TestWithinPanicSorted(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1, 0}, 0)\n}\n\nfunc TestWithinNaN(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t}{\n\t\t{[]float64{0, 1}},\n\t\t{[]float64{0, 1, 2}},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}},\n\t} {\n\t\tgot := Within(c.s, math.NaN())\n\t\tif got != -2 {\n\t\t\tt.Errorf(\"Within(%v, NaN) = %v, want -2\", c.s, got)\n\t\t}\n\t}\n}\n",
    "f8164ef3c4d50b252e6a8135c40a0ab5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with a single element\n\t// - Slice with all elements equal\n\t// - Slice with positive and negative elements\n\t// - Slice with very large and very small elements (to test numerical stability)\n\n\t// Test case 1: Empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp([]float64{}) did not panic\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n\n\t// Test case 2: Slice with a single element\n\tgot := LogSumExp([]float64{1.0})\n\twant := 1.0\n\tif got != want {\n\t\tt.Errorf(\"LogSumExp([]float64{1.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 3: Slice with all elements equal\n\tgot = LogSumExp([]float64{2.0, 2.0, 2.0})\n\twant = math.Log(3) + 2.0\n\tif got != want {\n\t\tt.Errorf(\"LogSumExp([]float64{2.0, 2.0, 2.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 4: Slice with positive and negative elements\n\tgot = LogSumExp([]float64{1.0, -1.0, 2.0, -2.0})\n\twant = math.Log(math.Exp(1)+math.Exp(-1)+math.Exp(2)+math.Exp(-2))\n\tif math.Abs(got-want) \u003e 1e-10 {\n\t\tt.Errorf(\"LogSumExp([]float64{1.0, -1.0, 2.0, -2.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 5: Slice with very large and very small elements\n\tgot = LogSumExp([]float64{1000.0, -1000.0, 2000.0, -2000.0})\n\twant = 2000.0\n\tif math.IsInf(got, 0) || math.Abs(got-want) \u003e 1e-10 {\n\t\tt.Errorf(\"LogSumExp([]float64{1000.0, -1000.0, 2000.0, -2000.0}) = %v, want %v\", got, want)\n\t}\n}\n",
    "f8a59234d5fba12b9c07d35cf59640d8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\t// Test case 1: Unsorted array\n\tdst1 := []float64{3, 1, 4, 2}\n\tinds1 := make([]int, len(dst1))\n\tArgsort(dst1, inds1)\n\tif !reflect.DeepEqual(dst1, []float64{1, 2, 3, 4}) {\n\t\tt.Errorf(\"dst1 != []float64{1, 2, 3, 4}, dst1 = %v\", dst1)\n\t}\n\tif !reflect.DeepEqual(inds1, []int{1, 3, 0, 2}) {\n\t\tt.Errorf(\"inds1 != []int{1, 3, 0, 2}, inds1 = %v\", inds1)\n\t}\n\n\t// Test case 2: Sorted array\n\tdst2 := []float64{1, 2, 3, 4}\n\tinds2 := make([]int, len(dst2))\n\tArgsort(dst2, inds2)\n\tif !reflect.DeepEqual(dst2, []float64{1, 2, 3, 4}) {\n\t\tt.Errorf(\"dst2 != []float64{1, 2, 3, 4}, dst2 = %v\", dst2)\n\t}\n\tif !reflect.DeepEqual(inds2, []int{0, 1, 2, 3}) {\n\t\tt.Errorf(\"inds2 != []int{0, 1, 2, 3}, inds2 = %v\", inds2)\n\t}\n\n\t// Test case 3: Array with duplicates\n\tdst3 := []float64{2, 4, 1, 3, 2}\n\tinds3 := make([]int, len(dst3))\n\tArgsort(dst3, inds3)\n\tif !reflect.DeepEqual(dst3, []float64{1, 2, 2, 3, 4}) {\n\t\tt.Errorf(\"dst3 != []float64{1, 2, 2, 3, 4}, dst3 = %v\", dst3)\n\t}\n\t// Note: there are multiple valid inds3 arrays here due to the duplicates\n\t// We'll just check that it sorts correctly\n\tif !sort.IsSorted(sort.Float64Slice(dst3)) {\n\t\tt.Errorf(\"dst3 is not sorted, dst3 = %v\", dst3)\n\t}\n}",
    "fbcec84a399d16e857a04dd4101ba926": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l is Inf, u is regular\n\t// - l is regular, u is Inf\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := math.NaN()\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is Inf, u is regular\n\tt.Run(\"LInfURegular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is regular, u is Inf\n\tt.Run(\"LRegularUInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(1)\n\t\texpected := []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "fdddd85e91abddc251b9da767bee01fa": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt1 := []float64{4, 5, 6}\n\tAddTo(dst, s, t1)\n\tassert.Equal(t, []float64{5, 7, 9}, dst)\n}",
    "fe478ab38e642e30157bc134e5ad80b3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, -5, 5, 0, 5},\n\t\t{11, -5, 5, 0, 5},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{10, -5, 5, 2.5, 7},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, 1, 1, 1, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for Inf and NaN.\n\tinfCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, math.Inf(1), 0, 0, 1},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), 0, 0, 1},\n\t\t{2, 0, math.Inf(-1), 0, 0},\n\t\t{2, math.NaN(), 0, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 1},\n\t\t{2, math.NaN(), math.NaN(), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(-1), 2},\n\t}\n\n\tfor i, tc := range infCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for v outside (l, u) and (u, l).\n\toutOfRangeCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, 2, 0},\n\t\t{10, 1, 0, -1, 9},\n\t}\n\n\tfor i, tc := range outOfRangeCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tpanicCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 1, 0.5},\n\t\t{0, 0, 1, 0.5},\n\t\t{-1, 0, 1, 0.5},\n\t}\n\n\tfor i, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) did not panic\", i, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "fffbfad0db7ae393fa0704ea9b316d33": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.9,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    2.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"first element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"last element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4.1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"at upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound NaN, upper bound finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\tv:    3,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    1,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds NaN\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\tv:    1,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf, odd n, v finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf, even n, v finite\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf, odd n, v = +Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf, odd n, v = -Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf, even n, v = +Inf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds +Inf, even n, v = -Inf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound finite, upper bound +Inf, v equal to lower bound\",\n\t\t\tn:    5,\n\t\t\tl:    -2,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound finite, upper bound +Inf\",\n\t\t\tn:    5,\n\t\t\tl:    -2,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound +Inf, upper bound finite, v equal to upper bound\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    -2,\n\t\t\tv:    -2,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound +Inf, upper bound finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    -2,\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v = -Inf, increasing\",\n\t\t\tn:    5,\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v = -Inf, decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    2,\n\t\t\tu:    -2,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v = +Inf, increasing\",\n\t\t\tn:    5,\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v = +Inf, decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    2,\n\t\t\tu:    -2,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for v = %v: got: %d want: %d\", tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t}{\n\t\t{\n\t\t\tname: \"n = 0\",\n\t\t\tn:    0,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 1\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest.Panic(t, func() { NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v) })\n\t\t})\n\t}\n}\n"
}