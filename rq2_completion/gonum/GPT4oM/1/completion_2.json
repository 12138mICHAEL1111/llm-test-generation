{"0026966f482687b357882089f4e9ee0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, -5, -7.5, 2},\n\t\t{5, -10, -5, -10, 0},\n\t\t{5, -10, -5, -5, 4},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{5, 10, 0, 10, 0},\n\t\t{5, 10, 0, 0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","00ff8da04f0e838382a81a82fbe07efe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3-4-5 triangle\n\t\t{[]float64{1, 2, 2}, 2, 3}, // sqrt(1^2 + 2^2 + 2^2)\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for L = 0 (not defined, should use Count instead)\n\t\t{[]float64{1, 2, 3}, 0, 0}, // This is a special case, should not be used\n\n\t\t// Test cases for general L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)}, // (1^3 + 2^3 + 3^3)^(1/3)\n\t\t{[]float64{1, 2, 3}, 4, math.Pow(1+16+81, 1.0/4.0)}, // (1^4 + 2^4 + 3^4)^(1/4)\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif !floatEquals(got, tt.want) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc floatEquals(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","013e5ee407fb258d6a8c3fda98af7c6a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Basic span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Single element span\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on short dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinite lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinite upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Both bounds infinite\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tfor i, v := range result {\n\t\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","0215348bb87bbfbf266f19937ec2247e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{5.0, 6.0, 7.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{4.0, 4.0, 4.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10.0, 20.0, 30.0},\n\t\t\ts:        []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{9.0, 19.0, 29.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\t\tSub(dstCopy, test.s)\n\t\tfor i, v := range dstCopy {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Sub(%v, %v) = %v; expected %v\", test.dst, test.s, dstCopy, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths, but did not panic\")\n\t\t}\n\t}()\n\tSub([]float64{1.0, 2.0}, []float64{1.0})\n}","028e90cbce778d1961c87aa647c65dad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, -1, 0},       // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, 10, 0, 5, 2},        // Reversed bounds\n\t\t{5, 10, 0, 10, 0},       // Lower bound with reversed bounds\n\t\t{5, 10, 0, 0, 4},        // Upper bound with reversed bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 4}, // Inf bounds with value in range\n\t\t{5, math.Inf(-1), math.Inf(1), -1, 0}, // Inf bounds with value below range\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 4}, // Inf bounds with value above range\n\t\t{2, 0, 10, 5, 1},        // Edge case with n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","02c76544e44aa50c3890e81b07f8e90f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, should return 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity, should return index of max\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity, should return index of min\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 len(test.s) == 0 {\n\t\t\t\t\t// Expected panic for zero length slice\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","02d05743532d1daecf41e66d43e30cae":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},       // Closer to upper half\n\t\t{3, 1, 3, 2, 1},          // Small span\n\t\t{3, 1, 3, 1, 0},          // Small span at lower bound\n\t\t{3, 1, 3, 3, 2},          // Small span at upper bound\n\t\t{2, 1, 1, 1, 0},          // Edge case where l == u\n\t\t{2, 1, 1, 2, 1},          // Edge case where l == u, above\n\t\t{2, 1, 1, 0, 0},          // Edge case where l == u, below\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value for v\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","02dace20380755f8b679152b01cb1c37":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       1,\n\t\t\tu:       1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       2,\n\t\t\tu:       8,\n\t\t\texpected: []float64{2, 4, 6, 8},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 6),\n\t\t\tl:       -3,\n\t\t\tu:       3,\n\t\t\texpected: []float64{-3, -2, -1, 0, 1, 3},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       10,\n\t\t\tu:       math.NaN(),\n\t\t\texpected: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","02fbbeaf9207bbe077f089b5539b257d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t// Test case for L = 2\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t// Test case for L = math.Inf(1)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t// Test case for L = 0 (not a valid case, but testing behavior)\n\t\t{[]float64{1, 2, 3}, 0, math.NaN()},\n\t\t// Test case for negative values\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t// Test case for mixed values\n\t\t{[]float64{0, 0, 0}, 1, 0},\n\t\t// Test case for large values\n\t\t{[]float64{1e10, 2e10, 3e10}, 1, 6e10},\n\t\t// Test case for small values\n\t\t{[]float64{1e-10, 2e-10, 3e-10}, 1, 6e-10},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif math.IsNaN(tt.want) {\n\t\t\t\tif !math.IsNaN(got) {\n\t\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want NaN\", tt.slice, tt.L, got)\n\t\t\t\t}\n\t\t\t} else if got != tt.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0448c285f2fcbc79b86a5077593f1471":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","0481378a1b09214b71ea7267f94d33e1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0}, // All elements are the same\n\t\t{[]float64{2.0, 3.0, 1.0, 1.0}, 2}, // Multiple minimums, first occurrence\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1}, // NaN at the start\n\t\t{[]float64{2.0, math.NaN(), 3.0}, 0}, // NaN in the middle\n\t\t{[]float64{2.0, 3.0, math.NaN()}, 0}, // NaN at the end\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx([]) did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","049bf5e147c76a4cefac4edd03539ef1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.1, 2}, // Just above middle\n\t\t{5, 0, 10, 4.9, 2}, // Just below middle\n\t\t{5, 10, 0, 5, 2}, // Reversed bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t\t{2, 0, 10, 5, 1}, // Edge case with minimum n\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","0509e0638a4b45d441f01d4ba3e331eb":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttests := []struct {\n\t\tc        float64\n\t\tdst      []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tc:        2.0,\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{2.0, 4.0, 6.0},\n\t\t},\n\t\t{\n\t\t\tc:        0.0,\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tc:        -1.0,\n\t\t\tdst:      []float64{1.0, -2.0, 3.0},\n\t\t\texpected: []float64{-1.0, 2.0, -3.0},\n\t\t},\n\t\t{\n\t\t\tc:        1.5,\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tc:        3.0,\n\t\t\tdst:      []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tScale(test.c, test.dst)\n\t\tif !equalSlices(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Scale(%v, %v) = %v; want %v\", test.c, test.dst, test.dst, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","078c692d78e6f34adcf892727898b8a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    2,\n\t\t\tu:    8,\n\t\t\twant: []float64{2, 4, 6, 8},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    5,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equal(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","07a3669a4df39454690361c55d14ee12":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 3, 1},         // Closer to lower bound\n\t\t{5, 0, 10, 7, 3},         // Closer to upper bound\n\t\t{3, 0, 10, 5, 1},         // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},         // Edge case with reversed bounds\n\t\t{2, 0, 10, 5, 1},         // Edge case with n=2\n\t\t{2, 10, 0, 5, 1},         // Edge case with reversed bounds and n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value for v\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","082fe751a23930a68a019f44025e09cd":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","08367c21374f71c8896f648b0805835b":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","0843ef585b873a1a79ee4ad7a8360783":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 2.5, 1}, // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3}, // Closer to upper half\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2 at lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2 at upper bound\n\t\t{2, 0, 10, 15, 1}, // Edge case with n=2 above upper bound\n\t\t{2, 0, 10, -5, 0}, // Edge case with n=2 below lower bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","08d82e43185b5ac68d847ab24ea6f61b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse Inf bounds\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","092d969bdc8d331e1383b09ae960574d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t// Test case for L = 2\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t// Test case for L = math.Inf(1)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t// Test case for L = 3\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 2, 0},\n\t\t// Test case for L = 0 (not valid, but checking behavior)\n\t\t{[]float64{1, 2, 3}, 0, math.NaN()},\n\t\t// Test case for L \u003c 0 (not valid, but checking behavior)\n\t\t{[]float64{1, 2, 3}, -1, math.NaN()},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif math.IsNaN(tt.want) {\n\t\t\tif !math.IsNaN(got) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want NaN\", tt.slice, tt.L, got)\n\t\t\t}\n\t\t} else if got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","0a4296a1d29592be5b3cbae3eddad4e4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif !isEqual(v, test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{1}, 0, 1)\n}\n\nfunc isEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","0a81dba7d0fdfeb9b2ee90d5fffab1ef":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 10, 0, 5, 2},         // Reverse bounds\n\t\t{5, 10, 0, 10, 0},        // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},         // Reverse bounds, upper bound\n\t\t{5, 10, 0, 11, 0},        // Reverse bounds, above upper\n\t\t{5, 10, 0, -1, 4},        // Reverse bounds, below lower\n\t\t{3, 0, 10, 5, 1},         // Edge case with n=3\n\t\t{3, 0, 10, 0, 0},         // Edge case with n=3, lower bound\n\t\t{3, 0, 10, 10, 2},        // Edge case with n=3, upper bound\n\t\t{2, 0, 10, 5, 1},         // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},         // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1},        // Edge case with n=2, upper bound\n\t\t{2, 0, 10, -1, 0},        // Edge case with n=2, below lower\n\t\t{2, 0, 10, 11, 1},        // Edge case with n=2, above upper\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","0b097e9900feb8b9e641c792209cf25f":"// minidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice     []float64\n\t\texpected  int\n\t\texpectPanic bool\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1, false}, // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0, false}, // All elements are the same\n\t\t{[]float64{math.NaN(), 2.0, 1.0}, 2, false}, // NaN in the slice\n\t\t{[]float64{math.NaN(), math.NaN()}, 0, false}, // All elements are NaN\n\t\t{[]float64{2.0, 3.0, math.NaN()}, 0, false}, // NaN at the end\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2, false}, // Negative values\n\t\t{[]float64{}, 0, true}, // Panic case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not panic\", test.slice)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := MinIdx(test.slice)\n\t\tif !test.expectPanic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.slice, result, test.expected)\n\t\t}\n\t}\n}","0b471cefc5359254a2f629459fb3aade":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnan := math.NaN()\n\ttestsNaN := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        nan,\n\t\t\tu:        4,\n\t\t\texpected: []float64{nan, nan, nan, nan, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        nan,\n\t\t\texpected: []float64{0, nan, nan, nan, nan},\n\t\t},\n\t}\n\n\tfor _, test := range testsNaN {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif !isEqual(result[i], test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","0c3582a382574f253a9d3e2de6f04b2e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tslice1 []float64\n\t\tslice2 []float64\n\t\twant   bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, []float64{1.0, 2.0, math.NaN()}, true},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{math.NaN(), 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{math.NaN()}, []float64{math.NaN()}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{3.0, 2.0, 1.0}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.slice1, tt.slice2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.slice1, tt.slice2, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0cbfee12334c61b215b68e7039d3e04c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","0d144bb389e3e2f7fce75bb9ab4c36ba":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 10, 0, 5, 2},           // Reverse bounds\n\t\t{5, 10, 0, 10, 0},          // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},           // Reverse bounds, upper bound\n\t\t{5, 10, 0, -1, 4},          // Reverse bounds, below lower bound\n\t\t{5, 10, 0, 11, 0},          // Reverse bounds, above upper bound\n\t\t{3, 0, 10, 5, 1},           // Edge case with n=3\n\t\t{3, 0, 10, 0, 0},           // Edge case with n=3, lower bound\n\t\t{3, 0, 10, 10, 2},          // Edge case with n=3, upper bound\n\t\t{3, 0, 10, 11, 2},          // Edge case with n=3, above upper bound\n\t\t{3, 0, 10, -1, 0},          // Edge case with n=3, below lower bound\n\t\t{2, 0, 10, 5, 1},           // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},           // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1},          // Edge case with n=2, upper bound\n\t\t{2, 0, 10, 11, 1},          // Edge case with n=2, above upper bound\n\t\t{2, 0, 10, -1, 0},          // Edge case with n=2, below lower bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","0d37d4ebe8ea732945906d799178ed91":"// count_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"count positives\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"count negatives\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003c 0\n\t\t\t},\n\t\t\ts:        []float64{-1, -2, 0, 1, 2},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"count zeros\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x == 0\n\t\t\t},\n\t\t\ts:        []float64{0, 0, 1, 2, 3},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"count all\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"count none\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Count(tt.f, tt.s)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Count() = %d, expected %d\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0d38cf851eedbeb3bf60880a2ff1cb98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test cases for L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 1, 9, false},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 1, 0, false},\n\n\t\t// Test cases for L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 2, 0, false},\n\n\t\t// Test cases for infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, math.Inf(1), 3, false},\n\n\t\t// Test cases for general L-norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0), false},\n\t\t{[]float64{1, 2}, []float64{1, 2}, 3, 0, false},\n\n\t\t// Test case for panic due to length mismatch\n\t\t{[]float64{1, 2}, []float64{1}, 2, 0, true},\n\t\t{[]float64{1}, []float64{1, 2}, 2, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v with L=%v, but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","0e04172c6c2d5d231457bf49bbcc2001":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected NaN at index %d\", test.dst, test.l, test.u, result, i)\n\t\t\t\t}\n\t\t\t} else if result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v at index %d\", test.dst, test.l, test.u, result, test.expected[i], i)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when length of dst is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","0e9561493f6229f9472a0d33b0425509":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{5, 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        10,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range got {\n\t\t\tif math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tt.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif got[i] != tt.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","0f3a51095de34ca23f6513dd63718b5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{1, 3.1622776601683795, 10, 31.622776601683793, 100},\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        100,\n\t\t\texpected: []float64{0, 0, 0, 0, 100},\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\texpected: []float64{1, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 100},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        -100,\n\t\t\texpected: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Single element case\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := LogSpan(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(tt.expected[i]) {\n\t\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\t\tt.Errorf(\"expected NaN, got %v\", result[i])\n\t\t\t\t\t}\n\t\t\t\t} else if result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected[i], result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic, got none\")\n\t\t\t}\n\t\t}()\n\t\tLogSpan(make([]float64, 1), 1, 10)\n\t})\n}","0fd11dba8dbc082251b5cc7acfffe5cd":"// add_to_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, expected []float64\n\t}{\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\texpected: []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1, 1, 1},\n\t\t\ts:       []float64{1, 1, 1},\n\t\t\tt:       []float64{1, 1, 1},\n\t\t\texpected: []float64{3, 3, 3},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{math.NaN(), 2},\n\t\t\tt:       []float64{3, 4},\n\t\t\texpected: []float64{math.NaN(), 6},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := AddTo(test.dst, test.s, test.t)\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif result[i] != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddTo did not panic on length mismatch\")\n\t\t}\n\t}()\n\n\tAddTo([]float64{0}, []float64{1, 2}, []float64{3, 4})\n}","10520592a0f56f200f0a6b8fc4e6f903":"package floats\n\nimport (\n\t\"testing\"\n)\n\n// TestEqualFunc tests the EqualFunc function.\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tcomparator func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tcomparator: func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tcomparator: func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\tcomparator: func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\tcomparator: func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"One empty slice\",\n\t\t\ts1:       []float64{1.0},\n\t\t\ts2:       []float64{},\n\t\t\tcomparator: func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\ts1:       []float64{1.0, 2.0, float64(0) / float64(0)}, // NaN\n\t\t\ts2:       []float64{1.0, 2.0, float64(0) / float64(0)}, // NaN\n\t\t\tcomparator: func(a, b float64) bool { return (a != a \u0026\u0026 b != b) || a == b }, // Handle NaN\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.s1, tt.s2, tt.comparator)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v) = %v; want %v\", tt.s1, tt.s2, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","11f572eb365996ad3a7cf07e62825761":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t// Test case for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t// Test case for L = Inf (max absolute value)\n\t\t{[]float64{-1, -2, 3}, math.Inf(1), 3},\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t// Test case for L = 0 (not defined, should be handled)\n\t\t{[]float64{1, 2, 3}, 0, math.NaN()}, // Assuming you want to return NaN for undefined L\n\t\t// Test case for negative values\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t// Test case for L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t// Test case for L \u003c 1 (should still compute)\n\t\t{[]float64{1, 2, 3}, 0.5, math.Pow(6, 2)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif math.IsNaN(tt.want) {\n\t\t\tif !math.IsNaN(got) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want NaN\", tt.slice, tt.L, got)\n\t\t\t}\n\t\t} else if got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","1233b208bd7b9681685f0e7a71169e0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 1, 3, 2, 1},           // Edge case with 3 points\n\t\t{3, 1, 3, 1, 0},           // Edge case with 3 points at lower bound\n\t\t{3, 1, 3, 3, 2},           // Edge case with 3 points at upper bound\n\t\t{2, 1, 3, 2, 1},           // Edge case with 2 points\n\t\t{2, 1, 3, 1, 0},           // Edge case with 2 points at lower bound\n\t\t{2, 1, 3, 3, 1},           // Edge case with 2 points at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","128299297328105251c94c426bd401ac":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Between lower and middle\n\t\t{5, 0, 10, 7.5, 3},       // Between middle and upper\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Value at positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Value at negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","156e9026367d2431fbba36241809755c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v, but did not panic\", test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","16389cca552661e959b771ae10933bd1":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, should return 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity, should return index of max\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity, should return index of min\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 len(test.s) == 0 {\n\t\t\t\t\t// Expected panic for zero-length slice\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","16b961141bad023dbcab537e8956f070":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","175bec1e74ac88c0ebf6618319ad2aea":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tname:     \"Basic span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -4,\n\t\t\tu:        0,\n\t\t\texpected: []float64{-4, -3, -2, -1, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with same l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on short dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf to Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.panic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","178631791ebe40ac3e37a083dbafcaf0":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 10, 15},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 8, 12},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero slices\",\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tname:     \"length mismatch dst\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{5, 10, 15},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tname:     \"length mismatch s and t\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 10},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative result\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 1, 1},\n\t\t\tt:        []float64{2, 2, 2},\n\t\t\texpected: []float64{-1, -1, -1},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"%s: expected panic but did not get one\", tt.name)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := SubTo(tt.dst, tt.s, tt.t)\n\n\t\tif !tt.panic {\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"%s: expected %v, got %v\", tt.name, tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","17b48362ee126933a53c1a193c164509":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, y, s []float64\n\t\talpha     float64\n\t\texpected  []float64\n\t}{\n\t\t{\n\t\t\tdst:     []float64{1, 2, 3},\n\t\t\ty:       []float64{4, 5, 6},\n\t\t\ts:       []float64{1, 1, 1},\n\t\t\talpha:   2,\n\t\t\texpected: []float64{6, 7, 8}, // 4 + 2*1, 5 + 2*1, 6 + 2*1\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ty:       []float64{1, 2, 3},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\talpha:   1,\n\t\t\texpected: []float64{2, 4, 6}, // 1 + 1*1, 2 + 1*2, 3 + 1*3\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{10, 20, 30},\n\t\t\ty:       []float64{1, 2, 3},\n\t\t\ts:       []float64{0, 0, 0},\n\t\t\talpha:   5,\n\t\t\texpected: []float64{1, 2, 3}, // 1 + 5*0, 2 + 5*0, 3 + 5*0\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) = %v; want %v\", test.dst, test.y, test.alpha, test.s, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic due to length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length mismatch, but did not panic\")\n\t\t}\n\t}()\n\tAddScaledTo([]float64{1}, []float64{1, 2}, 1, []float64{1}) // dst and y lengths do not match\n}","1830f8f917008a5af3ab25c87b2ae2dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, 7.5, 3},        // Between middle and upper\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, -10, -5, -7.5, 2},     // Negative range\n\t\t{5, -10, -5, -11, 0},      // Below negative lower bound\n\t\t{5, -10, -5, -4, 4},       // Above negative upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity value\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","18f63684bb35c6121ee813332812b6fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1\n\t\t{slice: []float64{1, -2, 3}, L: 1, want: 6},\n\t\t// Test case for L = 2\n\t\t{slice: []float64{1, -2, 3}, L: 2, want: math.Sqrt(14)},\n\t\t// Test case for L = math.Inf(1)\n\t\t{slice: []float64{1, -2, 3}, L: math.Inf(1), want: 3},\n\t\t// Test case for empty slice\n\t\t{slice: []float64{}, L: 1, want: 0},\n\t\t// Test case for negative values\n\t\t{slice: []float64{-1, -2, -3}, L: 1, want: 6},\n\t\t// Test case for all zeros\n\t\t{slice: []float64{0, 0, 0}, L: 1, want: 0},\n\t\t// Test case for mixed values\n\t\t{slice: []float64{0, 2, -2, 3}, L: 2, want: math.Sqrt(17)},\n\t\t// Test case for L = 0 (not valid, but testing behavior)\n\t\t{slice: []float64{1, 2, 3}, L: 0, want: math.NaN()}, // Expect NaN for L=0\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif math.IsNaN(tt.want) {\n\t\t\t\tif !math.IsNaN(got) {\n\t\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want NaN\", tt.slice, tt.L, got)\n\t\t\t\t}\n\t\t\t} else if got != tt.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1968ed211494d5115fccc7fbe0d9b841":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v, dst=%v\", test.l, test.u, test.dst)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.panic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input l=%v, u=%v, dst=%v, expected %v, got %v\", test.l, test.u, test.dst, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","19b2aa9741f579897b5c9a00dec4d507":"// mul_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{2.0, 4.0, 6.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{2.0, 8.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0},\n\t\t\texpected: []float64{3.0, 8.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{2.0},\n\t\t\texpected: []float64{2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","1ad9c3bf09c1a9d8050c0ee5abf9560b":"// add_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tAdd(test.dst, test.s)\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.dst {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v, got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","1c4cb9f8a7e88f9578abe483cfc61f88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},         // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},         // Max at the start\n\t\t{[]float64{1.0, 3.0, 3.0}, 1},         // Max at the end\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1}, // Ignore NaN\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 0}, // Ignore NaN\n\t\t{[]float64{math.NaN(), math.NaN()}, 0}, // All NaN\n\t\t{[]float64{math.Inf(-1), math.Inf(1)}, 1}, // Negative and positive infinity\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},      // All negative values\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","1c5f72f2d5979de07ba7baa8000ca229":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        1,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","1ca3cc76bc3280f4036eb5e02262113a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 3, 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1, 1, 1, 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN handling\n\tdst := make([]float64, 5)\n\tresult := Span(dst, math.NaN(), 10)\n\tfor i := range result[:len(result)-1] {\n\t\tif !math.IsNaN(result[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tif result[len(result)-1] != 10 {\n\t\tt.Errorf(\"Expected last element to be 10, got %v\", result[len(result)-1])\n\t}\n\n\tresult = Span(dst, 0, math.NaN())\n\tfor i := range result[1:] {\n\t\tif !math.IsNaN(result[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i+1, result[i])\n\t\t}\n\t}\n\tif result[0] != 0 {\n\t\tt.Errorf(\"Expected first element to be 0, got %v\", result[0])\n\t}\n\n\t// Test Inf handling\n\tdst = make([]float64, 5)\n\tresult = Span(dst, math.Inf(-1), math.Inf(1))\n\tfor i := range result[:len(result)/2] {\n\t\tif result[i] != math.Inf(-1) {\n\t\t\tt.Errorf(\"Expected Inf(-1) at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tfor i := len(result) / 2; i \u003c len(result); i++ {\n\t\tif result[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected Inf(1) at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n}","1d6ce67971a15d6b9f8427cb2884ae20":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1e-10, 1e-10}, 1e10},\n\t\t{[]float64{1e-10, 1e10, 1e-10}, 1e10},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 4.0},\n\t\t{[]float64{-1.0, -1.0, -1.0, -1.0}, -4.0},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{1.0, math.NaN()}, math.NaN()},\n\t\t{[]float64{math.NaN(), math.NaN()}, math.NaN()},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected NaN\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","1fdd45a9c18c7c68f389281bb34338b8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 3}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 3}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower bound\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Positive value within bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 3}, // Positive value within bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Positive infinity\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed bounds\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","1fe92cb8cfb822ebbb0cb855c24a048d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Middle value\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closer to the first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closer to the last element\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Below the minimum\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Above the maximum\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Exact match\n\t\t{[]float64{1.0, 2.0, 2.0, 3.0}, 2.0, 1}, // Duplicate values\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 2.0, 1}, // NaN in the slice\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN as value\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, math.Inf(-1), 0}, // Negative infinity\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, math.Inf(1), 2}, // Positive infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif gotIdx := NearestIdx(tt.s, tt.v); gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","200507033a4953d93b579d69ed390e88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2}, // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0}, // Normal case\n\t\t{[]float64{1.0, 3.0, 3.0}, 1}, // First max case\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1}, // NaN ignored\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 2}, // NaN ignored\n\t\t{[]float64{math.NaN(), math.NaN(), 3.0}, 2}, // All NaN except last\n\t\t{[]float64{math.NaN(), math.NaN(), 1.0}, 2}, // All NaN except last\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, 0}, // All NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","20b1c7750ca546302f3faea997b5b38d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},       // Middle value\n\t\t{5, 0, 10, 0, 0},       // Lower bound\n\t\t{5, 0, 10, 10, 4},      // Upper bound\n\t\t{5, 0, 10, 7.5, 3},     // Between middle and upper\n\t\t{5, 0, 10, -1, 0},      // Below lower bound\n\t\t{5, 0, 10, 11, 4},      // Above upper bound\n\t\t{5, -10, 0, -5, 2},     // Negative range\n\t\t{5, -10, 0, -11, 0},    // Below negative lower bound\n\t\t{5, -10, 0, 1, 4},      // Above negative upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), -math.Inf(1), 0}, // Below Inf lower bound\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Above Inf upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","210f3b2cc25d3852c35a761e34477c91":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v, but did not panic\", test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","213b596d12483bcacb7cf3ba03419666":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // v is between s[1] and s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0}, // v is equal to s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v is equal to s[2] (out of range)\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v is greater than s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v is less than s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","226111ab2928dc905e44814f6f9015be":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t// Test case for L = 2\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t// Test case for L = math.Inf(1)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t// Test case for L = 3\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3)},\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 1, 1},\n\t\t// Test case for all zeros\n\t\t{[]float64{0, 0, 0}, 1, 0},\n\t\t// Test case for negative values\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t// Test case for mixed values\n\t\t{[]float64{-1, 2, -3}, 2, math.Sqrt(14)},\n\t\t// Test case for large values\n\t\t{[]float64{1e10, -1e10, 1e10}, 1, 3e10},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","22bd207af381f87686834da5d600c1ad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Middle value\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closer to first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closer to last element\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Below range\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Above range\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN value\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","252ed22fd9f5304c94adacddc06a1137":"// has_nan_test.go\npackage floats\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  bool\n\t}{\n\t\t{input: []float64{1.0, 2.0, 3.0}, want: false}, // No NaN\n\t\t{input: []float64{math.NaN(), 1.0, 2.0}, want: true}, // NaN present\n\t\t{input: []float64{1.0, math.NaN(), 3.0}, want: true}, // NaN present\n\t\t{input: []float64{math.NaN(), math.NaN()}, want: true}, // All NaN\n\t\t{input: []float64{}, want: false}, // Empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := HasNaN(test.input)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"HasNaN(%v) = %v; want %v\", test.input, got, test.want)\n\t\t}\n\t}\n}","253f0b1f1c4b549501d40eca15d5eced":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 1, 3, 2, 1},           // Edge case with 3 points\n\t\t{3, 1, 3, 1, 0},           // Edge case with 3 points at lower bound\n\t\t{3, 1, 3, 3, 2},           // Edge case with 3 points at upper bound\n\t\t{2, 1, 3, 2, 1},           // Edge case with 2 points\n\t\t{2, 1, 3, 1, 0},           // Edge case with 2 points at lower bound\n\t\t{2, 1, 3, 3, 1},           // Edge case with 2 points at upper bound\n\t\t{2, 1, 3, 2.5, 1},         // Edge case with 2 points in the middle\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %f, %f, %f), expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","25ce682804023f9a12509c8ac3f9216a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(0),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(0)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(0),\n\t\t\tu:        math.Inf(0),\n\t\t\texpected: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !equalSlices(result, tt.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, result, tt.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","26a35a13561a9794e4226386d82986f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test case for L1 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 1, expected: 9},\n\t\t// Test case for L2 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 2, expected: math.Sqrt(27)},\n\t\t// Test case for L-infinity norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: math.Inf(1), expected: 3},\n\t\t// Test case for L3 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 3, expected: math.Pow(27, 1.0/3.0)},\n\t\t// Test case for empty slices\n\t\t{s: []float64{}, t: []float64{}, L: 1, expected: 0},\n\t\t// Test case for mismatched lengths (should panic)\n\t\t{s: []float64{1, 2}, t: []float64{1}, L: 1, panic: true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","273f0a878b8e6f3562e9f28f044dc394":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"simple positive numbers\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple negative numbers\",\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0},\n\t\t\texpected: -6.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed numbers\",\n\t\t\tinput:    []float64{1.0, -1.0, 2.0, -2.0},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"large numbers\",\n\t\t\tinput:    []float64{1e10, 1e10, 1e10},\n\t\t\texpected: 3e10,\n\t\t},\n\t\t{\n\t\t\tname:     \"small numbers\",\n\t\t\tinput:    []float64{1e-10, 1e-10, 1e-10},\n\t\t\texpected: 3e-10,\n\t\t},\n\t\t{\n\t\t\tname:     \"zeros\",\n\t\t\tinput:    []float64{0.0, 0.0, 0.0},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{math.NaN(), 1.0, 2.0},\n\t\t\texpected: math.NaN(), // Expected output should be NaN\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity values\",\n\t\t\tinput:    []float64{math.Inf(1), 1.0, 2.0},\n\t\t\texpected: math.Inf(1), // Expected output should be +Inf\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity values\",\n\t\t\tinput:    []float64{math.Inf(-1), -1.0, -2.0},\n\t\t\texpected: math.Inf(-1), // Expected output should be -Inf\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.IsNaN(tt.expected) {\n\t\t\t\tif !math.IsNaN(result) {\n\t\t\t\t\tt.Errorf(\"expected NaN, got %v\", result)\n\t\t\t\t}\n\t\t\t} else if result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","275967bd3d165d6f5e107ac14d6101cc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Reverse bounds at lower\n\t\t{5, 10, 0, 0, 4}, // Reverse bounds at upper\n\t\t{5, 10, 0, 11, 0}, // Reverse bounds above upper\n\t\t{5, 10, 0, -1, 4}, // Reverse bounds below lower\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{3, 0, 10, 0, 0}, // Edge case with n=3 at lower\n\t\t{3, 0, 10, 10, 2}, // Edge case with n=3 at upper\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2 at lower\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2 at upper\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","27980de3e3145bbf91a6bce006ce4d0c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1},         // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0},         // All elements are the same\n\t\t{[]float64{math.NaN(), 2.0, 1.0}, 2}, // NaN should be ignored\n\t\t{[]float64{2.0, math.NaN(), 1.0}, 2}, // NaN in the middle\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 0}, // NaN at the end\n\t\t{[]float64{math.NaN(), math.NaN()}, 0}, // All NaN\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2},     // Negative values\n\t\t{[]float64{0.0, 0.0, 0.0}, 0},         // Zeros\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","2799b7f6d5b93f89992e821705bebff0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.1, 3}, // Just above middle\n\t\t{5, 0, 10, 4.9, 2}, // Just below middle\n\t\t{3, 1, 3, 2, 1}, // Edge case with n=3\n\t\t{10, -5, 5, 0, 5}, // Middle value with negative lower bound\n\t\t{10, -5, 5, -6, 0}, // Below lower bound with negative lower bound\n\t\t{10, -5, 5, 6, 9}, // Above upper bound with negative lower bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","28520fc1a5692c9c87d9da5daba3a32d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0}, // All elements are the same\n\t\t{[]float64{2.0, 3.0, 1.0, 1.0}, 2}, // Multiple minimums, first index should be returned\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2}, // Negative numbers\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1}, // NaN present, should ignore it\n\t\t{[]float64{math.NaN(), math.NaN(), 1.0}, 2}, // All NaNs except one\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","288f617c62576d3f1a88038094c17195":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Minimum is at index 1\n\t\t{[]float64{1.0, 1.0, 1.0}, 0}, // All elements are the same, first index\n\t\t{[]float64{2.0, 3.0, 1.0, 2.0}, 2}, // Minimum is at index 2\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1}, // Ignore NaN, minimum is at index 1\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 0}, // Ignore NaN, minimum is at index 0\n\t\t{[]float64{math.NaN(), math.NaN(), 3.0}, 2}, // Ignore NaNs, minimum is at index 2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","28ebcdc9ba99fb1af3edf4495a630a68":"// minidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0}, // All elements are the same\n\t\t{[]float64{math.NaN(), 2.0, 1.0}, 2}, // NaN present, minimum is at the end\n\t\t{[]float64{2.0, math.NaN(), 1.0}, 2}, // NaN in the middle\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 0}, // NaN at the end\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2}, // Negative numbers\n\t\t{[]float64{math.Inf(1), 1.0, 2.0}, 1}, // Positive infinity\n\t\t{[]float64{math.Inf(-1), -1.0, -2.0}, 2}, // Negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","28f9800a7a4182bbc7af30b587ca4260":"// norm_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\n\t\t// Test cases for L \u003c 1 (not defined in the function)\n\t\t{[]float64{1, 2, 3}, 0.5, math.Pow(14, 2)},\n\t\t{[]float64{-1, -2, -3}, 0.5, math.Pow(14, 2)},\n\t\t{[]float64{1, -2, 3}, 0.5, math.Pow(14, 2)},\n\t\t{[]float64{}, 0.5, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","29038392105c5bc234f760656fcb22e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2}, // Normal case\n\t\t{[]float64{3.0, 3.0, 3.0}, 0},           // All elements are the same\n\t\t{[]float64{1.0, 2.0, math.NaN(), 3.0}, 3}, // Ignore NaN\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 2},      // NaN at the start\n\t\t{[]float64{math.NaN(), math.NaN()}, 0},     // All NaN\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},           // Negative values\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","2912766f5fa08aadae1282284cedee38":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{5, 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        10,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","29321ecf0482984dd39ea3b7ce875e3b":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with negative values\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -4,\n\t\t\tu:        0,\n\t\t\texpected: []float64{-4, -3, -2, -1, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with equal bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with NaN at upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif !equal(result[i], tt.expected[i]) {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for dst length \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\nfunc equal(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","29360998acd13b342952710bb8afacf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","295ed50fd8578a673bb2e3fcc8350d9c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.Inf(1)},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{}, 0.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN for input %v, got %v\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %v, got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","29b9b1c0f0123acdc4bd5a5dcb577350":"// maxidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2}, // Normal case\n\t\t{[]float64{3.0, 3.0, 3.0}, 0},           // All elements are the same\n\t\t{[]float64{1.0, 2.0, math.NaN(), 3.0}, 3}, // NaN in the slice\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1},   // NaN at the start\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},        // All negative values\n\t\t{[]float64{0.0, 0.0, 0.0}, 0},           // All zeros\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","2a86c48c0b34e51f7e81c07ad226cfc8":"// subto_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, expected []float64\n\t\texpectPanic         bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 6, 7},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 4, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{5, 6},\n\t\t\tt:        []float64{1, 2},\n\t\t\texpected: []float64{4, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 6, 7},\n\t\t\tt:        []float64{1, 2},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{5, 6, 7},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: dst=%v, s=%v, t=%v\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := SubTo(test.dst, test.s, test.t)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"SubTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2adf7865b18d991dea53dc6df7a87df3":"// File: prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                  // Test with empty slice\n\t\t{[]float64{1, 2, 3}, 6},           // Test with positive numbers\n\t\t{[]float64{1, -2, 3}, -6},         // Test with a negative number\n\t\t{[]float64{-1, -2, -3}, -6},       // Test with all negative numbers\n\t\t{[]float64{0, 1, 2}, 0},           // Test with zero in the slice\n\t\t{[]float64{1.5, 2.0, 2.5}, 7.5},   // Test with decimal numbers\n\t\t{[]float64{1, 2, 0.5}, 1},         // Test with mixed integers and decimals\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2c01766532bd63aa2abc38cc94eb14e6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    2,\n\t\t\tu:    10,\n\t\t\twant: []float64{2, 4, 6, 10},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    5,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equal(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","2c0b11a375fc921998c1c9c945a1e821":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},       // Closer to upper half\n\t\t{3, 1, 3, 2, 1},          // Edge case with smaller n\n\t\t{3, 1, 3, 1, 0},          // Edge case with smaller n at lower bound\n\t\t{3, 1, 3, 3, 2},          // Edge case with smaller n at upper bound\n\t\t{2, 1, 3, 2, 1},          // Edge case with n = 2\n\t\t{2, 1, 3, 1, 0},          // Edge case with n = 2 at lower bound\n\t\t{2, 1, 3, 3, 1},          // Edge case with n = 2 at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value for v\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", got)\n\t}\n}","2d185405319948d8cbedc6a6a50ab7fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\tpanic     bool\n\t}{\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{4, 8, 12},\n\t\t\tt:       []float64{2, 4, 6},\n\t\t\texpected: []float64{2, 2, 2},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{10, 20, 30},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\texpected: []float64{10, 10, 10},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{0, 0},\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1)}, // Division by zero\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{0, 0},\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1)}, // Division by zero\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0},\n\t\t\ts:       []float64{1},\n\t\t\tt:       []float64{1},\n\t\t\texpected: []float64{1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{1},\n\t\t\texpected: nil, // Length mismatch\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0},\n\t\t\ts:       []float64{1},\n\t\t\tt:       []float64{1, 2},\n\t\t\texpected: nil, // Length mismatch\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, but did not panic\", test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := DivTo(test.dst, test.s, test.t)\n\n\t\tif !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"DivTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] \u0026\u0026 !(math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i])) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2d9592ac59a1a355ee03def9ab0094c3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 2}, // Middle value with inverted bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with inverted bounds\n\t\t{5, 10, 0, 0, 4}, // Upper bound with inverted bounds\n\t\t{5, 10, 0, -1, 4}, // Below lower bound with inverted bounds\n\t\t{5, 10, 0, 11, 0}, // Above upper bound with inverted bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v; expected %v\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value for v\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %v\", result)\n\t}\n}","2e64769798a5cc94d729f8d90e29adfd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tc        float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tc:        2,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{2, 4, 6},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\tc:        0,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2},\n\t\t\tc:        3,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: nil,\n\t\t\tpanic:    true, // Length mismatch\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\tc:        5,\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", test.dst, test.c, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := ScaleTo(test.dst, test.c, test.s)\n\n\t\tif !test.panic {\n\t\t\tif !equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) = %v; want %v\", test.dst, test.c, test.s, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 { // Allow for floating point precision issues\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2e8f04b46a7cc612ea38ffd806e2eb04":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","2f1a12d46d26c88d281ab17f5d43f813":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Nearest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Nearest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0}, // Nearest to 0.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0}, // Nearest to 1.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Nearest to 2.0 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Nearest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // NaN input should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // +Inf should return index of max value\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // -Inf should return index of min value\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","3089a094a99d51ef78034874e78c9a53":"// logsumexp_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Normal case\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))}, // Negative values\n\t\t{[]float64{0}, 0}, // Single zero\n\t\t{[]float64{math.Inf(1)}, math.Inf(1)}, // Positive infinity\n\t\t{[]float64{math.Inf(-1)}, math.Inf(-1)}, // Negative infinity\n\t\t{[]float64{math.NaN()}, math.NaN()}, // NaN case\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif math.IsNaN(result) \u0026\u0026 !math.IsNaN(test.expected) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = NaN, expected %v\", test.input, test.expected)\n\t\t} else if !math.IsNaN(result) \u0026\u0026 math.IsNaN(test.expected) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v, expected NaN\", test.input, result)\n\t\t} else if !math.IsNaN(result) \u0026\u0026 !math.IsNaN(test.expected) \u0026\u0026 !floatEquals(result, test.expected) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v, expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic for empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// floatEquals checks if two float64 values are approximately equal\nfunc floatEquals(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","30dee26f57fa90a8a53794231ce2c69e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // Single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0}, {2.0, 3.0}}, false}, // Two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true}, // Three slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Three slices with one different length\n\t\t{[][]float64{{}, {}, {}}, true}, // Multiple empty slices\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","310cb20bedefcc5ffc221258026fc89f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","315d479ff232fd65956f9b3da7e0e12b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},       // Middle value\n\t\t{5, 0, 10, 0, 0},       // Lower bound\n\t\t{5, 0, 10, 10, 4},      // Upper bound\n\t\t{5, 0, 10, 7.5, 3},     // Between middle and upper\n\t\t{5, 0, 10, -1, 0},      // Below lower bound\n\t\t{5, 0, 10, 11, 4},      // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Value in the middle\n\t\t{5, math.Inf(-1), math.Inf(1), -1, 0}, // Value below the range\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 2}, // Value in the middle\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","31da813b746c7eabd381b135198484d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 3, 1},         // Closer to lower bound\n\t\t{5, 0, 10, 7, 3},         // Closer to upper bound\n\t\t{5, 0, 10, 5.5, 2},       // Between middle and upper\n\t\t{5, 0, 10, 4.5, 1},       // Between middle and lower\n\t\t{3, 0, 10, 5, 1},         // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},         // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 0},         // Edge case with n=2\n\t\t{2, 10, 0, 5, 1},         // Edge case with inverted bounds and n=2\n\t\t{2, math.NaN(), 10, 5, 1}, // NaN lower bound\n\t\t{2, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1}, // Inverted Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","32bb0402b219e3687bbce36b83414407":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", test.s, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n\n\t// Test panic for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for empty slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{})\n}","345c9a3be0ead2a6bb443889e1480273":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        2,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        2,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{2, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","34830695dc149b4a5cc409e9b2a8f053":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1e-10, -1e10}, 0.0},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 4.0},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{[]float64{1.0, -1.0, 1.0, -1.0}, 0.0},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{math.Inf(1), 1.0}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), -1.0}, math.Inf(-1)},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN for input %v, got %v\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"Expected %v for input %v, got %v\", test.expected, test.input, result)\n\t\t}\n\t}\n}","34c0d99226cdf4b4227be15a1f145e68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 2.5, 1}, // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3}, // Closer to upper half\n\t\t{3, -1, 1, 0, 1}, // Edge case with negative bounds\n\t\t{3, -1, 1, -2, 0}, // Below negative bound\n\t\t{3, -1, 1, 2, 2}, // Above positive bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","34ff38c1847746783a7293319ecf85f8":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers with k \u003c 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first three even numbers, but only two exist\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find no elements with k = 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find no elements with empty slice\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","356d6aedd0b043c46f7fcf7e3ff1cbc9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\n\t\t// Test cases for negative values\n\t\t{[]float64{-1, -2, -3}, -1, 0}, // Invalid L, should handle gracefully\n\t\t{[]float64{1, 2, 3}, -2, 0},    // Invalid L, should handle gracefully\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","358cb99636fbb9e701ee9e0d5a0edac1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, 7.5, 3},        // Between lower and upper\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, -10, -5, -7.5, 2},     // Negative range\n\t\t{5, -10, -5, -10, 0},      // Lower bound negative\n\t\t{5, -10, -5, -5, 4},       // Upper bound negative\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf range\n\t\t{5, math.Inf(-1), math.Inf(1), -math.Inf(1), 0}, // Below Inf range\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Above Inf range\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v; want %v\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","35e4e0a40afe6a5e168783bb39d5cb1d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2}, // Closest to 3.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0}, // Closest to 1.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, should return 0\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, math.Inf(-1), 0}, // Closest to -Inf is at index 0\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, math.Inf(1), 2}, // Closest to +Inf is at index 2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","36b46310cb1e47d0cbd345cbb5e97feb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{3, 1, 2, 1.5, 1}, // Middle value with smaller n\n\t\t{3, 1, 2, 1, 0}, // Lower bound with smaller n\n\t\t{3, 1, 2, 2, 2}, // Upper bound with smaller n\n\t\t{3, 1, 2, 0.5, 0}, // Below lower bound with smaller n\n\t\t{3, 1, 2, 2.5, 2}, // Above upper bound with smaller n\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", result)\n\t}\n}","3777da618e67948fe1f0988381d359df":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.Inf(1)},\n\t\t{[]float64{math.SmallestNonzeroFloat64, math.SmallestNonzeroFloat64}, 2 * math.SmallestNonzeroFloat64},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif !floatEqual(result, test.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// floatEqual checks if two float64 values are approximately equal.\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-10\n\treturn math.Abs(a-b) \u003c epsilon\n}","382421897ddac293a7eaf5803663f8ba":"// sub_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{5.0, 6.0, 7.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{4.0, 4.0, 4.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10.0, 20.0},\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\texpected: []float64{9.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: []float64{0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tSub(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3843bad289f379e1a739b632988424fb":"// find_test.go\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements that are greater than 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements that are less than 0\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, -2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 elements that are even\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 0 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{0},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 1 element that is negative\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) || !equalErrors(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalErrors(a, b error) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a != nil \u0026\u0026 b != nil {\n\t\treturn a.Error() == b.Error()\n\t}\n\treturn false\n}","39db05dc4a24eb9227f51017d3d973fe":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity value\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Negative infinity value\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","3a76d4dd149871d67008d88252023be3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Minimum is at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0}, // Minimum is at index 0\n\t\t{[]float64{2.0, 2.0, 2.0}, 0}, // All values are the same, first index is returned\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1}, // NaN should be ignored, minimum is at index 1\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 0}, // NaN in the middle, minimum is at index 0\n\t\t{[]float64{math.NaN(), math.NaN(), 3.0}, 2}, // All NaNs except one, minimum is at index 2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","3adb71339e22f88f256492a10f5ad403":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.5, 3}, // Between middle and upper\n\t\t{5, 0, 10, 4.5, 2}, // Between middle and lower\n\t\t{3, 1, 2, 1.5, 1}, // Edge case with 3 points\n\t\t{2, 1, 2, 1.5, 0}, // Edge case with 2 points\n\t\t{2, 1, 2, 1, 0}, // Exact lower bound\n\t\t{2, 1, 2, 2, 1}, // Exact upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower bound\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Positive infinity upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v; expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","3bddc91a49dd0c307d9de0e1281590c7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnan := math.NaN()\n\tdst := make([]float64, 5)\n\n\t// l is NaN\n\tresult := Span(dst, nan, 5)\n\tfor i := 0; i \u003c len(result)-1; i++ {\n\t\tif !math.IsNaN(result[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tif result[len(result)-1] != 5 {\n\t\tt.Errorf(\"Expected last element to be 5, got %v\", result[len(result)-1])\n\t}\n\n\t// u is NaN\n\tresult = Span(dst, 0, nan)\n\tfor i := 1; i \u003c len(result); i++ {\n\t\tif !math.IsNaN(result[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tif result[0] != 0 {\n\t\tt.Errorf(\"Expected first element to be 0, got %v\", result[0])\n\t}\n\n\t// Test Inf cases\n\tdst = make([]float64, 5)\n\n\t// Both l and u are Inf\n\tresult = Span(dst, math.Inf(1), math.Inf(1))\n\tfor i := 0; i \u003c len(result); i++ {\n\t\tif result[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected Inf at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\n\t// l is Inf\n\tresult = Span(dst, math.Inf(1), 0)\n\tfor i := 0; i \u003c len(result)-1; i++ {\n\t\tif result[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected Inf at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tif result[len(result)-1] != 0 {\n\t\tt.Errorf(\"Expected last element to be 0, got %v\", result[len(result)-1])\n\t}\n\n\t// u is Inf\n\tresult = Span(dst, 0, math.Inf(1))\n\tfor i := 1; i \u003c len(result); i++ {\n\t\tif result[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected Inf at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tif result[0] != 0 {\n\t\tt.Errorf(\"Expected first element to be 0, got %v\", result[0])\n\t}\n}","3d239a05153f127756cc4206cf13ce2f":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, 1.0, -1e10},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, 1e-10, -1e10},\n\t\t\texpected: 1e-10,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.NaN(), 1.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 1.0},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(-1), -1.0},\n\t\t\texpected: math.Inf(-1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN for input %v, got %v\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %v, got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","3f1fcb2afc428a0210f30e3b742123c1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, -10, -5, -7.5, 2}, // Negative range\n\t\t{5, -10, -5, -10, 0}, // Lower bound negative\n\t\t{5, -10, -5, -5, 4}, // Upper bound negative\n\t\t{3, 1, 2, 1.5, 1}, // Edge case with 3 points\n\t\t{2, 1, 2, 1.5, 0}, // Edge case with 2 points\n\t\t{2, 1, 2, 1, 0}, // Exact lower bound with 2 points\n\t\t{2, 1, 2, 2, 1}, // Exact upper bound with 2 points\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","3fa7e3b95f5c707b1cf62da5c1bdb6f4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\ttests := []struct {\n\t\tc      float64\n\t\tdst    []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tc:      5,\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\texpect: []float64{6, 7, 8},\n\t\t},\n\t\t{\n\t\t\tc:      -3,\n\t\t\tdst:    []float64{4, 5, 6},\n\t\t\texpect: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tc:      0,\n\t\t\tdst:    []float64{10, 20, 30},\n\t\t\texpect: []float64{10, 20, 30},\n\t\t},\n\t\t{\n\t\t\tc:      2.5,\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\texpect: []float64{2.5, 2.5, 2.5},\n\t\t},\n\t\t{\n\t\t\tc:      1,\n\t\t\tdst:    []float64{-1, -2, -3},\n\t\t\texpect: []float64{0, -1, -2},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tAddConst(test.c, test.dst)\n\t\tfor i, v := range test.dst {\n\t\t\tif v != test.expect[i] {\n\t\t\t\tt.Errorf(\"AddConst(%v, %v) = %v; want %v\", test.c, test.dst, test.dst, test.expect)\n\t\t\t}\n\t\t}\n\t}\n}","402da2b0239a95cd0ad9382497c83698":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        8,\n\t\t\texpected: []float64{2, 4, 6, 8},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif !isEqual(v, test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc isEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","408bf5d6763678341e7519c97944b765":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","4171fcb628d4c71d3830d56fe113e994":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Reverse bounds, lower\n\t\t{5, 10, 0, 0, 4}, // Reverse bounds, upper\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Inf bounds, middle\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf bounds, upper\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Inf bounds, lower\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","425513ae8a69a98a714e8b3f95e333d2":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},      // Middle value\n\t\t{5, 0, 10, 0, 0},      // Lower bound\n\t\t{5, 0, 10, 10, 4},     // Upper bound\n\t\t{5, 0, 10, 7.5, 3},    // Between bounds\n\t\t{5, 0, 10, -1, 0},     // Below lower bound\n\t\t{5, 0, 10, 11, 4},     // Above upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Both bounds are infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Value is positive infinity\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // Upper bound NaN\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // Both bounds NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","4255a92f176f4d91698166bcd5e8c176":"// mul_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{2.0},\n\t\t\texpected: []float64{2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","427a068f7b9d98292d45ba8f0298d820":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","437c902372f0d98605b3971c25a238e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between two values\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","43b37766db5973e6b66d2f8e975f0b50":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements greater than 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements greater than 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        -1,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 elements greater than 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        3,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 5 elements greater than 0 (insufficient elements)\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        5,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 0 elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tif (err != nil) != (tt.err != nil) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t} else if err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","43da2b9b629e14fe67c3831d7c5be202":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reverse\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reverse\n\t\t{5, 10, 0, -1, 4}, // Below lower bound with reverse\n\t\t{5, 10, 0, 11, 0}, // Above upper bound with reverse\n\t\t{3, 1, 5, 3, 1}, // Edge case with n=3\n\t\t{3, 1, 5, 1, 0}, // Edge case with n=3 at lower bound\n\t\t{3, 1, 5, 5, 2}, // Edge case with n=3 at upper bound\n\t\t{2, 1, 5, 3, 1}, // Edge case with n=2\n\t\t{2, 1, 5, 1, 0}, // Edge case with n=2 at lower bound\n\t\t{2, 1, 5, 5, 1}, // Edge case with n=2 at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","448e96e64dc8a814b9196333c8e74a69":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, -10, 0, -5, 2}, // Negative range\n\t\t{5, -10, 0, -10, 0}, // Negative lower bound\n\t\t{5, -10, 0, 0, 4}, // Negative upper bound\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2 at lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2 at upper bound\n\t\t{2, 0, 10, 5.1, 1}, // Edge case with n=2 just above middle\n\t\t{2, 0, 10, -0.1, 0}, // Edge case with n=2 just below lower\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","44b252eb7d64662d0890dd69335bcff7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first k elements that are greater than 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements that are greater than 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not enough elements found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find zero elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find more elements than available\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tk:        5,\n\t\t\texpected: []int{0, 1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","4511cbb301b7d8bfcf0b0dedbc359aa4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, l: %v, u: %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","453441fed479c6b931c95d8e6a2dc624":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 3, 1}, // Closer to lower\n\t\t{5, 0, 10, 7, 3}, // Closer to upper\n\t\t{3, 1, 1, 1, 0}, // Edge case where l == u\n\t\t{3, 1, 1, 2, 2}, // Edge case where l == u, above\n\t\t{3, 1, 1, 0, 0}, // Edge case where l == u, below\n\t\t{2, 1, 3, 2, 1}, // Edge case with minimum n\n\t\t{2, 1, 3, 1, 0}, // Edge case with minimum n, at lower bound\n\t\t{2, 1, 3, 3, 1}, // Edge case with minimum n, at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","45a30c5828885a89ba83eb56d93bcb68":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},         // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},         // Closer to upper half\n\t\t{3, 0, 10, 5, 1},           // Odd number of points\n\t\t{4, 0, 10, 5, 1},           // Even number of points\n\t\t{5, math.NaN(), 10, 5, 4},  // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},   // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","4627622097568676db1c4bb86f0f6c45":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 10, 0, 5, 2},         // Reverse bounds\n\t\t{5, 10, 0, 10, 0},        // Reverse bounds at lower\n\t\t{5, 10, 0, 0, 4},         // Reverse bounds at upper\n\t\t{5, 10, 0, 5, 2},         // Middle value in reverse\n\t\t{3, 0, 10, 5, 1},         // Minimum valid n\n\t\t{3, 0, 10, 0, 0},         // Minimum valid n at lower bound\n\t\t{3, 0, 10, 10, 2},        // Minimum valid n at upper bound\n\t\t{2, 0, 10, 5, 1},         // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},         // Edge case with n=2 at lower bound\n\t\t{2, 0, 10, 10, 1},        // Edge case with n=2 at upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 4}, // Positive infinity upper\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","4779c1536b5e5170e27ec9a3d10c39ae":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCumProd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{1, 2, 6},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{0, 0, 0},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{5},\n\t\t\texpected: []float64{5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{1, 2},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tCumProd(test.dst, test.s)\n\t\tif !test.expectPanic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","47f60ea89af4f421e1d95c0dab96a75e":"// maxidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4}, // Maximum at the end\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0}, // Maximum at the start\n\t\t{[]float64{1.0, 3.0, 3.0, 2.0, 1.0}, 1}, // First maximum\n\t\t{[]float64{math.NaN(), 2.0, 3.0, math.NaN()}, 2}, // Ignore NaN values\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, 0}, // All NaN values\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := MaxIdx(test.input); got != test.expected {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", test.input, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","485f3f9430a5c1ee9fe363f2c8c5ca6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice   []float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0}, // All elements are the same\n\t\t{[]float64{2.0, 3.0, 1.0, 1.0}, 2}, // Multiple minimums, first occurrence\n\t\t{[]float64{math.NaN(), 2.0, 1.0}, 2}, // NaN should be ignored\n\t\t{[]float64{math.NaN(), math.NaN(), 1.0}, 2}, // All NaNs except one\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2}, // Negative numbers\n\t\t{[]float64{0.0, 0.0, 0.0}, 0}, // Zeros\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := MinIdx(tt.slice)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d; want %d\", tt.slice, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx([]) did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","4902acfcc99189c581fc8a8766675600":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{5, 0, 10, 5.1, 2},        // Just above middle\n\t\t{5, 0, 10, 4.9, 2},        // Just below middle\n\t\t{3, 0, 10, 5, 1},          // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},          // Edge case with reversed bounds\n\t\t{2, 0, 10, 5, 0},          // Edge case with n=2\n\t\t{2, 10, 0, 5, 0},          // Edge case with reversed bounds and n=2\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","498646d911c3405408999849c323ca03":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1 (Manhattan norm)\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t// Test case for L = 2 (Euclidean norm)\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t// Test case for L = 3\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t// Test case for L = math.Inf(1) (Max norm)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 2, 0},\n\t\t// Test case for L = 0 (should not be used, but included for completeness)\n\t\t{[]float64{1, 2, 3}, 0, 0}, // This case should be handled as per your requirements\n\t\t// Test case for L \u003c 0 (should not be used, but included for completeness)\n\t\t{[]float64{1, 2, 3}, -1, 0}, // This case should be handled as per your requirements\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","49ba2faa968d0b16296a65774ac0301a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},         // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},         // Closer to upper half\n\t\t{5, 10, 0, 5, 2},           // Reversed bounds\n\t\t{5, 10, 0, 10, 0},          // Reversed bounds, lower bound\n\t\t{5, 10, 0, 0, 4},           // Reversed bounds, upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4}, // Reversed Inf bounds\n\t\t{2, 0, 10, 5, 1},           // Edge case with n=2\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","49f1f6060a6fe1ef71ebca94b2d03f19":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower bound\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper bound\n\t\t{5, 0, 10, 5.1, 2},        // Just above middle\n\t\t{5, 0, 10, 4.9, 2},        // Just below middle\n\t\t{3, 0, 10, 5, 1},          // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},          // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 0},          // Edge case with n=2\n\t\t{2, 10, 0, 5, 1},          // Edge case with inverted bounds and n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","4a76c915a614c1a32e928870371d7c11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, -1, 0},       // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, 0, 10, 3.5, 1},      // Between lower and upper\n\t\t{5, 0, 10, 7.5, 3},      // Between lower and upper\n\t\t{3, 0, 10, 5, 1},        // Edge case with n=3\n\t\t{2, 0, 10, 5, 1},        // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},        // Edge case with n=2 at lower bound\n\t\t{2, 0, 10, 10, 1},       // Edge case with n=2 at upper bound\n\t\t{2, 0, 10, -1, 0},       // Edge case with n=2 below lower bound\n\t\t{2, 0, 10, 11, 1},       // Edge case with n=2 above upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","4b1a23c141eedc527eec4c3fbbbf89e3":"// subto_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t}{\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{5, 5, 5},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 3, 2},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{10, 20},\n\t\t\tt:       []float64{5, 15},\n\t\t\texpected: []float64{5, 5},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0, 0},\n\t\t\ts:       []float64{1, 2, 3, 4},\n\t\t\tt:       []float64{0, 0, 0, 0},\n\t\t\texpected: []float64{1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SubTo(test.dst, test.s, test.t)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"SubTo(%v, %v, %v) = %v; expected %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths, but did not panic\")\n\t\t}\n\t}()\n\tSubTo([]float64{0}, []float64{1, 2}, []float64{3, 4})\n}","4ba005c9cdfe22faa8fc506e95a25089":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, 7.5, 3},         // Between lower and upper\n\t\t{5, 10, 0, 5, 2},           // Reverse bounds\n\t\t{5, 10, 0, 10, 0},          // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},           // Reverse bounds, upper bound\n\t\t{5, 10, 0, 5.5, 3},         // Reverse bounds, between\n\t\t{3, 0, 1, 0.5, 1},          // Minimum valid n\n\t\t{3, 0, 1, 0, 0},            // Minimum valid n, lower bound\n\t\t{3, 0, 1, 1, 2},            // Minimum valid n, upper bound\n\t\t{3, 0, 1, 0.75, 1},         // Minimum valid n, between\n\t\t{2, 0, 1, 0.5, 1},          // Edge case with n=2\n\t\t{2, 0, 1, 0, 0},            // Edge case with n=2, lower bound\n\t\t{2, 0, 1, 1, 1},            // Edge case with n=2, upper bound\n\t\t{2, 0, 1, 0.25, 0},         // Edge case with n=2, between\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN input\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","4c6cdb436525f21ceeedad76790926b9":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // L2 norm\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3, // max absolute difference\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !almostEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic on mismatched lengths\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}\n\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","4cbcd075e4543798c309fb6ee26e85d1":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reverse\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reverse\n\t\t{5, 10, 0, -1, 4}, // Below lower bound with reverse\n\t\t{5, 10, 0, 11, 0}, // Above upper bound with reverse\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Inf bounds with value\n\t\t{5, math.Inf(-1), math.Inf(1), -1, 0}, // Inf bounds below\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 3}, // Inf bounds above\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","4e1af0d7b8ed5d716b99fd19e75c5557":"// add_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0, 5.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{0.0, 0.0, 0.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tAdd(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, v, test.dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","4eb979ccf40b8e4948c951fe71f3192c":"// mul_to_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\tpanic     bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tt:       []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:   false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\ts:       []float64{1.0, 2.0},\n\t\t\tt:       []float64{3.0, 4.0},\n\t\t\texpected: []float64{3.0, 8.0},\n\t\t\tpanic:   false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\ts:       []float64{1.0, 2.0},\n\t\t\tt:       []float64{3.0, 4.0},\n\t\t\texpected: nil,\n\t\t\tpanic:   true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\ts:       []float64{1.0},\n\t\t\tt:       []float64{2.0},\n\t\t\texpected: nil,\n\t\t\tpanic:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, but did not panic\", tt.s, tt.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := MulTo(tt.dst, tt.s, tt.t)\n\n\t\tif !tt.panic {\n\t\t\tif !equal(result, tt.expected) {\n\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) = %v; want %v\", tt.dst, tt.s, tt.t, result, tt.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","4ee2b8620a8d952f91ac91175e990d11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Between lower and middle\n\t\t{5, 0, 10, 7.5, 3},        // Between middle and upper\n\t\t{3, 1, 1, 1, 0},           // Edge case with equal bounds\n\t\t{3, 1, 1, 1.5, 0},         // Edge case with equal bounds and value above\n\t\t{3, 1, 1, 0.5, 2},         // Edge case with equal bounds and value below\n\t\t{2, 0, 1, 0.5, 0},         // Edge case with minimum n\n\t\t{2, 1, 2, 1.5, 0},         // Edge case with minimum n and bounds\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Edge case with infinities\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1}, // Edge case with reversed infinities\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","50a644966ebeb9b5f9f075ffe29701a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.panic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, %v, %v: expected %v, got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","50bf89e11cdfc6a5f67944e93b69ded7":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 3, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 even numbers, not enough found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        3,\n\t\t\texpected: []int{1},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 0 elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 1 element\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        1,\n\t\t\texpected: []int{2},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !equalSlices(inds, tt.expected) {\n\t\t\t\tt.Errorf(\"expected indices: %v, got: %v\", tt.expected, inds)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two slices of integers\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","5100393d9c20179d1f466df07560df26":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\talpha    float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\talpha:    2.0,\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{9.0, 12.0, 15.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\talpha:    1.0,\n\t\t\ts:        []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 1.0},\n\t\t\talpha:    0.5,\n\t\t\ts:        []float64{2.0, 2.0},\n\t\t\texpected: []float64{2.0, 2.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\t\tAddScaled(dstCopy, test.alpha, test.s)\n\n\t\tfor i, v := range dstCopy {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"AddScaled(%v, %v, %v) = %v; want %v\", test.dst, test.alpha, test.s, dstCopy, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddScaled did not panic for mismatched lengths\")\n\t\t}\n\t}()\n\tAddScaled([]float64{1.0}, 1.0, []float64{1.0, 2.0})\n}","513e0f7a072d293d0d8efdd905153883":"// subto_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 5, 5},\n\t\t\tt:        []float64{2, 2, 2},\n\t\t\texpected: []float64{3, 3, 3},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 1, 1},\n\t\t\texpected: []float64{0, 1, 2},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 1, 1},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{1, 1, 1},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v\", test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := SubTo(test.dst, test.s, test.t)\n\n\t\tif !test.panic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"SubTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","51de97e964a1fffb9b422eb59da5400d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{4, 8, 12},\n\t\t\ts:        []float64{2, 4, 6},\n\t\t\texpected: []float64{2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{1, 1, 1},\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10, 20, 30},\n\t\t\ts:        []float64{10, 5, 2},\n\t\t\texpected: []float64{1, 4, 15},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tDiv(test.dst, test.s)\n\t\tfor i, v := range test.dst {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Div(%v, %v) = %v; expected %v\", test.dst, test.s, test.dst, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths, but did not panic\")\n\t\t}\n\t}()\n\tDiv([]float64{1, 2}, []float64{1})\n\t\n\t// Test for division by zero\n\tdst := []float64{1, 2, 3}\n\ts := []float64{1, 0, 3}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for division by zero, but did not panic\")\n\t\t}\n\t}()\n\tDiv(dst, s)\n}","51e62d3003c1cef2b289488bb49642bc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 1, 5, 3, 1},           // Edge case with 3 points\n\t\t{3, 1, 5, 1, 0},           // Edge case with 3 points at lower bound\n\t\t{3, 1, 5, 5, 2},           // Edge case with 3 points at upper bound\n\t\t{2, 1, 5, 3, 1},           // Edge case with 2 points\n\t\t{2, 1, 5, 1, 0},           // Edge case with 2 points at lower bound\n\t\t{2, 1, 5, 5, 1},           // Edge case with 2 points at upper bound\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Edge case with infinities\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1}, // Edge case with inverted infinities\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v: expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","51e6755e7f508768bca93b584325caa1":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 10, 0, 5, 2},          // Reverse bounds\n\t\t{5, 10, 0, 10, 0},         // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},          // Reverse bounds, upper bound\n\t\t{5, 10, 0, 5.5, 2},        // Reverse bounds, middle value\n\t\t{3, 0, 10, 5, 1},          // Edge case with n=3\n\t\t{2, 0, 10, 5, 1},          // Edge case with n=2\n\t\t{2, 10, 0, 5, 1},          // Edge case with reverse bounds and n=2\n\t\t{2, 0, 0, 0, 0},           // Edge case with equal bounds\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Edge case with infinities\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1}, // Edge case with reverse infinities\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","51f37ea8b340d88b86dd6365594f823f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Normal case\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))}, // Negative values\n\t\t{[]float64{0, 0, 0}, 0}, // All zeros\n\t\t{[]float64{math.Inf(1), 1, 2}, math.Inf(1)}, // Positive infinity\n\t\t{[]float64{math.Inf(-1), -1, -2}, math.Inf(-1)}, // Negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif !almostEqual(result, test.expected) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic on empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic on empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// almostEqual checks if two float64 values are approximately equal\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","535e683dd7462e2c87fae6b37215e513":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts, t     []float64\n\t\tL        float64\n\t\texpected float64\n\t\texpectPanic bool\n\t}{\n\t\t// Test case: Normal case with L = 1\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t// Test case: Normal case with L = 2\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t// Test case: Normal case with L = Inf\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t// Test case: Edge case with empty slices\n\t\t{[]float64{}, []float64{}, 1, 0, false},\n\t\t// Test case: Mismatched lengths (should panic)\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t\t// Test case: Mismatched lengths (should panic)\n\t\t{[]float64{1}, []float64{1, 2}, 1, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.expectPanic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","54cf5f7fc12931717650aaf61a9e1990":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 0, 10, 5, 1},          // Edge case with 3 points\n\t\t{3, 10, 0, 5, 1},          // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 1},          // Edge case with 2 points\n\t\t{2, 10, 0, 5, 1},          // Edge case with inverted bounds and 2 points\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower bound\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 4}, // Positive infinity upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity value\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Inverted infinities\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v: expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","5510c4a37a65894d6414bbbb693794cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 5.5, 3},        // Between middle and upper\n\t\t{5, 0, 10, 4.5, 2},        // Between middle and lower\n\t\t{3, 0, 10, 5, 1},          // Edge case with 3 points\n\t\t{3, 10, 0, 5, 1},          // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 0},          // Edge case with 2 points\n\t\t{2, 10, 0, 5, 1},          // Edge case with inverted bounds and 2 points\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Edge case with infinities\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1}, // Edge case with inverted infinities\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), math.NaN(), 0}, // NaN value\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","553492048d9a895e0c7a6480f8a52aa9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","557c377cf77cfee5862a9c9ac824624d":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e10, 1e10, 1e10}, 3e10},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{[]float64{1.0, -1.0, 1.0, -1.0}, 0.0},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()}, // Edge case: NaN present\n\t\t{[]float64{math.Inf(1), 1.0}, math.Inf(1)}, // Edge case: positive infinity\n\t\t{[]float64{math.Inf(-1), -1.0}, math.Inf(-1)}, // Edge case: negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif !equalFloat(result, test.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc equalFloat(a, b float64) bool {\n\treturn math.IsNaN(a) \u0026\u0026 math.IsNaN(b) || math.Abs(a-b) \u003c 1e-9\n}","566741d6f8a87aed21ab7e8ff5149d73":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 1}, // Below lower bound\n\t\t{5, 0, 10, 11, 3}, // Above upper bound\n\t\t{5, 0, 10, 2.5, 1}, // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3}, // Closer to upper half\n\t\t{3, 0, 10, 5, 1}, // Edge case with 3 points\n\t\t{3, 10, 0, 5, 1}, // Reverse bounds\n\t\t{2, 0, 10, 5, 0}, // Edge case with 2 points\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","585b7ac09a3b8d7ae48ddfa3fb2ed341":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(0),\n\t\t\twant: []float64{math.Inf(1), 0, math.NaN(), 0, math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(0),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(0),\n\t\t\twant: []float64{0, 0, 0, 0, math.Inf(0)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","58c241954b2664727c41d7721efab838":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0},\n\t\t\texpected: []float64{4.0, 6.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tAdd(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.dst {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v, got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","596038e104a8cfd0669b4e0ae9d834d2":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 3, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 even numbers, not enough found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 3, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{0, 0}, // should return empty slice and error\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 0 elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 1 element, found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{2},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 1 element, not found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{0, 0}, // should return empty slice and error\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","59cfb0df3d116931d8ef233f5c4d4ba1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        10,\n\t\t\texpected: []float64{5, 10},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN handling\n\tdst := make([]float64, 5)\n\tresult := Span(dst, math.NaN(), 5)\n\tfor i := range result[:len(result)-1] {\n\t\tif !math.IsNaN(result[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tif result[len(result)-1] != 5 {\n\t\tt.Errorf(\"Expected last element to be 5, got %v\", result[len(result)-1])\n\t}\n\n\tresult = Span(dst, 0, math.NaN())\n\tfor i := range result[1:] {\n\t\tif !math.IsNaN(result[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i+1, result[i])\n\t\t}\n\t}\n\tif result[0] != 0 {\n\t\tt.Errorf(\"Expected first element to be 0, got %v\", result[0])\n\t}\n\n\t// Test Inf handling\n\tdst = make([]float64, 5)\n\tresult = Span(dst, math.Inf(-1), math.Inf(1))\n\tfor i := range result[:len(result)/2] {\n\t\tif result[i] != math.Inf(-1) {\n\t\t\tt.Errorf(\"Expected Inf(-1) at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n\tfor i := len(result) / 2; i \u003c len(result); i++ {\n\t\tif result[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected Inf(1) at index %d, got %v\", i, result[i])\n\t\t}\n\t}\n}","59e9807e410b3b1e42476d1626350de1":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{-10, -5, 0, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        15,\n\t\t\texpected: []float64{5, 15},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc TestSpanSpecialCases(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","5a067b714f12586ffcf7e6ed3a76e094":"// minidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Minimum is at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0}, // Minimum is at index 0\n\t\t{[]float64{2.0, 2.0, 2.0}, 0}, // All elements are the same, first index is returned\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1}, // NaN is ignored, minimum is at index 1\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 0}, // NaN is ignored, minimum is at index 0\n\t\t{[]float64{math.NaN(), math.NaN(), 1.0}, 2}, // NaNs ignored, minimum is at index 2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","5aa15949cd7c6551c734080cf1d8b245":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0}, 1.0)\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0}, 2.0)\n}","5cab14684e3236374aff22310a463d29":"// maxidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},             // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},             // Maximum at the start\n\t\t{[]float64{1.0, 3.0, 3.0}, 1},             // Multiple max values, first occurrence\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},     // NaN should be ignored\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 2},     // NaN in the middle\n\t\t{[]float64{math.NaN(), math.NaN()}, 0},   // All NaN values\n\t\t{[]float64{math.Inf(-1), math.Inf(1)}, 1}, // Negative and positive infinity\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},          // All negative values\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not panic\", test.input)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif len(test.input) == 0 {\n\t\t\t\tMaxIdx(test.input)\n\t\t\t}\n\t\t})\n\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5cfd5efc057e14d6f915e2f0e3a7a4e1":"// equal_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\ts1      []float64\n\t\ts2      []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{1.0}, []float64{1.0}, true},\n\t\t{[]float64{1.0}, []float64{2.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Equal(test.s1, test.s2)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Equal(%v, %v) = %v; expected %v\", test.s1, test.s2, result, test.expected)\n\t\t}\n\t}\n}","5db0ca7cc9e199b358e4086356bd249f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3-4-5 triangle\n\t\t{[]float64{-3, -4}, 2, 5},\n\t\t{[]float64{0, 0}, 2, 0},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for other L values\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif !floatEqual(got, tt.want) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","5e5b494cf15f876e881c448b70eb2381":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, expected []float64\n\t}{\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{5, 6, 7},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 4, 4},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{10, 20, 30},\n\t\t\tt:       []float64{5, 5, 5},\n\t\t\texpected: []float64{5, 15, 25},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{1, 1},\n\t\t\texpected: []float64{0, 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SubTo(test.dst, test.s, test.t)\n\t\tfor i := range result {\n\t\t\tif math.Abs(result[i]-test.expected[i]) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"SubTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"SubTo did not panic on length mismatch\")\n\t\t}\n\t}()\n\tSubTo([]float64{0}, []float64{1, 2}, []float64{1})\n}","5ec0328f90a34d616e3b204f7b27312c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 3, 1},          // Closer to lower bound\n\t\t{5, 0, 10, 7, 3},          // Closer to upper bound\n\t\t{5, 0, 10, 5.5, 2},        // Between middle and upper\n\t\t{5, 0, 10, 4.5, 1},        // Between middle and lower\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity value\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Negative infinity value\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expect panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","61372161edf3c9defd238b1135cd48bc":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 6),\n\t\t\tl:    10,\n\t\t\tu:    20,\n\t\t\twant: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range got {\n\t\t\tif got[i] != tt.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span([]float64{0}) did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst []float64\n\t\tl, u float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range nanTests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range got {\n\t\t\tif (math.IsNaN(got[i]) \u0026\u0026 !math.IsNaN(tt.want[i])) || (!math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tt.want[i])) || got[i] != tt.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}","619b5b88adc14dd5e12b4896a2e60292":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},\n\t\t{[]float64{1.0, 3.0, 3.0}, 1},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 2},\n\t\t{[]float64{math.NaN(), math.NaN(), 3.0}, 2},\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, 0}, // This case should panic\n\t}\n\n\tfor _, test := range tests {\n\t\tif len(test.input) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not panic\", test.input)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","63eb0a38dfc2724cfeb1f978ccfde92a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.5, 2}, // Between middle and upper\n\t\t{5, 0, 10, 4.5, 1}, // Between lower and middle\n\t\t{5, 10, 0, 5, 2}, // Reversed bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reversed\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reversed\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 4}, // Inf bounds with value\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","63fa0b8a84228ec317cfed7688363a0a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         -1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 0),\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         4,\n\t\t\texpected:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(-1),\n\t\t\texpected:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v, but did not panic\", test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic {\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For input l=%v, u=%v, expected %v but got %v\", test.l, test.u, test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","6413829de65ffe830657a47656e35ce0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // NaN bounds\n\t\t{3, 0, 10, 5, 1}, // Edge case with n = 3\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","656d8243e7ab61dd1b5d5d4c0a1c2a51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\texpected:  []float64{0, 2.5, 5, 7.5, 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         -5,\n\t\t\tu:         5,\n\t\t\texpected:  []float64{-5, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 0),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         10,\n\t\t\texpected:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         0,\n\t\t\texpected:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, l: %v, u: %v, but did not panic\", test.dst, test.l, test.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(test.dst, test.l, test.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For dst: %v, l: %v, u: %v, expected %v but got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","65a07e02fcce872028436f8a915909a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Nearest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Nearest to 2.0 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Nearest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Nearest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Nearest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // Nearest to NaN returns index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Nearest to +Inf returns index of max\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Nearest to -Inf returns index of min\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: %v\", test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdx(test.s, math.NaN())\n\t\t})\n\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","65fd8ad4512dfef4102fe3bfb9270a4f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := math.NaN()\n\tu := 5.0\n\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\n\tresult := Span(dst, l, u)\n\tfor i, v := range result {\n\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(expected[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", dst, l, u, result, expected)\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := math.Inf(-1)\n\tu := math.Inf(1)\n\texpected := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\n\tresult := Span(dst, l, u)\n\tfor i, v := range result {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", dst, l, u, result, expected)\n\t\t}\n\t}\n}","6614f0f640bed3219f6edca88d44dd37":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // Upper bound NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // v is -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // v is Inf\n\t\t{5, 10, 0, 5, 2}, // Reversed bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","662f2e407358b89be4281a5a18880939":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // sqrt((4-1)^2 + (5-2)^2 + (6-3)^2)\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 3, // max(|4-1|, |5-2|, |6-3|)\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif math.Abs(result-test.expected) \u003e 1e-9 {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic on length mismatch\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}","66d292c1ce226e5c8864cc13fe05bc21":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, -1, -1},      // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},      // Between lower and middle\n\t\t{5, 0, 10, 7.5, 3},      // Between middle and upper\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Inf lower\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf upper\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n = %d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v: expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","67dd6295b47259e6fb279f0555c34da2":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No slices\n\t\t{[][]float64{{1.0}}, true}, // One slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0}, {2.0, 3.0}}, false}, // Two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}}, false}, // Two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false}, // Three slices of different lengths\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}}, true}, // Three slices of equal length\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := EqualLengths(tt.slices...)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t}\n\t}\n}","68474e5a72e61670a6cb46b5ac1305bf":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                     // Test case for empty slice\n\t\t{[]float64{1, 2, 3}, 6},               // Test case for normal case\n\t\t{[]float64{0, 1, 2}, 0},               // Test case with zero\n\t\t{[]float64{1, -1, 1}, -1},             // Test case with negative number\n\t\t{[]float64{2, 2, 2, 2}, 16},           // Test case with repeated elements\n\t\t{[]float64{1.5, 2.0, 2.5}, 7.5},       // Test case with floating point numbers\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","68899a430ddf4f6f239e756b66bbbffb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts, t []float64\n\t\twant bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true},\n\t\t{[]float64{math.NaN(), 2, 3}, []float64{math.NaN(), 2, 3}, true},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{math.NaN()}, []float64{math.NaN()}, true},\n\t\t{[]float64{1, 2, 3}, []float64{3, 2, 1}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.s, tt.t)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","68e0afb435fbddde65eef21993523abe":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // v is between s[1] and s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0}, // v is equal to s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v is equal to s[2], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v is less than s[0], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v is greater than s[2], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN, should return -1\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","690866bf0f92f2e1f2a6c438c10bc8eb":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 5.1, 3},        // Just above middle\n\t\t{5, 0, 10, 4.9, 2},        // Just below middle\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Negative infinity\n\t\t{3, 1, 2, 1.5, 1},         // Small span\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","6930d616072f2ca90b31519426117788":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Normal case\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))}, // Negative values\n\t\t{[]float64{0, 0, 0}, 0}, // All zeros\n\t\t{[]float64{math.Inf(1), 1, 2}, math.Inf(1)}, // Infinity in input\n\t\t{[]float64{math.Inf(-1), 1, 2}, math.Log(math.Exp(1) + math.Exp(2))}, // Negative infinity in input\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif !almostEqual(result, test.expected) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic for empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// Helper function to compare floating point numbers\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-10\n\treturn math.Abs(a-b) \u003c epsilon\n}","69897caeb65fe72f7aa78c474973b3a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 10, 0, 5, 2},           // Reverse bounds\n\t\t{5, 10, 0, 10, 0},          // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},           // Reverse bounds, upper bound\n\t\t{5, 10, 0, 11, 0},          // Reverse bounds, above upper bound\n\t\t{5, 10, 0, -1, 4},          // Reverse bounds, below lower bound\n\t\t{3, 0, 10, 5, 1},           // Edge case with n=3\n\t\t{3, 0, 10, 0, 0},           // Edge case with n=3, lower bound\n\t\t{3, 0, 10, 10, 2},          // Edge case with n=3, upper bound\n\t\t{2, 0, 10, 5, 1},           // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},           // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1},          // Edge case with n=2, upper bound\n\t\t{2, 10, 0, 5, 1},           // Edge case with n=2, reverse bounds\n\t\t{2, 10, 0, 10, 0},          // Edge case with n=2, reverse bounds, lower bound\n\t\t{2, 10, 0, 0, 1},           // Edge case with n=2, reverse bounds, upper bound\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","6aede9c09c69006b852dd6e16ffad905":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif !equal(result[i], tt.expected[i]) {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panics on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n\n\tt.Run(\"panics on empty dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on empty dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{}, 0, 1)\n\t})\n}\n\nfunc equal(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","6af629ddd937cab703589d0bb7a8abe6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 5.1, 2},        // Just above middle\n\t\t{5, 0, 10, 4.9, 2},        // Just below middle\n\t\t{5, 10, 0, 5, 2},          // Reversed bounds\n\t\t{5, 10, 0, 10, 0},         // Lower bound in reversed\n\t\t{5, 10, 0, 0, 4},          // Upper bound in reversed\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity case\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // Both bounds NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","6bfc7b9f97ba65b7653d66b1e69f0b80":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tf        func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"equal with NaN\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0, float64(NaN())},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0, float64(NaN())},\n\t\t\tf:        func(a, b float64) bool { return (a == b) || (a != a \u0026\u0026 b != b) }, // NaN check\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"one NaN\",\n\t\t\ts1:       []float64{1.0, 2.0, float64(NaN())},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return (a == b) || (a != a \u0026\u0026 b != b) }, // NaN check\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.s1, tt.s2, tt.f)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v) = %v; want %v\", tt.s1, tt.s2, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","6c7c9566e0529939e343a754e38af8a8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        10,\n\t\t\texpected: []float64{2, 4, 6, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        -3,\n\t\t\tu:        3,\n\t\t\texpected: []float64{-3, -2, -1, 0, 1, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n","6d06d0759e4be25c7b630ad5ceb5bc13":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between middle and upper\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{3, 1, 3, 2, 1}, // Small span\n\t\t{3, 1, 3, 1, 0}, // Exact lower bound in small span\n\t\t{3, 1, 3, 3, 2}, // Exact upper bound in small span\n\t\t{2, 1, 1, 1, 0}, // Edge case with equal bounds\n\t\t{2, 1, 1, 2, 0}, // Edge case with equal bounds, above\n\t\t{2, 1, 1, 0, 0}, // Edge case with equal bounds, below\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","6d21515f8125323eb177cf800f931b07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        10,\n\t\t\texpected: []float64{2, 4, 6, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        -3,\n\t\t\tu:        3,\n\t\t\texpected: []float64{-3, -2, -1, 0, 1, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        10,\n\t\t\texpected: []float64{5, 10},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic for length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","6deba74db0b90460246258ff700fb465":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when length of dst is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","6f60e11c27d167cc98a6c777b2ed309f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 5.1, 3},       // Just above middle\n\t\t{5, 0, 10, 4.9, 2},       // Just below middle\n\t\t{3, 1, 3, 2, 1},          // Edge case with n=3\n\t\t{3, 1, 3, 1, 0},          // Edge case with n=3 at lower bound\n\t\t{3, 1, 3, 3, 2},          // Edge case with n=3 at upper bound\n\t\t{2, 1, 3, 2, 1},          // Edge case with n=2\n\t\t{2, 1, 3, 1, 0},          // Edge case with n=2 at lower bound\n\t\t{2, 1, 3, 3, 1},          // Edge case with n=2 at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","6f8f0cf089b9296b93c93e650fdcf0f6":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, should return 0\n\t\t{[]float64{math.Inf(1), 2.0, 3.0}, math.Inf(1), 0}, // Positive infinity case\n\t\t{[]float64{1.0, 2.0, math.Inf(-1)}, math.Inf(-1), 2}, // Negative infinity case\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","705779804a0d6e416d989d33e5d71d2c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 0, 10, 5, 1},          // Edge case with 3 points\n\t\t{3, 0, 10, 0, 0},          // Edge case with 3 points at lower bound\n\t\t{3, 0, 10, 10, 2},         // Edge case with 3 points at upper bound\n\t\t{2, 0, 10, 5, 0},          // Edge case with 2 points\n\t\t{2, 0, 10, 0, 0},          // Edge case with 2 points at lower bound\n\t\t{2, 0, 10, 10, 1},         // Edge case with 2 points at upper bound\n\t\t{2, 0, 10, 5.1, 1},        // Edge case with 2 points, closer to upper\n\t\t{2, 0, 10, -1, 0},         // Edge case with 2 points, below lower\n\t\t{2, 0, 10, 11, 1},         // Edge case with 2 points, above upper\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.n \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n}","70ef5cf162ccbbbeaffa61109d9d5327":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 3.5, 1},       // Between lower and upper\n\t\t{5, 0, 10, 7.5, 3},       // Between lower and upper\n\t\t{3, 0, 10, 5, 1},         // Edge case with n=3\n\t\t{3, 10, 0, 5, 2},         // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 1},         // Edge case with n=2\n\t\t{2, 10, 0, 5, 0},         // Edge case with inverted bounds and n=2\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Infinite bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Infinite bounds\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 tt.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n}","719fbaed10eb9f84af07d905fd6dc8b6":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e10, 1e10, 1e10}, 3e10},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 4.0},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.Inf(1)},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN for input %v, got %v\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %v, got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","72080191d1a0f6a037ea1ba79b729034":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttests := []struct {\n\t\ts1      []float64\n\t\ts2      []float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\ts1:      []float64{1, 2, 3},\n\t\t\ts2:      []float64{4, 5, 6},\n\t\t\texpected: 32, // 1*4 + 2*5 + 3*6\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{0, 0, 0},\n\t\t\ts2:      []float64{1, 2, 3},\n\t\t\texpected: 0, // 0*1 + 0*2 + 0*3\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{1, 2},\n\t\t\ts2:      []float64{1, 2, 3},\n\t\t\texpected: 0,\n\t\t\tpanic:    true, // Lengths do not match\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{1, 2, 3, 4},\n\t\t\ts2:      []float64{1, 2, 3},\n\t\t\texpected: 0,\n\t\t\tpanic:    true, // Lengths do not match\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for s1: %v, s2: %v\", test.s1, test.s2)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Dot(test.s1, test.s2)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Dot(%v, %v) = %v; expected %v\", test.s1, test.s2, result, test.expected)\n\t\t}\n\t}\n}","731ef9c1650a0835b8d91c3e5645ea3d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{10, 10, 10, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) \u0026\u0026 math.IsNaN(v) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","7342be149dca4d93bbc1c7058fc4b165":"// same_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts, t []float64\n\t\twant bool\n\t}{\n\t\t// Test cases with equal slices\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{math.NaN(), 2.0, 3.0}, true},\n\t\t{[]float64{1.0, math.NaN(), 3.0}, []float64{1.0, math.NaN(), 3.0}, true},\n\t\t{[]float64{math.NaN(), math.NaN()}, []float64{math.NaN(), math.NaN()}, true},\n\n\t\t// Test cases with unequal slices\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, math.NaN()}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, false},\n\n\t\t// Test cases with empty slices\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{}, []float64{1.0}, false},\n\t\t{[]float64{1.0}, []float64{}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.s, tt.t)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","735adf687a18e301fe773c3aa12dfa6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, 7.5, 3},       // Between middle and upper\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, -10, -5, -7.5, 2},    // Negative range\n\t\t{5, -10, -5, -10, 0},     // Lower bound negative\n\t\t{5, -10, -5, -5, 4},      // Upper bound negative\n\t\t{3, 0, 1, 0.5, 1},        // Edge case with n=3\n\t\t{2, 0, 1, 0.5, 0},        // Edge case with n=2\n\t\t{2, 0, 1, 0, 0},          // Edge case with n=2 at lower bound\n\t\t{2, 0, 1, 1, 1},          // Edge case with n=2 at upper bound\n\t\t{2, 0, 1, math.NaN(), 0}, // NaN value\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{2, math.Inf(-1), math.Inf(1), math.Inf(1), 1}, // Inf upper\n\t\t{2, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Inf lower\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v; expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","742c3a0e60b52275548045f9937128ed":"// argsort_stable_test.go\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdst:      []float64{3.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 2.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 2.0, 2.0},\n\t\t\tinds:     make([]int, 4),\n\t\t\texpectedInds: []int{0, 3, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5.0, 3.0, 3.0, 5.0},\n\t\t\texpected: []float64{3.0, 3.0, 5.0, 5.0},\n\t\t\tinds:     make([]int, 4),\n\t\t\texpectedInds: []int{1, 2, 0, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\texpected: []float64{1.0},\n\t\t\tinds:     make([]int, 1),\n\t\t\texpectedInds: []int{0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tArgsortStable(test.dst, test.inds)\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Expected dst: %v, got: %v\", test.expected, test.dst)\n\t\t}\n\t\tif !reflect.DeepEqual(test.inds, test.expectedInds) {\n\t\t\tt.Errorf(\"Expected inds: %v, got: %v\", test.expectedInds, test.inds)\n\t\t}\n\t}\n\n\t// Test for panic on mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths, but did not panic\")\n\t\t}\n\t}()\n\tArgsortStable([]float64{1.0, 2.0}, []int{0})\n}","74b6c2682cd0091c2b1d38011061c6ec":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, expected []float64\n\t\texpectPanic         bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{5, 7, 9},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{3, 4},\n\t\t\texpected: []float64{4, 6},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{3, 4},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input dst: %v, s: %v, t: %v, but did not panic\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := AddTo(test.dst, test.s, test.t)\n\n\t\tif !test.expectPanic {\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For input dst: %v, s: %v, t: %v, expected %v, got %v\", test.dst, test.s, test.t, test.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","7531e22078872885620137b8f10e36fa":"// File: addto_test.go\n\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\texpected:  []float64{5, 7, 9},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ts:         []float64{1, 2},\n\t\t\tt:         []float64{3, 4},\n\t\t\texpected:  []float64{4, 6},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{1, 2},\n\t\t\tt:         []float64{3, 4},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0},\n\t\t\ts:         []float64{1},\n\t\t\tt:         []float64{2},\n\t\t\texpected:  []float64{3},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: dst=%v, s=%v, t=%v\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := AddTo(test.dst, test.s, test.t)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","75568582d0db1dd3b3d9aaadf9b871d7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // v is between s[0] and s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // v is equal to s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v is equal to s[2] (out of bounds)\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v is less than s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v is greater than s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // v is between s[1] and s[2]\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, -1}, // All elements are the same\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","764003bc0b16664630dab25d0a7361f9":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // ((4-1) + (5-2) + (6-3))\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3, // max(|4-1|, |5-2|, |6-3|)\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        3,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !floatEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic on length mismatch\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}\n\n// floatEqual checks if two float64 values are approximately equal.\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","7775eae90044d2b83c4ba237a18e6524":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2}, // closest to 3.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // closest to 2.0 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, should return 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // +Inf case, should return index of max\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // -Inf case, should return index of min\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic on zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice, but did not panic\")\n\t\t}\n\t}()\n\t_ = NearestIdx([]float64{}, 1.0)\n}","77b93326ee7c291bfa127d16988aa7d8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1, 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc TestSpanSpecialCases(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected NaN\", test.dst, test.l, test.u, result)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","79104be89c9c1a79798d2bc6dce60d34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        1,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1, 1, 1, 1, 1, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue // Both are NaN, consider them equal\n\t\t\t}\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","79ba96a414ec58600a22cf4d6a65c7d9":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{3, 1, 2, 1.5, 1}, // Small span\n\t\t{2, 1, 2, 1.5, 0}, // Edge case with two elements\n\t\t{2, 1, 1, 1, 0}, // Edge case with equal bounds\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","79f3aca3977491f8d5f9776daa658477":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    2,\n\t\t\tu:    10,\n\t\t\twant: []float64{2, 4, 6, 10},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), 0, 0, 0, math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","7ae0b412168e3741e885695e100e10dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{10, 10, 10, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","7ba6c1a9d9cfc826feb1c6cc29a7d1d5":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, 1e-10}, 1e10 + 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{math.Inf(1), 1.0}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), -1.0}, math.Inf(-1)},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected NaN\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","7be2cfa5773f77e57f0b52a902a37906":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reverse\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reverse\n\t\t{5, 10, 0, 11, 0}, // Above upper bound with reverse\n\t\t{5, 10, 0, -1, 4}, // Below lower bound with reverse\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{3, 0, 10, 0, 0}, // Edge case with n=3 at lower bound\n\t\t{3, 0, 10, 10, 2}, // Edge case with n=3 at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","7ce7e0ff5d5a26e4ace3cfba39e5cd75":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first three even numbers, but only two exist\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 0},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find no elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find with k = 0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !equalSlices(got, tt.expected) || !equalErrors(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", got, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalErrors(a, b error) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a != nil \u0026\u0026 b != nil {\n\t\treturn a.Error() == b.Error()\n\t}\n\treturn false\n}","7dbdc50dd0c7ca092a6eb33c2b115cb4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // Single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false}, // Three slices, one different length\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}}, true}, // Three slices of equal length\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7dee733e37d1cd403fa43e560561b44b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{10, 10, 10, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","7e067ec2eec8c0ce92a797561684a201":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reverse\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reverse\n\t\t{5, 10, 0, 5, 2}, // Middle value with reverse\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Upper Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Lower Inf\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // Both NaN\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(int(tt.n), tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","7e0e584ee99bb04f534bf4a061567134":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first three even numbers, but only two exist\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is zero\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","7e338ea1edf5d53d16546d7262adfbf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 15, 4}, // Above upper bound\n\t\t{5, 0, 10, -5, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 4}, // Reverse bounds\n\t\t{3, 0, 10, 5, 1}, // Odd number of points\n\t\t{3, 0, 10, 0, 0}, // Lower bound with odd points\n\t\t{3, 0, 10, 10, 2}, // Upper bound with odd points\n\t\t{3, 0, 10, 15, 2}, // Above upper bound with odd points\n\t\t{3, 0, 10, -5, 0}, // Below lower bound with odd points\n\t\t{2, 0, 10, 5, 1}, // Minimum valid n\n\t\t{2, 0, 10, 0, 0}, // Lower bound with minimum n\n\t\t{2, 0, 10, 10, 1}, // Upper bound with minimum n\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value for v\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","7f25d22513ef6e04b64a192ed3cfc5b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, -10, -5, -7.5, 1},    // Negative range\n\t\t{5, -10, -5, -10, 0},     // Lower bound negative\n\t\t{5, -10, -5, -5, 4},      // Upper bound negative\n\t\t{3, 0, 1, 0.5, 1},        // Edge case with n=3\n\t\t{2, 0, 1, 0.5, 1},        // Edge case with n=2\n\t\t{2, 0, 1, 0, 0},          // Edge case with n=2 at lower bound\n\t\t{2, 0, 1, 1, 1},          // Edge case with n=2 at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test NaN input\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", got)\n\t}\n}","7f3a126a386b9ed26bfb0769fd5122a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},           // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},           // Max at the beginning\n\t\t{[]float64{1.0, 3.0, 3.0}, 1},           // Max at the end with duplicates\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},   // Ignore NaN\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 2},   // Ignore NaN\n\t\t{[]float64{math.NaN(), math.NaN()}, 0}, // All NaN\n\t\t{[]float64{math.Inf(-1), math.Inf(1)}, 1}, // Negative and positive infinity\n\t\t{[]float64{math.Inf(1), math.Inf(1)}, 0}, // Both positive infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","7f6810e613aee48e70477e69512564f4":"// equal_lengths_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // One slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false}, // Three slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true}, // Three slices of equal length\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}}, false}, // Two slices of different lengths\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f69ce5884584bab680bef849c1ae2aa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        10,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(result, tt.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, result, tt.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","806936f5d9d784f8306b0ac2a5943872":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // Single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}}, true}, // Three slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0, 5.0}, {6.0}}, false}, // Three slices of different lengths\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","809daefdfb910db4c42b0f1b1277fcbe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         -2,\n\t\t\tu:         2,\n\t\t\texpected:  []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 6),\n\t\t\tl:         10,\n\t\t\tu:         20,\n\t\t\texpected:  []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         5,\n\t\t\tu:         10,\n\t\t\texpected:  []float64{5, 10},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         4,\n\t\t\texpected:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif (math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(test.expected[i])) || (!math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i])) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         10,\n\t\t\texpected:  []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","80ffe1ef1dc80434c8321ba0d2fb1c7c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  []float64{0, 2.5, 5, 7.5, 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 3),\n\t\t\tl:     1,\n\t\t\tu:     1,\n\t\t\twant:  []float64{1, 1, 1},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 2),\n\t\t\tl:     -5,\n\t\t\tu:     5,\n\t\t\twant:  []float64{-5, 5},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 0),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  nil,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 1),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  nil,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.NaN(),\n\t\t\tu:     10,\n\t\t\twant:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\twant:  []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\twant:  []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     10,\n\t\t\twant:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\twant:  []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\tpanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","8164f904edbace0e687a6eb1a01a3af5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test cases for L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t{[]float64{1, -1, 0}, []float64{0, 1, 1}, 1, 3, false},\n\t\t\n\t\t// Test cases for L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 2, 0, false},\n\n\t\t// Test cases for L-infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, math.Inf(1), 3, false},\n\n\t\t// Test case for empty slices\n\t\t{[]float64{}, []float64{}, 1, 0, false},\n\t\t\n\t\t// Test case for mismatched lengths (should panic)\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t\t{[]float64{1}, []float64{1, 2}, 1, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","820e22f4df79d99e681e83421197f3ad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{0, 0, 0}, 1, 0},\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t\n\t\t// Test cases for L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3-4-5 triangle\n\t\t{[]float64{0, 0, 0}, 2, 0},\n\t\t{[]float64{1, 2, 2}, 2, 3}, // sqrt(1^2 + 2^2 + 2^2)\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 0},\n\n\t\t// Test cases for L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)}, // (1^3 + 2^3 + 3^3)^(1/3)\n\t\t{[]float64{1, 1, 1}, 3, 1},\n\n\t\t// Edge cases\n\t\t{[]float64{}, 1, -1}, // Empty slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","8237b765f07159af3926d27949397523":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{-5, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, %v, %v expected %v but got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","82cfd02b37e335e4d6d30fe85596f5fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3^2 + 4^2 = 25 -\u003e sqrt(25) = 5\n\t\t{[]float64{-3, -4}, 2, 5},\n\t\t{[]float64{0, 0}, 2, 0},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for general L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)}, // (1^3 + 2^3 + 3^3)^(1/3)\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","8316756719bd266dc16a02ec38ac71fe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},         // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},         // Closer to upper half\n\t\t{3, 1, 3, 2, 1},            // Small span\n\t\t{3, 1, 3, 1, 0},            // Small span, lower bound\n\t\t{3, 1, 3, 3, 2},            // Small span, upper bound\n\t\t{2, 1, 3, 2, 1},            // Edge case with two elements\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","833b21a0075c577fde94c189898f66a9":"package floats\n\nimport (\n\t\"testing\"\n)\n\ntype argsort struct {\n\ts    []float64\n\tinds []int\n}\n\nfunc (a argsort) Swap(i, j int) {\n\ta.s[i], a.s[j] = a.s[j], a.s[i]\n\t_, _, _, _, _, _, _, _ = a.inds{}, i, a.inds{}, j, a.inds{}, j, a.inds{}, i\n}\n\nfunc TestSwap(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    argsort\n\t\ti, j     int\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname: \"Swap first and last\",\n\t\t\tinput: argsort{\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\ti: 0, j: 2,\n\t\t\texpected: []float64{3.0, 2.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Swap middle elements\",\n\t\t\tinput: argsort{\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\ti: 1, j: 2,\n\t\t\texpected: []float64{1.0, 3.0, 2.0, 4.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Swap same elements\",\n\t\t\tinput: argsort{\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\ti: 1, j: 1,\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.input.Swap(tt.i, tt.j)\n\t\t\tif !equalSlices(tt.input.s, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, tt.input.s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","84cba209de73be9fc8a65c3115cd478d":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements that are greater than 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements that are less than 0\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, -2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 elements that are equal to 3\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 3 },\n\t\t\ts:        []float64{1, 2, 3, 3, 3},\n\t\t\tk:        3,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 0 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 1 element that is negative\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !equalSlices(result, tt.expected) || !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","84cf1db0881ba9374d11a631125e887c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 3, 1},         // Closer to lower\n\t\t{5, 0, 10, 7, 3},         // Closer to upper\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 4}, // Value within infinity bounds\n\t\t{5, math.Inf(-1), math.Inf(1), -1, 0}, // Value below infinity bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 4}, // Value above infinity bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected index %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","84fc49945a232770c24f21a053cee5a1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 2.5, 1}, // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3}, // Closer to upper half\n\t\t{3, 1, 3, 2, 1}, // Testing with smaller n\n\t\t{3, 1, 3, 1, 0}, // Testing with smaller n at lower bound\n\t\t{3, 1, 3, 3, 2}, // Testing with smaller n at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN handling\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","8660c16f640958be268b424125fc3fec":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1 (Manhattan norm)\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t// Test case for L = 2 (Euclidean norm)\n\t\t{[]float64{3, 4}, 2, 5},\n\t\t// Test case for L = math.Inf(1) (Max norm)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t// Test case for L = 0 (should not be used, but testing behavior)\n\t\t{[]float64{1, -2, 3}, 0, 0}, // Expected behavior should be defined\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t// Test case for negative values\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t// Test case for mixed values\n\t\t{[]float64{1, 2, 3, -4}, 3, math.Pow(1*1 + 2*2 + 3*3 + 4*4, 1.0/3.0)},\n\t\t// Test case for large values\n\t\t{[]float64{1e10, 2e10, 3e10}, 1, 6e10},\n\t\t// Test case for small values\n\t\t{[]float64{1e-10, 2e-10, 3e-10}, 1, 6e-10},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif !equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare float64 values for equality\nfunc equal(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","876a136b2371b18a843f206bffeb3c2a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},       // Closer to upper half\n\t\t{3, 0, 10, 5, 1},         // Odd number of points\n\t\t{3, 10, 0, 5, 1},         // Reverse bounds\n\t\t{3, math.NaN(), 10, 5, 2}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{3, math.Inf(-1), math.Inf(1), 1, 2}, // Inf bounds\n\t\t{3, 0, 0, 0, 0},          // All bounds are zero\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","88a0193ded84b9e893d23ff426b1843c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tpanicExpected bool\n\t}{\n\t\t// Normal cases\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0)},\n\n\t\t// Edge cases\n\t\t{[]float64{}, []float64{}, 1, -1, false}, // Empty slices should return -1\n\t\t{[]float64{1}, []float64{1}, 1, 0, false}, // Same points should return 0\n\n\t\t// Panic cases\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true}, // Different lengths should panic\n\t\t{[]float64{1}, []float64{1, 2}, 1, 0, true}, // Different lengths should panic\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panicExpected {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panicExpected \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","8900aa68771056c6d140df5d1c575cfa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{-10, -5, 0, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        15,\n\t\t\texpected: []float64{5, 15},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","8957cbfb628c000e6a23a0af86dc0e6d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{1},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","8a268a807febdd1589044723d42783f7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound (reverse)\n\t\t{5, 10, 0, 0, 4}, // Upper bound (reverse)\n\t\t{5, 10, 0, 7.5, 3}, // Between bounds (reverse)\n\t\t{3, 0, 10, 5, 1}, // Edge case with 3 points\n\t\t{3, 0, 10, 0, 0}, // Edge case with 3 points at lower bound\n\t\t{3, 0, 10, 10, 2}, // Edge case with 3 points at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected index 0 for NaN value, got %d\", result)\n\t}\n}","8d7bf8dcb492c4994dab8bf626b97ed0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        10,\n\t\t\texpected: []float64{5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","8db84bf8b529bb0fc69aa47c2d3ac7c6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity case\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity case\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif gotIdx := NearestIdx(tt.s, tt.v); gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","8f9e9416d8c0aaecb379aacadcf67c50":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 10, 0, 5, 2},           // Reverse bounds\n\t\t{5, 10, 0, 10, 4},          // Upper bound with reverse\n\t\t{5, 10, 0, 0, 0},           // Lower bound with reverse\n\t\t{5, 10, 0, -1, 0},          // Below lower bound with reverse\n\t\t{5, 10, 0, 11, 4},          // Above upper bound with reverse\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower bound\n\t\t{5, math.Inf(-1), math.Inf(1), 10, 4}, // Positive infinity upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), math.NaN(), 0}, // NaN value\n\t\t{3, 0, 10, 5, 1},           // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},           // Edge case with reverse bounds and n=3\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected index %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","9012a9920bb033f073d1054b802c5912":"// File: find_test.go\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements greater than 0\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements greater than 0\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 elements greater than 0, not enough found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 0 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 1 element greater than 0\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, -3, 4},\n\t\t\tk:        1,\n\t\t\texpected: []int{1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 2 elements with NaN\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x != x }, // NaN check\n\t\t\ts:        []float64{1, 2, 3, 4, 5, float64(0) / float64(0)}, // last element is NaN\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tif (err != nil) \u0026\u0026 (tt.err == nil || err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t} else if (err == nil) \u0026\u0026 (tt.err != nil) {\n\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","90eda1a8282de7144480b0cef156e607":"// maxidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2}, // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0}, // Normal case\n\t\t{[]float64{1.0, 3.0, 3.0}, 1}, // First max index\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1}, // Ignore NaN\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 2}, // Ignore NaN\n\t\t{[]float64{math.NaN(), math.NaN()}, 0}, // All NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","9303356005fcdaa7752836a212c96a6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for general L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{0, 0, 0}, 3, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","930bfa10b6dc4b7a361ff5e9c117915b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Expected value calculated directly\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))},\n\t\t{[]float64{0}, 0}, // LogSumExp of a single element\n\t\t{[]float64{math.Inf(1), 1}, math.Inf(1)}, // Test with positive infinity\n\t\t{[]float64{math.Inf(-1), -1}, math.Inf(-1)}, // Test with negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif !equalApprox(result, test.expected, 1e-10) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic on empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic on empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// Helper function to check approximate equality\nfunc equalApprox(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}","93bb65f0c24933e8c6e5822ca34a87d6":"package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{3.0, 2.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{5.5, 4.4, 3.3, 2.2, 1.1},\n\t\t\texpected: []float64{1.1, 2.2, 3.3, 4.4, 5.5},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: []float64{42.0},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0},\n\t\t\texpected: []float64{-3.0, -2.0, -1.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Create a copy of the input to avoid modifying the original slice\n\t\tinputCopy := make([]float64, len(test.input))\n\t\tcopy(inputCopy, test.input)\n\n\t\tReverse(inputCopy)\n\n\t\tif !reflect.DeepEqual(inputCopy, test.expected) {\n\t\t\tt.Errorf(\"Reverse(%v) = %v; want %v\", test.input, inputCopy, test.expected)\n\t\t}\n\t}\n}","95db695f7002f97cfcc763d5f131bde2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 3, 1}, // Closer to lower bound\n\t\t{5, 0, 10, 7, 3}, // Closer to upper bound\n\t\t{3, 1, 2, 1.5, 1}, // Test with smaller span\n\t\t{3, 1, 2, 1, 0}, // Exact lower bound with smaller span\n\t\t{3, 1, 2, 2, 2}, // Exact upper bound with smaller span\n\t\t{2, 1, 2, 1.5, 0}, // Edge case with two elements\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","971cdb9966ab10f3b6a66f22cf666530":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\ts1, s2 []float64\n\t\ttol    float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  1e-9,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.1},\n\t\t\ttol:  0.1,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.1, 3.0},\n\t\t\ttol:  0.05,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  1e-9,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{},\n\t\t\ts2:   []float64{},\n\t\t\ttol:  1e-9,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  0.0,\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualApprox(tt.s1, tt.s2, tt.tol)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %v) = %v; want %v\", tt.s1, tt.s2, tt.tol, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","97f6a508a005bcc949f1573f054387f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between upper and middle\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // Upper bound NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Both bounds Inf\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4}, // Both bounds Inf reversed\n\t\t{3, 0, 10, 5, 1}, // Odd number of points\n\t\t{2, 0, 10, 5, 1}, // Even number of points\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t} else if r != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","98455f52f62b2e50bb908d3d0ed0a1ec":"// prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                      // Test with an empty slice\n\t\t{[]float64{1}, 1},                     // Test with a single element\n\t\t{[]float64{2, 3}, 6},                  // Test with two elements\n\t\t{[]float64{1, 2, 3, 4}, 24},           // Test with multiple elements\n\t\t{[]float64{-1, -2, -3}, -6},           // Test with negative elements\n\t\t{[]float64{0, 1, 2}, 0},                // Test with zero in the slice\n\t\t{[]float64{1.5, 2.5}, 3.75},           // Test with floating point numbers\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9968eecfdf30082706212c97588e7293":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1, 2, 3},\n\t\t\texpected: math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3)),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{-1, -2, -3},\n\t\t\texpected: math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3)),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{0, 0, 0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 1, 2},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(-1), -1, -2},\n\t\t\texpected: math.Inf(-1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1, 2, math.NaN()},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif math.IsNaN(result) \u0026\u0026 math.IsNaN(test.expected) {\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic for empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}","99d6db2036d4ac3edc0116983f0e560d":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts, t   []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(27), // sqrt((4-1)^2 + (5-2)^2 + (6-3)^2)\n\t\t},\n\t\t{\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3, // max(|4-1|, |5-2|, |6-3|)\n\t\t},\n\t\t{\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      3,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expect)\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic on length mismatch\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}","9a496ba17ec527d8f006609f6f843ff6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{10, 20, 30},\n\t\t\ts:        []float64{2, 4, 5},\n\t\t\texpected: []float64{5, 5, 6},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{1, 1, 1},\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5, 10, 15},\n\t\t\ts:        []float64{0.5, 2, 3},\n\t\t\texpected: []float64{10, 5, 5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tDiv(test.dst, test.s)\n\t\tfor i, v := range test.expected {\n\t\t\tif test.dst[i] != v {\n\t\t\t\tt.Errorf(\"Div(%v, %v) = %v; expected %v\", test.dst, test.s, test.dst, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Div did not panic on length mismatch\")\n\t\t}\n\t}()\n\tDiv([]float64{1, 2}, []float64{1})\n}","9a6f496faafe107e1f1f8261c46d7bf1":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Middle value\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closer to first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closer to last element\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Below the range\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Above the range\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0}, // All elements the same\n\t\t{[]float64{1.0, 2.0, 1.0}, 1.0, 0}, // Same value, first index\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 2.0, 1}, // NaN in the slice\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 2.0, 1}, // NaN at the end\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, -1.0, 0}, // Negative infinity\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, 1.0, 2}, // Positive infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","9a98ff29fee4e9f72e766486242fbc11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.panic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, %v, %v; expected %v, got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","9ab1d4dcd4e6e4dd07be351879e21a61":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // v is in the middle\n\t\t{5, 0, 10, 0, 0}, // v is equal to l\n\t\t{5, 0, 10, 10, 4}, // v is equal to u\n\t\t{5, 0, 10, 15, 4}, // v is above u\n\t\t{5, 0, 10, -5, 0}, // v is below l\n\t\t{5, 10, 0, 5, 2},  // v is in the middle with inverted bounds\n\t\t{5, 10, 0, 10, 0}, // v is equal to l with inverted bounds\n\t\t{5, 10, 0, 0, 4},  // v is equal to u with inverted bounds\n\t\t{5, 10, 0, -5, 4}, // v is below l with inverted bounds\n\t\t{5, 10, 0, 15, 0}, // v is above u with inverted bounds\n\t\t{3, 0, 10, 5, 1},  // edge case with n=3\n\t\t{3, 0, 10, 0, 0},  // edge case with n=3\n\t\t{3, 0, 10, 10, 2}, // edge case with n=3\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","9b77ccabddafb9d8dc5b4b9224996375":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, y, s []float64\n\t\talpha     float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ty:        []float64{4, 5, 6},\n\t\t\ts:        []float64{1, 1, 1},\n\t\t\talpha:    2,\n\t\t\texpected: []float64{6, 7, 8},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ty:        []float64{1, 2, 3},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\talpha:    0.5,\n\t\t\texpected: []float64{1.5, 2, 2.5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2},\n\t\t\ty:        []float64{3, 4, 5},\n\t\t\ts:        []float64{1, 1},\n\t\t\talpha:    1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ty:        []float64{4, 5, 6},\n\t\t\ts:        []float64{1, 2},\n\t\t\talpha:    1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %+v, but did not panic\", test)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input %+v, expected %v, got %v\", test, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","9c55932632ea7107edec31327f638aa7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 1}, // v is between s[0] and s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // v is equal to s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 2}, // v is between s[1] and s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v is equal to s[2], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v is less than s[0], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v is greater than s[2], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -0}, // v is NaN, should return -0\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Within(test.s, test.v); got != test.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", test.s, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","9cb0d360d85ad376bf2194447eafd178":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{1.0, math.NaN(), 3.0}, true},\n\t\t{[]float64{math.NaN(), math.NaN()}, true},\n\t\t{[]float64{}, false},\n\t\t{[]float64{math.Inf(1), math.Inf(-1), 0.0}, false},\n\t\t{[]float64{math.NaN(), 1.0, math.Inf(1)}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := HasNaN(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"HasNaN(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9d291a0a7219e71f1248386c72c4ebdd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{1, 2, 2}, 2, 3},\n\t\t{[]float64{-1, -2, -2}, 2, 3},\n\t\t{[]float64{3, 4, 0}, 2, 5},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif math.Abs(got-tt.want) \u003e 1e-9 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","9d4ab18a2d3be262fae27fe7439bf295":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"find first k elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is zero\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is negative, return all\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"not enough elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"no elements match\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !equalSlices(result, tt.expected) || !equalErrors(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalErrors(a, b error) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a != nil \u0026\u0026 b != nil {\n\t\treturn a.Error() == b.Error()\n\t}\n\treturn false\n}","9e6b0f9dd9f49f75a5ba370e3a417163":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t// Test L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t// Test L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t// Test L-infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t// Test L3 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0)},\n\t\t// Test zero-length slices\n\t\t{[]float64{}, []float64{}, 2, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic for mismatched lengths\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 2)\n}","a016dbc2f0d6caf11e2cb0a3b863ab48":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // Upper bound NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Both bounds Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // v is -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // v is Inf\n\t\t{5, 10, 0, 5, 2}, // Reversed bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","a27f6a53f7ef837c6a2016083242e078":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t}\n\n\tfor _, test := range infTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","a2bf07ba250a0365f9ac0b0f63d41c94":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test case for L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t// Test case for L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t// Test case for L-infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t// Test case for empty slices\n\t\t{[]float64{}, []float64{}, 1, 0, false},\n\t\t// Test case for mismatched lengths (should panic)\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v with L=%v, but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","a3fe2ed40acd3b91aacc802c7c7b7333":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Middle value\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Exact match\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closer to first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closer to last element\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Below the range\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Above the range\n\t\t{[]float64{1.0, 2.0, 3.0, 2.5}, 2.5, 3}, // Multiple closest values\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 2.0, 1}, // NaN in slice\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 2.0, 1}, // NaN first\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN value\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","a41f57f74af72aeefcd635aa831db8f0":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v \u003e= s[len(s)]\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v \u003e s[len(s)]\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, -1}, // v \u003c s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","a47dd1cdc3dc83bbdb439193cd64f607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.1, 3}, // Just above middle\n\t\t{5, 0, 10, 4.9, 2}, // Just below middle\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{2, 0, 10, 5, 0}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2 at lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2 at upper bound\n\t\t{2, 0, 10, -1, 0}, // Edge case with n=2 below lower bound\n\t\t{2, 0, 10, 11, 1}, // Edge case with n=2 above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Inverted Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","a497dd8b46bc2c813c600319f2b295de":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","a4b60974e46bfdf6e006c7d82aaa379c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, 15, 4},         // Above upper bound\n\t\t{5, 0, 10, -5, 0},         // Below lower bound\n\t\t{5, 10, 0, 5, 0},          // Reverse bounds\n\t\t{5, 10, 0, 10, 4},         // Reverse bounds, upper\n\t\t{5, 10, 0, -5, 0},         // Reverse bounds, below\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse Inf bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // Both NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","a4d1d307540cd4a4d2ac0b2fb9d31721":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test case for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test case for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test case for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test case for L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(36, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\n\t\t// Test case for negative and mixed values\n\t\t{[]float64{-1, 0, 1}, 1, 2},\n\t\t{[]float64{-1, 0, 1}, 2, 1.4142135623730951}, // sqrt(2)\n\t\t{[]float64{-1, 0, 1}, math.Inf(1), 1},\n\n\t\t// Test case for large values\n\t\t{[]float64{1e10, 2e10, 3e10}, 1, 6e10},\n\t\t{[]float64{1e10, 2e10, 3e10}, 2, math.Sqrt(14e20)},\n\t\t{[]float64{1e10, 2e10, 3e10}, math.Inf(1), 3e10},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif !floatEqual(got, tt.want) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","a521218401b9b8dba09f0819080b73d1":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // L2 distance\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3, // max absolute difference\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        3,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:     []float64{1, 2},\n\t\t\tt:     []float64{1},\n\t\t\tL:     1,\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v with L=%v, but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","a54d54664865f2c31b2989b19aa1f707":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(tt.expected[i]) {\n\t\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\t\tt.Errorf(\"expected NaN at index %d, got %v\", i, result[i])\n\t\t\t\t\t}\n\t\t\t\t} else if result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v at index %d, got %v\", tt.expected[i], i, result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","a5e41a7195939f58c03fbd26820a8ba7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Middle value\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closer to first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closer to last element\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Below the range\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Above the range\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Exact match\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0}, // All elements the same\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n\n\t// Test NaN value\n\tif gotIdx := NearestIdx([]float64{1.0, 2.0, 3.0}, math.NaN()); gotIdx != 0 {\n\t\tt.Errorf(\"NearestIdx with NaN = %d; want 0\", gotIdx)\n\t}\n\n\t// Test positive infinity\n\tif gotIdx := NearestIdx([]float64{1.0, 2.0, 3.0}, math.Inf(1)); gotIdx != 2 {\n\t\tt.Errorf(\"NearestIdx with +Inf = %d; want 2\", gotIdx)\n\t}\n\n\t// Test negative infinity\n\tif gotIdx := NearestIdx([]float64{1.0, 2.0, 3.0}, math.Inf(-1)); gotIdx != 0 {\n\t\tt.Errorf(\"NearestIdx with -Inf = %d; want 0\", gotIdx)\n\t}\n}","a69b30c54f2b14f26c3f18c8767573b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test cases for L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 1, 9, false},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 1, 0, false},\n\n\t\t// Test cases for L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 2, 0, false},\n\n\t\t// Test cases for infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, math.Inf(1), 3, false},\n\n\t\t// Test cases for general L-norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0), false},\n\t\t{[]float64{1, 2}, []float64{1, 2}, 3, 0, false},\n\n\t\t// Test case for panic due to length mismatch\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t\t{[]float64{1}, []float64{1, 2}, 1, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v with L=%v, but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","a7d15f2cc559aa317134a3b5cf5abf3b":"// File: sub_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\ts       []float64\n\t\twant    []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:     []float64{5.0, 6.0, 7.0},\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\twant:    []float64{4.0, 4.0, 4.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{10.0, 20.0},\n\t\t\ts:       []float64{5.0, 15.0},\n\t\t\twant:    []float64{5.0, 5.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1.0},\n\t\t\ts:       []float64{1.0},\n\t\t\twant:    []float64{0.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1.0, 2.0},\n\t\t\ts:       []float64{1.0},\n\t\t\twant:    nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{},\n\t\t\ts:       []float64{},\n\t\t\twant:    []float64{},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Sub() did not panic for dst: %v, s: %v\", tt.dst, tt.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tSub(tt.dst, tt.s)\n\n\t\tif !tt.wantPanic {\n\t\t\tfor i, v := range tt.want {\n\t\t\t\tif tt.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","a9d4441a857e403200ecd0cceab9906d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        10,\n\t\t\texpected: []float64{5, 10},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","aaf32cd17c4604ddafa4458bb47ea3c4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{10, 10, 10, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","ab7dc606c0b084ab5d94a2ed91fc6c4b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{4, 8, 12},\n\t\t\tt:         []float64{2, 4, 6},\n\t\t\texpected:  []float64{2, 2, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ts:         []float64{4, 8, 12},\n\t\t\tt:         []float64{2, 4, 6},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true, // dst length does not match s\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{4, 8},\n\t\t\tt:         []float64{2, 4},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true, // s length does not match t\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{0, 0, 0},\n\t\t\tt:         []float64{1, 1, 1},\n\t\t\texpected:  []float64{0, 0, 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{0, 0, 0},\n\t\t\texpected:  []float64{0, 0, 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v\", test.s, test.t)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tDivTo(test.dst, test.s, test.t)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := DivTo(test.dst, test.s, test.t)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For input s: %v, t: %v, expected %v, got %v\", test.s, test.t, test.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","abb812288b8de738509d66c3ec95412e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Closest to 2.0 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, math.Inf(-1), 0}, // Negative infinity case\n\t\t{[]float64{math.Inf(-1), 0.0, math.Inf(1)}, math.Inf(1), 2}, // Positive infinity case\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","adc5acf237e9d9e0b0eaa3cab7609c7a":"package floats\n\nimport (\n\t\"testing\"\n)\n\ntype argsort struct {\n\tinds []int\n}\n\nfunc (a argsort) Swap(i, j int) {\n\ta.inds[i], a.inds[j] = a.inds[j], a.inds[i]\n}\n\nfunc TestSwap(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\ti, j     int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"swap first and last\",\n\t\t\tinds:     []int{0, 1, 2, 3},\n\t\t\ti:        0,\n\t\t\tj:        3,\n\t\t\texpected: []int{3, 1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"swap middle elements\",\n\t\t\tinds:     []int{0, 1, 2, 3},\n\t\t\ti:        1,\n\t\t\tj:        2,\n\t\t\texpected: []int{0, 2, 1, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"swap same elements\",\n\t\t\tinds:     []int{0, 1, 2, 3},\n\t\t\ti:        1,\n\t\t\tj:        1,\n\t\t\texpected: []int{0, 1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"swap out of bounds\",\n\t\t\tinds:     []int{0, 1, 2, 3},\n\t\t\ti:        -1,\n\t\t\tj:        4,\n\t\t\texpected: []int{0, 1, 2, 3}, // should not change\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ta := argsort{inds: tt.inds}\n\t\t\ta.Swap(tt.i, tt.j)\n\n\t\t\tif !equalSlices(a.inds, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, a.inds)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","af54b607219a486ffb62bfa2478b3568":"// equal_lengths_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // Single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Two slices of unequal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false}, // Three slices of unequal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true}, // Three slices of equal length\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","af91ec866fc2f872635e8cfdd90e66fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\ts1      []float64\n\t\ts2      []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{1.0}, []float64{1.0}, true},\n\t\t{[]float64{1.0}, []float64{2.0}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Equal(test.s1, test.s2)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Equal(%v, %v) = %v; expected %v\", test.s1, test.s2, result, test.expected)\n\t\t}\n\t}\n}","afb6691cc094d2b363d8525e14a19ac8":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCumSum(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: []float64{1, 3, 6, 10, 15},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\ts:        []float64{10, 20, 30},\n\t\t\texpected: []float64{10, 30, 60},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\ts:        []float64{0, 0, 0, 0},\n\t\t\texpected: []float64{0, 0, 0, 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tCumSum(test.dst, test.s)\n\t\tfor i, v := range test.expected {\n\t\t\tif test.dst[i] != v {\n\t\t\t\tt.Errorf(\"CumSum(%v, %v) = %v; expected %v\", test.dst, test.s, test.dst, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length mismatch did not occur\")\n\t\t}\n\t}()\n\tCumSum(make([]float64, 3), []float64{1, 2})\n}","afc5e1b592f391571a48959e2f9e490f":"// count_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"Count positives\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{1.0, -2.0, 3.0, 0.0, 4.5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Count negatives\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003c 0\n\t\t\t},\n\t\t\ts:        []float64{-1.0, -2.0, 3.0, 0.0, -4.5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Count zeros\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x == 0\n\t\t\t},\n\t\t\ts:        []float64{0.0, -2.0, 3.0, 0.0, 4.5},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Count all positives\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Count no positives\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Count NaN values\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x != x // NaN check\n\t\t\t},\n\t\t\ts:        []float64{1.0, 2.0, 3.0, float64(0)/0.0, 4.5},\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Count(tt.f, tt.s)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Count() = %d, expected %d\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","b023a706762e4bc46743e63893e9d4ca":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\tpanic     bool\n\t}{\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\texpected: []float64{4, 10, 18},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{3, 4},\n\t\t\texpected: []float64{3, 8},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{3, 4},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v, t: %v\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := MulTo(test.dst, test.s, test.t)\n\t\tif !test.panic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For dst: %v, s: %v, t: %v, expected %v, got %v\", test.dst, test.s, test.t, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b057253b10925d31efe70b9b96fdeb78":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 3.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n\n\t// Test panic for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for empty slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{})\n}","b0f9a3504d61dd97d7d30c129c71d603":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Normal case\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0}, // Edge case: v == s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // Edge case: v == s[len(s)-1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // Edge case: v \u003e s[len(s)-1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // Edge case: v \u003c s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // Edge case: v is NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","b1237c007a154e7551e96e4abef395ac":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2},\n\t\t{[]float64{1.0, 2.0, 3.0, 2.5}, 2.5, 3},\n\t\t{[]float64{1.0, 2.0, math.NaN(), 3.0}, 2.5, 1},\n\t\t{[]float64{math.Inf(-1), 0, math.Inf(1)}, -1.0, 0},\n\t\t{[]float64{math.Inf(-1), 0, math.Inf(1)}, 1.0, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"zero length slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 1.0)\n\t})\n}","b171a68a65a0482c47261417a55b4971":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between middle and upper\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity value\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Negative infinity value\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","b19603c719cd669e4b4e7417b1673a44":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // v is between s[0] and s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // v is between s[1] and s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v is equal to s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v is less than s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v is greater than s[2]\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0}, 1.0)\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0}, 2.0)\n}","b1c211d15e5b97db52c1164cf02ab259":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{3, 1, 3, 2, 1}, // Edge case with smaller n\n\t\t{2, 1, 3, 1, 0}, // Edge case with n = 2\n\t\t{2, 1, 3, 3, 1}, // Edge case with n = 2 at upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","b213bf54d996e0039fda47719746bfab":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1e10, 1e10}, 3e10},\n\t\t{[]float64{1.0, 1e-10, -1.0}, 1e-10},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 4.0},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.Inf(1)},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN for input %v, got %v\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"Expected %v for input %v, got %v\", test.expected, test.input, result)\n\t\t}\n\t}\n}","b24730c325c23f8e9cf5a440666a54cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v, but did not panic\", test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","b247c18384f0d8daf42cbf9e1815e8cd":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1e10, 1e10}, 3e10},\n\t\t{[]float64{1.0, 1e-10, 1.0}, 2.0},\n\t\t{[]float64{1.0, -1.0, 1.0}, 1.0},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.Inf(1)},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{}, 0.0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected NaN\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","b274b8c757536346f03da55ed0a60c98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds, middle value\n\t\t{5, 10, 0, 10, 0}, // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4}, // Reverse bounds, upper bound\n\t\t{5, 10, 0, -1, 4}, // Reverse bounds, below lower bound\n\t\t{5, 10, 0, 11, 0}, // Reverse bounds, above upper bound\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{3, 0, 10, 0, 0}, // Edge case with n=3, lower bound\n\t\t{3, 0, 10, 10, 2}, // Edge case with n=3, upper bound\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2, upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","b2b41c0984a6fc130569c29ce9ac8aed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, l: %v, u: %v, but did not panic\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For dst: %v, l: %v, u: %v, expected: %v, got: %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","b39b4e92d68ff04931e1f9c49dce0d52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test case: L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t// Test case: L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t// Test case: L-infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t// Test case: Zero length slices (should panic)\n\t\t{[]float64{}, []float64{}, 1, 0, true},\n\t\t// Test case: Mismatched lengths (should panic)\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t\t// Test case: Empty slice with non-zero L (should return 0)\n\t\t{[]float64{}, []float64{1, 2, 3}, 1, 0, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","b40f3129f28d9f1eeaeb9805d894b2d5":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // sqrt((4-1)^2 + (5-2)^2 + (6-3)^2)\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 3, // max(|4-1|, |5-2|, |6-3|)\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length mismatch, but did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}","b453eeefaf291a83ffcb9e4516aac460":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.1, 3}, // Just above middle\n\t\t{5, 0, 10, 4.9, 2}, // Just below middle\n\t\t{3, 0, 10, 5, 1}, // Edge case with 3 points\n\t\t{2, 0, 10, 5, 1}, // Edge case with 2 points\n\t\t{2, 0, 10, 0, 0}, // Edge case with 2 points at lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with 2 points at upper bound\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Edge case with infinities\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1}, // Edge case with reversed infinities\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","b4b092207079221ea52e0eecea53fb6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test case: L1 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 1, expected: 9},\n\t\t// Test case: L2 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 2, expected: math.Sqrt(27)},\n\t\t// Test case: L-infinity norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: math.Inf(1), expected: 3},\n\t\t// Test case: L3 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 3, expected: math.Pow(27, 1.0/3.0)},\n\t\t// Test case: Zero-length slices\n\t\t{s: []float64{}, t: []float64{}, L: 1, expected: 0},\n\t\t// Test case: Mismatched lengths (should panic)\n\t\t{s: []float64{1, 2}, t: []float64{1}, L: 1, panic: true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","b517facd54cabc2f4032e18bd4d107cd":"// mul_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0, 5.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{2.0, 3.0, 4.0},\n\t\t\ts:        []float64{0.0, 0.0, 0.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"Expected dst[%d] = %v, got %v\", i, v, test.dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","b62580acc0fe992fad3b01981ef69e94":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\texpected:  []float64{5, 7, 9},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{1, 2},\n\t\t\tt:         []float64{4, 5},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ts:         []float64{},\n\t\t\tt:         []float64{},\n\t\t\texpected:  []float64{0, 0, 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input dst: %v, s: %v, t: %v\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := AddTo(test.dst, test.s, test.t)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input dst: %v, s: %v, t: %v, expected %v, got %v\", test.dst, test.s, test.t, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b62c0496f8758e4bda8819180b790391":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // L2 distance\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, -2, 3},\n\t\t\tt:       []float64{-4, 5, -6},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 7, // Maximum absolute difference\n\t\t},\n\t\t{\n\t\t\ts:       []float64{},\n\t\t\tt:       []float64{},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length mismatch, but did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}","b7f2edbdc613f82d19b5b99c215ff5f3":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","b89f9f1089868798b9e02bcd5e68794b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{-10, -5, 0, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 1.8, 2.6, 3.4, 4.2, 5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.Abs(result[i]-test.expected[i]) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","b8a05ba3a712e311a1d2e9009147f26b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\tpanic    bool\n\t}{\n\t\t// Valid cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1, false}, // Edge case, should return -1\n\n\t\t// Panic cases\n\t\t{[]float64{1.0}, 1.0, -1, true}, // len(s) \u003c 2\n\t\t{[]float64{3.0, 1.0}, 2.0, -1, true}, // s is not sorted\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1, true}, // v is NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1, false}, // v \u003c s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1, false}, // v \u003e= s[len(s)-1]\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, but did not panic\", test.s, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Within(test.s, test.v)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n}","b90b25d30caac34e602553815fe2c041":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, 1e-10}, 1e10 + 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.MaxFloat64 + math.MaxFloat64},\n\t\t{[]float64{math.SmallestNonzeroFloat64, math.SmallestNonzeroFloat64}, 2 * math.SmallestNonzeroFloat64},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif !floatEqual(result, test.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare floating point numbers for equality\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-10\n\treturn math.Abs(a-b) \u003c epsilon\n}","ba6c5492461668b1361d8b51e520bf52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: %+v, but did not panic\", test)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic {\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For input %+v, expected %v, got %v\", test, test.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","bd09c4b3139e4799017cb559fa235589":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic when length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test for NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","bd0baf941d695935d5dc6dc476aff106":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Closer to upper half\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2 at lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2 at upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // Upper bound NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Both bounds are Inf\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4}, // Both bounds are Inf in reverse\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","bdbac0eb9fce9bd1874ee7d0e7ca5d5a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\talpha     float64\n\t\ts         []float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       []float64{1.0, 2.0, 3.0},\n\t\t\talpha:     2.0,\n\t\t\ts:         []float64{4.0, 5.0, 6.0},\n\t\t\texpected:  []float64{9.0, 12.0, 15.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0.0, 0.0},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{1.0, 1.0},\n\t\t\texpected:  []float64{1.0, 1.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{1.0},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{2.0},\n\t\t\texpected:  []float64{3.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{1.0, 2.0},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{1.0},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{},\n\t\t\texpected:  []float64{},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, alpha: %v, s: %v\", test.dst, test.alpha, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tAddScaled(test.dst, test.alpha, test.s)\n\n\t\tif !test.expectPanic {\n\t\t\tfor i, v := range test.dst {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For dst: %v, alpha: %v, s: %v, expected %v, got %v\", test.dst, test.alpha, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","bf076eed918d7c3223f67e7e25518cf2":"// file: same_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tslice1 []float64\n\t\tslice2 []float64\n\t\twant   bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, []float64{1.0, 2.0, math.NaN()}, true},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{math.NaN(), 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{math.NaN()}, []float64{math.NaN()}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{3.0, 2.0, 1.0}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.slice1, tt.slice2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.slice1, tt.slice2, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfda35f3c18a5baeca503393dbab6526":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tdst := make([]float64, 5)\n\tSpan(dst, math.NaN(), 5)\n\tfor _, v := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(v) {\n\t\t\tt.Errorf(\"expected NaN, got %v\", v)\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 5 {\n\t\tt.Errorf(\"expected %v, got %v\", 5, dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.NaN())\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"expected %v, got %v\", 0, dst[0])\n\t}\n\n\t// Test Inf cases\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := range dst {\n\t\tif dst[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"expected %v, got %v\", math.Inf(1), dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\tfor i := range dst {\n\t\tif dst[i] != math.Inf(-1) {\n\t\t\tt.Errorf(\"expected %v, got %v\", math.Inf(-1), dst[i])\n\t\t}\n\t}\n}","c0ec03dca8cd07a84c9284fb4860376c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between bounds\n\t\t{5, -10, 0, -5, 2}, // Negative range\n\t\t{5, -10, 0, -10, 0}, // Negative lower bound\n\t\t{5, -10, 0, 0, 4}, // Negative upper bound\n\t\t{3, 1, 2, 1.5, 1}, // Edge case with 3 points\n\t\t{2, 1, 2, 1.5, 0}, // Edge case with 2 points\n\t\t{2, 1, 2, 1, 0}, // Exact lower bound with 2 points\n\t\t{2, 1, 2, 2, 1}, // Exact upper bound with 2 points\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","c0edc28b0bb8ad039cd83dc2899be0c1":"// mul_to_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\texpected  []float64\n\t\tpanic     bool\n\t}{\n\t\t{\n\t\t\tdst:     []float64{1, 2, 3},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\texpected: []float64{4, 10, 18},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{0, 0, 0},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{3, 4},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for inputs: dst=%v, s=%v, t=%v\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := MulTo(test.dst, test.s, test.t)\n\t\tif !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For inputs: dst=%v, s=%v, t=%v, expected %v, got %v\", test.dst, test.s, test.t, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 { // Use a tolerance for float comparison\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c219c9759b2b913ab17a36a30c8a5282":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // no input slices\n\t\t{[][]float64{{1.0}}, true}, // single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // two slices of equal length\n\t\t{[][]float64{{1.0}, {2.0, 3.0}}, false}, // two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0, 5.0}}, false}, // two slices of different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true}, // three slices of equal length\n\t\t{[][]float64{{1.0}, {2.0}, {3.0, 4.0}}, false}, // three slices, one different length\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c245931e3d9384bd8814b85c1d7c28c5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Normal cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0}, // Closest to 1.0 is 1.0 at index 0\n\n\t\t// Edge cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, should return 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity case, should return index of max\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity case, should return index of min\n\n\t\t// Panics\n\t}\n\n\tfor _, test := range tests {\n\t\tif len(test.s) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v\", test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", test.s, test.v, result, test.expect)\n\t\t}\n\t}\n}","c319c9163393d0f1a232cc36990f80f8":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif !floatEqual(result[i], test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","c36fad062905512cad6644b00bea6fb9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4}, // Reverse bounds, upper bound\n\t\t{5, 10, 0, -1, 4}, // Reverse bounds, below lower\n\t\t{5, 10, 0, 11, 0}, // Reverse bounds, above upper\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{2, 0, 10, 5, 1}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1}, // Edge case with n=2, upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN handling\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN, got %d\", result)\n\t}\n}","c424d8a35f7c8b05e45733b34ada50f6":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},       // Closer to upper half\n\t\t{3, 0, 10, 5, 1},         // Odd number of points\n\t\t{3, 10, 0, 5, 1},         // Reverse bounds\n\t\t{3, math.NaN(), 10, 5, 2}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{3, math.Inf(-1), math.Inf(1), 1, 1}, // Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","c4347345bb3b757aabbc440dd959adf5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4}, // Normal case\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0}, // Descending order\n\t\t{[]float64{1.0, 3.0, 3.0, 2.0}, 1},      // Multiple max values\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 2},    // NaN at the start\n\t\t{[]float64{1.0, math.NaN(), 3.0}, 2},    // NaN in the middle\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 1},     // NaN at the end\n\t\t{[]float64{math.NaN(), math.NaN()}, -1}, // All NaN values\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expected == -1 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not panic\", test.input)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c44e095c6325fd9ca41dd7c3957a9234":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // Single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two equal length slices\n\t\t{[][]float64{{1.0}, {2.0, 3.0}}, false}, // Two unequal length slices\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two equal length slices\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false}, // Three slices, unequal lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true}, // Three equal length slices\n\t\t{[][]float64{{1.0}, {2.0}, {3.0}, {4.0}}, true}, // Four equal length slices\n\t\t{[][]float64{{1.0}, {2.0}, {3.0, 4.0}, {5.0}}, false}, // Four slices, one unequal\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c50cc8843b4580e570dbf84f66a3386f":"// file: find_test.go\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first three even numbers with insufficient elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 0},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find no elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first element greater than 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 3 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{3},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) || !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c5390b0747a0390f595f5a93fd3be797":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 3},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif !equal(v, test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc equal(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","c63de35547795507c7e26f34c81f2123":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{5.0, 6.0, 7.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{4.0, 4.0, 4.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10.0, 20.0},\n\t\t\ts:        []float64{5.0, 15.0},\n\t\t\texpected: []float64{5.0, 5.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: []float64{0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tSub(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","c66f332326724bc488067fc1ae2dee45":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{1, 3.1622776601683795, 10, 31.622776601683793, 100},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        10,\n\t\t\tu:        1000,\n\t\t\texpected: []float64{10, 31.622776601683793, 1000},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        0,\n\t\t\tu:        100,\n\t\t\texpected: []float64{0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -10,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSpan(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tLogSpan(make([]float64, 1), 1, 10)\n}","c67238fc1cdc7f32abd6e8a9759afd8f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\tt.Errorf(\"expected NaN at index %d, got %v\", i, result[i])\n\t\t\t\t}\n\t\t\t} else if result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"expected %v at index %d, got %v\", test.expected[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","c68f0eeab1152e158103052b21dc3f6f":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0},\n\t\t\texpected: []float64{3.0, 8.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{2.0, 3.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","c6e905e1ad53e35ccd01273d9f1d7878":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reverse\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reverse\n\t\t{5, 10, 0, 11, 0}, // Above upper bound with reverse\n\t\t{5, 10, 0, -1, 4}, // Below lower bound with reverse\n\t\t{3, 1, 2, 1.5, 1}, // Edge case with n=3\n\t\t{2, 1, 2, 1.5, 0}, // Edge case with n=2\n\t\t{2, 1, 2, 1, 0}, // Exact lower bound with n=2\n\t\t{2, 1, 2, 2, 1}, // Exact upper bound with n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", got)\n\t}\n}","c70bd4226e4382659ab756194d226ddb":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Normal case\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // v equals s[i]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v equals s[i+1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v \u003c s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v \u003e= s[len(s)-1]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Normal case\n\t\t{[]float64{1.0, 2.0, 2.0, 3.0}, 2.0, 1}, // Non-unique values\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", test.s, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Panic cases\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0}, 1.0) // Should panic\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice did not occur\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0}, 2.0) // Should panic\n}","c84004bbf3a69183c622f48e660f5b13":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Normal cases\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0)},\n\n\t\t// Edge cases\n\t\t{[]float64{}, []float64{}, 1, 0},\n\t\t{[]float64{1}, []float64{1}, 2, 0},\n\t\t{[]float64{1}, []float64{2}, 1, 1},\n\n\t\t// Panic cases\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t\t{[]float64{1}, []float64{1, 2}, 1, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","c9072aa3fc2774f4553a579a976d9871":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, l: %v, u: %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c9a488ed3661683813cdc9acf0983fe4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when length of dst is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","ca0939efcf7f3a8da4f08dbb68580e05":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts, t []float64\n\t\twant bool\n\t}{\n\t\t// Test cases with equal slices\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{0.0, 0.0, 0.0}, []float64{0.0, 0.0, 0.0}, true},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{math.NaN(), 2.0, 3.0}, true},\n\t\t{[]float64{1.0, math.NaN(), 3.0}, []float64{1.0, math.NaN(), 3.0}, true},\n\n\t\t// Test cases with different lengths\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\n\t\t// Test cases with different values\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 3.0, 2.0}, false},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, math.NaN()}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.s, tt.t)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ca5c8d4320f117c218de35798e287ba6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity value\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Negative infinity value\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","cad7b02fd7a43024f9e31aaa000ba4d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 3, 1}, // Closer to lower\n\t\t{5, 0, 10, 7, 3}, // Closer to upper\n\t\t{3, 1, 2, 1.5, 1}, // Edge case with 3 points\n\t\t{3, 1, 2, 1, 0}, // Exact lower bound with 3 points\n\t\t{3, 1, 2, 2, 2}, // Exact upper bound with 3 points\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","cb2f4ecce6f8ce30d05a1cb5dedc4149":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, -1}, // Edge case with duplicates\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","cb50929c3d31ad17a3f460bf88000ad7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64, 1.0}, math.MaxFloat64 + math.MaxFloat64},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, math.NaN()},\n\t\t{[]float64{}, 0.0}, // Edge case: empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v for input %v\", result, test.input)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %v, got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","cb535218c3f70cf84aad141358af65fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test case for L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t// Test case for L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t// Test case for L-infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t// Test case for a zero-length slice\n\t\t{[]float64{}, []float64{}, 1, 1, false},\n\t\t// Test case for mismatched lengths (should panic)\n\t\t{[]float64{1, 2}, []float64{1}, 1, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","cba9f4ddaeffe47ca5b276cb857f5a91":"// norm_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1 (Manhattan norm)\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2 (Euclidean norm)\n\t\t{[]float64{3, 4}, 2, 5},\n\t\t{[]float64{0, 0}, 2, 0},\n\t\t{[]float64{1, 2, 2}, 2, 3},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test cases for L = math.Inf(1) (Maximum norm)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for general L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cbb8d4e698be7f05734f9a6261da1335":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","cd1af6b4b2cac1a9911a1fa1e5f63565":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},         // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},         // Closer to upper half\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf upper\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Inf lower\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // Both NaN\n\t\t{3, 0, 10, 5, 1},           // Edge case with n=3\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v; expected %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","cd2551357bf5a4761b1d93b27199cd8e":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1e10, 1e10}, 3e10},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{1.0, 1.0, 1.0, 1.0}, 4.0},\n\t\t{[]float64{}, 0.0}, // Test for empty slice\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()}, // Test for NaN\n\t\t{[]float64{math.Inf(1), 1.0}, math.Inf(1)}, // Test for positive infinity\n\t\t{[]float64{math.Inf(-1), -1.0}, math.Inf(-1)}, // Test for negative infinity\n\t\t{[]float64{1.0, -1.0, 1.0, -1.0}, 0.0}, // Test for cancellation\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif !equal(result, test.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare float64 values for equality, accounting for NaN\nfunc equal(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","cd59b1cd0bb3ec2ddb479fb44184b611":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // L2 distance\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 3, // Maximum absolute difference\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, -2, 3},\n\t\t\tt:       []float64{-1, 2, -3},\n\t\t\tL:       1,\n\t\t\texpected: 8,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{0, 0, 0},\n\t\t\tt:       []float64{0, 0, 0},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic for mismatched lengths\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}","cdbdf12b54f31cf75f3fe8b5f104b1b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(test.expected[i]) || !math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","cec8ccef0f30afa2aa52c89fdd1aaf3a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 6},                          // L1 norm\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},             // L2 norm\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)}, // L3 norm\n\t\t{[]float64{1, -2, 3}, 1, 6},                         // L1 norm with negative\n\t\t{[]float64{-1, -2, -3}, 1, 6},                       // L1 norm with all negative\n\t\t{[]float64{0, 0, 0}, 1, 0},                          // L1 norm with zeros\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},               // L-infinity norm\n\t\t{[]float64{}, 1, 0},                                // Empty slice\n\t\t{[]float64{math.NaN(), 1, 2}, 1, 3},                // NaN handling\n\t\t{[]float64{math.Inf(1), 1, 2}, 1, math.Inf(1)},     // Inf handling\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Norm(tt.slice, tt.L)\n\t\t\tif !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floating point numbers for equality\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","ced77cd244892a4bc6b7d487dd1b6d4a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tc        float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tc:        2,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 1, 1},\n\t\t\tc:        0.5,\n\t\t\ts:        []float64{2, 4, 6},\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 2},\n\t\t\tc:        3,\n\t\t\ts:        []float64{4, 5},\n\t\t\texpected: []float64{12, 15},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := ScaleTo(test.dst, test.c, test.s)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ScaleTo did not panic for mismatched lengths\")\n\t\t}\n\t}()\n\tScaleTo([]float64{1}, 1, []float64{1, 2})\n}","cee9aea2c702fc18ba210f59a68d56ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","cf3d2ac834f186c8f0097e850e7bbbbe":"// equal_func_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tf        func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal with NaN\",\n\t\t\ts1:       []float64{1.0, 2.0, float64(0) / float64(0)}, // NaN\n\t\t\ts2:       []float64{1.0, 2.0, float64(0) / float64(0)}, // NaN\n\t\t\tf:        func(a, b float64) bool { return (a != a \u0026\u0026 b != b) || a == b }, // Handle NaN\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"One empty slice\",\n\t\t\ts1:       []float64{1.0},\n\t\t\ts2:       []float64{},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.s1, tt.s2, tt.f)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v) = %v; want %v\", tt.s1, tt.s2, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","cfbb4651815b01c03980fee9bcea668b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, 3, 1},           // Closer to lower bound\n\t\t{5, 0, 10, 7, 3},           // Closer to upper bound\n\t\t{5, 0, 10, 5.5, 2},         // Between two points\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 2}, // Inf bounds, middle value\n\t\t{5, math.Inf(-1), math.Inf(1), 5, 4}, // Inf bounds, above\n\t\t{5, math.Inf(-1), math.Inf(1), -5, 0}, // Inf bounds, below\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","cfc03b5acebd84a7b4d5789bde286391":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find more elements than available\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"find zero elements requested\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first element that is greater than 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 3 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{3},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equal(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d00820bb1a4bd89672dcb2c82326bc12":"// mul_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0, 5.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{2.0},\n\t\t\texpected: []float64{2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.dst {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","d03fbbedb07ba59353ee3aa2469554c4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is zero\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"not enough elements found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first element greater than 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{2},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d0618cf3772a1cbdb3f414697491934f":"// file: find_test.go\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first three even numbers with insufficient elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 0},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"find no elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"k is zero\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) || !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d1ae84045c77da5ac561a7f186238cb5":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, -1, 0},       // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},      // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},      // Closer to upper half\n\t\t{3, 0, 10, 5, 1},        // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},        // Edge case with reversed bounds\n\t\t{2, 0, 10, 5, 0},        // Edge case with n=2\n\t\t{2, 10, 0, 5, 0},        // Edge case with reversed bounds and n=2\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","d1e51f3ebef2601345a50316d8222b28":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Normal case\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))}, // Negative values\n\t\t{[]float64{0, 0, 0}, 0}, // All zeros\n\t\t{[]float64{math.Inf(1), 1}, math.Inf(1)}, // Positive infinity\n\t\t{[]float64{math.Inf(-1), -1}, math.Inf(-1)}, // Negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif !floatEqual(result, test.expected) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for empty slice, but did not panic\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// Helper function to compare floating point numbers\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-10\n\treturn math.Abs(a-b) \u003c epsilon\n}","d21d94f17836ef34ef6e24fe8f5c1794":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"No slices\", [][]float64{}, true},\n\t\t{\"One empty slice\", [][]float64{{}}, true},\n\t\t{\"One non-empty slice\", [][]float64{{1.0, 2.0, 3.0}}, true},\n\t\t{\"Two equal length slices\", [][]float64{{1.0, 2.0}, {3.0, 4.0}}, true},\n\t\t{\"Two unequal length slices\", [][]float64{{1.0}, {2.0, 3.0}}, false},\n\t\t{\"Three equal length slices\", [][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true},\n\t\t{\"Three unequal length slices\", [][]float64{{1.0, 2.0}, {3.0}, {4.0, 5.0}}, false},\n\t\t{\"Multiple equal length slices\", [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}}, true},\n\t\t{\"Multiple unequal length slices\", [][]float64{{1.0, 2.0}, {3.0, 4.0, 5.0}, {6.0}}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d2d4683e15ed6c7820e9cc788de1ae6c":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first two even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find more elements than available\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find zero elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first element greater than 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 3 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{3},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tif (err == nil \u0026\u0026 tt.err != nil) || (err != nil \u0026\u0026 tt.err == nil) || (err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d3f731fcec5e030b686db890c77b0152":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2}, // Closest to 3.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Closest to 0.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closest to 1.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case, returns index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity case\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity case\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 len(test.s) == 0 {\n\t\t\t\t\t// Expected panic for zero length slice\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","d472e2d93552a6c0dda8754ae8121fc6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       4,\n\t\t\twant:    []float64{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{1, 1, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       -1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{-1, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       1,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\twant:    []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       0,\n\t\t\twant:    []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantErr {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic for dst: %v, l: %v, u: %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !tt.wantErr \u0026\u0026 !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","d54d5f470d5f7010a1f68fb43aacbcd4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, -1, 0},       // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, 0, 10, 3, 1},        // Between lower and upper\n\t\t{5, 0, 10, 7, 3},        // Closer to upper\n\t\t{5, 10, 0, 5, 2},        // Reverse bounds\n\t\t{5, 10, 0, 10, 0},       // Reverse bounds, lower\n\t\t{5, 10, 0, 0, 4},        // Reverse bounds, upper\n\t\t{5, 10, 0, 11, 0},       // Reverse bounds, above upper\n\t\t{5, 10, 0, -1, 4},       // Reverse bounds, below lower\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), 10, 5, 0}, // Negative infinity lower bound\n\t\t{5, 0, math.Inf(1), 5, 4}, // Positive infinity upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","d54f36e019297f6ad65085cc8a881991":"// equal_approx_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\ts1, s2 []float64\n\t\ttol    float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  1e-10,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.1},\n\t\t\ttol:  0.1,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.1, 3.0},\n\t\t\ttol:  0.05,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0},\n\t\t\ttol:  1e-10,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\ttol:  1e-10,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  0.0,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0000001},\n\t\t\ttol:  1e-7,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0001},\n\t\t\ttol:  1e-5,\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := EqualApprox(tt.s1, tt.s2, tt.tol)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %v) = %v; want %v\", tt.s1, tt.s2, tt.tol, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d7391925b9ae35074c2ad1cdf8cee8b0":"// equal_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{1.0}, []float64{1.0}, true},\n\t\t{[]float64{1.0}, []float64{2.0}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Equal(test.s1, test.s2)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Equal(%v, %v) = %v; expected %v\", test.s1, test.s2, result, test.expected)\n\t\t}\n\t}\n}","d799b91a3bd21a0eb9863753a3943661":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, 15, 4},        // Above upper bound\n\t\t{5, 0, 10, -5, 0},        // Below lower bound\n\t\t{5, 10, 0, 5, 2},         // Reverse bounds\n\t\t{5, 10, 0, 10, 0},        // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},         // Reverse bounds, upper bound\n\t\t{5, 10, 0, -5, 4},        // Reverse bounds, below lower bound\n\t\t{5, 10, 0, 15, 0},        // Reverse bounds, above upper bound\n\t\t{3, 0, 10, 5, 1},         // Edge case with n=3\n\t\t{3, 0, 10, 0, 0},         // Edge case with n=3, lower bound\n\t\t{3, 0, 10, 10, 2},        // Edge case with n=3, upper bound\n\t\t{2, 0, 10, 5, 1},         // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},         // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1},        // Edge case with n=2, upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value, got %d\", result)\n\t}\n}","d7b6ea6bd6829ec9f86229042aa6cc5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{5, 10, 0, 5, 2},          // Reversed bounds\n\t\t{5, 10, 0, 10, 0},         // Reversed bounds, lower bound\n\t\t{5, 10, 0, 0, 4},          // Reversed bounds, upper bound\n\t\t{5, 10, 0, 11, 0},         // Reversed bounds, above upper\n\t\t{5, 10, 0, -1, 4},         // Reversed bounds, below lower\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), -1, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t\t{2, 0, 10, 5, 1},          // Edge case with n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","d8099fc547bc3e0cba409e34e0be5d49":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        10,\n\t\t\texpected: []float64{2, 4, 6, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","d91536c4291955fa1cb968ab179e0f7a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},       // Middle value\n\t\t{5, 0, 10, 0, 0},       // Lower bound\n\t\t{5, 0, 10, 10, 4},      // Upper bound\n\t\t{5, 0, 10, -1, 0},      // Below lower bound\n\t\t{5, 0, 10, 11, 4},      // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},     // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},     // Closer to upper half\n\t\t{3, 0, 10, 5, 1},       // Edge case with n=3\n\t\t{3, 10, 0, 5, 1},       // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 0},       // Edge case with n=2\n\t\t{2, 10, 0, 5, 0},       // Edge case with inverted bounds and n=2\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Inverted Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","d9c055ec104c56718a9f735546ef9f34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 10, 0, 5, 2},           // Reverse bounds\n\t\t{5, 10, 0, 10, 0},          // Reverse bounds, upper\n\t\t{5, 10, 0, 0, 4},           // Reverse bounds, lower\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // Infinity bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse infinity bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","db0efa97eac5aa38beace3d862c72995":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 10, 0, 5, 2}, // Reversed bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with reversed bounds\n\t\t{5, 10, 0, 0, 4}, // Upper bound with reversed bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Negative infinity lower bound\n\t\t{5, math.Inf(-1), math.Inf(1), 10, 4}, // Positive infinity upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), math.NaN(), 0}, // NaN value\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","dc0c51f114dd31f4e8df118530ca14e5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 0, 10, 5, 1},          // Edge case with 3 points\n\t\t{3, 10, 0, 5, 2},          // Reverse bounds\n\t\t{2, 0, 10, 5, 0},          // Edge case with 2 points\n\t\t{2, 10, 0, 5, 1},          // Reverse bounds with 2 points\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4}, // Reverse Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n = %d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","dc352efe1934cd3627e87fc74681474a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},               // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},               // Normal case with max at start\n\t\t{[]float64{1.0, 3.0, 3.0}, 1},               // Max value appears multiple times\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},            // All negative values\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1},       // NaN at the start\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 0},       // NaN in the middle\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 1},       // NaN at the end\n\t\t{[]float64{math.NaN(), math.NaN()}, 0},     // All NaN values\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.input == nil {\n\t\t\tt.Panic(\"input slice is nil\")\n\t\t}\n\t\tif len(test.input) == 0 {\n\t\t\tt.Panic(\"input slice is zero length\")\n\t\t}\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","dcd2c202fca790496c6f66029cca00a0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","dcfe3ecfae6fa288d7bcd0d33508722c":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    2,\n\t\t\tu:    8,\n\t\t\twant: []float64{2, 4, 6, 8},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","de0f41c026a90025ceeee7a8b47d9b51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 7.5, 3}, // Between lower and upper\n\t\t{5, 10, 0, 5, 2}, // Reverse bounds\n\t\t{5, 10, 0, 10, 0}, // Reverse bounds, lower\n\t\t{5, 10, 0, 0, 4}, // Reverse bounds, upper\n\t\t{5, 10, 0, 7.5, 3}, // Reverse bounds, between\n\t\t{3, 0, 10, 5, 1}, // Minimum valid n\n\t\t{3, 0, 10, 0, 0}, // Minimum valid n, lower bound\n\t\t{3, 0, 10, 10, 2}, // Minimum valid n, upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value for v\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", result)\n\t}\n}","df7fb887ea18e4ff6789fa276836ed07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        3,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{3, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        2,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        2,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{2, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(tt.expected[i]) {\n\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", tt.dst, tt.l, tt.u, result, tt.expected)\n\t\t\t\t}\n\t\t\t} else if result[i] != tt.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", tt.dst, tt.l, tt.u, result, tt.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","e0511d81fad1093714fcf21a2a02a933":"// File: prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                  // Edge case: empty slice\n\t\t{[]float64{1}, 1},                 // Single element\n\t\t{[]float64{2, 3}, 6},              // Two elements\n\t\t{[]float64{1, 2, 3, 4}, 24},       // Multiple elements\n\t\t{[]float64{-1, 2, -3}, 6},         // Negative and positive elements\n\t\t{[]float64{0, 1, 2}, 0},           // Zero in the slice\n\t\t{[]float64{1.5, 2.0, 2.5}, 7.5},   // Floating point numbers\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e0de08f91bb8621093aea8a6f6895828":"// argsort_test.go\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdst:      []float64{3.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5.0, 3.0, 4.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tinds:     make([]int, 5),\n\t\t\texpectedInds: []int{3, 4, 1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\texpected: []float64{1.0},\n\t\t\tinds:     make([]int, 1),\n\t\t\texpectedInds: []int{0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tArgsort(test.dst, test.inds)\n\n\t\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\t\tt.Errorf(\"expected dst %v, got %v\", test.expected, test.dst)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(test.inds, test.expectedInds) {\n\t\t\t\tt.Errorf(\"expected inds %v, got %v\", test.expectedInds, test.inds)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic on length mismatch\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic on length mismatch, but did not panic\")\n\t\t\t}\n\t\t}()\n\t\tArgsort([]float64{1.0, 2.0}, []int{0})\n\t})\n}","e23f0499b54dde9b7d452678e119f319":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},       // Closer to upper half\n\t\t{5, 10, 0, 5, 2},         // Reversed bounds\n\t\t{5, 10, 0, 10, 0},        // Reversed bounds, lower bound\n\t\t{5, 10, 0, 0, 4},         // Reversed bounds, upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf bounds, upper\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Inf bounds, lower\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(1, 0, 10, 5) but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","e25ace83e9153cf53faa9bc86e8579de":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},       // Closer to upper half\n\t\t{3, 1, 2, 1.5, 1},        // Edge case with smaller n\n\t\t{3, 1, 2, 1, 0},          // Exact lower bound with smaller n\n\t\t{3, 1, 2, 2, 2},          // Exact upper bound with smaller n\n\t\t{2, 1, 2, 1.5, 0},        // Edge case with n = 2\n\t\t{2, 1, 2, 1, 0},          // Exact lower bound with n = 2\n\t\t{2, 1, 2, 2, 1},          // Exact upper bound with n = 2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","e36e2d6500656f6ab7d05eebfb5207f7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to 3.5 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0}, // Closest to 0.5 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0}, // Closest to 1.0 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, 2}, // Closest to 4.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN case\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity case\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity case\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v\", test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif len(test.s) == 0 {\n\t\t\t\tNearestIdx(test.s, test.v)\n\t\t\t}\n\t\t})\n\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", test.s, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","e3d4b6f7a4af707bc819ae7f7d99fff2":"// norm_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test case for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for general L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(14, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}","e3debfe533834eb7a925993f5da8abed":"// argsort_test.go\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdst:      []float64{3.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5.0, 3.0, 8.0, 1.0},\n\t\t\texpected: []float64{1.0, 3.0, 5.0, 8.0},\n\t\t\tinds:     make([]int, 4),\n\t\t\texpectedInds: []int{3, 1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{0, 1, 2},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tArgsort(test.dst, test.inds)\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Expected dst %v, got %v\", test.expected, test.dst)\n\t\t}\n\t\tif !reflect.DeepEqual(test.inds, test.expectedInds) {\n\t\t\tt.Errorf(\"Expected inds %v, got %v\", test.expectedInds, test.inds)\n\t\t}\n\t}\n\n\t// Test for panic on mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths, but did not panic\")\n\t\t}\n\t}()\n\tArgsort([]float64{1.0, 2.0}, []int{0}) // This should panic\n}","e46741c04a2ae3e8fb5d63a0dfcf1389":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t\t{[]float64{1.0, 2.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0}, 2.0, -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %v; expected %v\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","e4b1a35bdcaef67e0246950a70f8a28b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4}, // Reverse Inf bounds\n\t\t{3, 1, 2, 1.5, 1},          // Edge case with n=3\n\t\t{2, 1, 2, 1.5, 0},          // Edge case with n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","e551b450b466d5af6639a408ad6d1cd2":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","e56decab21bda765dea786add27026fb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 2.5, 1}, // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3}, // Closer to upper half\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf upper bound\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), math.Inf(-1), 4}, // Reversed Inf upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","e5e9fa216268e609baeb416605b77cd2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, 0, 10, 11, 4},        // Above upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, 10, 0, 5, 2},         // Reversed bounds\n\t\t{5, 10, 0, 10, 0},        // Lower bound with reversed\n\t\t{5, 10, 0, 0, 4},         // Upper bound with reversed\n\t\t{5, 10, 0, 11, 0},        // Above upper bound with reversed\n\t\t{5, 10, 0, -1, 0},        // Below lower bound with reversed\n\t\t{3, 0, 10, 5, 1},         // Minimum valid n\n\t\t{3, 0, 10, 0, 0},         // Minimum valid n at lower bound\n\t\t{3, 0, 10, 10, 2},        // Minimum valid n at upper bound\n\t\t{2, 0, 10, 5, 1},         // Edge case with n = 2\n\t\t{2, 0, 10, 0, 0},         // Edge case with n = 2 at lower bound\n\t\t{2, 0, 10, 10, 1},        // Edge case with n = 2 at upper bound\n\t\t{2, 0, 10, 5.1, 1},       // Edge case with n = 2 just above middle\n\t\t{2, 0, 10, -0.1, 0},      // Edge case with n = 2 just below lower\n\t\t{2, 0, 10, 10.1, 1},      // Edge case with n = 2 just above upper\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","e7908f6ba9246e52947f0c450542ee07":"// prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                     // Test case for empty slice\n\t\t{[]float64{5}, 5},                    // Test case for single element\n\t\t{[]float64{1, 2, 3, 4}, 24},          // Test case for multiple elements\n\t\t{[]float64{0, 1, 2, 3}, 0},           // Test case with zero\n\t\t{[]float64{-1, -2, -3}, -6},          // Test case with negative numbers\n\t\t{[]float64{2, 2, 2, 2}, 16},          // Test case with repeated elements\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e7de2bec59d8d297fc181da6f481f74b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, y, s []float64\n\t\talpha     float64\n\t\texpected  []float64\n\t}{\n\t\t{\n\t\t\tdst:     []float64{1, 2, 3},\n\t\t\ty:       []float64{4, 5, 6},\n\t\t\ts:       []float64{1, 1, 1},\n\t\t\talpha:   2,\n\t\t\texpected: []float64{6, 7, 8}, // 4 + 2*1, 5 + 2*1, 6 + 2*1\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ty:       []float64{1, 2, 3},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\talpha:   1,\n\t\t\texpected: []float64{2, 4, 6}, // 1 + 1*1, 2 + 1*2, 3 + 1*3\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{5, 5, 5},\n\t\t\ty:       []float64{1, 2, 3},\n\t\t\ts:       []float64{0, 0, 0},\n\t\t\talpha:   10,\n\t\t\texpected: []float64{6, 7, 8}, // 1 + 10*0, 2 + 10*0, 3 + 10*0\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) = %v; want %v\", test.dst, test.y, test.alpha, test.s, result, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddScaledTo did not panic on mismatched lengths\")\n\t\t}\n\t}()\n\tAddScaledTo([]float64{1}, []float64{1, 2}, 1, []float64{1})\n}","e8244b76a457320d0ab3b95b58a6c2da":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{5, 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        10,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","e846085b6c4d3e90047c324e42424143":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","e84c735c076f2f8bd8d768404cfa6161":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{5, 0, 10, 2.5, 1},        // Closer to lower half\n\t\t{5, 0, 10, 7.5, 3},        // Closer to upper half\n\t\t{3, 1, 1, math.NaN(), 0},  // NaN value\n\t\t{3, math.NaN(), 1, 0, 2},  // NaN lower bound\n\t\t{3, 1, math.NaN(), 0, 0},  // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 2}, // Reverse Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","eaffafaa2e0ca1f7561e224cb9d3208c":"// prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                     // Test with an empty slice\n\t\t{[]float64{1, 2, 3}, 6},               // Test with positive numbers\n\t\t{[]float64{0, 1, 2}, 0},               // Test with zero in the slice\n\t\t{[]float64{-1, -2, -3}, -6},           // Test with negative numbers\n\t\t{[]float64{-1, 2, -3}, 6},             // Test with mixed signs\n\t\t{[]float64{2, 2, 2, 2}, 16},           // Test with repeated numbers\n\t\t{[]float64{1.5, 2.5, 3.5}, 13.125},    // Test with floating point numbers\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","eb2979221b37e0bc94da0f2b22cd5473":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t// Test cases for L1 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 1, 9, false},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 1, 0, false},\n\n\t\t// Test cases for L2 norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0, false},\n\n\t\t// Test cases for infinity norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, math.Inf(1), 3, false},\n\n\t\t// Test cases for general L-norm\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0), false},\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 3, math.Pow(27, 1.0/3.0), false},\n\n\t\t// Test case for panic due to length mismatch\n\t\t{[]float64{1, 2}, []float64{1}, 2, 0, true},\n\t\t{[]float64{1}, []float64{1, 2}, 2, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","ed4c3249384c384098afcc70d1b2cbca":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, 1e-10}, 1e10 + 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{[]float64{1.0, -1.0, 1.0, -1.0}, 0.0},\n\t\t{[]float64{math.MaxFloat64, math.MaxFloat64}, math.MaxFloat64 + math.MaxFloat64},\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()},\n\t\t{[]float64{1.0, math.NaN()}, math.NaN()},\n\t\t{[]float64{math.NaN(), math.NaN()}, math.NaN()},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v for input %v\", result, test.input)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %v, got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","edd6222fcf0881ddecd2e6230084c628":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v, but did not panic\", test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","ede839d8aa21a2a990793caf464a7fa3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, 5.1, 2}, // Just above middle\n\t\t{5, 0, 10, 4.9, 2}, // Just below middle\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{3, 10, 0, 5, 1}, // Edge case with inverted bounds\n\t\t{2, 0, 10, 5, 0}, // Edge case with n=2\n\t\t{2, 0, 10, 0, 0}, // Lower bound with n=2\n\t\t{2, 0, 10, 10, 1}, // Upper bound with n=2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","ee11c775a2b30640658618f6276f10f9":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\ts1      []float64\n\t\ts2      []float64\n\t\ttol     float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, 0.01, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.01}, 0.01, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, 0.0, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.1}, 0.1, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, 0.01, false},\n\t\t{[]float64{}, []float64{}, 0.01, true},\n\t\t{[]float64{1.0}, []float64{1.0}, 0.01, true},\n\t\t{[]float64{1.0}, []float64{1.01}, 0.01, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := EqualApprox(test.s1, test.s2, test.tol)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"EqualApprox(%v, %v, %v) = %v; expected %v\", test.s1, test.s2, test.tol, result, test.expected)\n\t\t}\n\t}\n}","eee73366a6b12e52db5a164b7574ac06":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname: \"find first two even numbers\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn int(x)%2 == 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname: \"find all numbers greater than 3\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 3\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{3, 4},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname: \"k is zero\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003c 0\n\t\t\t},\n\t\t\ts:        []float64{-1, -2, 3, 4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname: \"not enough elements found\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 10\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname: \"find first one element\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x == 3\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{2},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","ef173baae917f51659bbeea6f5a88278":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // v is between s[0] and s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // v is equal to s[1]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v is equal to s[2] (not less than s[2])\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1}, // v is less than s[0]\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, -1}, // v is greater than s[2]\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // v is between s[1] and s[2]\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 3.5, 2}, // v is between s[2] and s[3]\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for len(s) \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice, but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","f000ba2650b7d541450f4670b4290607":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.panic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, %v, %v; expected %v, got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","f0b30df2d6d93e47dff67646e0ce6c10":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\t\t{5, 10, 0, 5, 2}, // Middle value with inverted bounds\n\t\t{5, 10, 0, 10, 0}, // Lower bound with inverted bounds\n\t\t{5, 10, 0, 0, 4}, // Upper bound with inverted bounds\n\t\t{5, 10, 0, -1, 4}, // Below lower bound with inverted bounds\n\t\t{5, 10, 0, 11, 0}, // Above upper bound with inverted bounds\n\t\t{3, 0, 10, 5, 1}, // Edge case with n=3\n\t\t{3, 0, 10, 0, 0}, // Edge case with n=3 at lower bound\n\t\t{3, 0, 10, 10, 2}, // Edge case with n=3 at upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != -1 {\n\t\tt.Errorf(\"Expected -1 for NaN input, got %d\", result)\n\t}\n}","f15c3362d300b641bf4f7188dbe271b2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(test.expected[i])) || v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tinfinityTests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t}\n\n\tfor _, test := range infinityTests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","f2c99ede0b70b8c7222aa22af27455ed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0}, // All elements are the same\n\t\t{[]float64{math.NaN(), 2.0, 1.0}, 2}, // NaN should be ignored\n\t\t{[]float64{2.0, math.NaN(), 1.0}, 2}, // NaN in the middle\n\t\t{[]float64{math.NaN(), math.NaN(), 1.0}, 2}, // All NaN except one\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 0}, // NaN at the end\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","f2d0a4e0607696b81d0f7831b78f1a69":"// mul_to_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Basic multiplication\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{4, 10, 18},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Destination length mismatch\",\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{3, 4},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero length slices\",\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiplication with zeros\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{0, 0, 0},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := MulTo(tt.dst, tt.s, tt.t)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","f2f791bd017a2c0391ee414f8e34deb6":"package floats\n\nimport (\n\t\"testing\"\n)\n\ntype argsort struct {\n\ts []float64\n}\n\nfunc (a argsort) Less(i, j int) bool {\n\treturn a.s[i] \u003c= a.s[j]\n}\n\nfunc TestLess(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  []float64\n\t\ti, j   int\n\t\texpect bool\n\t}{\n\t\t{\"LessEqual\", []float64{1.0, 2.0, 3.0}, 0, 1, true},\n\t\t{\"LessNotEqual\", []float64{2.0, 1.0, 3.0}, 0, 1, false},\n\t\t{\"Equal\", []float64{1.0, 1.0, 3.0}, 0, 1, true},\n\t\t{\"Greater\", []float64{3.0, 2.0, 1.0}, 1, 2, false},\n\t\t{\"EdgeCase\", []float64{1.0, 1.0, 1.0}, 1, 2, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ta := argsort{s: tt.input}\n\t\t\tresult := a.Less(tt.i, tt.j)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","f4050e94ad42ab51bda296b51cea2843":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        10,\n\t\t\tu:        20,\n\t\t\texpected: []float64{10, 12, 14, 16, 18, 20},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        5,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(test.expected[i]) {\n\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %f\", i, result[i])\n\t\t\t\t}\n\t\t\t} else if result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", test.expected[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","f51a1aaeae1dd7bf0c8e26f89b8b78ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{1, 3.1622776601683795, 10, 31.622776601683793, 100},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        10,\n\t\t\tu:        1000,\n\t\t\texpected: []float64{10, 31.622776601683793, 1000},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        0.1,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0.1, 1, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSpan(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif !floatEqual(v, test.expected[i]) {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSpan did not panic for dst length less than 2\")\n\t\t}\n\t}()\n\tLogSpan(make([]float64, 1), 1, 10)\n\n\t// Test NaN cases\n\tnanTests := []struct {\n\t\tdst []float64\n\t\tl, u float64\n\t}{\n\t\t{make([]float64, 5), -1, 10},\n\t\t{make([]float64, 5), 1, -10},\n\t}\n\n\tfor _, test := range nanTests {\n\t\tresult := LogSpan(test.dst, test.l, test.u)\n\t\tfor _, v := range result {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) = %v; expected NaN\", test.dst, test.l, test.u, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function to compare float64 values for equality\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","f5730e5037fa3baa3a7797e3cf5e3a11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Minimum is at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0}, // Minimum is at index 0\n\t\t{[]float64{2.0, 2.0, 2.0}, 0}, // All elements are the same, first index is returned\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1}, // NaN is ignored, minimum is at index 1\n\t\t{[]float64{math.NaN(), math.NaN(), 0.0}, 2}, // All NaNs except for one, which is the minimum\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","f5bab763ada8fe7c36081efa09724629":"// File: add_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.5, 2.5},\n\t\t\ts:        []float64{3.5, 4.5},\n\t\t\texpected: []float64{5.0, 7.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Create a copy of dst to avoid modifying the original slice\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\t// Call the Add function\n\t\tAdd(dstCopy, test.s)\n\n\t\t// Check if the result matches the expected output\n\t\tfor i, v := range dstCopy {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Add(%v, %v) = %v; want %v\", test.dst, test.s, dstCopy, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length mismatch, but did not panic\")\n\t\t}\n\t}()\n\tAdd([]float64{1.0, 2.0}, []float64{1.0})\n}","f609d4620b7ad1d4e4f0ba7a78ef6ae8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, 7.5, 3},      // Between bounds\n\t\t{5, 0, 10, -1, 0},       // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t\t{3, 0, 10, 5, 1},        // Odd number of points\n\t\t{4, 0, 10, 5, 1},        // Even number of points\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expect panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","f6c14f0baeb9d56eb54d29effcc34ad0":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantPanic bool\n\t}{\n\t\t// Test valid cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1, false},\n\n\t\t// Test edge cases\n\t\t{[]float64{1.0, 2.0}, 1.0, 0, false},\n\t\t{[]float64{1.0, 2.0}, 2.0, -1, false},\n\t\t{[]float64{1.0, 2.0}, 3.0, -2, false},\n\t\t{[]float64{1.0, 2.0}, 0.5, -2, false},\n\n\t\t// Test panic cases\n\t\t{[]float64{1.0}, 1.0, 0, true}, // len(s) \u003c 2\n\t\t{[]float64{2.0, 1.0}, 1.5, 0, true}, // s is not sorted\n\t\t{[]float64{1.0, 2.0}, math.NaN(), 0, true}, // v is NaN\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and value %v, but did not panic\", tt.s, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Within(tt.s, tt.v)\n\t\tif !tt.wantPanic \u0026\u0026 got != tt.want {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.want)\n\t\t}\n\t}\n}","f8164ef3c4d50b252e6a8135c40a0ab5":"// logsumexp_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Normal case\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))}, // Negative values\n\t\t{[]float64{0, 0, 0}, 0}, // All zeros\n\t\t{[]float64{math.Inf(1), 1, 2}, math.Inf(1)}, // Positive infinity\n\t\t{[]float64{math.Inf(-1), -1, -2}, math.Inf(-1)}, // Negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := LogSumExp(test.input)\n\t\tif !equalApprox(result, test.expected, 1e-10) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic on empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic on empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\n// Helper function to compare floating point numbers with a tolerance\nfunc equalApprox(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}","f8a59234d5fba12b9c07d35cf59640d8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t}{\n\t\t{\n\t\t\tdst:      []float64{3.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tinds:     []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5.0, 3.0, 4.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tinds:     []int{3, 4, 1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t\tinds:     []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{math.NaN(), 2.0, 1.0},\n\t\t\texpected: []float64{1.0, 2.0, math.NaN()},\n\t\t\tinds:     []int{2, 1, 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tinds := make([]int, len(test.dst))\n\t\tfor i := range inds {\n\t\t\tinds[i] = i\n\t\t}\n\n\t\tArgsort(test.dst, inds)\n\n\t\t// Check if dst is sorted\n\t\tfor i := 1; i \u003c len(test.dst); i++ {\n\t\t\tif test.dst[i] \u003c test.dst[i-1] {\n\t\t\t\tt.Errorf(\"Expected sorted dst, got %v\", test.dst)\n\t\t\t}\n\t\t}\n\n\t\t// Check if inds contains the correct indices\n\t\tfor i, idx := range inds {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected dst[%d] = %v, got %v\", i, test.expected[i], test.dst[i])\n\t\t\t}\n\t\t\tif idx != test.inds[i] {\n\t\t\t\tt.Errorf(\"Expected inds[%d] = %d, got %d\", i, test.inds[i], idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths, but did not panic\")\n\t\t}\n\t}()\n\tArgsort([]float64{1.0, 2.0}, []int{0}) // should panic\n}","fbcec84a399d16e857a04dd4101ba926":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for input %v, %v, %v\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"for input %v, %v, %v: expected %v, got %v\", test.dst, test.l, test.u, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","fdddd85e91abddc251b9da767bee01fa":"// File: addto_test.go\n\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t, expected []float64\n\t\texpectPanic         bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{5, 7, 9},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{4, 5},\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: dst=%v, s=%v, t=%v\", test.dst, test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := AddTo(test.dst, test.s, test.t)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", test.dst, test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","fe478ab38e642e30157bc134e5ad80b3":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, 5.1, 2},         // Just above middle\n\t\t{5, 0, 10, 4.9, 2},         // Just below middle\n\t\t{3, 0, 10, 5, 1},           // Odd count\n\t\t{3, 10, 0, 5, 1},           // Reversed bounds\n\t\t{3, math.NaN(), 10, 5, 2},  // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0},   // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{3, math.Inf(-1), math.Inf(1), 2, 1}, // Inf bounds\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 0}, // Reversed Inf bounds\n\t\t{3, math.Inf(1), math.Inf(-1), 2, 0}, // Reversed Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","fffbfad0db7ae393fa0704ea9b316d33":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},     // Middle value\n\t\t{5, 0, 10, 0, 0},     // Lower bound\n\t\t{5, 0, 10, 10, 4},    // Upper bound\n\t\t{5, 0, 10, 15, 4},    // Above upper bound\n\t\t{5, 0, 10, -5, 0},    // Below lower bound\n\t\t{5, 10, 0, 5, 2},     // Reverse bounds\n\t\t{5, 10, 0, 10, 0},    // Reverse bounds, lower bound\n\t\t{5, 10, 0, 0, 4},     // Reverse bounds, upper bound\n\t\t{5, 10, 0, -5, 4},    // Reverse bounds, below lower bound\n\t\t{5, 10, 0, 15, 0},    // Reverse bounds, above upper bound\n\t\t{3, 0, 10, 5, 1},     // Edge case with n=3\n\t\t{3, 0, 10, 0, 0},     // Edge case with n=3, lower bound\n\t\t{3, 0, 10, 10, 2},    // Edge case with n=3, upper bound\n\t\t{2, 0, 10, 5, 1},     // Edge case with n=2\n\t\t{2, 0, 10, 0, 0},     // Edge case with n=2, lower bound\n\t\t{2, 0, 10, 10, 1},    // Edge case with n=2, upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}"}