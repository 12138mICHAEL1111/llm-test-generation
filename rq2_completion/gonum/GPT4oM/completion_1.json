{"0026966f482687b357882089f4e9ee0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\tidx int\n\t}{\n\t\t{5, 0, 10, 5, 2},      // Normal case in the middle\n\t\t{5, 0, 10, 0, 0},      // Edge case at the lower bound\n\t\t{5, 0, 10, 10, 4},     // Edge case at the upper bound\n\t\t{5, 5, 0, 0, 0},       // Reversed bounds\n\t\t{5, -10, 10, -5, 2},   // Negative range and value\n\t\t{3, 0, 10, math.NaN(), 0}, // v is NaN\n\t\t{3, math.NaN(), 10, 5, 2}, // l is NaN\n\t\t{3, 0, math.NaN(), 5, 0},  // u is NaN\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // l is -Inf, u is Inf\n\t\t{2, 0, 10, 10, 1}, // Exactly two elements\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); tt.n \u003c 2 \u0026\u0026 r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for n=%d\", tt.n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.idx {\n\t\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %f, %f, %f); expected %d, got %d\", \n\t\t\t\t\ttt.n, tt.l, tt.u, tt.v, tt.idx, result)\n\t\t\t}\n\t\t})\n\t}\n}","00ff8da04f0e838382a81a82fbe07efe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice   []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t// Test with an empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test with L = 1\n\t\t{[]float64{1, -1}, 1, 2},\n\t\t{[]float64{3, -4, 5}, 1, 12},\n\n\t\t// Test with L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3-4-5 triangle\n\t\t{[]float64{1, 2, 2}, 2, 3}, // sqrt(1^2 + 2^2 + 2^2)\n\n\t\t// Test with L = Inf\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{10, -20, 5}, math.Inf(1), 20},\n\n\t\t// Test with positive and negative values\n\t\t{[]float64{-3, -4}, 2, 5}, // 3-4-5 triangle\n\t\t{[]float64{5, 12}, 1, 17}, // 5 + 12\n\n\t\t// Test with non-integer L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1/3.0)}, // (1^3 + 2^3 + 3^3)^(1/3)\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.slice, test.L)\n\t\tif math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; expected %v\", test.slice, test.L, result, test.expected)\n\t\t}\n\t}\n}","013e5ee407fb258d6a8c3fda98af7c6a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdstLen    int\n\t\tl, u      float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname: \"Standard case\",\n\t\t\tdstLen: 5,\n\t\t\tl: 0, \n\t\t\tu: 4, \n\t\t\texpected: []float64{0, 1, 2, 3, 4}, \n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Dst length of 2\",\n\t\t\tdstLen: 2,\n\t\t\tl: 1, \n\t\t\tu: 3, \n\t\t\texpected: []float64{1, 3}, \n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Panic on length less than 2\",\n\t\t\tdstLen: 1,\n\t\t\tl: 1, \n\t\t\tu: 3, \n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN in lower bound\",\n\t\t\tdstLen: 5,\n\t\t\tl: math.NaN(), \n\t\t\tu: 4, \n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4}, \n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN in upper bound\",\n\t\t\tdstLen: 5,\n\t\t\tl: 0, \n\t\t\tu: math.NaN(), \n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}, \n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinity in lower bound\",\n\t\t\tdstLen: 5,\n\t\t\tl: math.Inf(1), \n\t\t\tu: 4, \n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4}, \n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinity in upper bound\",\n\t\t\tdstLen: 5,\n\t\t\tl: 0, \n\t\t\tu: math.Inf(1), \n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)}, \n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds are infinity\",\n\t\t\tdstLen: 5,\n\t\t\tl: math.Inf(1), \n\t\t\tu: math.Inf(1), \n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}, \n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, tt.dstLen)\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not get one\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Span(dst, tt.l, tt.u)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEquals(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Helper function to compare floating point numbers for equality\nfunc floatEquals(a, b float64) bool {\n\treturn math.IsNaN(a) \u0026\u0026 math.IsNaN(b) || a == b\n}","0215348bb87bbfbf266f19937ec2247e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{5.0, 6.0, 7.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{4.0, 4.0, 4.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts:        []float64{-1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, -4.0, -6.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{0.0, 0.0, 0.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\t\tSub(dstCopy, test.s)\n\n\t\tfor i, val := range dstCopy {\n\t\t\tif val != test.expected[i] {\n\t\t\t\tt.Errorf(\"Sub(%v, %v) = %v; want %v\", test.dst, test.s, dstCopy, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Sub did not panic with mismatched lengths\")\n\t\t}\n\t}()\n\n\tSub([]float64{1.0, 2.0}, []float64{1.0})\n\n}","028e90cbce778d1961c87aa647c65dad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},                // Middle value test\n\t\t{5, 0, 10, 0, 0},                // Lower bound test\n\t\t{5, 0, 10, 10, 4},               // Upper bound test\n\t\t{5, 0, 10, -1, 0},               // Below lower bound test\n\t\t{5, 0, 10, 11, 4},               // Above upper bound test\n\t\t{5, 0, math.NaN(), 5, 0},        // u is NaN\n\t\t{5, math.NaN(), 10, 5, 4},       // l is NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // l is -Inf and v is positive\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 0}, // v within bounds\n\t\t{3, 2, 5, 3, 1},                  // Exact middle test\n\t\t{3, 1, 3, 2, 1},                  // Equal bounds test\n\t\t{2, 0, 10, 0, 0},                 // Edge case of minimum span\n\t\t{2, 1, 1, 1, 0},                  // Same bounds test (zero span)\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 tt.n \u003c 2 {\n\t\t\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but got none\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v; expected %d, got %d\", tt.n, tt.l, tt.u, tt.v, tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","02c76544e44aa50c3890e81b07f8e90f":"// nearestidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},   // Exact match\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},   // Between two values\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},   // Closer to the lower bound\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2},   // Exact match at the upper bound\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0},   // All identical\n\t\t{[]float64{1.0, 2.0, 2.0}, 2.1, 1},   // Between duplicates\n\t\t{[]float64{-1.0, 0.0, 1.0}, 0.5, 2},  // Positive and negative values\n\t\t{[]float64{-1.0, 0.0, 1.0}, -0.5, 0}, // Negative value\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"NearestIdx(%v, %v)\", tt.s, tt.v), func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"got %d, want %d\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic on zero length slice, but didn't get one\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n\n\t// Test for NaN value\n\tif got := NearestIdx([]float64{1.0, 2.0, 3.0}, math.NaN()); got != 0 {\n\t\tt.Errorf(\"got %d, want 0 for NaN input\", got)\n\t}\n\n\t// Test for positive infinity\n\tif got := NearestIdx([]float64{1.0, 2.0, 3.0}, math.Inf(1)); got != 2 {\n\t\tt.Errorf(\"got %d, want 2 for positive infinity\", got)\n\t}\n\n\t// Test for negative infinity\n\tif got := NearestIdx([]float64{1.0, 2.0, 3.0}, math.Inf(-1)); got != 0 {\n\t\tt.Errorf(\"got %d, want 0 for negative infinity\", got)\n\t}\n}","02d05743532d1daecf41e66d43e30cae":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t\texpectPanic bool\n\t}{\n\t\t{3, 0, 10, 5, 1, false},          // Exactly in the middle\n\t\t{5, 0, 10, 3, 1, false},          // Closer to the start\n\t\t{5, 0, 10, 8, 4, false},          // Closer to the end\n\t\t{4, 0, 10, 10, 3, false},         // At the upper bound\n\t\t{4, 0, 10, 0, 0, false},          // At the lower bound\n\t\t{2, -10, -5, -7, 0, false},       // Negative range\n\t\t{5, -10, -5, -12, 0, false},      // Outside lower bound\n\t\t{5, -5, 0, 2, 4, false},           // Outside upper bound\n\t\t{3, 0, 0, 0, 0, false},           // Edge case where l == u == v\n\t\t{1, 0, 10, 5, 0, true},           // n \u003c 2 should panic\n\t\t{3, 0, math.NaN(), 5, 2, false}, // Upper bound is NaN\n\t\t{3, math.NaN(), 10, 5, 0, false}, // Lower bound is NaN\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false}, // Inf bounds\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 2, false}, // Reverse Inf bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != test.expectPanic {\n\t\t\t\t\tt.Errorf(\"Expected panic: %v, but got: %v\", test.expectPanic, r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", int(test.n), test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t}()\n\t}\n}","02dace20380755f8b679152b01cb1c37":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"basic span\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative span\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -10,\n\t\t\tu:    -1,\n\t\t\twant: []float64{-10, -7.25, -4.5, -1.75, -1},\n\t\t},\n\t\t{\n\t\t\tname: \"same l and u\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    5,\n\t\t\tu:    5,\n\t\t\twant: []float64{5, 5, 5, 5, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"span with NaN lower\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"span with NaN upper\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"panics on dst length \u003c 2\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    5,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.wantErr {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic, got no panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\t\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !compareSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !isEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc isEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","02fbbeaf9207bbe077f089b5539b257d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 6},                          // L1 norm\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},             // L2 norm\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},            // L2 norm (mixed signs)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},                // L-inf norm\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},             // L-inf norm (negative)\n\t\t{[]float64{}, 1, 0},                                 // empty slice\n\t\t{[]float64{0}, 1, 0},                                // single element zero\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)},    // L3 norm\n\t\t{[]float64{5, 12, 13}, 2, 13},                       // Pythagorean triple with L2\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Norm(test.slice, test.L)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.slice, test.L, got, test.want)\n\t\t}\n\t}\n}","0448c285f2fcbc79b86a5077593f1471":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         -2,\n\t\t\tu:         2,\n\t\t\texpected:  []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         3,\n\t\t\texpected:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 3},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         2,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{2, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 6),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range tt.expected {\n\t\t\tif math.IsNaN(tt.expected[i]) {\n\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, result[i])\n\t\t\t\t}\n\t\t\t} else if result[i] != tt.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", tt.expected[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for lengths less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length \u003c 2 but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","0481378a1b09214b71ea7267f94d33e1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0},\n\t\t{[]float64{3.0, 2.0, 1.0}, 2},\n\t\t{[]float64{2.0, 2.0, 1.0, 2.0}, 2},\n\t\t{[]float64{math.NaN(), 2.0, 1.0, 1.0}, 2},\n\t\t{[]float64{2.0, math.NaN(), 1.0}, 2},\n\t\t{[]float64{math.NaN(), math.NaN()}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := MinIdx(test.input); got != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, got, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for zero-length slice\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","049bf5e147c76a4cefac4edd03539ef1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\twant    int\n\t}{\n\t\t{5, 0, 10, 5, 2},                  // v is in the middle of the span\n\t\t{5, 0, 10, 0, 0},                  // v is equal to the lower bound\n\t\t{5, 0, 10, 10, 4},                 // v is equal to the upper bound\n\t\t{5, 0, 10, 10.1, 4},               // v is just above upper bound\n\t\t{5, 0, 10, -0.1, 0},               // v is just below lower bound\n\t\t{5, 10, 0, 5, 2},                  // l \u003e u, v in the middle\n\t\t{5, 10, 0, 10, 0},                 // l \u003e u, v equal to upper bound\n\t\t{5, 10, 0, 0, 4},                  // l \u003e u, v equal to lower bound\n\t\t{5, 10, 0, 15, 0},                 // l \u003e u, v just above upper bound\n\t\t{5, 10, 0, -5, 4},                 // l \u003e u, v just below lower bound\n\t\t{3, 0, 1, 0.5, 1},                 // edge case with n = 3\n\t\t{2, 0, 1, 0.5, 0},                 // edge case with n = 2\n\t\t{2, 0, 1, 1, 1},                   // edge case with n = 2, v equal to upper bound\n\t\t{2, 0, 1, -1, 0},                  // edge case with n = 2, v below range\n\t\t{2, 0, 1, 2, 1},                   // edge case with n = 2, v above range\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan(1, 0, 1, 0) did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test NaN case\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want %d\", got, 0)\n\t}\n}","0509e0638a4b45d441f01d4ba3e331eb":"// scale_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttests := []struct {\n\t\tc         float64\n\t\tdst       []float64\n\t\texpected  []float64\n\t}{\n\t\t{\n\t\t\tc:        2,\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\texpected: []float64{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tc:        0,\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tc:        1,\n\t\t\tdst:      []float64{1, 1, 1},\n\t\t\texpected: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tc:        -1,\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\texpected: []float64{-1, -2, -3},\n\t\t},\n\t\t{\n\t\t\tc:        3.5,\n\t\t\tdst:      []float64{0, -1, 2},\n\t\t\texpected: []float64{0, -3.5, 7},\n\t\t},\n\t\t{\n\t\t\tc:        1,\n\t\t\tdst:      []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tScale(test.c, test.dst)\n\t\tfor i := range test.dst {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v but got %v for c %v and dst %v\", test.expected, test.dst, test.c, test.dst)\n\t\t\t}\n\t\t}\n\t}\n}","078c692d78e6f34adcf892727898b8a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       1,\n\t\t\tu:       3,\n\t\t\twant:    []float64{1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       1,\n\t\t\tu:       3,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       1,\n\t\t\tu:       3,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(-1),\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       10,\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(-1),\n\t\t\twant:    []float64{0, 0, 0, 0, math.Inf(-1)},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantErr {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic for dst length %d l = %v, u = %v\", len(tt.dst), tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !compareSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc compareSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn a == b || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}","07a3669a4df39454690361c55d14ee12":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl, u  float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Normal case within bounds\n\t\t{5, 0, 10, 0, 0},           // Lower bound edge case\n\t\t{5, 0, 10, 10, 4},          // Upper bound edge case\n\t\t{5, 10, 0, 5, 2},           // Normal case with reversed bounds\n\t\t{5, 10, 0, 10, 0},          // Lower bound edge case with reversed bounds\n\t\t{5, 10, 0, 0, 4},           // Upper bound edge case with reversed bounds\n\t\t{3, 1, 5, 3, 1},            // Normal case with odd n\n\t\t{3, 5, 1, 3, 1},            // Normal case with odd n and reversed bounds\n\t\t{10, 0, 100, math.NaN(), 0}, // NaN v\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0}, // v within (-Inf, Inf)\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 0}, // v within (Inf, -Inf)\n\t\t{2, 10, 5, 8, 0},           // Edge case - smallest n\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n\n\t// Test panic cases\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\n\tNearestIdxForSpan(1, 0, 10, 5) // Should panic\n}","082fe751a23930a68a019f44025e09cd":"// File: span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases as pairs of inputs and expected results\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -3,\n\t\t\tu:        3,\n\t\t\texpected: []float64{-3, 0, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{1, 1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 7),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 7),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(tt.expected[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","08367c21374f71c8896f648b0805835b":"// span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     1.0,\n\t\t\tu:     5.0,\n\t\t\twant:  []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 3),\n\t\t\tl:     0.0,\n\t\t\tu:     2.0,\n\t\t\twant:  []float64{0.0, 1.0, 2.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 2),\n\t\t\tl:     -1.0,\n\t\t\tu:     1.0,\n\t\t\twant:  []float64{-1.0, 1.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 0),\n\t\t\tl:     0.0,\n\t\t\tu:     1.0,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 1),\n\t\t\tl:     0.0,\n\t\t\tu:     1.0,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.NaN(),\n\t\t\tu:     1.0,\n\t\t\twant:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0.0,\n\t\t\tu:     math.NaN(),\n\t\t\twant:  []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\twant:  []float64{math.Inf(-1), -1, 0, 1, math.Inf(1)},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     0.0,\n\t\t\twant:  []float64{math.Inf(-1), -0.75, -0.5, -0.25, 0.0},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panics {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v but did not panic\", test)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Span(test.dst, test.l, test.u)\n\n\t\tif !test.panics \u0026\u0026 !equalSlices(got, test.want) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; want %v\", test.dst, test.l, test.u, got, test.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !(math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) || a[i] == b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","0843ef585b873a1a79ee4ad7a8360783":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, -10, 0, -5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{3, math.NaN(), 10, 3, 2},\n\t\t{3, -10, math.NaN(), -3, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},\n\t\t{4, math.Inf(1), math.Inf(1), 2, 0},\n\t\t{2, 1, 2, 1.5, 0},\n\t\t{2, 1, 2, 3, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but it did not panic.\")\n\t\t}\n\t}()\n\t_ = NearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test NaN input for v\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", got)\n\t}\n}","08d82e43185b5ac68d847ab24ea6f61b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t\texpectPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 10, 0, 5, 2, false}, // Testing with inverted bounds\n\t\t{5, 10, 0, 10, 0, false}, // Inverted bounds, expect first index\n\t\t{5, 10, 0, 0, 4, false}, // Inverted bounds, expect last index\n\t\t{5, math.NaN(), 10, 5, 4, false}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0, false}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2, false}, // Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0, false}, // Inverted Inf bounds\n\t\t{5, 0, 10, math.NaN(), 0, false}, // NaN target\n\t\t{2, 0, 10, 5, 1, false}, // Lower bound case\n\t\t{1, 0, 10, 5, 0, true}, // Panic case (n \u003c 2)\n\t\t{3, 0, 0, 0, 0, false}, // All equal elements\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input n=%d, l=%v, u=%v, v=%v\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v: expected %d, got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}","092d969bdc8d331e1383b09ae960574d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},        // L2 norm\n\t\t{[]float64{1, -2, 3}, 1, 6},                   // L1 norm\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},        // L∞ norm\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},    // L2 norm with negatives\n\t\t{[]float64{}, 1, 0},                           // empty slice\n\t\t{[]float64{5}, 1, 5},                          // single element\n\t\t{[]float64{3, 4, 5, 12}, 2, math.Sqrt(194)},  // L2 norm with larger numbers\n\t\t{[]float64{7, 8, 4, -10}, 1, 29},              // L1 norm with mixed signs\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.slice, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; expected %v\", test.slice, test.L, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestNormSpecialCases(t *testing.T) {\n\t// Check zero norm using Count function (not implemented in this test)\n\tif Count(func(x float64) bool { return x != 0 }, []float64{}) != 0 {\n\t\tt.Errorf(\"Expected Count to be 0 for empty slice\")\n\t}\n}","0a4296a1d29592be5b3cbae3eddad4e4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tdst       []float64\n\t\tl         float64\n\t\tu         float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:      \"Basic span\",\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Panic on length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Handling NaN for l\",\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         4,\n\t\t\texpected:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Handling NaN for u\",\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Handling Inf for l and u\",\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Panic on Inf for l and -Inf for u\",\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(-1),\n\t\t\texpected:  nil,\n\t\t\texpectPanic: false, // This case needs to be carefully verified based on expected behavior.\n\t\t},\n\t\t{\n\t\t\tname:      \"Panic on length zero\",\n\t\t\tdst:       []float64{},\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tfor i, v := range result {\n\t\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","0a81dba7d0fdfeb9b2ee90d5fffab1ef":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\twant    int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle case\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, -1, 0},       // Below lower bound\n\t\t{5, 0, 10, 11, 4},       // Above upper bound\n\t\t{5, 10, 0, 5, 0},        // Inverted bounds\n\t\t{5, 10, 0, -1, 4},       // Inverted bounds with negative\n\t\t{3, 0, 10, math.NaN(), 0}, // v is NaN\n\t\t{3, math.NaN(), 10, 5, 2}, // l is NaN\n\t\t{3, 0, math.NaN(), 5, 0}, // u is NaN\n\t\t{4, math.Inf(-1), math.Inf(1), -0.5, 0}, // Inf bounds with negative v\n\t\t{4, math.Inf(-1), math.Inf(1), 0.5, 3},  // Inf bounds with positive v\n\t\t{2, 0, 1, 0.5, 0},        // Edge case at minimal n\n\t\t{2, 0, 1, 1, 1},          // Edge case at minimal n, upper bound\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panic on n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","0b097e9900feb8b9e641c792209cf25f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1},          // normal case\n\t\t{[]float64{5.0, 5.0, 5.0}, 0},          // all elements the same\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2},      // negative values\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1},  // NaN in the slice, should ignore\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 0},  // NaN in the middle\n\t\t{[]float64{math.NaN(), math.NaN()}, 0}, // all NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx([]) did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","0b471cefc5359254a2f629459fb3aade":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tdst       []float64\n\t\tl         float64\n\t\tu         float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\"Valid Span\", make([]float64, 5), 0, 4, []float64{0, 1, 2, 3, 4}, false},\n\t\t{\"Valid Span with Negative\", make([]float64, 5), -4, 0, []float64{-4, -3, -2, -1, 0}, false},\n\t\t{\"Valid Span with Small Range\", make([]float64, 5), 1, 1, []float64{1, 1, 1, 1, 1}, false},\n\t\t{\"Valid Span with Inf\", make([]float64, 5), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)}, false},\n\t\t{\"Panic on Short Slice\", make([]float64, 1), 0, 1, nil, true},\n\t\t{\"Panic on Empty Slice\", nil, 0, 1, nil, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !tt.expectPanic \u0026\u0026 !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !equalFloat(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Helper function to compare float64 values for equality considering NaN\nfunc equalFloat(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","0c3582a382574f253a9d3e2de6f04b2e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts, t []float64\n\t\twant bool\n\t}{\n\t\t// Test with equal non-NaN slices\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},\n\t\t// Test with different length slices\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, false},\n\t\t// Test with NaN values treated as equal\n\t\t{[]float64{math.NaN(), 2, 3}, []float64{math.NaN(), 2, 3}, true},\n\t\t// Test with one NaN value in otherwise equal slices\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true},\n\t\t// Test with non-identical elements\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},\n\t\t// Test with empty slices\n\t\t{[]float64{}, []float64{}, true},\n\t\t// Test with one empty slice\n\t\t{[]float64{1}, []float64{}, false},\n\t\t// Test with all NaN slices\n\t\t{[]float64{math.NaN(), math.NaN()}, []float64{math.NaN(), math.NaN()}, true},\n\t\t// Test with slices of different NaN placements\n\t\t{[]float64{math.NaN(), 2}, []float64{2, math.NaN()}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Same(tt.s, tt.t)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.s, tt.t, got, tt.want)\n\t\t}\n\t}\n}","0cbfee12334c61b215b68e7039d3e04c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Normal case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal bounds\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        3.0,\n\t\t\tu:        3.0,\n\t\t\texpected: []float64{3.0, 3.0, 3.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative bounds\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -4.0,\n\t\t\tu:        -1.0,\n\t\t\texpected: []float64{-4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with Inf\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with NaN\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with NaN 2\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        1.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) {\n\t\t\t\t\tif !math.IsNaN(tt.expected[i]) {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, got)\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, got)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic, but did not get one\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}","0d144bb389e3e2f7fce75bb9ab4c36ba":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\texp int\n\t}{\n\t\t{5, 0, 10, 5, 2},      // Midpoint case\n\t\t{5, 0, 10, 0, 0},      // Lower bound case\n\t\t{5, 0, 10, 10, 4},     // Upper bound case\n\t\t{5, 5, 0, 4, 1},       // Reversed bounds\n\t\t{5, 5, 0, 6, 0},       // Outside bounds case\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, 1, 1, 1, 0},       // All points are the same\n\t\t{3, 1, 2, 1.5, 1},     // Test with three points\n\t\t{3, 1, 2, 3, 2},       // Test with value above upper bound\n\t\t{3, 1, 2, 0, 0},       // Test with value below lower bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.exp {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.exp)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN value\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"Expected index 0 for NaN value, got %d\", got)\n\t}\n}","0d37d4ebe8ea732945906d799178ed91":"package floats\n\nimport \"testing\"\n\n// TestCount tests the Count function.\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"count positives\",\n\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"count evens\",\n\t\t\tf:    func(x float64) bool { return int(x)%2 == 0 },\n\t\t\ts:    []float64{0, 1, 2, 3, 4, 5, 6},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"count negatives\",\n\t\t\tf:    func(x float64) bool { return x \u003c 0 },\n\t\t\ts:    []float64{-1, -2, -3, 1, 2},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\ts:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"count NaN\",\n\t\t\tf:    func(x float64) bool { return x != x }, // NaN check\n\t\t\ts:    []float64{1, 2, 3, float64(0) / float64(0)}, // Include NaN value\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Count(tt.f, tt.s)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0d38cf851eedbeb3bf60880a2ff1cb98":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ts         []float64\n\t\tt         []float64\n\t\tL         float64\n\t\twant      float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"Distance L1\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tt:     []float64{1.0, 2.0, 3.0},\n\t\t\tL:     1,\n\t\t\twant:  0.0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Distance L2\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tt:     []float64{4.0, 5.0, 6.0},\n\t\t\tL:     2,\n\t\t\twant:  math.Sqrt(27), // sqrt((3^2 + 3^2 + 3^2))\n\t\t},\n\t\t{\n\t\t\tname:  \"Distance LInf\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tt:     []float64{4.0, 5.0, 1.0},\n\t\t\tL:     math.Inf(1),\n\t\t\twant:  3.0, // max(|1-4|, |2-5|, |3-1|) = max(3, 3, 2)\n\t\t},\n\t\t{\n\t\t\tname:       \"Different lengths\",\n\t\t\ts:          []float64{1.0, 2.0},\n\t\t\tt:          []float64{1.0, 2.0, 3.0},\n\t\t\tL:          2,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Empty slices\",\n\t\t\ts:          []float64{},\n\t\t\tt:          []float64{},\n\t\t\tL:          1,\n\t\t\twant:       0.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Distance(tt.s, tt.t, tt.L)\n\t\t\tif !tt.expectPanic \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0e04172c6c2d5d231457bf49bbcc2001":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        2,\n\t\t\texpected: []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 10),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, -0.7777777777777778, -0.5555555555555556, -0.3333333333333333, -0.1111111111111111, 0.1111111111111111, 0.3333333333333333, 0.5555555555555556, 0.7777777777777778, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        3,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        1,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i, v := range got {\n\t\t\tif !isEqual(v, tt.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", tt.dst, tt.l, tt.u, got, tt.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc isEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","0e9561493f6229f9472a0d33b0425509":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst  []float64\n\t\tl, u float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    10.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{10.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 6),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for invalid lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic for dst length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.IsNaN(a) \u0026\u0026 math.IsNaN(b) || a == b\n}","0f3a51095de34ca23f6513dd63718b5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tdesc     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdesc:     \"Basic logarithmic span\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{1, 10, 100},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Edge case with zeros\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        0,\n\t\t\texpected: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Negative bounds\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -10,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Another negative bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -5,\n\t\t\tu:        -2,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Lower bound greater than upper bound\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        10,\n\t\t\tu:        1,\n\t\t\texpected: []float64{10, 5, 2.5, 1},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"Testing NaNs in output\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        0,\n\t\t\tu:        -100,\n\t\t\texpected: []float64{0, math.NaN()},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.desc, func(t *testing.T) {\n\t\t\tresult := LogSpan(test.dst, test.l, test.u)\n\t\t\tfor i, v := range test.expected {\n\t\t\t\t// Check for NaN equality\n\t\t\t\tif math.IsNaN(v) {\n\t\t\t\t\tif !math.IsNaN(result[i]) {\n\t\t\t\t\t\tt.Errorf(\"expected NaN but got %v\", result[i])\n\t\t\t\t\t}\n\t\t\t\t} else if result[i] != v {\n\t\t\t\t\tt.Errorf(\"expected %v but got %v\", v, result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic but did not get one\")\n\t\t}\n\t}()\n\tLogSpan(make([]float64, 1), 1, 10)\n}","0fd11dba8dbc082251b5cc7acfffe5cd":"// add_to_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t   []float64\n\t\texpected    []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:        []float64{0, 0, 0},\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{4, 5, 6},\n\t\t\texpected:   []float64{5, 7, 9},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        []float64{0, 0},\n\t\t\ts:          []float64{1, 2},\n\t\t\tt:          []float64{3, 4},\n\t\t\texpected:   []float64{4, 6},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        []float64{0, 0},\n\t\t\ts:          []float64{1},\n\t\t\tt:          []float64{2},\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:        []float64{},\n\t\t\ts:          []float64{1, 2},\n\t\t\tt:          []float64{1, 2},\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\ts:          []float64{1, 2},\n\t\t\tt:          []float64{3, 4},\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for input dst: %v, s: %v, t: %v\", test.dst, test.s, test.t)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tAddTo(test.dst, test.s, test.t)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := AddTo(test.dst, test.s, test.t)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"unexpected result for input dst: %v, s: %v, t: %v; got %v, want %v\",\n\t\t\t\t\t\ttest.dst, test.s, test.t, result, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","10520592a0f56f200f0a6b8fc4e6f903":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tf        func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0},\n\t\t\ts2:       []float64{1.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"One empty, one not\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{1.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Close elements with tolerance\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.00001, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a - b \u003c 0.0001 \u0026\u0026 b - a \u003c 0.0001 },\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.s1, tt.s2, tt.f)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, expected %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","11f572eb365996ad3a7cf07e62825761":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Zero slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"One element, L=1\",\n\t\t\tslice:    []float64{3},\n\t\t\tL:        1,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"One element, L=2\",\n\t\t\tslice:    []float64{4},\n\t\t\tL:        2,\n\t\t\texpected: 4, // L2 norm =\u003e sqrt(4^2) = 4\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple elements, L=1\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6, // L1 norm = 1 + 2 + 3 = 6\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple elements, L=2\",\n\t\t\tslice:    []float64{1, 2, 2},\n\t\t\tL:        2,\n\t\t\texpected: 3, // L2 norm = sqrt(1^2 + 2^2 + 2^2) = sqrt(9) = 3\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity norm\",\n\t\t\tslice:    []float64{-1, -5, 2},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5, // Maximum absolute value\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative values, L=1\",\n\t\t\tslice:    []float64{-1, -2, -3},\n\t\t\tL:        1,\n\t\t\texpected: 6, // L1 norm = |-1| + |-2| + |-3| = 6\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative values, L=2\",\n\t\t\tslice:    []float64{-3, -4, -5},\n\t\t\tL:        2,\n\t\t\texpected: 7.0710678118654755, // L2 norm = sqrt(3^2 + 4^2 + 5^2) \n\t\t},\n\t\t{\n\t\t\tname:     \"All elements zero\",\n\t\t\tslice:    []float64{0, 0, 0},\n\t\t\tL:        3,\n\t\t\texpected: 0, // Any L-norm of zeros\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","1233b208bd7b9681685f0e7a71169e0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, -5, -7.5, 2},\n\t\t{5, -10, -5, -11, 0},\n\t\t{5, -10, -5, -4, 4},\n\t\t{3, 1, 4, 2.5, 1},\n\t\t{3, 1, 4, 4, 2},\n\t\t{3, 1, 4, 1, 0},\n\t\t{3, 1, 4, 2, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{4, -math.Inf(1), math.Inf(1), 0, 2},\n\t\t{4, math.NaN(), 5, 0, 3},\n\t\t{4, 1, math.NaN(), 0, 0},\n\t\t{4, math.Inf(-1), math.Inf(-1), -2, 0},\n\t\t{4, math.Inf(1), math.Inf(1), 2, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // This should panic\n}","128299297328105251c94c426bd401ac":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\texp int\n\t}{\n\t\t{3, 0, 10, 5, 1},         // Middle of span\n\t\t{5, 0, 10, 2.5, 1},       // Closer to lower bound\n\t\t{5, 0, 10, 8, 3},         // Closer to upper bound\n\t\t{5, 0, 10, 10, 4},        // At upper bound\n\t\t{5, 0, 10, 0, 0},         // At lower bound\n\t\t{5, 0, 10, -5, 0},        // Below lower bound\n\t\t{5, 0, 10, 15, 4},        // Above upper bound\n\t\t{3, -5, 5, -4, 1},        // Negative span with negative value\n\t\t{4, -10, -5, -7.5, 1},    // Negative span with value in the range\n\t\t{2, -10, -5, -6, 0},      // Edge case with 2 points at lower bound\n\t\t{2, 10, 5, 8, 1},         // Reversed span\n\t\t{2, math.NaN(), 5, 0, 1}, // NaN lower bound\n\t\t{2, 10, math.NaN(), 0, 0}, // NaN upper bound\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // Both bounds are infinity\n\t\t{3, 0, 0, 0, 1},            // All zeros\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.n \u003c 2 {\n\t\t\t\t\t\treturn // Expected panic for n \u003c 2\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.exp {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.exp)\n\t\t\t}\n\t\t})\n\t}\n}","156e9026367d2431fbba36241809755c":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\texp []float64\n\t}{\n\t\t{\n\t\t\tdst: make([]float64, 5),\n\t\t\tl:   0,\n\t\t\tu:   10,\n\t\t\texp: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 3),\n\t\t\tl:   1,\n\t\t\tu:   3,\n\t\t\texp: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 4),\n\t\t\tl:   -2,\n\t\t\tu:   2,\n\t\t\texp: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 6),\n\t\t\tl:   -1,\n\t\t\tu:   1,\n\t\t\texp: []float64{-1, -0.6, -0.2, 0.2, 0.6, 1},\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 2),\n\t\t\tl:   3,\n\t\t\tu:   9,\n\t\t\texp: []float64{3, 9},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tfor i, v := range result {\n\t\t\tif !floatEqual(v, tt.exp[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, result, tt.exp)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic but got none\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)  // Should panic\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","16389cca552661e959b771ae10933bd1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},   // Average case\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},   // Exact match\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},   // Closer to the first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2},   // Beyond the last element\n\t\t{[]float64{-1.0, -2.0, -3.0}, -2.5, 1}, // Average case with negative values\n\t\t{[]float64{5, 10}, 7, 0},               // Average case with two elements\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdx([]float64{}, 0) did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0)\n\n\t// Additional edge cases\n\ttestsNaN := []struct {\n\t\ts []float64\n\t}{\n\t\t{[]float64{math.NaN(), 1.0, 2.0}},\n\t\t{[]float64{1.0, math.NaN(), 2.0}},\n\t\t{[]float64{1.0, 2.0, math.NaN()}},\n\t}\n\n\tfor _, tt := range testsNaN {\n\t\tt.Run(\"NaN value\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx(tt.s, math.NaN())\n\t\t\tif gotIdx != 0 {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, NaN) = %d; want 0\", tt.s, gotIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test infinity values\n\ttestsInfinity := []struct {\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{math.Inf(1), 2}, // should return index of max element\n\t\t{math.Inf(-1), 0}, // should return index of min element\n\t}\n\n\tfor _, tt := range testsInfinity {\n\t\tt.Run(\"Infinity value\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdx([]float64{1.0, 2.0, 3.0}, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx([]float64{1.0, 2.0, 3.0}, %v) = %d; want %d\", tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}","16b961141bad023dbcab537e8956f070":"// span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdstLength  int\n\t\tl, u       float64\n\t\texpected   []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:       \"normal case\",\n\t\t\tdstLength:  5,\n\t\t\tl:          0,\n\t\t\tu:          4,\n\t\t\texpected:   []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"same lower and upper bounds\",\n\t\t\tdstLength:  5,\n\t\t\tl:          2,\n\t\t\tu:          2,\n\t\t\texpected:   []float64{2, 2, 2, 2, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"length less than two\",\n\t\t\tdstLength:  1,\n\t\t\tl:          1,\n\t\t\tu:          2,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"NaN lower bound\",\n\t\t\tdstLength:  5,\n\t\t\tl:          math.NaN(),\n\t\t\tu:          2,\n\t\t\texpected:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"NaN upper bound\",\n\t\t\tdstLength:  5,\n\t\t\tl:          1,\n\t\t\tu:          math.NaN(),\n\t\t\texpected:   []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"infinity bounds\",\n\t\t\tdstLength:  5,\n\t\t\tl:          math.Inf(1),\n\t\t\tu:          math.Inf(1),\n\t\t\texpected:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"from -Inf to Inf\",\n\t\t\tdstLength:  5,\n\t\t\tl:          math.Inf(-1),\n\t\t\tu:          math.Inf(1),\n\t\t\texpected:   []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, tt.dstLength)\n\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but didn't get one\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Span(dst, tt.l, tt.u)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\t\tt.Errorf(\"Expected length %d, got %d\", len(tt.expected), len(result))\n\t\t\t\t}\n\t\t\t\tfor i, v := range result {\n\t\t\t\t\tif !equalFloat(v, tt.expected[i]) {\n\t\t\t\t\t\tt.Errorf(\"At index %d: expected %v, got %v\", i, tt.expected[i], v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloat(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","175bec1e74ac88c0ebf6618319ad2aea":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst        []float64\n\t\tl, u      float64\n\t\texpected   []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          1.0,\n\t\t\tu:          5.0,\n\t\t\texpected:   []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          0.0,\n\t\t\tu:          6.0,\n\t\t\texpected:   []float64{0.0, 3.0, 6.0},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          -10.0,\n\t\t\tu:          -5.0,\n\t\t\texpected:   []float64{-10.0, -5.0},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.NaN(),\n\t\t\tu:          10.0,\n\t\t\texpected:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          10.0,\n\t\t\tu:          math.NaN(),\n\t\t\texpected:   []float64{10.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          1.0,\n\t\t\tu:          3.0,\n\t\t\texpected:   []float64{1.0, 3.0},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          1.0,\n\t\t\tu:          2.0,\n\t\t\texpected:   nil,\n\t\t\tshouldPanic: true, // should panic due to length \u003c 2\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.shouldPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range result {\n\t\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(tt.expected[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v for input %v, %v, %v; got %v\", tt.expected, tt.dst, tt.l, tt.u, result)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","178631791ebe40ac3e37a083dbafcaf0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\ts     []float64\n\t\tt     []float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t// Test basic subtraction\n\t\t{\n\t\t\tdst:   []float64{0, 0, 0},\n\t\t\ts:     []float64{5, 10, 15},\n\t\t\tt:     []float64{1, 2, 3},\n\t\t\twant:  []float64{4, 8, 12},\n\t\t\tpanic: false,\n\t\t},\n\t\t// Test with negative numbers\n\t\t{\n\t\t\tdst:   []float64{0, 0, 0},\n\t\t\ts:     []float64{-5, -10, -15},\n\t\t\tt:     []float64{-1, -2, -3},\n\t\t\twant:  []float64{-4, -8, -12},\n\t\t\tpanic: false,\n\t\t},\n\t\t// Test with lengths that do not match (should panic)\n\t\t{\n\t\t\tdst:   []float64{0, 0},\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{1, 2},\n\t\t\twant:  nil,\n\t\t\tpanic: true,\n\t\t},\n\t\t// Test dst length mismatch (should panic)\n\t\t{\n\t\t\tdst:   []float64{0},\n\t\t\ts:     []float64{1, 2},\n\t\t\tt:     []float64{1, 2},\n\t\t\twant:  nil,\n\t\t\tpanic: true,\n\t\t},\n\t\t// Test with empty slices (dst is empty)\n\t\t{\n\t\t\tdst:   []float64{},\n\t\t\ts:     []float64{},\n\t\t\tt:     []float64{},\n\t\t\twant:  []float64{},\n\t\t\tpanic: false,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tif tt.panic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Fatalf(\"test %d did not panic\", i)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSubTo(tt.dst, tt.s, tt.t)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !equalSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"test %d: got %v, want %v\", i, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// equalSlices checks if two slices are equal.\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-10 { // tolerance for floating point comparison\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","17b48362ee126933a53c1a193c164509":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\ty         []float64\n\t\talpha     float64\n\t\ts         []float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\ty:         []float64{1, 2, 3},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{1, 1, 1},\n\t\t\texpected:  []float64{2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ty:         []float64{2, 3},\n\t\t\talpha:     0.5,\n\t\t\ts:         []float64{4, 6},\n\t\t\texpected:  []float64{4, 6},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ty:         []float64{2, 3},\n\t\t\talpha:     0,\n\t\t\ts:         []float64{4, 6},\n\t\t\texpected:  []float64{2, 3},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0},\n\t\t\ty:         []float64{1},\n\t\t\talpha:     2.0,\n\t\t\ts:         []float64{3},\n\t\t\texpected:  []float64{7},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ty:         []float64{5},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{1},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true, // Different lengths\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{0, 0},\n\t\t\ty:         []float64{1, 2},\n\t\t\talpha:     1.0,\n\t\t\ts:         []float64{3},\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true, // Different lengths\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for inputs %+v but did not panic\", test)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For inputs %+v, expected result %v, got %v\", test, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","1830f8f917008a5af3ab25c87b2ae2dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\thasPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 0, 10, -1, 0, false},\n\t\t{5, 0, 10, 11, 4, false},\n\t\t{5, 2, 8, 5, 1, false},\n\t\t{5, 0, 0, 0, 0, false},\n\t\t{2, 0, 10, 5, 1, false},\n\t\t{3, -1, 1, 0, 1, false},\n\t\t{2, -1, 1, 1, 1, false},\n\t\t{2, -1, 1, -1, 0, false},\n\t\t{1, 0, 10, 5, 0, true}, // Should panic\n\t\t{5, math.NaN(), 10, 5, 4, false},\n\t\t{5, 0, math.NaN(), 5, 0, false},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0, false},\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.hasPanic {\n\t\t\tassertPanic(t, func() { NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v) })\n\t\t} else {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\",\n\t\t\t\t\ttt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc assertPanic(t *testing.T, f func()) {\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"expected panic but did not occur\")\n\t\t}\n\t}()\n\tf()\n}","18f63684bb35c6121ee813332812b6fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice   []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t// Test with some regular values\n\t\t{[]float64{1, 2, 3}, 1, 6}, // L1 norm\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)}, // L2 norm\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)}, // L2 norm with negative values\n\t\t{[]float64{1, 2, 3}, 3, math.Pow((1+8+27), 1.0/3.0)}, // L3 norm\n\n\t\t// Test with special case L = Inf\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3}, // max absolute value\n\n\t\t// Test with an empty slice\n\t\t{[]float64{}, 1, 0}, // Norm of empty slice\n\n\t\t// Test with L = 0, which should be handled by the Count function\n\t\t// (Not applicable here, as L should be a positive number; just for completeness)\n\t\t{[]float64{}, 0, 0}, // edge case (norm not defined for L == 0)\n\n\t\t// Test with L = math.Inf(1) with mixed values\n\t\t{[]float64{-5, -10, 3.2}, math.Inf(1), 10}, // max absolute value with negatives\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.slice, test.L)\n\t\tif !floatEquals(result, test.expected) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; expected %v\", test.slice, test.L, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare floating point numbers for equality\nfunc floatEquals(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","1968ed211494d5115fccc7fbe0d9b841":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         1,\n\t\t\tu:         5,\n\t\t\texpected:  []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         0,\n\t\t\tu:         2,\n\t\t\texpected:  []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         -1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{-1, -0.66666667, -0.33333333, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         10,\n\t\t\tu:         20,\n\t\t\texpected:  []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tfor i := range test.expected {\n\t\t\tif math.Abs(got[i]-test.expected[i]) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, got, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Test panic for length of dst \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1) // This should panic\n}","19b2aa9741f579897b5c9a00dec4d507":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\ts         []float64\n\t\texpected  []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       []float64{2.0, 3.0, 4.0},\n\t\t\ts:         []float64{1.0, 2.0, 3.0},\n\t\t\texpected:  []float64{2.0, 1.5, 1.33333}, // 2.0/1.0, 3.0/2.0, 4.0/3.0\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{5.0, 6.0},\n\t\t\ts:         []float64{2.0, 3.0, 4.0},\n\t\t\texpected:  nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{10.0, 20.0},\n\t\t\ts:         []float64{0.0, 5.0},\n\t\t\texpected:  []float64{inf, 4.0}, // 10.0/0.0 will panic\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{1.0},\n\t\t\ts:         []float64{1.0},\n\t\t\texpected:  []float64{1.0}, // 1.0/1.0\n\t\t\tshouldPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.shouldPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tMul(test.dst, test.s)\n\t\t\t}()\n\t\t} else {\n\t\t\tMul(test.dst, test.s)\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif i \u003c len(test.dst) \u0026\u0026 test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"For dst: %v and s: %v, expected %v at index %d, but got %v\", test.dst, test.s, v, i, test.dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","1ad9c3bf09c1a9d8050c0ee5abf9560b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts:        []float64{-4.0, -5.0, -6.0},\n\t\t\texpected: []float64{-5.0, -7.0, -9.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      nil,\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tAdd(test.dst, test.s)\n\t\tif !test.panic {\n\t\t\tgot := test.dst\n\t\t\tif len(got) != len(test.expected) {\n\t\t\t\tt.Errorf(\"expected length %d, got %d\", len(test.expected), len(got))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"for dst: %v, s: %v; expected[%d] = %f, got[%d] = %f\", test.dst, test.s, i, test.expected[i], i, got[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","1c4cb9f8a7e88f9578abe483cfc61f88":"// maxidx_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{[]float64{3.0, 3.0, 3.0}, 0},\n\t\t{[]float64{-1.0, -2.0, -3.0, -1.0}, 0},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},\n\t\t{[]float64{5.0}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on zero-length slice\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"Expected panic on zero-length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","1c5f72f2d5979de07ba7baa8000ca229":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       4,\n\t\t\twant:    []float64{0, 1, 2, 3, 4},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       -1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{-1, 0, 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{1, 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       5,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       2,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{2, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       1,\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       1,\n\t\t\tu:       math.Inf(-1),\n\t\t\twant:    []float64{1, math.Inf(-1), math.Inf(-1)},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","1ca3cc76bc3280f4036eb5e02262113a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Valid Span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 0.0, 10.0\n\t\texpected := []float64{0.0, 2.5, 5.0, 7.5, 10.0}\n\t\tresult := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Short Slice Panics\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for length \u003c 2, but got none\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 10)\n\t})\n\n\tt.Run(\"NaN Handling for l\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 10.0\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0}\n\t\tresult := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(expected[i]) || result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaN Handling for u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 0.0\n\t\tu := math.NaN()\n\t\texpected := []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tresult := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(expected[i]) || result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinity Handling for l\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(-1)\n\t\tu := math.Inf(1)\n\t\texpected := []float64{-math.Inf(1), -math.Inf(1), 0, math.Inf(1), math.Inf(1)}\n\t\tresult := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinity Handling for u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 0.0\n\t\tu := math.Inf(1)\n\t\texpected := []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)}\n\t\tresult := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n}","1d6ce67971a15d6b9f8427cb2884ae20":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, 1e-10, 1e-10},\n\t\t\texpected: 1e10,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 4.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.NaN()},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0},\n\t\t\texpected: -6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 1.0},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(-1), -1.0},\n\t\t\texpected: math.Inf(-1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0, -1.0},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.MaxFloat64, math.MaxFloat64},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.MaxFloat64, -math.MaxFloat64},\n\t\t\texpected: 0.0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif (math.IsNaN(result) \u0026\u0026 !math.IsNaN(test.expected)) || (result != test.expected \u0026\u0026 !math.IsNaN(result)) {\n\t\t\tt.Errorf(\"For input %v, expected %v but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","1fdd45a9c18c7c68f389281bb34338b8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl, u  float64\n\t\tv     float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},              // middle value\n\t\t{5, 0, 10, 0, 0},              // lower bound\n\t\t{5, 0, 10, 10, 3},             // upper bound\n\t\t{5, 0, 10, -1, 0},             // below lower bound\n\t\t{5, 0, 10, 11, 3},             // above upper bound\n\t\t{5, 5, 15, 10, 2},             // middle value with different bounds\n\t\t{3, 1, 2, 1, 0},               // edge case with lower bounds\n\t\t{4, 1, 1, 1, 0},                // l and u are equal\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 1}, // inf cases\n\t\t{4, math.Inf(-1), math.Inf(1), math.Inf(1), 3}, // inf cases\n\t\t{2, 0, 1, 0.5, 0},             // edge case with the lowest n\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d l=%v u=%v v=%v\", test.n, test.l, test.u, test.v), func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic when n \u003c 2\n\tdefer func() { recover() }()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\tt.Error(\"Expected panic for n \u003c 2 did not occur\")\n}","1fe92cb8cfb822ebbb0cb855c24a048d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\n// TestNearestIdx tests the NearestIdx function for various cases.\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts   []float64\n\t\tv   float64\n\t\tidx int\n\t}{\n\t\t// Test with standard cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2},\n\t\t{[]float64{10.0, 20.0, 30.0}, 25.0, 1},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -2.5, 1},\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1.5, 1}, // treat NaN as the most distant\n\n\t\t// Test cases with multiple closest values\n\t\t{[]float64{1.0, 2.0, 2.0, 3.0}, 2.0, 1}, // choose lowest index if multiple closest\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0},\n\n\t\t// Edge case: very large numbers\n\t\t{[]float64{1e10, 2e10, 3e10}, 2e10, 1},\n\n\t\t// Edge case: check NaN (should return 0)\n\t\t{[]float64{1.0, 2.0}, math.NaN(), 0},\n\n\t\t// Edge case: check +Inf (should return max index)\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2},\n\n\t\t// Edge case: check -Inf (should return min index)\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.idx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.idx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero-length input\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdx must panic on zero-length slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","200507033a4953d93b579d69ed390e88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"single positive number\",\n\t\t\tinput:    []float64{5.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple numbers, max at start\",\n\t\t\tinput:    []float64{10.0, 2.0, 3.0, 4.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple numbers, max at end\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 10.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple numbers, max in middle\",\n\t\t\tinput:    []float64{1.0, 10.0, 3.0, 4.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple identical max values\",\n\t\t\tinput:    []float64{1.0, 10.0, 10.0, 4.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"with NaN values\",\n\t\t\tinput:    []float64{math.NaN(), 10.0, 5.0, 10.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"all NaN values\",\n\t\t\tinput:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpected: 0, // This will be adjusted based on your implementation to handle NaN\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"all NaN values\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not receive one\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice but did not receive one\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","20b1c7750ca546302f3faea997b5b38d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},             // Middle value in the span\n\t\t{5, 0, 10, 0, 0},             // Lower bound\n\t\t{5, 0, 10, 10, 4},            // Upper bound\n\t\t{5, 0, 10, -1, 0},            // Below lower bound\n\t\t{5, 0, 10, 11, 4},            // Above upper bound\n\t\t{5, 10, 0, 5, 2},             // Reverse bounds\n\t\t{3, math.NaN(), 10, 5, 2},   // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0},    // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Infinite bounds\n\t\t{3, math.Inf(-1), math.Inf(1), 1, 2}, // Infinite bounds, value in between\n\t\t{1, 0, 10, 5, 0},             // Panic case (n \u003c 2)\n\t\t{3, 0, 0, 0, 0},              // All zeros\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif tt.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", tt.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","210f3b2cc25d3852c35a761e34477c91":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpect    []float64\n\t\texpectPanic bool // indicates whether this test should panic\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         1,\n\t\t\tu:         5,\n\t\t\texpect:    []float64{1, 2, 3, 4, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\texpect:    []float64{0, 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         -2,\n\t\t\tu:         2,\n\t\t\texpect:    []float64{-2, 0, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 0),\n\t\t\tl:         1,\n\t\t\tu:         2,\n\t\t\texpect:    nil, // expects panic\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         1,\n\t\t\tu:         2,\n\t\t\texpect:    nil, // expects panic\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         5,\n\t\t\texpect:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         1,\n\t\t\tu:         math.NaN(),\n\t\t\texpect:    []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         1,\n\t\t\texpect:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         1,\n\t\t\tu:         math.Inf(-1),\n\t\t\texpect:    []float64{1, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, l: %v, u: %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tif !tt.expectPanic \u0026\u0026 !equalSlices(result, tt.expect) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, result, tt.expect)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","213b596d12483bcacb7cf3ba03419666":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts           []float64\n\t\tv           float64\n\t\texpectedIdx int\n\t\texpectedPanics bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1, false},\n\t\t{[]float64{3.0, 2.0, 1.0}, 2.5, -1, true}, // Not sorted\n\t\t{[]float64{1.0}, 1.5, -1, true},          // Less than 2 elements\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectedPanics {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v, but did not panic\", test.s, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Within(test.s, test.v)\n\n\t\tif got != test.expectedIdx {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", test.s, test.v, got, test.expectedIdx)\n\t\t}\n\t}\n\n\t// Edge case for NaN\n\tif got := Within([]float64{1.0, 2.0, 3.0}, math.NaN()); got != -1 {\n\t\tt.Errorf(\"Expected -1 for NaN input; got %d\", got)\n\t}\n}","226111ab2928dc905e44814f6f9015be":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t// Test for L = 1\n\t\t{[]float64{1, -2, 3}, 1, 6}, // |1| + |-2| + |3| = 6\n\t\t{[]float64{0, 0, 0}, 1, 0},   // |0| + |0| + |0| = 0\n\n\t\t// Test for L = 2 (using a special case)\n\t\t{[]float64{3, 4}, 2, 5},      // √(3² + 4²) = 5\n\t\t{[]float64{5, 12}, 2, 13},    // √(5² + 12²) = 13\n\n\t\t// Test for L = Infinity (max absolute value)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3}, // max(|1|, |-2|, |3|) = 3\n\t\t{[]float64{-1, -5, 2}, math.Inf(1), 5}, // max(|-1|, |-5|, |2|) = 5\n\n\t\t// Test for generic L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)}, // (1³ + 2³ + 3³)^(1/3)\n\t\t{[]float64{4, -5, 6}, 4, math.Pow(77, 1.0/4.0)}, // (4⁴ + |-5|⁴ + 6⁴)^(1/4)\n\n\t\t// Edge case: empty slice\n\t\t{[]float64{}, 1, 1}, // return 1 for empty slice\n\t\t{[]float64{}, 2, 1}, // return 1 for empty slice\n\t\t{[]float64{}, math.Inf(1), 1}, // return 1 for empty slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.s, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.s, tt.L, got, tt.want)\n\t\t}\n\t}\n}","22bd207af381f87686834da5d600c1ad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},          // Nearest value to 2.5 is at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0},           // Nearest value to 0.0 is at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2},           // Nearest value to 3.5 is at index 2\n\t\t{[]float64{1.0, 2.0, 3.0}, -1.0, 0},          // Nearest value to -1.0 is at index 0\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0},           // Nearest value to 1.0, multiple values, first index is 0\n\t\t{[]float64{5.0, 10.0, 15.0}, 9.0, 1},         // Nearest value to 9.0 is at index 1\n\t\t{[]float64{5.0, 10.0, 15.0}, 20.0, 2},        // Nearest value to 20.0 is at index 2\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", test.s, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdx did not panic for zero length slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n\n\t// Test for NaN value\n\tresult := NearestIdx([]float64{1.0, 2.0, 3.0}, math.NaN())\n\tif result != 0 { // Should return 0 because v is NaN\n\t\tt.Errorf(\"NearestIdx returned %d for NaN input; want 0\", result)\n\t}\n}","252ed22fd9f5304c94adacddc06a1137":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{input: []float64{1.0, 2.0, 3.0}, expected: false},\n\t\t{input: []float64{1.0, math.NaN(), 3.0}, expected: true},\n\t\t{input: []float64{math.NaN(), math.NaN()}, expected: true},\n\t\t{input: []float64{}, expected: false},\n\t\t{input: []float64{math.Inf(1), math.Inf(-1), 3.0}, expected: false},\n\t\t{input: []float64{math.NaN(), 1.0, 2.0}, expected: true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := HasNaN(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"HasNaN(%v) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","253f0b1f1c4b549501d40eca15d5eced":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Testing with a straightforward case\n\t\t{5, 0, 10, 5, 2}, // Expect index 2 for value 5\n\t\t{5, 0, 10, 0, 0}, // Expect index 0 for value 0\n\t\t{5, 0, 10, 10, 4}, // Expect index 4 for value 10\n\t\t{5, 0, 10, 3, 1}, // Expect index 1 for value 3\n\t\t{5, 1, 5, 2.5, 1}, // Expect index 1 for value 2.5\n\t\t{5, 5, 1, 2, 4}, // Expect index 4 for value 2 when l \u003e u\n\n\t\t// Testing cases with NaN and Inf\n\t\t{5, math.NaN(), 10, 5, 4}, // Expect index 4 if lower bound is NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // Expect index 0 if upper bound is NaN\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Expect index 4 for upper Inf\n\t\t{5, math.Inf(1), math.Inf(-1), math.Inf(-1), 0}, // Expect index 0 for lower Inf\n\n\t\t// Testing edge cases\n\t\t{3, -1, 1, -2, 0}, // Expect index 0 for value out of bounds (left)\n\t\t{3, -1, 1, 2, 2}, // Expect index 2 for value out of bounds (right)\n\t\t{2, 0, 0, 0, 0}, // Expect index 0 in a degenerate case\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Testing for panic scenarios\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0) // This should panic\n}","25ce682804023f9a12509c8ac3f9216a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      4,\n\t\t\twant:   []float64{0, 1, 2, 3, 4},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      2,\n\t\t\tu:      6,\n\t\t\twant:   []float64{2, 4, 6},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      -10,\n\t\t\tu:      10,\n\t\t\twant:   []float64{-10, 10},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 0),\n\t\t\tl:      1,\n\t\t\tu:      5,\n\t\t\twant:   nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      1,\n\t\t\tu:      5,\n\t\t\twant:   nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      2,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), 2},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      -math.Inf(1),\n\t\t\tu:      math.Inf(0),\n\t\t\twant:   []float64{-math.Inf(1), -math.Inf(1), 0, math.Inf(0)},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(0),\n\t\t\twant:   []float64{0, 0, 0, math.Inf(0)},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() { recover() }()\n\t\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range tt.want {\n\t\t\t\tif math.IsNaN(v) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span() = %v, want NaN at index %d\", got, i)\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != v {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want %v at index %d\", got, tt.want, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","26a35a13561a9794e4226386d82986f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 1, 0},                      // Distance should be 0\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},                     // Manhattan distance\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},         // Euclidean distance\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},           // Max distance\n\t\t{[]float64{}, []float64{}, 1, 0},                                   // Distance of empty slices\n\t\t{[]float64{1}, []float64{1}, 2, 0},                                 // Single element similarity\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 len(test.s) != len(test.t) {\n\t\t\t\t\t// panic expected due to length mismatch\n\t\t\t\t\treturn\n\t\t\t\t} else if r != nil {\n\t\t\t\t\tt.Errorf(\"Distance panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := Distance(test.s, test.t, test.L)\n\t\t\tif !almostEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two float64 values with a tolerance for floating point arithmetic\nfunc almostEqual(a, b float64) bool {\n\tconst tolerance = 1e-9\n\treturn math.Abs(a-b) \u003c tolerance\n}","273f0a878b8e6f3562e9f28f044dc394":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []float64\n\t\toutput float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{[]float64{1.0, -1.0, 1.0, -1.0}, 0.0},\n\t\t{[]float64{math.MaxFloat64, 1.0}, math.MaxFloat64},\n\t\t{[]float64{math.MaxFloat64, -math.MaxFloat64}, 0.0},\n\t\t{[]float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{[]float64{0.1, 1e-10, 0.2, 0.1}, 0.4000000001},\n\t\t{[]float64{}, 0.0},  // Edge case: empty slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif !equal(result, tt.output) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", tt.input, result, tt.output)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floating point numbers\nfunc equal(a, b float64) bool {\n\tconst tolerance = 1e-9 // Allow for a small difference due to floating-point arithmetic\n\treturn math.Abs(a-b) \u003c tolerance\n}","275967bd3d165d6f5e107ac14d6101cc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{3, 0, 10, 5, 1},             // Normal case\n\t\t{4, 1, 9, 5, 2},              // Normal case\n\t\t{5, -10, 10, 0, 2},           // Normal case\n\t\t{5, 0, 1, 0.5, 2},            // Normal case\n\t\t{2, 1, 2, 1.5, 1},            // Lower bound case\n\t\t{2, 1, 2, 2, 1},              // Upper bound case\n\t\t{2, 1, 2, 1, 0},              // Exact lower bound\n\t\t{2, 1, 2, 2, 1},              // Exact upper bound\n\t\t{5, 1, 3, 4, 4},              // Out of range above\n\t\t{5, 1, 3, 0, 0},              // Out of range below\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // Inf case\n\t\t{3, math.NaN(), 10, 5, 2},   // NA case\n\t\t{3, 0, math.NaN(), 5, 0},    // NA case\n\t\t{3, math.Inf(-1), math.Inf(-1), -1, 0}, // Same Inf\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Edge case testing\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)  // This should panic\n}","27980de3e3145bbf91a6bce006ce4d0c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0},\n\t\t{[]float64{3.0, 1.0, 2.0}, 1},\n\t\t{[]float64{-1.0, 0.0, 2.0}, 0},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 0},\n\t\t{[]float64{math.NaN(), math.NaN(), 3.0}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d; want %d\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx did not panic for zero length slice\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","2799b7f6d5b93f89992e821705bebff0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Test valid case with n = 3\n\t\t{3, 0, 1, 0.5, 1},\n\t\t// Test valid case with n = 5\n\t\t{5, 0, 2, 1, 2},\n\t\t// Test lower bound l \u003c u\n\t\t{5, 0, 10, -1, 0},\n\t\t// Test upper bound l \u003e u\n\t\t{5, 10, 0, 11, 0},\n\t\t// Test NaN value\n\t\t{5, 0, 10, math.NaN(), 0},\n\t\t// Test lower bound inf\n\t\t{5, math.Inf(-1), 10, -5, 0},\n\t\t// Test upper bound inf\n\t\t{5, 0, math.Inf(1), 5, 4},\n\t\t// Test equal bounds\n\t\t{5, 5, 5, 5, 0},\n\t\t// Test n \u003c 2 case\n\t\t{1, 0, 1, 0, 0}, // Expect a panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.n \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif result != tt.expect \u0026\u0026 tt.n \u003e= 2 {\n\t\t\tt.Errorf(\"Unexpected result for n=%d, l=%v, u=%v, v=%v: got %d, want %d\", tt.n, tt.l, tt.u, tt.v, result, tt.expect)\n\t\t}\n\t}\n}","28520fc1a5692c9c87d9da5daba3a32d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1},         // normal case\n\t\t{[]float64{1.0, 1.0, 1.0}, 0},         // all elements are the same\n\t\t{[]float64{2.5, -1.5, 3.0, 0.0}, 1},  // negative minimum\n\t\t{[]float64{math.NaN(), 1.0, 0.0}, 2}, // NaN handling, min valid number\n\t\t{[]float64{math.NaN(), math.NaN()}, 0}, // all NaNs, returns first index\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := MinIdx(tt.input)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d; want %d\", tt.input, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx([]) did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","288f617c62576d3f1a88038094c17195":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput  []float64\n\t\toutput int\n\t}{\n\t\t{[]float64{2.0, 3.0, 1.0}, 2},           // Normal case\n\t\t{[]float64{5.0, 1.0, 1.0, 2.0}, 1},      // Multiple minimums\n\t\t{[]float64{-1.0, -2.0, 0.0, 1.0}, 1},    // Negative numbers\n\t\t{[]float64{math.NaN(), 2.0, 1.0}, 2},    // Handling NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.output {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.output)\n\t\t}\n\t}\n\n\tt.Run(\"panic on zero length\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for zero length slice but did not occur\")\n\t\t\t}\n\t\t}()\n\t\tMinIdx([]float64{})\n\t})\n}","28ebcdc9ba99fb1af3edf4495a630a68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1},\n\t\t{[]float64{5.0, 1.0, 1.0}, 1},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, math.NaN()}, 0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2},\n\t\t{[]float64{1.0}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := MinIdx(test.s)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For input %v, expected index %d, got %d\", test.s, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","28f9800a7a4182bbc7af30b587ca4260":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tslice      []float64\n\t\tL          float64\n\t\texpected   float64\n\t\tshouldFail bool\n\t}{\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm\",\n\t\t\tslice:    []float64{3, 4},\n\t\t\tL:        2,\n\t\t\texpected: 5, // 3^2 + 4^2 = 25 =\u003e sqrt(25) = 5\n\t\t},\n\t\t{\n\t\t\tname:     \"LInf norm\",\n\t\t\tslice:    []float64{-1, -2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"Invalid L value (0)\",\n\t\t\tslice:      []float64{1, 2, 3},\n\t\t\tL:          0,\n\t\t\texpected:   0, // this is for illustration; implement check for invalid L if necessary\n\t\t\tshouldFail: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Large L value\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        10,\n\t\t\texpected: math.Pow(math.Pow(1, 10)+math.Pow(2, 10)+math.Pow(3, 10)+math.Pow(4, 10)+math.Pow(5, 10), 1.0/10.0),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif tt.shouldFail {\n\t\t\t\t// Here we would typically check for a panic or error,\n\t\t\t\t// but since Norm does not handle invalid L in the provided code, \n\t\t\t\t// we would skip this check if not updated. \n\t\t\t\t// If 'shouldFail' is set to true and Norm does not panic, fail the test.\n\t\t\t\tt.Errorf(\"expected failure for L value: %v\", tt.L)\n\t\t\t} else if result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","29038392105c5bc234f760656fcb22e2":"// file: maxidx_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},         // Normal case\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},       // All negative values\n\t\t{[]float64{1.0, 3.0, 2.0, 3.0}, 1},    // Duplicate max value\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 2},  // NaN in slice\n\t\t{[]float64{math.NaN(), math.NaN(), 5.0, math.NaN()}, 2}, // All NaNs except one\n\t\t{[]float64{math.Inf(-1), math.Inf(1)}, 1}, // Inf values\n\t\t{[]float64{}, 0},                        // Empty slice, expect panic\n\t}\n\n\tfor _, test := range tests {\n\t\tif len(test.input) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but no panic occurred\", test.input)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2912766f5fa08aadae1282284cedee38":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal spacing between two points\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\texpect: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"Single span\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      2.0,\n\t\t\tu:      2.0,\n\t\t\texpect: []float64{2.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"Negative spacing\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -3.0,\n\t\t\tu:      -1.0,\n\t\t\texpect: []float64{-3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"Panic on short length\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Panic on empty slice\",\n\t\t\tdst:    []float64{},\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Handling NaN in lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      4.0,\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"Handling NaN in upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      1.0,\n\t\t\tu:      math.NaN(),\n\t\t\texpect: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"Handling infinite bounds\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expect == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic, but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t\t} else {\n\t\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\t\tfor i, v := range result {\n\t\t\t\t\tif v != tt.expect[i] {\n\t\t\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expect[i], v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","29321ecf0482984dd39ea3b7ce875e3b":"// file: span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\texpected: []float64{0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -2.0,\n\t\t\tu:        2.0,\n\t\t\texpected: []float64{-2.0, -1.0, 0.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{10.0, 10.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range result {\n\t\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(tt.expected[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected[i], v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panics on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic, but got none\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n\n\tt.Run(\"handles NaN values for l\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\t\tresult := Span(dst, math.NaN(), 5.0)\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"handles NaN values for u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tresult := Span(dst, 1.0, math.NaN())\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 math.IsNaN(expected[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"handles infinities\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)}\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n}","29360998acd13b342952710bb8afacf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       4,\n\t\t\twant:    []float64{0, 1, 2, 3, 4},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       -1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{-1, 0, 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{1, 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       1,\n\t\t\tu:       2,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       2,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), 2},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       2,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{2, math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\twant:    []float64{math.Inf(-1), math.NaN(), math.NaN(), math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, l: %v, u: %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\n// equalSlices checks if two slices of float64 are equal.\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// floatEqual checks if two float64 values are approximately equal.\nfunc floatEqual(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","295ed50fd8578a673bb2e3fcc8350d9c":"// File: sum_compensated_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"empty slice\", []float64{}, 0.0},\n\t\t{\"single element\", []float64{5.0}, 5.0},\n\t\t{\"multiple elements\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"negative elements\", []float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{\"mixed elements\", []float64{-1.0, 2.5, 3.5}, 5.0},\n\t\t{\"large numbers\", []float64{1e10, 1e10, 1e10}, 3e10},\n\t\t{\"small numbers\", []float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{\"float precision\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(test.input)\n\t\t\tif math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","29b9b1c0f0123acdc4bd5a5dcb577350":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice   []float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 5, 2}, 1},\n\t\t{[]float64{-1, -2, -3, -4}, 0},\n\t\t{[]float64{math.NaN(), 2, 3}, 1},\n\t\t{[]float64{1, math.NaN(), 3}, 0},\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, 0},  // all NaN\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgotIdx := MaxIdx(tt.slice)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", tt.slice, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","2a86c48c0b34e51f7e81c07ad226cfc8":"// subto_test.go\n\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\ts     []float64\n\t\tt     []float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\ts:    []float64{3, 5, 7},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: []float64{2, 3, 4},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{0, 0},\n\t\t\ts:    []float64{3, 5, 7},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: nil,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\ts:    []float64{3, 5, 7},\n\t\t\tt:    []float64{1, 2},\n\t\t\twant: nil,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{3, 5, 7},\n\t\t\ts:    []float64{3, 5, 7},\n\t\t\tt:    []float64{0, 0, 0},\n\t\t\twant: []float64{3, 5, 7},\n\t\t\tpanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input (dst: %v, s: %v, t: %v), but did not.\", test.dst, test.s, test.t)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSubTo(test.dst, test.s, test.t)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := SubTo(test.dst, test.s, test.t)\n\t\t\tif !equal(got, test.want) {\n\t\t\t\tt.Errorf(\"SubTo(%v, %v, %v) = %v, want %v\", test.dst, test.s, test.t, got, test.want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// equal checks if two slices are equal.\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2adf7865b18d991dea53dc6df7a87df3":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{}, 1},\n\t\t{[]float64{2.0}, 2.0},\n\t\t{[]float64{2.0, 3.0}, 6.0},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 24.0},\n\t\t{[]float64{-1.0, -2.0}, 2.0},\n\t\t{[]float64{0.0}, 0.0},\n\t\t{[]float64{1.0, 0.5, 0.1}, 0.05},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Prod(tt.input)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Prod(%v) = %v; want %v\", tt.input, got, tt.want)\n\t\t}\n\t}\n}","2c01766532bd63aa2abc38cc94eb14e6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\t\tdst         []float64\n\t\tl           float64\n\t\tu           float64\n\t\texpected    []float64\n\t\tpanic       bool // indicates whether we expect a panic\n\t}{\n\t\t{\n\t\t\tdescription: \"normal span\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           0,\n\t\t\tu:           4,\n\t\t\texpected:    []float64{0, 1, 2, 3, 4},\n\t\t\tpanic:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"span with negative bounds\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           -4,\n\t\t\tu:           0,\n\t\t\texpected:    []float64{-4, -3, -2, -1, 0},\n\t\t\tpanic:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"span with zero range\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           2,\n\t\t\tu:           2,\n\t\t\texpected:    []float64{2, 2, 2, 2, 2},\n\t\t\tpanic:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"panic when length of dst is less than 2\",\n\t\t\tdst:         make([]float64, 1),\n\t\t\tl:           0,\n\t\t\tu:           1,\n\t\t\texpected:    nil,\n\t\t\tpanic:       true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"span with NaN lower bound\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           math.NaN(),\n\t\t\tu:           4,\n\t\t\texpected:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\tpanic:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"span with NaN upper bound\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           0,\n\t\t\tu:           math.NaN(),\n\t\t\texpected:    []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"span with inf lower and upper bounds\",\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           math.Inf(-1),\n\t\t\tu:           math.Inf(1),\n\t\t\texpected:    []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, math.Inf(1)},\n\t\t\tpanic:       false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tassertPanic(t, func() { Span(tt.dst, tt.l, tt.u) })\n\t\t} else {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range tt.expected {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"%s: expected %v, got %v\", tt.description, tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// assertPanic asserts that a function call results in a panic.\nfunc assertPanic(t *testing.T, f func()) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic but did not panic\")\n\t\t}\n\t}()\n\tf()\n}","2c0b11a375fc921998c1c9c945a1e821":"// File: nearest_idx_for_span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},    // Closest to mid point\n\t\t{5, 0, 10, 0, 0},    // Closest to lower bound\n\t\t{5, 0, 10, 10, 4},   // Closest to upper bound\n\t\t{5, -10, 10, -5, 1}, // Closest to negative mid point\n\t\t{5, 10, 0, 5, 3},    // Closest to mid point with inverted bounds\n\t\t{5, 0, 10, -1, 0},   // Outside lower limit\n\t\t{5, 0, 10, 11, 4},   // Outside upper limit\n\t\t{5, math.NaN(), 10, 5, 4},  // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0},   // Upper bound NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Infinite bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","2d185405319948d8cbedc6a6a50ab7fc":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid division\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{4, 9, 16},\n\t\t\tt:        []float64{2, 3, 4},\n\t\t\texpected: []float64{2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on length mismatch - dst length\",\n\t\t\tdst:      []float64{0, 0}, // Length 2\n\t\t\ts:        []float64{1, 2, 3}, // Length 3\n\t\t\tt:        []float64{1, 2, 3}, // Length 3\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on length mismatch - s length\",\n\t\t\tdst:      []float64{0, 0, 0}, // Length 3\n\t\t\ts:        []float64{4, 5}, // Length 2\n\t\t\tt:        []float64{2, 3}, // Length 2\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for test %s, but did not get one\", tt.name)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := DivTo(tt.dst, tt.s, tt.t)\n\n\t\t\tif !tt.expectPanic \u0026\u0026 !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Got %v, expected %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2d9592ac59a1a355ee03def9ab0094c3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 3, 1},      // v is in the middle of the range\n\t\t{5, 0, 10, 0, 0},      // v is at lower bound\n\t\t{5, 0, 10, 10, 4},     // v is at upper bound\n\t\t{5, -10, 0, -7, 2},    // negative range\n\t\t{5, 0, 0, 0, 0},       // all zeros\n\t\t{3, 1, 1, 1, 0},       // case with no range\n\t\t{4, 1, 3, 2, 1},       // even number of spans\n\t\t{7, 1, 4, 2.5, 2},     // testing with fractional midpoints\n\t\t{4, 1, 4, 5, 3},       // v exceeds upper bound\n\t\t{4, 4, 1, 0, 3},       // reverse order bounds\n\t\t{10, 0, 0, -1, 0},     // v below lower bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\",\n\t\t\t\t\ttest.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic condition\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","2e64769798a5cc94d729f8d90e29adfd":"package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n    tests := []struct {\n       \tname     string\n       \tdst      []float64\n       \tc        float64\n       \ts        []float64\n       \texpected []float64\n    }{\n        {\n            name:     \"simple scaling\",\n            dst:      []float64{0, 0, 0},\n            c:        2,\n            s:        []float64{1, 2, 3},\n            expected: []float64{2, 4, 6},\n        },\n        {\n            name:     \"negative scaling\",\n            dst:      []float64{0, 0, 0},\n            c:        -1,\n            s:        []float64{1, 2, 3},\n            expected: []float64{-1, -2, -3},\n        },\n        {\n            name:     \"zero scaling\",\n            dst:      []float64{0, 0, 0},\n            c:        0,\n            s:        []float64{1, 2, 3},\n            expected: []float64{0, 0, 0},\n        },\n        {\n            name:     \"matching lengths\",\n            dst:      []float64{0, 0},\n            c:        3,\n            s:        []float64{1, 2},\n            expected: []float64{3, 6},\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            defer func() {\n                if recover() == nil {\n                    t.Errorf(\"Expected panic for mismatched lengths of dst and s\")\n                }\n            }()\n            ScaleTo(tt.dst, tt.c, tt.s)\n            if !Equal(tt.dst, tt.expected) {\n                t.Errorf(\"got %v, want %v\", tt.dst, tt.expected)\n            }\n        })\n    }\n\n    // Test for panic: lengths do not match\n    dst := []float64{0, 0, 0}\n    s := []float64{1, 2}\n    defer func() {\n        if r := recover(); r == nil {\n            t.Errorf(\"ScaleTo did not panic with mismatched lengths\")\n        }\n    }()\n    ScaleTo(dst, 1, s)\n}","2e8f04b46a7cc612ea38ffd806e2eb04":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tl, u float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{0, 10, make([]float64, 11), []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}},\n\t\t{-5, 5, make([]float64, 11), []float64{-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5}},\n\t\t{1, 1, make([]float64, 5), []float64{1, 1, 1, 1, 1}},\n\t\t{math.NaN(), 10, make([]float64, 11), []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}},\n\t\t{0, math.NaN(), make([]float64, 11), []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}},\n\t\t{math.Inf(-1), math.Inf(1), make([]float64, 3), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tt.want[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif got[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v) = %v, want %v\", tt.dst, tt.l, got, tt.want)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on short lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic with len \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","2f1a12d46d26c88d281ab17f5d43f813":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Middle value\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // Closer to 1.0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closer to 3.0\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0}, // Below range\n\t\t{[]float64{1.0, 2.0, 3.0, 2.0}, 2.1, 1}, // Duplicates in range\n\t\t{[]float64{-1.0, -2.0, -3.0}, -2.5, 1}, // Negative values\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0}, // All same values\n\t\t{[]float64{}, 1.0, -1}, // Zero length slice (panic)\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.s == nil {\n\t\t\tt.Run(\"zero length slice\", func(t *testing.T) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx did not panic for zero length slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdx(tt.s, tt.v)\n\t\t\t})\n\t\t} else {\n\t\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxWithSpecialValues(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // v is positive infinity\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // v is negative infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tgotIdx := NearestIdx(tt.s, tt.v)\n\t\tif gotIdx != tt.wantIdx {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, gotIdx, tt.wantIdx)\n\t\t}\n\t}\n}","3089a094a99d51ef78034874e78c9a53":"// logsumexp_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Regular case\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))}, // Negative values\n\t\t{[]float64{0}, 0}, // Single value\n\t\t{[]float64{1, 1, 1}, math.Log(3)}, // Same values\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"LogSumExp(%v)\", tt.input), func(t *testing.T) {\n\t\t\tresult := LogSumExp(tt.input)\n\t\t\tif !equal(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"LogSumExp_EmptySlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for empty slice\")\n\t\t\t}\n\t\t}()\n\t\tLogSumExp([]float64{})\n\t})\n}\n\nfunc equal(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","30dee26f57fa90a8a53794231ce2c69e":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t\t{\"One empty slice\", [][]float64{{}}, true},\n\t\t{\"Equal length slices\", [][]float64{{1.0, 2.0}, {3.0, 4.0}}, true},\n\t\t{\"Different length slices\", [][]float64{{1.0, 2.0}, {3.0}}, false},\n\t\t{\"All empty slices\", [][]float64{{}, {}, {}}, true},\n\t\t{\"Mixed empty and non-empty slices\", [][]float64{{1.0, 2.0}, {}, {3.0}}, false},\n\t\t{\"Single non-empty slice\", [][]float64{{1.0}}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","310cb20bedefcc5ffc221258026fc89f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\tfees  []float64\n\t}{\n\t\t{dst: make([]float64, 5), l: 0, u: 10, fees: []float64{0, 2.5, 5, 7.5, 10}},\n\t\t{dst: make([]float64, 3), l: 1, u: 7, fees: []float64{1, 4, 7}},\n\t\t{dst: make([]float64, 4), l: -2, u: 2, fees: []float64{-2, -1, 0, 2}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(tt.fees[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"expected NaN at pos %d, got %v\", i, v)\n\t\t\t\t}\n\t\t\t} else if v != tt.fees[i] {\n\t\t\t\tt.Errorf(\"expected %v at pos %d, got %v\", tt.fees[i], i, v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on insufficient length\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1) // Should panic\n}","315d479ff232fd65956f9b3da7e0e12b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, expectedIdx int\n\t\tl, u, v       float64\n\t\texpectPanic   bool\n\t}{\n\t\t{2, 0, 0, 1, 0.5, false},    // Midpoint\n\t\t{5, 2, 0, 1, 0.4, false},    // Closer to lower bound\n\t\t{5, 2, 0, 1, 0.6, false},    // Closer to upper bound\n\t\t{5, 0, 1, 3, 0.5, false},    // Boundaries inverted\n\t\t{5, 4, 1, 3, 3.0, false},    // Closer to upper bound inverted\n\t\t{5, 0, math.Inf(-1), math.Inf(1), 0.0, false}, // Inf boundaries\n\t\t{5, 5, math.Inf(-1), math.Inf(-1), 0.0, false}, // Lower bound is Inf\n\t\t{2, 0, math.NaN(), 1, 0.0, false}, // Lower bound NaN\n\t\t{2, 1, 0, math.NaN(), 0.0, false}, // Upper bound NaN\n\t\t{2, 0, 0, 0, 0.0, false},    // Both bounds equal\n\t\t{1, 0, 0, 1, 0.5, true},     // Panic case: n \u003c 2\n\t\t{0, 0, 0, 1, 0.5, true},     // Panic case: n \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d, l=%f, u=%f, v=%f\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tactualIdx := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif actualIdx != tt.expectedIdx {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, actualIdx, tt.expectedIdx)\n\t\t}\n\t}\n}","31da813b746c7eabd381b135198484d7":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 1, 1},    // Normal case\n\t\t{5, 0, 10, 0, 0},    // Value is the lower bound\n\t\t{5, 0, 10, 10, 4},   // Value is the upper bound\n\t\t{5, 0, 10, 5, 2},    // Value is in the middle\n\t\t{5, -5, 5, 0, 2},    // Negative lower bound and positive upper bound\n\t\t{5, 5, 0, 7, 3},     // Lower bound greater than upper bound\n\t\t{3, 0, 10, 15, 2},   // Value above upper bound\n\t\t{3, 0, 10, -5, 0},   // Value below lower bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf case\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf case\n\t\t{5, math.NaN(), 10, 1, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 1, 0}, // NaN upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Expected index %d for NearestIdxForSpan(%d, %f, %f, %f), got %d\", \n\t\t\t\ttest.expect, test.n, test.l, test.u, test.v, result)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // Should panic\n}","32bb0402b219e3687bbce36b83414407":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts []float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 2.5, 2},\n\t\t{[]float64{0, 1, 2, 3}, 3, 3},\n\t\t{[]float64{0, 1, 2, 3}, 0, 0},\n\t\t{[]float64{0, math.Inf(1)}, 0, 0},\n\t\t{[]float64{0, 1}, 1, 1},\n\t\t{[]float64{1, 2, 3, 4}, 0.5, -1},\n\t\t{[]float64{1, 2, 3, 4}, 4, -1},\n\t\t{[]float64{1, 2, 3, 4}, math.NaN(), -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %v; expected %v\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for input length \u003c 2\")\n\t\t}\n\t}()\n\tWithin([]float64{1}, 1)\n\n\t// Test panic for unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted input\")\n\t\t}\n\t}()\n\tWithin([]float64{2, 1}, 1.5)\n}","345c9a3be0ead2a6bb443889e1480273":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst  []float64\n\t\tl, u float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    3,\n\t\t\twant: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, -0.3333333333333333, 0.3333333333333333, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    10,\n\t\t\tu:    20,\n\t\t\twant: []float64{10, 20},\n\t\t},\n\t\t{\n\t\t\tdst: make([]float64, 1), // This should cause panic\n\t\t\tl:   0,\n\t\t\tu:   1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif len(tt.dst) \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlices(got, tt.want) {\n\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 { // Allowing a small tolerance for float comparison\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","34830695dc149b4a5cc409e9b2a8f053":"// file: sum_compensated_test.go\npackage floats\n\nimport (\n\t\"testing\"\n\t\"math\"\n)\n\n// TestSumCompensated tests the SumCompensated function with various cases.\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0, 1e10, 1.0, -1e10},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, 1.0, 1e-10},\n\t\t\texpected: 1e10 + 1.0, // Should show how it handles large numbers\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{-1e10, 1.0, 1e10},\n\t\t\texpected: 1.0, // Cancel out large numbers\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.NaN(), 1.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 1.0},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0},\n\t\t\texpected: -6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0, // The sum of an empty slice should be 0\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif !math.IsNaN(result) \u0026\u0026 math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t\tif math.IsNaN(test.expected) \u0026\u0026 !math.IsNaN(result) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected NaN\", test.input, result)\n\t\t}\n\t}\n}","34c0d99226cdf4b4227be15a1f145e68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t\texpectPanic bool\n\t}{\n\t\t{2, 0, 10, 5, 1, false},           // Middle value\n\t\t{2, 0, 10, 0, 0, false},           // Value equals lower bound\n\t\t{2, 0, 10, 10, 1, false},          // Value equals upper bound\n\t\t{5, 0, 10, 1, 0, false},           // Value closer to lower bound\n\t\t{5, 0, 10, 9, 4, false},           // Value closer to upper bound\n\t\t{5, 0, 10, 5, 2, false},           // Middle of the span\n\t\t{5, 10, 0, 5, 2, false},           // Reverse span limits\n\t\t{3, math.NaN(), 10, 5, 2, false},  // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0, false},   // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0, false}, // Inf bounds\n\t\t{3, -1, 1, 2, 2, false},            // Bounds around zero\n\t\t{2, 0, 10, math.NaN(), 0, false},  // NaN value\n\t\t{1, 0, 10, 5, 0, true},             // Panic case: n \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d, l=%f, u=%f, v=%f, but did not\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"Expected index %d for n=%d, l=%f, u=%f, v=%f, got %d\", tt.expected, tt.n, tt.l, tt.u, tt.v, result)\n\t\t}\n\t}\n}","34ff38c1847746783a7293319ecf85f8":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\texpected  []int\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"finding first k elements true\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(x float64) bool { return x \u003e 0 },\n\t\t\ts:         []float64{-1, 2, 3, -4, 5},\n\t\t\tk:         2,\n\t\t\texpected:  []int{1, 2},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"k is 0\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(x float64) bool { return x \u003e 0 },\n\t\t\ts:         []float64{-1, 2, 3, -4, 5},\n\t\t\tk:         0,\n\t\t\texpected:  []int{},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"k is negative, return all found elements\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(x float64) bool { return x \u003e 0 },\n\t\t\ts:         []float64{-1, 2, 3, -4, 5},\n\t\t\tk:         -1,\n\t\t\texpected:  []int{1, 2, 4},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"not enough elements found\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(x float64) bool { return x \u003c 0 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         2,\n\t\t\texpected:  []int{1},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"no elements found\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(x float64) bool { return x \u003c 0 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         1,\n\t\t\texpected:  []int{},\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.expectErr, err)\n\t\t\t}\n\t\t\tif !equalSlices(inds, tt.expected) {\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", tt.expected, inds)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","356d6aedd0b043c46f7fcf7e3ff1cbc9":"// file: norm_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L1 norm of simple positive values\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm of simple positive values\",\n\t\t\tslice:    []float64{3, 4},\n\t\t\tL:        2,\n\t\t\texpected: 5, // 3^2 + 4^2 = 25, sqrt(25) = 5\n\t\t},\n\t\t{\n\t\t\tname:     \"L∞ norm (max absolute value)\",\n\t\t\tslice:    []float64{-1, -2, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm of negative values\",\n\t\t\tslice:    []float64{-1, -2, -3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm with zero values\",\n\t\t\tslice:    []float64{0, 0, 0},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"L4 norm of simple positive values\",\n\t\t\tslice:    []float64{1, 2, 3, 4},\n\t\t\tL:        4,\n\t\t\texpected: math.Pow(1*1 + 2*2 + 3*3 + 4*4, 1.0/4.0), // (30 ^ (1/4))\n\t\t},\n\t\t{\n\t\t\tname:     \"L-norm for a mix of positive and negative\",\n\t\t\tslice:    []float64{-1, 2, -3},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(math.Abs(-1)+math.Abs(2)+math.Abs(-3), 1.0/3.0), // (6^(1/3))\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif !almostEqual(result, tt.expected, 1e-9) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// almostEqual checks whether two float64 values are approximately equal.\nfunc almostEqual(a, b, epsilon float64) bool {\n\treturn math.Abs(a-b) \u003c epsilon\n}","358cb99636fbb9e701ee9e0d5a0edac1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn  int\n\t\tl  float64\n\t\tu  float64\n\t\tv  float64\n\t\texpected int\n\t\texpectPanic bool\n\t}{\n\t\t{3, 0, 10, 5, 1, false},\n\t\t{5, 0, 10, 2.5, 2, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, 5, 5, 5, 0, false},\n\t\t{3, math.NaN(), 10, 5, 2, false},\n\t\t{3, 10, math.NaN(), 5, 0, false},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2, false},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 0, false},\n\t\t{2, 0, 1, 0.5, 0, false},\n\t\t{1, 0, 1, 0.5, 0, true}, // should panic\n\t\t{3, 0, 1, math.NaN(), 0, false},\n\t\t{4, 0, 1, 10, 3, false},\n\t\t{4, 0, 1, -10, 0, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input n=%d, l=%f, u=%f, v=%f\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"For input n=%d, l=%f, u=%f, v=%f: expected %d, got %d\", tt.n, tt.l, tt.u, tt.v, tt.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}","35e4e0a40afe6a5e168783bb39d5cb1d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\ts          []float64\n\t\tv          float64\n\t\texpected   int\n\t\texpectPanic bool\n\t}{\n\t\t{\"Normal case 1\", []float64{1.0, 2.0, 3.0}, 2.5, 1, false},\n\t\t{\"Normal case 2\", []float64{1.0, 5.0, 3.0}, 4.0, 1, false},\n\t\t{\"Exact match\", []float64{1.0, 2.0, 3.0}, 3.0, 2, false},\n\t\t{\"Multiple nearest (lower index)\", []float64{1.0, 1.0, 3.0}, 1.5, 0, false},\n\t\t{\"NaN value\", []float64{1.0, 2.0, 3.0}, math.NaN(), 0, false},\n\t\t{\"Positive infinity\", []float64{1.0, 2.0, 3.0}, math.Inf(1), 2, false},\n\t\t{\"Negative infinity\", []float64{1.0, 2.0, 3.0}, math.Inf(-1), 0, false},\n\t\t{\"Empty slice\", []float64{}, 0.0, 0, true},  // expect panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif !tt.expectPanic {\n\t\t\t\t\t\tt.Errorf(\"Expected no panic, but got panic: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\t\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"got %d, want %d\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","36b46310cb1e47d0cbd345cbb5e97feb":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t\texpectPanic bool\n\t}{\n\t\t{2, 0, 10, 5, 1, false},               // Middle value\n\t\t{5, 0, 10, 2, 0, false},               // Closest to lower boundary\n\t\t{5, 0, 10, 8, 4, false},               // Closest to upper boundary\n\t\t{5, 0, 10, -1, 0, false},              // Outside lower boundary\n\t\t{5, 0, 10, 11, 4, false},              // Outside upper boundary\n\t\t{3, 0, 10, math.NaN(), 0, false},     // NaN input\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2, false}, // Inf bounds\n\t\t{3, math.NaN(), 10, 5, 2, false},      // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0, false},       // NaN upper bound\n\t\t{1, 0, 10, 5, 0, true},                 // Not enough points (should panic)\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%v, l=%v, u=%v, v=%v\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\n\t\tif result != int(test.expected) {\n\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v: expected %v, got %v\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}","3777da618e67948fe1f0988381d359df":"// file: sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{input: []float64{1.0, 2.0, 3.0}, want: 6.0},\n\t\t{input: []float64{1e10, 1.0, 1e-10}, want: 1e10 + 1.0},\n\t\t{input: []float64{1e-10, 1e-10, 1e-10}, want: 3e-10},\n\t\t{input: []float64{1.0, 1.0, 1.0, 1.0}, want: 4.0},\n\t\t{input: []float64{}, want: 0.0}, // testing empty slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.input)\n\t\t\tif !floatEquals(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floating point numbers with a tolerance\nfunc floatEquals(a, b float64) bool {\n\tconst tolerance = 1e-9\n\treturn math.Abs(a-b) \u003c tolerance\n}","382421897ddac293a7eaf5803663f8ba":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, expected []float64\n\t\texpectPanic      bool\n\t}{\n\t\t{\n\t\t\tdst:        []float64{5.0, 7.0, 9.0},\n\t\t\ts:          []float64{1.0, 2.0, 3.0},\n\t\t\texpected:   []float64{4.0, 5.0, 6.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        []float64{0.0, 0.0, 0.0},\n\t\t\ts:          []float64{1.0, 1.0, 1.0},\n\t\t\texpected:   []float64{-1.0, -1.0, -1.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        []float64{1.0, 2.0},\n\t\t\ts:          []float64{1.0, 2.0, 3.0},\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Sub did not panic for input %v and %v\", test.dst, test.s)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSub(test.dst, test.s) // Call Sub - expecting a panic\n\t\t\t}()\n\t\t} else {\n\t\t\tSub(test.dst, test.s)\n\t\t\tfor i := range test.expected {\n\t\t\t\tif math.Abs(test.dst[i]-test.expected[i]) \u003e 1e-9 {\n\t\t\t\t\tt.Errorf(\"Sub(%v, %v) = %v; want %v\", test.dst, test.s, test.dst, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3843bad289f379e1a739b632988424fb":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\texpected  []int\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tinds:      nil,\n\t\t\tf:         func(x float64) bool { return x \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         3,\n\t\t\texpected:  []int{2, 3, 4},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:      nil,\n\t\t\tf:         func(x float64) bool { return x \u003c 0 },\n\t\t\ts:         []float64{-1, -2, 3, 4, 5},\n\t\t\tk:         2,\n\t\t\texpected:  []int{0, 1},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:      nil,\n\t\t\tf:         func(x float64) bool { return x \u003e 10 },\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tk:         1,\n\t\t\texpected:  []int{},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinds:      nil,\n\t\t\tf:         func(x float64) bool { return x == 3 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5, 3, 3},\n\t\t\tk:         -1,\n\t\t\texpected:  []int{2, 5, 6},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:      nil,\n\t\t\tf:         func(x float64) bool { return x \u003e= 2 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\texpected:  []int{},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:      nil,\n\t\t\tf:         func(x float64) bool { return x \u003e 0 },\n\t\t\ts:         []float64{0, 0},\n\t\t\tk:         1,\n\t\t\texpected:  []int{},\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, err := Find(test.inds, test.f, test.s, test.k)\n\t\tif (err != nil) != test.expectErr {\n\t\t\tt.Errorf(\"expected error: %v, got: %v\", test.expectErr, err)\n\t\t}\n\t\tif !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"for input %v, expected %v, got %v\", test, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","39db05dc4a24eb9227f51017d3d973fe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpIdx int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // midpoint\n\t\t{5, 0, 10, 0, 0}, // lower bound\n\t\t{5, 0, 10, 10, 4}, // upper bound\n\t\t{5, 0, 10, 15, 4}, // above upper bound\n\t\t{5, 0, 10, -5, 0}, // below lower bound\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN input\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // extreme negatives\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 2}, // middle in infinite range\n\t\t{5, -10, -5, -7.5, 2}, // negative range midpoint\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif gotIdx := NearestIdxForSpan(test.n, test.l, test.u, test.v); gotIdx != test.expIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, got %d\", test.expIdx, gotIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic on n \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(1, 0, 10, 5)\n\t})\n}","3a76d4dd149871d67008d88252023be3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.2, 3.4, 0.5, 2.1}, 2},\n\t\t{[]float64{5.5, 5.5, 5.5}, 0},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2},\n\t\t{[]float64{0.0, 0.0, 0.0}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx did not panic for zero length slice\")\n\t\t}\n\t}()\n\tMinIdx([]float64{}) // This should panic\n}","3adb71339e22f88f256492a10f5ad403":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tpanic bool\n\t}{\n\t\t{3, 0, 10, 5, 1},           // Regular case\n\t\t{5, 0, 10, 11, 4},          // v exceeds upper bound\n\t\t{5, 0, 10, -1, 0},          // v below lower bound\n\t\t{4, 0, 10, 5, 2},           // Exact middle\n\t\t{6, 0, 10, 3, 1},           // Between lower and middle\n\t\t{6, 0, 10, 7, 4},           // Between middle and upper\n\t\t{5, 0, 10, 0, 0},           // Equal to lower bound\n\t\t{5, 0, 10, 10, 4},          // Equal to upper bound\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN in lower bound\n\t\t{5, 0, math.NaN(), 5, 0},  // NaN in upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Infinite bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 10, 4}, // v outside bounds\n\t\t{2, 0, 2, 1, 1},            // Edge case for two elements\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: %v, but did not panic\", tt)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n\n\t// Check panic cases\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // Should panic\n}","3bddc91a49dd0c307d9de0e1281590c7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Same start and end\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -5,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{-5, -4, -3, -2, -1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panics on short slice\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN case for l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN case for u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Positive infinity case for l\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative infinity case for u\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\trecover() // capture the panic\n\t\t\t\t}()\n\t\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t\t\tt.Error(\"expected panic but did not\")\n\t\t\t} else {\n\t\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\t\tfor i, v := range result {\n\t\t\t\t\tif math.IsNaN(tt.expected[i]) {\n\t\t\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\t\t\tt.Errorf(\"expected NaN, got %v\", v)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if v != tt.expected[i] {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected[i], v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","3d239a05153f127756cc4206cf13ce2f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{5.0},\n\t\t\texpected: 5.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"two elements\",\n\t\t\tinput:    []float64{1.0, 2.0},\n\t\t\texpected: 3.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative numbers\",\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0},\n\t\t\texpected: -6.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed numbers\",\n\t\t\tinput:    []float64{1.5, 2.5, -1.0, -0.5},\n\t\t\texpected: 2.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"floating point precision\",\n\t\t\tinput:    []float64{1e10, 1e-10, 1e-10},\n\t\t\texpected: 1e10,\n\t\t},\n\t\t{\n\t\t\tname:     \"all equal numbers\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 4.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{math.NaN(), 1.0, 2.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.input)\n\t\t\tif (math.IsNaN(got) \u0026\u0026 !math.IsNaN(tt.expected)) || (!math.IsNaN(got) \u0026\u0026 got != tt.expected) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","3f1fcb2afc428a0210f30e3b742123c1":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t\twantPanic  bool\n\t}{\n\t\t{3, 0, 10, 5, 1, false},\n\t\t{3, 0, 10, 0, 0, false},\n\t\t{3, 0, 10, 10, 2, false},\n\t\t{3, 10, 0, 5, 1, false}, // case where l \u003e u\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0, false},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2, false},\n\t\t{2, 0, 10, 5, 0, false},\n\t\t{2, 0, 10, 0, 0, false},\n\t\t{2, 0, 10, 10, 1, false},\n\t\t{1, 0, 10, 5, 0, true}, // expect panic\n\t\t{3, math.NaN(), 10, 5, 2, false},\n\t\t{3, 0, math.NaN(), 5, 0, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%v, l=%v, u=%v, v=%v\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v: expected %v, got %v\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}","3fa7e3b95f5c707b1cf62da5c1bdb6f4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\ttests := []struct {\n\t\tc      float64\n\t\tdst    []float64\n\t\texp    []float64\n\t}{\n\t\t{\n\t\t\tc:   1.0,\n\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\texp: []float64{2.0, 3.0, 4.0},\n\t\t},\n\t\t{\n\t\t\tc:   -1.0,\n\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\texp: []float64{0.0, 1.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tc:   0.0,\n\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\texp: []float64{1.0, 2.0, 3.0},\n\t\t},\n\t\t{\n\t\t\tc:   10.0,\n\t\t\tdst: []float64{-1.0, -2.0, -3.0},\n\t\t\texp: []float64{9.0, 8.0, 7.0},\n\t\t},\n\t\t{\n\t\t\tc:   2.5,\n\t\t\tdst: []float64{0.0, 0.0, 0.0},\n\t\t\texp: []float64{2.5, 2.5, 2.5},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Reset dst before calling AddConst\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\t// Call the function under test\n\t\tAddConst(test.c, dstCopy)\n\n\t\t// Check if the result matches the expected output\n\t\tfor i, v := range dstCopy {\n\t\t\tif v != test.exp[i] {\n\t\t\t\tt.Errorf(\"AddConst(%v, %v) = %v; want %v\", test.c, test.dst, dstCopy, test.exp)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","402da2b0239a95cd0ad9382497c83698":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst         []float64\n\t\tl, u       float64\n\t\texpected    []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           0,\n\t\t\tu:           10,\n\t\t\texpected:    []float64{0, 2.5, 5, 7.5, 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           -3,\n\t\t\tu:           3,\n\t\t\texpected:    []float64{-3, 0, 3},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 0),\n\t\t\tl:           0,\n\t\t\tu:           10,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 1),\n\t\t\tl:           1,\n\t\t\tu:           2,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 4),\n\t\t\tl:           math.NaN(),\n\t\t\tu:           5,\n\t\t\texpected:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           1,\n\t\t\tu:           math.NaN(),\n\t\t\texpected:    []float64{1, math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 4),\n\t\t\tl:           math.Inf(-1),\n\t\t\tu:           math.Inf(1),\n\t\t\texpected:    []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 4),\n\t\t\tl:           math.Inf(1),\n\t\t\tu:           1,\n\t\t\texpected:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic, but did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, result, tt.expected)\n\t\t}\n\t}\n}","408bf5d6763678341e7519c97944b765":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"regular case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero length array\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\texpected: nil, // Expecting a panic\n\t\t},\n\t\t{\n\t\t\tname:     \"one element array\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\texpected: nil, // Expecting a panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic for input: %+v\", tt)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif tt.expected != nil \u0026\u0026 !equal(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices for equality\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif (math.IsNaN(a[i]) \u0026\u0026 !math.IsNaN(b[i])) || (a[i] != b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","4171fcb628d4c71d3830d56fe113e994":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{5, -10, 10, 0, 2},\n\t\t{5, -10, 10, -10, 0},\n\t\t{5, -10, 10, 10, 4},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 1},\n\t\t{3, -1, 1, 0, 1},\n\t\t{3, -1, 1, -1, 0},\n\t\t{3, -1, 1, 1, 2},\n\t\t{2, 1, 1, 1, 0}, // edge case where l == u == v\n\t\t{2, 1, 1, 2, 1}, // edge case where l \u003e u\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0}, // testing infinity\n\t\t{2, 0, math.Inf(1), 10, 1}, // testing upper bound infinity\n\t\t{2, math.Inf(-1), 0, -10, 0}, // testing lower bound infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d l=%f u=%f v=%f\", tt.n, tt.l, tt.u, tt.v), func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test for NaN input\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"expected 0 for NaN input, got %d\", result)\n\t}\n}","425513ae8a69a98a714e8b3f95e333d2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // v is exactly in the middle of the span\n\t\t{5, 0, 10, 0, 0},          // v matches the lower bound\n\t\t{5, 0, 10, 10, 4},         // v matches the upper bound\n\t\t{5, 0, 10, 6, 3},          // v is above the lower and upper bounds\n\t\t{5, 0, 10, -1, 0},         // v is below the lower bound\n\t\t{5, 0, 10, 15, 4},         // v is above the upper bound\n\t\t{5, 0, 10, math.NaN(), 0}, // v is NaN\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // v is within negative and positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2}, // v is in between the span\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic condition with n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","4255a92f176f4d91698166bcd5e8c176":"package floats\n\nimport \"testing\"\n\nfunc TestMul(t *testing.T) {\n    // Test case 1: Basic multiplication\n    dst := []float64{1.0, 2.0, 3.0}\n    s := []float64{4.0, 5.0, 6.0}\n    expected := []float64{4.0, 10.0, 18.0}\n    Mul(dst, s)\n    for i, v := range dst {\n        if v != expected[i] {\n            t.Errorf(\"TestMul failed at index %d: got %v, want %v\", i, v, expected[i])\n        }\n    }\n\n    // Test case 2: Zero multiplication\n    dst = []float64{0.0, 0.0, 0.0}\n    s = []float64{4.0, 5.0, 6.0}\n    expected = []float64{0.0, 0.0, 0.0}\n    Mul(dst, s)\n    for i, v := range dst {\n        if v != expected[i] {\n            t.Errorf(\"TestMul failed at index %d: got %v, want %v\", i, v, expected[i])\n        }\n    }\n\n    // Test case 3: Negative values\n    dst = []float64{-1.0, -2.0, -3.0}\n    s = []float64{1.0, 2.0, 3.0}\n    expected = []float64{-1.0, -4.0, -9.0}\n    Mul(dst, s)\n    for i, v := range dst {\n        if v != expected[i] {\n            t.Errorf(\"TestMul failed at index %d: got %v, want %v\", i, v, expected[i])\n        }\n    }\n\n    // Test case 4: Length mismatch\n    defer func() {\n        if r := recover(); r == nil {\n            t.Errorf(\"TestMul did not panic for length mismatch\")\n        }\n    }()\n    dst = []float64{1.0, 2.0}\n    s = []float64{3.0, 4.0, 5.0}\n    Mul(dst, s)\n}","427a068f7b9d98292d45ba8f0298d820":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Valid case with 5 points\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 0.0, 10.0\n\t\tgot := Span(dst, l, u)\n\t\twant := []float64{0, 2.5, 5, 7.5, 10}\n\n\t\tfor i, v := range want {\n\t\t\tif got[i] != v {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Panic on length less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 10)\n\t})\n\n\tt.Run(\"Special case: NaN at lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.NaN(), 10.0\n\t\tgot := Span(dst, l, u)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}\n\n\t\tfor i, v := range want {\n\t\t\tif math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(v) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif got[i] != v {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Special case: Inf at both bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.Inf(-1), math.Inf(1)\n\t\tgot := Span(dst, l, u)\n\t\twant := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\n\t\tfor i, v := range want {\n\t\t\tif got[i] != v {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Special case: Inf at lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.Inf(1), 10.0\n\t\tgot := Span(dst, l, u)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10}\n\n\t\tfor i, v := range want {\n\t\t\tif got[i] != v {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Special case: Inf at upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 0.0, math.Inf(-1)\n\t\tgot := Span(dst, l, u)\n\t\twant := []float64{0, 0, 0, 0, math.Inf(-1)}\n\n\t\tfor i, v := range want {\n\t\t\tif got[i] != v {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t\t\t}\n\t\t}\n\t})\n}","437c902372f0d98605b3971c25a238e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},             // Middle of span\n\t\t{5, 0, 10, 0, 0},             // Lower bound\n\t\t{5, 0, 10, 10, 4},            // Upper bound\n\t\t{5, 10, 0, 5, 2},             // Inverted span\n\t\t{5, 0, 0, 0, 0},              // Zero span\n\t\t{3, -1, 1, -0.5, 1},          // Negative value in span\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 1}, // Inf values\n\t\t{4, math.NaN(), 10, 5, 3},   // NaN lower bound\n\t\t{4, 0, math.NaN(), 5, 0},    // NaN upper bound\n\t\t{4, math.Inf(-1), math.Inf(-1), -1, 0}, // Inf bounds equal\n\t\t{4, 1, 1, 1, 0},              // Constant value\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t}\n\t\t})\n\n\t\tif test.n \u003e= 2 {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","43b37766db5973e6b66d2f8e975f0b50":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"No elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"All elements found with k negative\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, -4},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"First k elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 3, 2, 4},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Fewer found than k\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"k is 0 - no return data\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !equal(got, tt.expected) || !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", got, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","43da2b9b629e14fe67c3831d7c5be202":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\texpectedIdx int\n\t\texpectedPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 0, 10, 15, 4, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, 10, 0, 0, 0, false},\n\t\t{5, 10, 0, -5, 4, false},\n\t\t{3, 0, 10, 5, 1, false},\n\t\t{2, 0, 10, 5, 0, false},\n\t\t{2, 0, 10, 0, 0, false},\n\t\t{2, 0, 10, 10, 1, false},\n\t\t{3, 0, 10, 15, 2, false},\n\t\t{3, 0, 10, -5, 0, false},\n\t\t{3, math.NaN(), 10, 5, 2, false},\n\t\t{3, 0, math.NaN(), 5, 0, false},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false},\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 0, false},\n\t\t{1, 1, 10, 5, 0, true}, // Should panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectedPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input (%d, %f, %f, %f), but did not panic\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expectedIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expectedIdx)\n\t\t\t}\n\t\t}\n\t}\n}","448e96e64dc8a814b9196333c8e74a69":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle point\n\t\t{5, 0, 10, 0, 0},         // Lower bound\n\t\t{5, 0, 10, 10, 4},        // Upper bound\n\t\t{5, -10, -5, -7.5, 1},    // Negative range, middle point\n\t\t{5, -10, -5, -10, 0},     // Negative range, lower bound\n\t\t{5, -10, -5, -5, 4},      // Negative range, upper bound\n\t\t{3, 0, 1, 0.5, 1},        // Edge case with n=3\n\t\t{10, 1, 5, 3, 4},         // Generic case\n\t\t{10, 1, 5, 0, 0},         // Out of range, low\n\t\t{10, 1, 5, 6, 9},         // Out of range, high\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 1, 5, 3)\n\n\t// Test NaN case\n\tresult := NearestIdxForSpan(5, 0, 10, math.NaN())\n\tif result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN value; got %d\", result)\n\t}\n\n\t// Test cases for +Inf and -Inf\n\tif result := NearestIdxForSpan(5, math.Inf(-1), math.Inf(1), 0); result != 0 {\n\t\tt.Errorf(\"Expected 0 for values between -Inf and Inf; got %d\", result)\n\t}\n\tif result := NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), math.Inf(1)); result != 1 {\n\t\tt.Errorf(\"Expected 1 for v = +Inf; got %d\", result)\n\t}\n\tif result := NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), math.Inf(-1)); result != 0 {\n\t\tt.Errorf(\"Expected 0 for v = -Inf; got %d\", result)\n\t}\n}","44b252eb7d64662d0890dd69335bcff7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: nil,\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        -1,\n\t\t\texpected: nil,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{0, 0, 0},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tinds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\tif !equalSlices(inds, tt.expected) || !errors.Is(err, tt.err) {\n\t\t\tt.Errorf(\"Find(%v, ...): got %v, %v; want %v, %v\", tt.inds, inds, err, tt.expected, tt.err)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","4511cbb301b7d8bfcf0b0dedbc359aa4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst        []float64\n\t\tl, u      float64\n\t\twant      []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          1.0,\n\t\t\tu:          5.0,\n\t\t\twant:      []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\twant:      []float64{0.0, 5.0, 10.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          -2.0,\n\t\t\tu:          2.0,\n\t\t\twant:      []float64{-2.0, 2.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          math.NaN(),\n\t\t\tu:          3.0,\n\t\t\twant:      []float64{math.NaN(), 3.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          3.0,\n\t\t\tu:          math.NaN(),\n\t\t\twant:      []float64{3.0, math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          math.Inf(1),\n\t\t\tu:          3.0,\n\t\t\twant:      []float64{math.Inf(1), 3.0, 3.0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          1.0,\n\t\t\tu:          math.Inf(-1),\n\t\t\twant:      []float64{1.0, 1.0, math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0.0,\n\t\t\tu:          1.0,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:        nil,\n\t\t\tl:          0.0,\n\t\t\tu:          1.0,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic but did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !tt.expectPanic \u0026\u0026 !equalSlice(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equalSlice(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","453441fed479c6b931c95d8e6a2dc624":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Middle value\n\t\t{5, 0, 10, 11, 4},        // Beyond upper bound\n\t\t{5, 0, 10, -1, 0},        // Below lower bound\n\t\t{5, -10, 0, -5, 2},       // Middle value with negative bounds\n\t\t{5, -10, -5, -7, 1},      // Middle value in negative range\n\t\t{5, 0, 0, 0, 0},          // Edge case with zero range\n\t\t{3, 1, 1, 1, 0},          // All values equal to bounds\n\t\t{3, 0, 10, math.NaN(), 0}, // v is NaN\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // v is more than lower bound\n\t\t{3, math.Inf(1), math.Inf(-1), -1, 0}, // inverted bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expect %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","45a30c5828885a89ba83eb56d93bcb68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t// Test basic functionality\n\t\t{5, 0, 10, 5, 2}, // v is exactly in the middle\n\t\t{5, 0, 10, 0, 0}, // v is equal to lower bound\n\t\t{5, 0, 10, 10, 4}, // v is equal to upper bound\n\t\t{5, 0, 10, 8, 3}, // v is closer to upper bound\n\t\t{5, 0, 10, 2, 1}, // v is closer to lower bound\n\t\t// Test edge cases\n\t\t{3, -5, 5, 0, 1}, // v in the middle of negative and positive\n\t\t{4, -5, 5, 6, 3}, // v greater than upper bound\n\t\t{4, -5, 5, -6, 0}, // v less than lower bound\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 1}, // v = 0 with infinite bounds\n\t\t{4, math.Inf(1), math.Inf(-1), 0, 0}, // v = 0 with inverted infinite bounds\n\t\t// Test NaN conditions\n\t\t{5, 0, 10, math.NaN(), 0}, // v is NaN\n\t\t{5, math.NaN(), 10, 5, 4}, // l is NaN\n\t\t{5, 0, math.NaN(), 5, 0}, // u is NaN\n\t}\n\n\tfor _, test := range tests {\n\t\t// Check for panic when n \u003c 2\n\t\tif test.n \u003c 2 {\n\t\t\tdefer func() { recover() }()\n\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n}","4627622097568676db1c4bb86f0f6c45":"// File: nearest_idx_for_span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},                      // normal case, v is in the middle\n\t\t{5, 0, 10, 0, 0},                      // v equals lower bound\n\t\t{5, 0, 10, 10, 4},                     // v equals upper bound\n\t\t{5, 0, 10, -1, 0},                     // v below lower bound\n\t\t{5, 0, 10, 11, 4},                     // v above upper bound\n\t\t{3, 1, 2, 1.5, 1},                     // v in between for small n\n\t\t{10, 1, 9, 5, 4},                      // normal case\n\t\t{2, -5, -1, -3, 1},                    // normal case with negative bounds\n\t\t{2, math.Inf(-1), math.Inf(1), math.NaN(), 0}, // v is NaN\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","4779c1536b5e5170e27ec9a3d10c39ae":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCumProd(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\ts         []float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{1, 2, 6},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{2, 3, 4},\n\t\t\texpected: []float64{2, 6, 24},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{0},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      nil,\n\t\t\ts:        nil,\n\t\t\texpected: nil,\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tCumProd(test.dst, test.s)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := CumProd(test.dst, test.s)\n\t\t\tif !Equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"For dst: %v, s: %v, expected %v, got %v\", test.dst, test.s, test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}","47f60ea89af4f421e1d95c0dab96a75e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tslice     []float64\n\t\texpected  int\n\t\texpectPanic bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2, false},\n\t\t{[]float64{3.0, 1.0, 2.0}, 0, false},\n\t\t{[]float64{1.0, 3.0, 3.0}, 1, false},\n\t\t{[]float64{math.NaN(), math.NaN()}, 0, false},\n\t\t{[]float64{math.NaN(), 1.0}, 1, false},\n\t\t{[]float64{}, nil, true}, // Expect panic\n\t\t{[]float64{5.0}, 0, false}, // Single element case\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not panic\", test.slice)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := MaxIdx(test.slice)\n\n\t\tif !test.expectPanic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", test.slice, result, test.expected)\n\t\t}\n\t}\n}","485f3f9430a5c1ee9fe363f2c8c5ca6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{5.0, 1.0, 2.0}, 1},\n\t\t{[]float64{3.0, -1.0, -1.0, 4.0}, 1},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},\n\t\t{[]float64{1.5, 1.5, 1.5}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MinIdx did not panic for zero length input\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","4902acfcc99189c581fc8a8766675600":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpIdx int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, -5, -7.5, 2},\n\t\t{5, -10, -5, -5, 0},\n\t\t{5, -10, -5, -10, 4},\n\t\t{3, -5, 5, 5, 2},\n\t\t{3, -5, 5, -5, 0},\n\t\t{2, 1, 2, 1.5, 0},\n\t\t{2, 1, 2, 1, 0},\n\t\t{2, 1, 2, 2, 1},\n\t\t{3, math.NaN(), 0, -1, 2},\n\t\t{3, 0, math.NaN(), -1, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.expIdx {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, got, test.expIdx)\n\t\t}\n\t}\n\n\t// Test panic for invalid `n`\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","498646d911c3405408999849c323ca03":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t// Test for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test for L = 2\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{}, 2, 0},\n\n\t\t// Test for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test for L = 3\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t{[]float64{-1, -2, -3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t{[]float64{1, -2, 3}, 3, math.Pow(1+8+27, 1.0/3.0)},\n\t\t{[]float64{}, 3, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.slice, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; expected %v\", test.slice, test.L, result, test.expected)\n\t\t}\n\t}\n}","49ba2faa968d0b16296a65774ac0301a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.5, 5},      // middle value\n\t\t{10, 0, 1, 0, 0},        // lower bound\n\t\t{10, 0, 1, 1, 9},        // upper bound\n\t\t{10, -1, 1, -0.5, 4},    // negative middle\n\t\t{10, -1, 1, 1.5, 9},     // outside upper\n\t\t{10, -1, 1, -1.5, 0},    // outside lower\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5}, // infinity bounds\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9}, // Inf input\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // -Inf input\n\t\t{10, math.NaN(), 1, 0.5, 9}, // NaN lower\n\t\t{10, 0, math.NaN(), 0.5, 0}, // NaN upper\n\t\t{2, 0, 1, 0.5, 0},         // edge case, will panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif tt.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", tt.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","49f1f6060a6fe1ef71ebca94b2d03f19":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{3, -1, 1, 0, 1},\n\t\t{6, -3, 3, 3, 5},\n\t\t{6, -3, 3, -3, 0},\n\t\t{4, 1, 5, 3, 2},\n\t\t{4, 5, 1, 3, 1},\n\t\t{2, 0, 2, 1, 1},\n\t\t{2, 2, 0, 1, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not Panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // should panic\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not Panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(0, 0, 10, 5) // should panic\n\n\t// Test cases for NaN values\n\ttestsNaN := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t}{\n\t\t{5, 0, 10, math.NaN()},\n\t\t{5, math.NaN(), 10, 5},\n\t\t{5, 0, math.NaN(), 5},\n\t\t{5, math.NaN(), math.NaN(), 5},\n\t}\n\n\tfor _, tt := range testsNaN {\n\t\tt.Run(\"NaN case\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tt.Logf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d\", tt.n, tt.l, tt.u, tt.v, got)\n\t\t})\n\t}\n}","4a76c915a614c1a32e928870371d7c11":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\twant   int\n\t\tisPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false}, // Middle case\n\t\t{5, 0, 10, 0, 0, false}, // Lower boundary\n\t\t{5, 0, 10, 10, 4, false}, // Upper boundary\n\t\t{3, 1, 1, 0, 0, false}, // l == u\n\t\t{3, 5, 3, 4, 0, false}, // decreasing range\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false}, // infinite bounds\n\t\t{3, math.NaN(), 10, 5, 2, false}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0, false}, // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 0, false}, // both bounds infinite\n\t\t{2, 0, 10, 5, 1, false}, // Minimum valid case\n\t\t{1, 0, 10, 5, 0, true}, // Panic case - n \u003c 2\n\t\t{5, 0, 10, math.NaN(), 0, false}, // NaN v\n\t\t{5, 10, 0, 5, 0, false}, // Reverse bounds\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.isPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif !tt.isPanic \u0026\u0026 got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","4b1a23c141eedc527eec4c3fbbbf89e3":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 10, 15},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 8, 12},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{10, 20},\n\t\t\tt:        []float64{3, 7},\n\t\t\texpected: []float64{7, 13},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tt:        []float64{1, 1, 1, 1},\n\t\t\texpected: []float64{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SubTo(test.dst, test.s, test.t)\n\t\tfor i, val := range result {\n\t\t\tif val != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", test.expected, result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panics for invalid lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths\")\n\t\t}\n\t}()\n\tSubTo([]float64{0}, []float64{1, 2}, []float64{3})\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched dst length\")\n\t\t}\n\t}()\n\tSubTo([]float64{0, 0}, []float64{1}, []float64{1})\n}","4ba005c9cdfe22faa8fc506e95a25089":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tn         int\n\t\tl, u, v   float64\n\t\texpected  int\n\t\twantPanic bool\n\t}{\n\t\t{\"Valid range, midpoint\", 5, 0, 10, 5, 2, false},\n\t\t{\"Valid range, below lower bound\", 5, 0, 10, -1, 0, false},\n\t\t{\"Valid range, above upper bound\", 5, 0, 10, 11, 4, false},\n\t\t{\"Invalid n, should panic\", 1, 0, 10, 5, 0, true},\n\t\t{\"NaN value in v\", 5, 0, 10, math.NaN(), 0, false},\n\t\t{\"NaN lower bound\", 5, math.NaN(), 10, 5, 4, false},\n\t\t{\"NaN upper bound\", 5, 0, math.NaN(), 5, 0, false},\n\t\t{\"Infinite lower bound, valid range\", 5, math.Inf(-1), 10, 5, 0, false},\n\t\t{\"Infinite upper bound, valid range\", 5, 0, math.Inf(1), 5, 4, false},\n\t\t{\"Lower bound equal to upper bound\", 5, 5, 5, 5, 0, false},\n\t\t{\"Upper bound is negative, lower bound is positive\", 5, 5, -5, 0, 0, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"%s: expected panic but did not panic\", test.name)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"%s: got %d, want %d\", test.name, result, test.expected)\n\t\t}\n\t}\n}","4c6cdb436525f21ceeedad76790926b9":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L1 norm with positive values\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9, // |4-1| + |5-2| + |6-3| = 3 + 3 + 3 = 9\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm with positive values\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // L2 = sqrt((4-1)^2 + (5-2)^2 + (6-3)^2) = sqrt(27)\n\t\t},\n\t\t{\n\t\t\tname:     \"L-infinity norm with mixed values\",\n\t\t\ts:        []float64{-1, 2, -3},\n\t\t\tt:        []float64{1, -2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 4, // max(|1 - -1|, |-2 - 2|, |3 - -3|) = 4\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero vector\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on mismatched lengths\",\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{1},\n\t\t\tL:        1,\n\t\t\texpected: 0, // This test checks for a panic\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.name == \"Panic on mismatched lengths\" {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for test %q, but did not get it.\", test.name)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif test.name != \"Panic on mismatched lengths\" \u0026\u0026 !floatEquals(result, test.expected) {\n\t\t\tt.Errorf(\"Test %q failed: expected %v, got %v\", test.name, test.expected, result)\n\t\t}\n\t}\n}\n\n// floatEquals checks if two float64 values are approximately equal.\nfunc floatEquals(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","4cbcd075e4543798c309fb6ee26e85d1":"// nearest_idx_for_span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool // indicates if it should panic\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1, false},    // Middle point\n\t\t{2, 0.0, 1.0, 0.0, 0, false},    // Exact lower bound\n\t\t{2, 0.0, 1.0, 1.0, 1, false},    // Exact upper bound\n\t\t{2, 0.0, 1.0, -1.0, 0, false},   // Below range\n\t\t{2, 0.0, 1.0, 2.0, 1, false},    // Above range\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0, false}, // Extrema case\n\t\t{5, 1.0, 10.0, 5.0, 2, false},    // Exact middle point\n\t\t{5, 1.0, 10.0, 0.0, 0, false},    // Below lower bound\n\t\t{5, 1.0, 10.0, 11.0, 4, false},   // Above upper bound\n\t\t{2, 1.0, 1.0, 1.0, 0, false},      // l == u\n\t\t{2, math.NaN(), 1.0, 0, 1, false}, // NaN lower bound\n\t\t{2, 0.0, math.NaN(), 0, 0, false}, // NaN upper bound\n\t\t{4, -1.0, 1.0, 0, 1, false},       // Negative to positive span\n\n\t\t// Panic cases\n\t\t{1, 0.0, 1.0, 0.5, 0, true}, // n less than 2\n\t\t{-1, 0.0, 1.0, 0.5, 0, true}, // n negative\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantP {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","4e1af0d7b8ed5d716b99fd19e75c5557":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: []float64{2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true, // Expect panic due to length mismatch\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true, // Expect panic due to length mismatch\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v, but did not panic\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tAdd(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif test.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"Add(%v, %v) = %v; expected %v\", test.dst, test.s, test.dst, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","4eb979ccf40b8e4948c951fe71f3192c":"// file: mul_to_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic multiplication\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiplication with zeros\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{0, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{0, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:     \"One element slices\",\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{2},\n\t\t\tt:        []float64{3},\n\t\t\texpected: []float64{3},\n\t\t},\n\t\t{\n\t\t\tname:     \"With negative values\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{-4, -10, -18},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tfor i := range result {\n\t\t\t\tif math.Abs(result[i]-tt.expected[i]) \u003e 1e-9 {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panics on mismatched lengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic but did not occur\")\n\t\t\t}\n\t\t}()\n\t\tMulTo([]float64{0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}) // Different lengths\n\t})\n\n\tt.Run(\"Panics on dst length mismatch\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic but did not occur\")\n\t\t\t}\n\t\t}()\n\t\tMulTo([]float64{0}, []float64{1, 2}, []float64{3, 4}) // Length of dst is not matching\n\t})\n}","4ee2b8620a8d952f91ac91175e990d11":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, 0, -5, 2},\n\t\t{5, -10, -5, -7, 1},\n\t\t{5, 5, 10, 7, 1},\n\t\t{5, -5, -10, -8, 3},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.NaN(), 10, 0, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{5, math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t{3, 0, 10, 5, 1}, // Special case, 3 elements\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // This should panic\n}","50a644966ebeb9b5f9f075ffe29701a4":"// file: span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t// Test case 1: Normal range\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t// Test case 2: Reverse range\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\twant: []float64{4, 3, 2, 1, 0},\n\t\t},\n\t\t// Test case 3: Panics when length of dst \u003c 2\n\t\t{\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tpanics: true,\n\t\t},\n\t\t// Test case 4: Inf to Inf\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t// Test case 5: NaN in lower bound\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t// Test case 6: NaN in upper bound\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panics {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for dst=%v, l=%v, u=%v, but did not\", tt.dst, tt.l, tt.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equalFloatSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc equalFloatSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEquals(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEquals(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","50bf89e11cdfc6a5f67944e93b69ded7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname: \"no elements found\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003e 10 },\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tk:    2,\n\t\t\texpected: nil,\n\t\t\terr:     errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname: \"all elements found with limit\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tk:    2,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:     nil,\n\t\t},\n\t\t{\n\t\t\tname: \"all elements found without limit\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tk:    -1,\n\t\t\texpected: []int{0, 1, 2},\n\t\t\terr:     nil,\n\t\t},\n\t\t{\n\t\t\tname: \"more elements requested than found\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003c 2 },\n\t\t\ts:    []float64{1, 3, 2},\n\t\t\tk:    3,\n\t\t\texpected: []int{0, 2},\n\t\t\terr:     errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname: \"exact elements found\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x == 2 },\n\t\t\ts:    []float64{1, 2, 2},\n\t\t\tk:    1,\n\t\t\texpected: []int{1},\n\t\t\terr:     nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !equal(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t} else if err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","5100393d9c20179d1f466df07560df26":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\talpha   float64\n\t\ts       []float64\n\t\twant    []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:     []float64{1.0, 2.0, 3.0},\n\t\t\talpha:   2.0,\n\t\t\ts:       []float64{4.0, 5.0, 6.0},\n\t\t\twant:    []float64{9.0, 12.0, 15.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1.0, 2.0},\n\t\t\talpha:   3.0,\n\t\t\ts:       []float64{4.0, 5.0, 6.0},\n\t\t\twant:    nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{7.0, 8.0, 9.0},\n\t\t\talpha:   0.5,\n\t\t\ts:       []float64{2.0, 4.0, 6.0},\n\t\t\twant:    []float64{8.0, 10.0, 12.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{},\n\t\t\talpha:   1.0,\n\t\t\ts:       []float64{},\n\t\t\twant:    []float64{},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic but did not panic for dst: %v, alpha: %v, s: %v\", tt.dst, tt.alpha, tt.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tAddScaled(tt.dst, tt.alpha, tt.s)\n\n\t\tif !tt.wantPanic {\n\t\t\tfor i, got := range tt.dst {\n\t\t\t\tif got != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","513e0f7a072d293d0d8efdd905153883":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{2, 3, 5},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: []float64{1, 1, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10, 20, 30},\n\t\t\ts:        []float64{10, 10, 10},\n\t\t\tt:        []float64{1, 1, 1},\n\t\t\texpected: []float64{9, 9, 9},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5, 5, 5},\n\t\t\ts:        []float64{5, 5, 5},\n\t\t\tt:        []float64{5, 5, 5},\n\t\t\texpected: []float64{0, 0, 0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected[i], v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"SubTo did not panic on length mismatch\")\n\t\t}\n\t}()\n\tSubTo([]float64{0}, []float64{1, 2}, []float64{3}) // lengths do not match\n}","51de97e964a1fffb9b422eb59da5400d":"package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n    // Test case 1: Basic division\n    dst := []float64{10, 20, 30}\n    s := []float64{2, 4, 6}\n    expected := []float64{5, 5, 5}\n    Div(dst, s)\n    for i, v := range dst {\n        if v != expected[i] {\n            t.Errorf(\"TestDiv failed: expected %v, got %v\", expected, dst)\n        }\n    }\n\n    // Test case 2: Division by 1 (should be unchanged)\n    dst = []float64{1, 2, 3}\n    s = []float64{1, 1, 1}\n    expected = []float64{1, 2, 3}\n    Div(dst, s)\n    for i, v := range dst {\n        if v != expected[i] {\n            t.Errorf(\"TestDiv failed: expected %v, got %v\", expected, dst)\n        }\n    }\n\n    // Test case 3: Panic on unequal length\n    defer func() {\n        if r := recover(); r == nil {\n            t.Errorf(\"TestDiv did not panic on unequal lengths\")\n        }\n    }()\n\n    dst = []float64{1, 2, 3}\n    s = []float64{1, 2} // Lengths do not match\n    Div(dst, s)\n}","51e62d3003c1cef2b289488bb49642bc":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},    // Middle point\n\t\t{5, 0, 10, 0, 0},    // Lower bound\n\t\t{5, 0, 10, 10, 4},   // Upper bound\n\t\t{5, 0, 10, 15, 4},   // Out of bounds above\n\t\t{5, 0, 10, -5, 0},   // Out of bounds below\n\t\t{5, 0, 0, 0, 0},     // Zero span\n\t\t{5, -10, 10, 0, 2},  // Middle point in negative to positive span\n\t\t{5, -10, -5, -8, 1}, // Middle point in negative span\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf limits with middle point\n\t\t{5, math.Inf(-1), math.Inf(1), 5, 2}, // Inf limits out of bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // both bounds NaN\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for invalid n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(n \u003c 2)\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","51e6755e7f508768bca93b584325caa1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, -5, -6, 1},\n\t\t{5, -5, 0, -10, 0},\n\t\t{5, 0, math.Inf(1), 5, 2},\n\t\t{5, math.Inf(-1), 0, -5, 0},\n\t\t{3, math.NaN(), 0, 0, 0},\n\t\t{3, 0, math.NaN(), 0, 0},\n\t\t{3, 0, 0, 0, 0}, // edge case\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 tt.n \u003c 2 {\n\t\t\t\t\t// Expected panic for cases with n \u003c 2\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 but did not get one\")\n\t\t}\n\t}()\n\t_ = NearestIdxForSpan(1, 0, 10, 5) // Expect panic\n}","51f37ea8b340d88b86dd6365594f823f":"package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\n// TestLogSumExp tests the LogSumExp function for various cases.\nfunc TestLogSumExp(t *testing.T) {\n    tests := []struct {\n        input    []float64\n        expected float64\n        shouldPanic bool\n    }{\n        {[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3)), false},\n        {[]float64{0, 0, 0}, math.Log(3), false},\n        {[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3)), false},\n        {[]float64{math.Inf(1)}, math.Inf(1), false},\n        {[]float64{math.Inf(-1), math.Inf(-1)}, math.Inf(-1), false},\n        {[]float64{}, 0, true},  // should panic when input is empty slice\n    }\n    \n    for _, test := range tests {\n        if test.shouldPanic {\n            defer func() {\n                if recover() == nil {\n                    t.Errorf(\"LogSumExp did not panic for input: %v\", test.input)\n                }\n            }()\n        }\n        \n        result := LogSumExp(test.input)\n        if !test.shouldPanic \u0026\u0026 result != test.expected {\n            t.Errorf(\"LogSumExp(%v) = %v; want %v\", test.input, result, test.expected)\n        }\n    }\n}","535e683dd7462e2c87fae6b37215e513":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t// Test case for L=1 with positive numbers\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t// Test case for L=2 with positive numbers\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t// Test case for L=Inf using extreme values\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t// Test with negative numbers\n\t\t{[]float64{-1, -2, -3}, []float64{-4, -5, -6}, 1, 9},\n\t\t// Test with zero vectors\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 2, 0},\n\t\t// Test with empty vectors\n\t\t{[]float64{}, []float64{}, 1, 0},  // should return 0 if both are empty\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif len(tt.s) != len(tt.t) {\n\t\t\t\t\t\t// Expected panic due to unequal lengths\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Distance panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif !floatEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare floating point numbers for equality\nfunc floatEqual(a, b float64) bool {\n\tconst tol = 1e-9\n\treturn math.Abs(a-b) \u003c tol\n}","54cf5f7fc12931717650aaf61a9e1990":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tisPanic bool\n\t}{\n\t\t{10, 0, 1, 0.5, 5, false},       // v is in the middle\n\t\t{10, 0, 1, 0, 0, false},         // v is equal to lower bound\n\t\t{10, 0, 1, 1, 9, false},         // v is equal to upper bound\n\t\t{10, 0, 1, -0.1, 0, false},      // v is less than lower bound\n\t\t{10, 0, 1, 1.1, 9, false},       // v is more than upper bound\n\t\t{5, 0, 10, 5, 2, false},         // v is in the middle for wider range\n\t\t{5, -10, -5, -7.5, 1, false},    // v is in the middle for negative numbers\n\t\t{5, -10, -5, -11, 0, false},     // v is less than lower bound negative\n\t\t{5, -10, -5, -4, 4, false},      // v is more than upper bound negative\n\t\t{2, 0, 10, 5, 1, false},         // Boundary test with n = 2\n\t\t{2, 10, 0, 5, 0, false},         // Same as above with inverted bounds\n\t\t{1, 0, 1, 0.5, 0, true},         // Panic case: n \u003c 2\n\t\t{2, math.NaN(), 1, 0.5, 1, false}, // Lower bound NaN\n\t\t{2, 0, math.NaN(), 0.5, 0, false}, // Upper bound NaN\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0, false}, // Inf bounds\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.isPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input n=%d, l=%f, u=%f, v=%f, got none\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","5510c4a37a65894d6414bbbb693794cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle value\n\t\t{5, 0, 10, 0, 0},          // Lower boundary\n\t\t{5, 0, 10, 10, 4},         // Upper boundary\n\t\t{5, -5, 5, -2.5, 2},       // Negative middle value\n\t\t{5, -5, 5, -5, 0},         // Exact lower boundary\n\t\t{5, -5, 5, 5, 4},          // Exact upper boundary\n\t\t{5, math.NaN(), 5, 1, 4}, // NaN lower bound\n\t\t{5, -5, math.NaN(), 1, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf boundaries\n\t\t{4, 0, 10, 5, 1},          // Even count in span\n\t\t{6, 0, 10, 10, 5},         // Even count, exact upper\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tactual := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","553492048d9a895e0c7a6480f8a52aa9":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpanValid(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    2.0,\n\t\t\twant: []float64{0.0, 1.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2.0,\n\t\t\tu:    2.0,\n\t\t\twant: []float64{-2.0, -1.0, 0.0, 2.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range got {\n\t\t\tif got[i] != tt.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanPanics(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic on short dst\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 1.0)\n}\n\nfunc TestSpanWithNaN(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := math.NaN()\n\tu := 5.0\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif i \u003c len(dst)-1 {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t} else {\n\t\t\tif dst[i] != u {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", u, i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tdst := make([]float64, 5)\n\tl := math.Inf(1)\n\tu := math.Inf(1)\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != l {\n\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", l, i, dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tl = math.Inf(-1)\n\tu = math.Inf(-1)\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != u {\n\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", u, i, dst[i])\n\t\t}\n\t}\n}","557c377cf77cfee5862a9c9ac824624d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{-1e10, 1.0, 1e10}, 1.0},\n\t\t{[]float64{1e10, 2e10, 3e10}, 6e10},\n\t\t{[]float64{}, 0.0}, // empty slice\n\t\t{[]float64{1.0, -1.0}, 0.0}, // cancellation\n\t\t{[]float64{math.MaxFloat64, 1.0, math.SmallestNonzeroFloat64}, math.MaxFloat64}, // extreme values\n\t\t{[]float64{math.NaN(), 1.0}, math.NaN()}, // NaN case\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := SumCompensated(test.input)\n\t\t\tif math.IsNaN(result) \u0026\u0026 !math.IsNaN(test.expected) || !math.IsNaN(result) \u0026\u0026 math.IsNaN(test.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t\tif result != test.expected \u0026\u0026 !math.IsNaN(result) \u0026\u0026 !math.IsNaN(test.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","566741d6f8a87aed21ab7e8ff5149d73":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t// Test cases for normal behavior\n\t\t{5, 0, 10, 5, 2},          // v within bounds\n\t\t{5, 0, 10, 0, 0},          // v equals lower bound\n\t\t{5, 0, 10, 10, 4},         // v equals upper bound\n\t\t{5, 0, 10, -1, 1},         // v below lower bound\n\t\t{5, 0, 10, 11, 3},         // v above upper bound\n\t\t{5, 10, 0, 5, 2},          // inverted bounds with v within\n\t\t{5, 10, 0, 10, 0},         // inverted bounds with v on lower\n\t\t{5, 10, 0, 0, 4},          // inverted bounds with v on upper\n\t\t{5, 10, 0, 11, 0},         // inverted bounds with v above upper\n\t\t{5, 10, 0, -1, 4},         // inverted bounds with v below lower\n\n\t\t// Test cases for special values\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},   // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // infinity boundaries and near zero\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // infinity boundaries and equal to upper\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // infinity boundaries and equal to lower\n\n\t\t// Test cases for edge cases\n\t\t{2, 0, 10, 5, 1},      // minimum n valid case\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 test.n \u003c 2 {\n\t\t\t\t\t// Expect panic for n \u003c 2\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but got none.\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","585b7ac09a3b8d7ae48ddfa3fb2ed341":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       1,\n\t\t\tu:       5,\n\t\t\twant:    []float64{1, 5},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       10,\n\t\t\tu:       10,\n\t\t\twant:    []float64{10, 10, 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       1,\n\t\t\tu:       1,\n\t\t\twant:    []float64{1, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       5,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(0),\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), math.NaN(), math.NaN(), math.Inf(0)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       10,\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(0),\n\t\t\twant:    []float64{0, 0, 0, 0, math.Inf(0)},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantErr {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic, but was expected to\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i, v := range got {\n\t\t\tif math.IsNaN(tt.want[i]) \u0026\u0026 !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t} else if v != tt.want[i] {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}","58c241954b2664727c41d7721efab838":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts:        []float64{1.5, 2.5, 3.5},\n\t\t\texpected: []float64{0.5, 0.5, 0.5},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{0.0, 0.0, 0.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := make([]float64, len(test.dst)) // Create a new slice for the result\n\t\tcopy(result, test.dst)                    // Copy initial values to result\n\t\tAdd(result, test.s)                       // Call the Add function\n\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Add(%v, %v) = %v; want %v\", test.dst, test.s, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic on length mismatch, but did not panicking\")\n\t\t}\n\t}()\n\n\tAdd([]float64{1.0, 2.0}, []float64{1.0}) // This should panic\n}","596038e104a8cfd0669b4e0ae9d834d2":"// find_test.go\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"no elements requested\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is negative, find all\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 1 },\n\t\t\ts:        []float64{1, 2, 3, 0, -1},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is positive, found enough elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k is positive, not enough elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 100 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !equalIntSlices(got, tt.expected) || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; expected %v, %v\", got, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalIntSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","59cfb0df3d116931d8ef233f5c4d4ba1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst         []float64\n\t\tl, u       float64\n\t\texpected   []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           0,\n\t\t\tu:           8,\n\t\t\texpected:    []float64{0, 2, 4, 6, 8},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           1,\n\t\t\tu:           1,\n\t\t\texpected:    []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 4),\n\t\t\tl:           1,\n\t\t\tu:           5,\n\t\t\texpected:    []float64{1, 2, 3, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         []float64{},\n\t\t\tl:           0,\n\t\t\tu:           1,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 1),\n\t\t\tl:           0,\n\t\t\tu:           1,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 0),\n\t\t\tl:           math.NaN(),\n\t\t\tu:           1,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 2),\n\t\t\tl:           math.Inf(1),\n\t\t\tu:           math.Inf(-1),\n\t\t\texpected:    []float64{math.Inf(1), math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 4),\n\t\t\tl:           math.NaN(),\n\t\t\tu:           5,\n\t\t\texpected:    []float64{math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for input l=%v, u=%v\", tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !equalSlices(result, tt.expected) {\n\t\t\tt.Errorf(\"expected %v, got %v, for input l=%v, u=%v\", tt.expected, result, tt.l, tt.u)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","59e9807e410b3b1e42476d1626350de1":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0.0,\n\t\t\tu:        6.0,\n\t\t\texpected: []float64{0.0, 3.0, 6.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        2.0,\n\t\t\tu:        8.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        2.0,\n\t\t\tu:        8.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic for dst of length %d\", len(tt.dst))\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.dst, tt.l, tt.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range result {\n\t\t\t\tif !isEqual(v, tt.expected[i]) {\n\t\t\t\t\tt.Errorf(\"Span() = %v, expected %v\", result, tt.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc isEqual(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","5a067b714f12586ffcf7e6ed3a76e094":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{1.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements with unique minimum\",\n\t\t\tinput:    []float64{3.0, 1.0, 2.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements with NaN\",\n\t\t\tinput:    []float64{math.NaN(), 2.0, 1.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements with multiple minimums\",\n\t\t\tinput:    []float64{5.0, 1.0, 1.0, 3.0},\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for empty slice, but did not\")\n\t\t\t}\n\t\t}()\n\t\tMinIdx([]float64{})\n\t})\n}","5aa15949cd7c6551c734080cf1d8b245":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts          []float64\n\t\tv          float64\n\t\texpected   int\n\t\texpectPanic bool\n\t}{\n\t\t{[]float64{1.0, 2.0}, 1.5, 0, false},  // Normal case\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1, false}, // Normal case\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.0, 0, false}, // Edge case\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1, false}, // Edge case (v == s[n-1])\n\t\t{[]float64{1.0, 2.0}, math.NaN(), -1, false}, // NaN case\n\t\t{[]float64{3.0, 1.0, 2.0}, 1.5, -1, true}, // Panics due to unsorted slice\n\t\t{[]float64{1.0}, 0.5, -1, true}, // Panics due to short span\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for s: %v, v: %v\", test.s, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n}","5cab14684e3236374aff22310a463d29":"// max_idx_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},                              // Normal case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},                              // Maximum at the start\n\t\t{[]float64{1.0, 3.0, 3.0}, 1},                              // Multiple max values\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1},                      // NaN at the start\n\t\t{[]float64{2.0, math.NaN(), 3.0}, 0},                      // NaN in the middle\n\t\t{[]float64{3.0, 3.0, math.NaN()}, 0},                      // NaN at the end\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, 0},      // All NaNs\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.input == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not panic\", test.input)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := MaxIdx(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Check panic for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for empty slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","5cfd5efc057e14d6f915e2f0e3a7a4e1":"package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\ts1     []float64\n\t\ts2     []float64\n\t\texpect bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0}, []float64{1.0, 2.0, 3.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{3.0, 2.0, 1.0}, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{1.0}, []float64{1.0}, true},\n\t\t{[]float64{1.0}, []float64{2.0}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Equal(tt.s1, tt.s2)\n\t\tif result != tt.expect {\n\t\t\tt.Errorf(\"Equal(%v, %v) = %v; want %v\", tt.s1, tt.s2, result, tt.expect)\n\t\t}\n\t}\n}","5db0ca7cc9e199b358e4086356bd249f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\"Zero slice\", []float64{}, 2, 0},\n\t\t{\"L1 norm of positive numbers\", []float64{1, 2, 3}, 1, 6},\n\t\t{\"L2 norm of positive numbers\", []float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{\"L3 norm of positive numbers\", []float64{1, 2, 3}, 3, math.Pow(36, 1.0/3)},\n\t\t{\"L max of negative numbers\", []float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{\"L1 norm with mixed sign numbers\", []float64{-1, 2, -3}, 1, 6},\n\t\t{\"L2 norm with mixed sign numbers\", []float64{-1, 2, -3}, 2, math.Sqrt(14)},\n\t\t{\"L3 norm with mixed sign numbers\", []float64{-1, 2, -3}, 3, math.Pow(36, 1.0/3)},\n\t\t{\"L max with mixed sign numbers\", []float64{-1, 2, -3}, math.Inf(1), 3},\n\t\t{\"L1 norm of slice with zeros\", []float64{0, 0, 0}, 1, 0},\n\t\t{\"L2 norm of slice with zeros\", []float64{0, 0, 0}, 2, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Norm(test.slice, test.L)\n\t\t\tif math.Abs(result-test.expected) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.slice, test.L, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","5e5b494cf15f876e881c448b70eb2381":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic subtraction\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{5, 6, 7},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: []float64{4, 4, 4},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"with negative numbers\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tt:        []float64{-1, -1, -1},\n\t\t\texpected: []float64{0, -1, -2},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"mismatched lengths panic\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2},\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"mismatched dst length panic\",\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{1, 2},\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic, but did not happen\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := SubTo(tt.dst, tt.s, tt.t)\n\n\t\t\tif !tt.wantPanic {\n\t\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 { // Use a tolerance for floating point comparison\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","5ec0328f90a34d616e3b204f7b27312c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tisPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, 10, 0, 10, 0, false},\n\t\t{5, 10, 0, 0, 4, false},\n\t\t{2, 0, 10, 5, 1, false},\n\t\t{2, 0, 10, 0, 0, false},\n\t\t{2, 0, 10, 10, 1, false},\n\t\t{2, 10, 0, 5, 1, false},\n\t\t{1, 0, 10, 5, 0, true}, // panic case\n\t\t{5, math.NaN(), 10, 5, 4, false}, // case with NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0, false}, // case with NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2, false},\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0, false},\n\t\t{5, 0, 0, 0, 0, false}, // case with l == u\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.isPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","61372161edf3c9defd238b1135cd48bc":"// spans_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -10,\n\t\t\tu:    -2,\n\t\t\twant: []float64{-10, -7, -4, -2},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    5,\n\t\t\tu:    15,\n\t\t\twant: []float64{5, 15},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panics if dst length \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n\n\tt.Run(\"returns NaNs for NaN inputs\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, math.NaN(), 10)\n\t\twant := []float64{math.NaN(), math.NaN(), 10}\n\n\t\tif !equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, NaN, %v) = %v; want %v\", dst, 10, got, want)\n\t\t}\n\t\tgot = Span(dst, 0, math.NaN())\n\t\twant = []float64{0, math.NaN(), math.NaN()}\n\n\t\tif !equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, %v, NaN) = %v; want %v\", dst, 0, got, want)\n\t\t}\n\t})\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","619b5b88adc14dd5e12b4896a2e60292":"// maxidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},           // Regular case\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},           // Maximum at the start\n\t\t{[]float64{2, 7, 5, 7, 1}, 1},           // Duplicate maximum values\n\t\t{[]float64{math.NaN(), 1, 2}, 2},        // Ignoring NaN values\n\t\t{[]float64{1, math.NaN(), 2}, 2},        // NaN in the middle\n\t\t{[]float64{3, 3, 3, 3}, 0},               // All elements are equal\n\t\t{[]float64{-1, -2, -3}, 0},              // Negative values\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","63eb0a38dfc2724cfeb1f978ccfde92a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{10, 0, 10, 5, 5},                  // Value in the middle of the span\n\t\t{10, 0, 10, 0, 0},                  // Value at the lower bound\n\t\t{10, 0, 10, 10, 9},                 // Value at the upper bound\n\t\t{10, -5, 5, 0, 5},                  // Value in the middle for negative to positive span\n\t\t{10, -10, 0, -5, 5},                // Negative range with value in the middle\n\t\t{10, 5, 15, 10, 5},                 // Value equals mid point\n\t\t{10, 5, 15, 12, 7},                 // Value between bounds\n\t\t{10, 0, 10, -1, 0},                 // Value below lower bound\n\t\t{10, 0, 10, 11, 9},                 // Value above upper bound\n\t\t{2, 0, 10, 5, 1},                   // Value in boundary case for min n\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; expect %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test for panic condition: n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","63fa0b8a84228ec317cfed7688363a0a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst        []float64\n\t\tl, u      float64\n\t\texpected   []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0,\n\t\t\tu:          4,\n\t\t\texpected:   []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          -1,\n\t\t\tu:          1,\n\t\t\texpected:   []float64{-1, 0, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 4),\n\t\t\tl:          1,\n\t\t\tu:          1,\n\t\t\texpected:   []float64{1, 1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 10),\n\t\t\tl:          math.NaN(),\n\t\t\tu:          5,\n\t\t\texpected:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 10),\n\t\t\tl:          5,\n\t\t\tu:          math.NaN(),\n\t\t\texpected:   []float64{5, math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 0),\n\t\t\tl:          0,\n\t\t\tu:          1,\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0,\n\t\t\tu:          1,\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic but did not occur\")\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !tt.expectPanic \u0026\u0026 !equalSlices(result, tt.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Helper function to compare float64 values for equality, considering NaNs\nfunc floatEqual(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","6413829de65ffe830657a47656e35ce0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpectedIdx int\n\t\texpectsPanic bool\n\t}{\n\t\t{3, 0, 2, 1, 1, false},\n\t\t{5, 1, 5, 3, 2, false},\n\t\t{4, 10, 20, 15, 2, false},\n\t\t{4, 20, 10, 15, 3, false},\n\t\t{6, 0, 6, 5, 5, false},\n\t\t{6, 6, 0, 1, 0, false},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3, false},\n\t\t{6, math.Inf(1), math.Inf(-1), 0, 0, false},\n\t\t{4, math.NaN(), 1, 0, 0, false},\n\t\t{4, 0, math.NaN(), 0, 3, false},\n\t\t{3, 0, 10, 11, 2, false},\n\t\t{2, 0, 10, 5, 1, false},\n\t\t{1, 0, 10, 5, 0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectsPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input: n=%v, l=%v, u=%v, v=%v\", test.n, test.l, test.u, test.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tidx := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\t\tif idx != test.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v: expected index %d, got %d\", test.n, test.l, test.u, test.v, test.expectedIdx, idx)\n\t\t\t}\n\t\t}\n\t}\n}","656d8243e7ab61dd1b5d5d4c0a1c2a51":"package floats\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst            []float64\n\t\tl, u           float64\n\t\texpected       []float64\n\t\texpectPanic    bool\n\t}{\n\t\t// Test case 1: Normal case with positive values\n\t\t{make([]float64, 5), 1.0, 5.0, []float64{1.0, 2.0, 3.0, 4.0, 5.0}, false},\n\t\t// Test case 2: Normal case with negative values\n\t\t{make([]float64, 5), -5.0, -1.0, []float64{-5.0, -4.0, -3.0, -2.0, -1.0}, false},\n\t\t// Test case 3: Normal case spanning zero\n\t\t{make([]float64, 5), -2.0, 2.0, []float64{-2.0, -1.0, 0.0, 1.0, 2.0}, false},\n\t\t// Test case 4: Length of dst \u003c 2 should panic\n\t\t{make([]float64, 1), 0.0, 1.0, nil, true},\n\t\t// Test case 5: Case where lower bound is NaN\n\t\t{make([]float64, 5), math.NaN(), 5.0, []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}, false},\n\t\t// Test case 6: Case where upper bound is NaN\n\t\t{make([]float64, 5), 0.0, math.NaN(), []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}, false},\n\t\t// Test case 7: Both bounds are Inf\n\t\t{make([]float64, 5), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.NaN()}, false},\n\t\t// Test case 8: Lower bound is Inf\n\t\t{make([]float64, 5), math.Inf(1), 5.0, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0}, false},\n\t\t// Test case 9: Upper bound is Inf\n\t\t{make([]float64, 5), 1.0, math.Inf(-1), []float64{1.0, 1.0, 1.0, 1.0, math.Inf(-1)}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, l: %v, u: %v\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"expected %v, got %v for dst: %v, l: %v, u: %v\", test.expected, result, test.dst, test.l, test.u)\n\t\t}\n\t}\n}\n\nfunc equalSlices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif math.IsNaN(s1[i]) \u0026\u0026 math.IsNaN(s2[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","65a07e02fcce872028436f8a915909a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.5, 1},  // nearest to 2.5 is 2.0 (index 1)\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 3.5, 2},  // nearest to 3.5 is 4.0 (index 3), but 3.0 is closer\n\t\t{[]float64{-1.0, -2.0, -3.0, -4.0}, -3.5, 2}, // nearest to -3.5 is -4.0 (index 3)\n\t\t{[]float64{5.0, 5.0, 5.0}, 5.0, 0},          // multiple the same value, returns first index\n\t\t{[]float64{1.0, 3.0, 5.0}, 4.0, 2},          // nearest to 4.0 is 5.0 (index 2)\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.0, 0}, // nearest to 0.0 is 1.0 (index 0)\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"NearestIdx(s=%v, v=%v)\", tt.s, tt.v), func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"ZeroLengthSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic when calling NearestIdx with zero length slice\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 1.0)\n\t})\n\n\tt.Run(\"NaNValue\", func(t *testing.T) {\n\t\tgot := NearestIdx([]float64{1.0, 2.0, 3.0}, math.NaN())\n\t\tif got != 0 {\n\t\t\tt.Errorf(\"Expected index 0 for NaN input, got %d\", got)\n\t\t}\n\t})\n\n\tt.Run(\"PositiveInfinity\", func(t *testing.T) {\n\t\tgot := NearestIdx([]float64{1.0, 2.0, 3.0}, math.Inf(1))\n\t\tif got != 2 { // should return index of maximum value\n\t\t\tt.Errorf(\"Expected index 2 for positive infinity, got %d\", got)\n\t\t}\n\t})\n\n\tt.Run(\"NegativeInfinity\", func(t *testing.T) {\n\t\tgot := NearestIdx([]float64{1.0, 2.0, 3.0}, math.Inf(-1))\n\t\tif got != 0 { // should return index of minimum value\n\t\t\tt.Errorf(\"Expected index 0 for negative infinity, got %d\", got)\n\t\t}\n\t})\n}","65fd8ad4512dfef4102fe3bfb9270a4f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    3,\n\t\t\tu:    6,\n\t\t\twant: []float64{3, 4.5, 6},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), -0, math.NaN(), 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) {\n\t\t\t\t\tif !math.IsNaN(tt.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif got[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panics on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif recover() == nil {\n\t\t\t\tt.Errorf(\"Span() did not panic for short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}","6614f0f640bed3219f6edca88d44dd37":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t\texpectPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 0, 10, -1, 0, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, 10, 0, 0, 4, false},\n\t\t{5, 10, 0, 10, 0, false},\n\t\t{5, 10, 0, 11, 0, false},\n\t\t{5, 10, 0, -5, 4, false},\n\t\t{1, 0, 10, 5, 0, true}, // Should panic\n\t\t{5, math.NaN(), 10, 5, 4, false},\n\t\t{5, 0, math.NaN(), 5, 0, false},\n\t\t{5, math.Inf(-1), math.Inf(1), 5, 2, false},\n\t\t{5, 0, 0, 0, 0, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for inputs: n=%d, l=%f, u=%f, v=%f\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"For inputs: n=%d, l=%f, u=%f, v=%f - expected index %d, got %d\", test.n, test.l, test.u, test.v, test.expect, result)\n\t\t}\n\t}\n}","662f2e407358b89be4281a5a18880939":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // L2 norm\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, -1, 2},\n\t\t\tt:       []float64{2, 0, 4},\n\t\t\tL:       math.Inf(1), // L-infinity norm\n\t\t\texpected: 3,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5},\n\t\t\tL:       2,\n\t\t\texpected: 0,\n\t\t\texpectPanic: true, // lengths do not match\n\t\t},\n\t\t{\n\t\t\ts:       []float64{},\n\t\t\tt:       []float64{},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1},\n\t\t\tt:       []float64{1},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for inputs: s=%v, t=%v, L=%v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\n\t\tif !test.expectPanic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","66d292c1ce226e5c8864cc13fe05bc21":"// NearestIdxForSpan_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, 5, 0, 7.5, 2},\n\t\t{5, 10, 0, 7.5, 2},\n\t\t{5, 0, 10, 11, 4},\n\t\t{5, 0, 10, -1, 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{3, 0, 1, 0.5, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic with n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","67dd6295b47259e6fb279f0555c34da2":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{[][]float64{}, true}, // No input slices\n\t\t{[][]float64{{1.0}}, true}, // Single slice\n\t\t{[][]float64{{1.0}, {2.0}}, true}, // Two slices of equal length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Two slices with same length\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Two slices with different lengths\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0}}, false}, // Three slices with different lengths\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}}, true}, // Three slices of equal length\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := EqualLengths(test.slices...)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", test.slices, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","68474e5a72e61670a6cb46b5ac1305bf":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{2.0, 3.0, 4.0}, 24.0},\n\t\t{[]float64{1.5, 2.5, 3.5}, 13.125},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{[]float64{-1.0, 2.0, 3.0}, -6.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Prod(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}","68899a430ddf4f6f239e756b66bbbffb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t// Test cases for slices with equal values\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t// Test cases for slices with NaN values (treated as equal)\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{math.NaN(), 2.0, 3.0}, true},\n\t\t// Test cases for slices with mixed NaN and numeric values\n\t\t{[]float64{1.0, math.NaN(), 3.0}, []float64{1.0, math.NaN(), 3.0}, true},\n\t\t// Test cases for slices with different lengths\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{[]float64{1.0}, []float64{}, false},\n\t\t// Test cases for slices with different values\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t// Test cases for slices with all NaN values\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, []float64{math.NaN(), math.NaN(), math.NaN()}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Same(test.s, test.t)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Same(%v, %v) = %v; expected %v\", test.s, test.t, result, test.expected)\n\t\t}\n\t}\n}","68e0afb435fbddde65eef21993523abe":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t// Test case where v is within the range of sorted s\n\t\t{[]float64{1, 2, 3, 4}, 2.5, 1},\n\t\t// Test case where v is exactly at the lower boundary\n\t\t{[]float64{1, 2, 3}, 1, 0},\n\t\t// Test case where v is exactly at the upper boundary\n\t\t{[]float64{1, 2, 3}, 2, 1},\n\t\t// Test case with a value less than the first element\n\t\t{[]float64{1, 2, 3}, 0.5, -1},\n\t\t// Test case with a value greater than or equal to the last element\n\t\t{[]float64{1, 2, 3}, 3, -1},\n\t\t// Test case with NaN value for v\n\t\t{[]float64{1, 2, 3}, math.NaN(), -1},\n\t\t// Test case with a single element slice (should panic)\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Check for panic on illegal input (len(s) \u003c 2)\n\t\t\t\t\tif len(test.s) \u003c 2 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\t\n\t\t\tresult := Within(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\t\n\t// Additional tests for panic cases\n\tassertPanic(t, func() { Within([]float64{1}) }, \"panicked on single element slice\")\n\tassertPanic(t, func() { Within([]float64{3, 1, 2}) }, \"panicked on unsorted slice\")\n}\n\nfunc assertPanic(t *testing.T, f func(), msg string) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for %s, but did not\", msg)\n\t\t}\n\t}()\n\tf()\n}","690866bf0f92f2e1f2a6c438c10bc8eb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\thasErr bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},      // Middle value within bounds\n\t\t{5, 0, 10, 0, 0, false},      // Lower bound\n\t\t{5, 0, 10, 10, 4, false},     // Upper bound\n\t\t{5, 5, 0, 7, 0, false},       // l \u003e u\n\t\t{5, math.NaN(), 10, 5, 4, false}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0, false}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0, false}, // -Inf and Inf bounds\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0, false}, // Inf and -Inf bounds\n\t\t{5, 0, 10, math.Inf(1), 4, false}, // Value is +Inf\n\t\t{5, 0, 10, math.Inf(-1), 0, false}, // Value is -Inf\n\t\t{3, 0, 10, 11, 2, false},       // Value above upper bound\n\t\t{3, 0, 10, -1, 0, false},       // Value below lower bound\n\t\t{1, 0, 10, 5, 0, true},         // Invalid case: panics on n \u003c 2\n\t\t{2, 0, 10, math.NaN(), 0, false}, // NaN value\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.hasErr {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(%d, %f, %f, %f), but did not panic.\", test.n, test.l, test.u, test.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.want)\n\t\t\t}\n\t\t}\n\t}\n}","6930d616072f2ca90b31519426117788":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t// Test case 1: Simple positive numbers\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Log(math.Exp(1.0) + math.Exp(2.0) + math.Exp(3.0))},\n\n\t\t// Test case 2: All zeros\n\t\t{[]float64{0.0, 0.0, 0.0}, 0.0},\n\n\t\t// Test case 3: Mixed positive and negative values\n\t\t{[]float64{-1.0, 0.0, 1.0}, math.Log(math.Exp(-1.0) + math.Exp(0.0) + math.Exp(1.0))},\n\n\t\t// Test case 4: Large numbers to check for overflow\n\t\t{[]float64{700.0, 800.0}, 800.0}, // log(Exp(700) + Exp(800)) should be approximated to Exp(800)\n\n\t\t// Test case 5: Edge case, very small numbers\n\t\t{[]float64{-1000.0, -1001.0}, -1000.0}, // log(Exp(-1000) + Exp(-1001)) should be approximated to Exp(-1000)\n\n\t\t// Test case 6: Single element\n\t\t{[]float64{5.0}, 5.0},\n\n\t\t// Test case 7: Empty slice (should panic)\n\t\t{[]float64{}, math.NaN()}, // This case will be handled with recover in the test\n\t}\n\n\tfor i, test := range tests {\n\t\tif len(test.input) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Test case %d: expected panic for empty input, but did not panic\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := LogSumExp(test.input)\n\t\tif !math.IsNaN(test.expected) \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Test case %d: expected %v, got %v\", i, test.expected, result)\n\t\t}\n\t}\n}","69897caeb65fe72f7aa78c474973b3a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tpanics bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, -10, -5, -7.5, 2, false},\n\t\t{5, -10, -5, -5, 0, false},\n\t\t{5, -10, -5, -10, 4, false},\n\t\t{2, 0, 10, 5, 1, false}, // Edge case n = 2\n\t\t{2, 10, 0, 5, 1, false}, // Edge case with reverse bounds\n\t\t{2, 0, 0, 0, 0, false},  // Edge case all zero span\n\t\t{3, math.NaN(), 10, 5, 2, false}, // case with NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0, false},  // case with NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false}, // case with infinities\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0, false}, // edge case where bounds are the same\n\t\t{3, -math.Inf(1), -math.Inf(1), 0, 0, false}, // edge case where bounds are both negative inf\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panics {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v but did not get one\", tt)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","6aede9c09c69006b852dd6e16ffad905":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{make([]float64, 5), 0, 4, []float64{0, 1, 2, 3, 4}},\n\t\t{make([]float64, 3), 2, 8, []float64{2, 5, 8}},\n\t\t{make([]float64, 7), -3, 3, []float64{-3, -2, -1, 0, 1, 2, 3}},\n\t\t{make([]float64, 4), 3, 3, []float64{3, 3, 3, 3}},\n\t\t{make([]float64, 2), 1, 5, []float64{1, 5}},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tif !equalSlices(got, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; want %v\", test.dst, test.l, test.u, got, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for dst length less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test behaviors with NaN and Inf\n\tnan := math.NaN()\n\tinfinity := math.Inf(1)\n\n\ttestsSpecialCases := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{make([]float64, 5), nan, 4, []float64{nan, nan, nan, nan, 4}},\n\t\t{make([]float64, 5), 0, nan, []float64{0, nan, nan, nan, nan}},\n\t\t{make([]float64, 5), infinity, 4, []float64{infinity, infinity, infinity, infinity, 4}},\n\t\t{make([]float64, 5), -4, infinity, []float64{-4, -3, -2, -1, infinity}},\n\t}\n\n\tfor _, test := range testsSpecialCases {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tif !equalSlices(got, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; want %v\", test.dst, test.l, test.u, got, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Helper function to compare float64 values for equality including NaN checks\nfunc floatEqual(x, y float64) bool {\n\tif math.IsNaN(x) \u0026\u0026 math.IsNaN(y) {\n\t\treturn true\n\t}\n\treturn x == y\n}","6af629ddd937cab703589d0bb7a8abe6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, expected int\n\t\tl, u, v     float64\n\t}{\n\t\t{5, 2, 0, 10, 5},             // Normal case within bounds\n\t\t{5, 0, 0, 10, -1},            // Value below lower bound\n\t\t{5, 4, 0, 10, 11},            // Value above upper bound\n\t\t{5, 1, 0, 10, 3},             // Normal case but closer to lower bound\n\t\t{5, 3, 0, 10, 7},             // Normal case but closer to upper bound\n\t\t{3, 0, 5, 5, math.NaN()},     // Test with NaN value for v\n\t\t{6, 0, math.NaN(), 10, 5},    // Test with NaN as lower bound\n\t\t{6, 5, 0, math.NaN(), 5},      // Test with NaN as upper bound\n\t\t{5, 2, math.Inf(-1), math.Inf(1), 0}, // Infinite bounds\n\t\t{5, 0, math.Inf(-1), math.Inf(1), math.Inf(-1)}, // Below infinite bounds\n\t\t{5, 4, math.Inf(-1), math.Inf(1), math.Inf(1)}, // Above infinite bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Check if panic is expected\n\t\t\t\t\tif test.n \u003c 2 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected index %d for NearestIdxForSpan(%d, %f, %f, %f), got %d\", test.expected, test.n, test.l, test.u, test.v, result)\n\t\t\t}\n\t\t})\n\n\t\t// Check for panic if n \u003c 2\n\t\tif test.n \u003c 2 {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(%d, %f, %f, %f), but did not panic\", test.n, test.l, test.u, test.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t}()\n\t\t}\n\t}\n}","6bfc7b9f97ba65b7653d66b1e69f0b80":"package floats\n\nimport \"testing\"\n\n// A simple equality function for testing\nfunc floatEquals(a, b float64) bool {\n\treturn a == b\n}\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"One empty slice\",\n\t\t\ts1:       []float64{1.0, 2.0},\n\t\t\ts2:       []float64{},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.s1, tt.s2, floatEquals)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v) = %v; want %v\", tt.s1, tt.s2, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","6c7c9566e0529939e343a754e38af8a8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\texpect  []float64\n\t\thasPanic bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\texpect:  []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       10,\n\t\t\tu:       20,\n\t\t\texpect:  []float64{10, 15, 20},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       -1,\n\t\t\tu:       1,\n\t\t\texpect:  []float64{-1, -0.3333333333333333, 0.3333333333333333, 1},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       5,\n\t\t\tu:       10,\n\t\t\texpect:  []float64{5, 10},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       1,\n\t\t\tu:       2,\n\t\t\thasPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       0,\n\t\t\tu:       0,\n\t\t\thasPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       1,\n\t\t\texpect:  []float64{math.NaN(), math.NaN(), 1},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\texpect:  []float64{0, math.NaN(), math.NaN()},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\texpect:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       0,\n\t\t\texpect:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t\thasPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.hasPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for dst length %d but did not panic\", len(test.dst))\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(test.dst, test.l, test.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tfor i := range result {\n\t\t\t\tif !floatEqual(result[i], test.expect[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expect)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Utility function to check for approximate equality of floats\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","6d06d0759e4be25c7b630ad5ceb5bc13":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Test with normal values\n\t\t{5, 0, 10, 5, 2}, // Middle value\n\t\t{5, 0, 10, 0, 0}, // Lower bound\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 11, 4}, // Above upper bound\n\t\t{5, 0, 10, -1, 0}, // Below lower bound\n\n\t\t// Test with negative bounds\n\t\t{5, -10, 0, -5, 2}, // Middle value\n\t\t{5, -10, 0, -10, 0}, // Lower bound\n\t\t{5, -10, 0, 0, 4}, // Upper bound\n\t\t{5, -10, 0, 1, 4}, // Above upper bound\n\t\t{5, -10, 0, -11, 0}, // Below lower bound\n\n\t\t// Test with equal bounds\n\t\t{5, 5, 5, 5, 0}, // All values same, should return 0\n\n\t\t// Test edge cases\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0}, // Inf, returning 0\n\t\t{5, math.Inf(1), math.Inf(1), math.Inf(1), 4}, // Inf, returning last index\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound\n\n\t\t// Exception test for NaN\n\t\t{5, 0, 10, math.NaN(), 0}, // Should return 0 for NaN v\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", test.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic condition for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0) // Should panic\n}","6d21515f8125323eb177cf800f931b07":"// spans_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\texp []float64\n\t}{\n\t\t// Standard case\n\t\t{make([]float64, 5), 0, 4, []float64{0, 1, 2, 3, 4}},\n\t\t// Case with negative range\n\t\t{make([]float64, 3), -1, 1, []float64{-1, 0, 1}},\n\t\t// Case with l and u being the same\n\t\t{make([]float64, 4), 2, 2, []float64{2, 2, 2, 2}},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tfor i := range got {\n\t\t\tif got[i] != test.exp[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, got, test.exp)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for NaN values\n\tt.Run(\"NaN Cases\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\tfor i := 0; i \u003c len(got)-1; i++ {\n\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d; got %v\", i, got[i])\n\t\t\t}\n\t\t}\n\t\tif got[len(got)-1] != 1 {\n\t\t\tt.Errorf(\"Expected %v at last index; got %v\", 1, got[len(got)-1])\n\t\t}\n\n\t\tgot = Span(dst, 1, math.NaN())\n\t\tfor i := 1; i \u003c len(got); i++ {\n\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d; got %v\", i, got[i])\n\t\t\t}\n\t\t}\n\t\tif got[0] != 1 {\n\t\t\tt.Errorf(\"Expected %v at first index; got %v\", 1, got[0])\n\t\t}\n\t})\n\n\t// Test for Inf cases\n\tt.Run(\"Inf Cases\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(-1), math.Inf(1))\n\t\tfor i := 0; i \u003c len(got)/2; i++ {\n\t\t\tif got[i] != math.Inf(-1) || got[len(got)-i-1] != math.Inf(1) {\n\t\t\t\tt.Errorf(\"Expected %v at index %d; got %v\", math.Inf(-1), i, got[i])\n\t\t\t}\n\t\t}\n\n\t\tgot = Span(dst, math.Inf(1), math.Inf(1)) // All elements should be 0 in this case\n\t\tfor i := 0; i \u003c len(got); i++ {\n\t\t\tif got[i] != 0 {\n\t\t\t\tt.Errorf(\"Expected %v at index %d; got %v\", 0, i, got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// Test for panic\n\tt.Run(\"Panic Cases\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic but did not occur\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n\n}","6deba74db0b90460246258ff700fb465":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst          []float64\n\t\tl, u        float64\n\t\texpected    []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         3,\n\t\t\texpected:  []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         0,\n\t\t\tu:         12,\n\t\t\texpected:  []float64{0, 4, 8, 12},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         -10,\n\t\t\tu:         10,\n\t\t\texpected:  []float64{-10, -5, 0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         5,\n\t\t\tu:         5,\n\t\t\texpected:  []float64{5, 5},\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 1),\n\t\t\tl:            1,\n\t\t\tu:            2,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 0),\n\t\t\tl:            1,\n\t\t\tu:            2,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         3,\n\t\t\texpected:  []float64{math.NaN(), math.NaN(), 3},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{1, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(-1),\n\t\t\texpected:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %+v, but did not panic\", test)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif test.expectPanic {\n\t\t\t// If we reached this point, we didn't panic, so we return.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"For input %+v, expected %+v, got %+v\", test, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !(math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) || a[i] == b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","6f60e11c27d167cc98a6c777b2ed309f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 1.0, 5.0, 3.0, 2},\n\t\t{5, 1.0, 5.0, 1.0, 0},\n\t\t{5, 1.0, 5.0, 5.0, 4},\n\t\t{5, 1.0, 5.0, 0.0, 0},\n\t\t{5, 5.0, 1.0, 3.0, 2},\n\t\t{5, 5.0, 1.0, 5.0, 0},\n\t\t{5, 5.0, 1.0, 1.0, 4},\n\t\t{5, 5.0, 1.0, 0.0, 4},\n\t\t{5, math.NaN(), 5.0, 3.0, 4},\n\t\t{5, 1.0, math.NaN(), 3.0, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 3.0, 2},\n\t\t{5, math.Inf(1), math.Inf(-1), -3.0, 0},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"n: \"+string(tt.n)+\", l: \"+string(tt.l)+\", u: \"+string(tt.u)+\", v: \"+string(tt.v), func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not recover\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\t\n\t// Test panic for NaN value\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NaN value, but did not recover\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(5, 1, 5, math.NaN())\n}","6f8f0cf089b9296b93c93e650fdcf0f6":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Nearest to 2.5 is 2.0 (index 1)\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.1, 1}, // Nearest to 2.1 is 2.0 (index 1)\n\t\t{[]float64{0.0, 1.0, 2.0}, 1.5, 1}, // Nearest to 1.5 is 1.0 (index 1)\n\t\t{[]float64{-1.0, 0.0, 1.0}, 0.5, 2}, // Nearest to 0.5 is 1.0 (index 2)\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0}, // Nearest to 0.5 is 1.0 (index 0)\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Nearest to 3.5 is 3.0 (index 2)\n\t\t{[]float64{1.0, 2.0, 2.0, 3.0}, 2.0, 1}, // Nearest to 2.0 is at index 1 (first occurrence)\n\t\t{[]float64{1.5, 1.5, 1.5}, 1.5, 0}, // All elements are the same\n\t\t{[]float64{1.0, 3.0, 5.0, 7.0}, 4.0, 2}, // Nearest to 4.0 is 5.0 (index 2)\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %.2f) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic when calling NearestIdx with an empty slice, but did not panic.\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0.0) // This should panic\n}","705779804a0d6e416d989d33e5d71d2c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{10, 0, 1, 0.5, 5},          // Middle value\n\t\t{10, 0, 1, 0, 0},            // Lower bound\n\t\t{10, 0, 1, 1, 9},            // Upper bound\n\t\t{10, -1, 1, 0, 5},           // Middle in negative to positive range\n\t\t{10, -1, 1, -1, 0},          // Lower bound negative\n\t\t{10, -1, 1, 1, 9},           // Upper bound positive\n\t\t{10, -1, 1, 0.9999, 9},      // Just below upper bound\n\t\t{5, -1, -0.5, -0.75, 3},     // Negative range with mid value\n\t\t{5, 1, 10, 5, 0},            // Value outside [l, u]\n\t\t{5, 10, 1, 5, 4},            // Reverse bounds\n\t\t{3, 0, 10, 10, 2},           // Upper bound exact\n\t\t{3, -math.Inf(1), math.Inf(1), 0, 1}, // Infinite bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","70ef5cf162ccbbbeaffa61109d9d5327":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t\tpanic    bool\n\t}{\n\t\t{2, 0, 10, 5, 1, false},\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, math.NaN(), 10, 5, 4, false},\n\t\t{5, 0, math.NaN(), 5, 0, false},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2, false},\n\t\t{2, 0, 10, math.NaN(), 0, false},\n\t\t{2, 0, 10, math.Inf(1), 1, false},\n\t\t{1, 0, 10, 5, 0, true}, // should panic\n\t\t{5, 0, 10, math.Inf(-1), 0, false},\n\t\t{5, 0, 10, math.Inf(1), 4, false},\n\t\t{5, 1, 3, 0.5, 0, false},\n\t\t{5, 1, 3, 3.5, 4, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tassertPanic(t, func() { NearestIdxForSpan(test.n, test.l, test.u, test.v) }) \n\t\t\tcontinue\n\t\t}\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc assertPanic(t *testing.T, f func()) {\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic but did not occur\")\n\t\t}\n\t}()\n\n\tf()\n}","719fbaed10eb9f84af07d905fd6dc8b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tslice   []float64\n\t\twant    float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tslice: []float64{1.0, 2.0, 3.0},\n\t\t\twant:  6.0,\n\t\t},\n\t\t{\n\t\t\tslice: []float64{1e20, 1e20, 1e-20},\n\t\t\twant:  2e20,\n\t\t},\n\t\t{\n\t\t\tslice: []float64{1e20, 1e20, -1e20},\n\t\t\twant:  1e20,\n\t\t},\n\t\t{\n\t\t\tslice: []float64{1.5, 2.5, 3.5},\n\t\t\twant:  7.5,\n\t\t},\n\t\t{\n\t\t\tslice: []float64{},\n\t\t\twant:  0.0,\n\t\t},\n\t\t{\n\t\t\tslice: []float64{math.NaN()},\n\t\t\twant:  math.NaN(),\n\t\t},\n\t\t{\n\t\t\tslice: []float64{math.Inf(1), math.Inf(1)},\n\t\t\twant:  math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.slice)\n\t\t\tif math.IsNaN(got) \u0026\u0026 !math.IsNaN(tt.want) || !math.IsNaN(got) \u0026\u0026 math.IsNaN(tt.want) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, tt.want)\n\t\t\t} else if !math.IsNaN(got) \u0026\u0026 !math.IsNaN(tt.want) \u0026\u0026 !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\tconst tolerance = 1e-9\n\treturn math.Abs(a-b) \u003c= tolerance\n}","72080191d1a0f6a037ea1ba79b729034":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttests := []struct {\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, 32.0},\n\t\t{[]float64{0.0, 0.0, 0.0}, []float64{1.0, 2.0, 3.0}, 0.0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, []float64{1.0, 2.0, 3.0}, -14.0},\n\t\t{[]float64{1.5, 2.5}, []float64{3.0, 4.0}, 19.5},\n\t\t{[]float64{}, []float64{}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := Dot(tt.s1, tt.s2)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"Dot(%v, %v) = %v; expected %v\", tt.s1, tt.s2, result, tt.expected)\n\t\t}\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Dot did not panic on length mismatch\")\n\t\t}\n\t}()\n\t_ = Dot([]float64{1.0, 2.0}, []float64{1.0})\n}","731ef9c1650a0835b8d91c3e5645ea3d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Valid span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Panic on short dst\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic but didn't occur\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"NaN in lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range expected {\n\t\t\tif (math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(expected[i])) || (!math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(expected[i])) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaN in upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range expected {\n\t\t\tif (math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(expected[i])) || (!math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(expected[i])) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinity lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), 1)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 1}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinity upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, 0, 0, 0, math.Inf(1)}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Both bounds are infinity\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n}","7342be149dca4d93bbc1c7058fc4b165":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{3.0, 2.0, 1.0}, false},\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, []float64{math.NaN(), 2.0, 3.0}, true},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, []float64{1.0, 2.0, math.NaN()}, true},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, []float64{1.0, math.NaN(), 2.0}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{1.0}, []float64{1.0}, true},\n\t\t{[]float64{1.0}, []float64{2.0}, false},\n\t\t{[]float64{math.NaN()}, []float64{math.NaN()}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Same(test.slice1, test.slice2)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Same(%v, %v) = %v; expected %v\", test.slice1, test.slice2, result, test.expected)\n\t\t}\n\t}\n}","735adf687a18e301fe773c3aa12dfa6b":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\tidx int\n\t}{\n\t\t{5, 0, 1, 0.25, 1},          // Closest to 0.25 in [0, 1]\n\t\t{5, 0, 1, 0.75, 3},          // Closest to 0.75 in [0, 1]\n\t\t{5, -1, 1, 0, 2},            // Closest to 0 in [-1, 1]\n\t\t{5, 1, 3, 2, 1},             // Closest to 2 in [1, 3]\n\t\t{5, -2, 2, 0, 2},            // Closest to 0 in [-2, 2]\n\t\t{5, 0, 10, 5, 2},            // Closest to 5 in [0, 10]\n\t\t{5, 0, 10, -5, 0},           // Closest to -5 in [0, 10]\n\t\t{5, -10, 0, -5, 2},          // Closest to -5 in [-10, 0]\n\t\t{5, -1, 1, math.NaN(), 0},   // NaN should return 0\n\t\t{3, 1, 1, 1, 0},              // Edge case where l == u\n\t\t{2, 1, 2, 1.5, 0},            // Edge case at midpoint\n\t\t{2, 0, 0, 0, 0},              // Closest to 0 when both bounds are 0 \n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 tt.n \u003e= 2 {\n\t\t\t\t\tt.Errorf(\"Expected no panic for n: %d, but got panic: %v\", tt.n, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif tt.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n: %d\", tt.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.idx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, result, tt.idx)\n\t\t\t}\n\t\t})\n\t}\n}","742c3a0e60b52275548045f9937128ed":"// argsort_stable_test.go\npackage floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdst:      []float64{3.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5.0, 3.0, 5.0, 4.0},\n\t\t\texpected: []float64{3.0, 4.0, 5.0, 5.0},\n\t\t\tinds:     make([]int, 4),\n\t\t\texpectedInds: []int{1, 3, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0, 1.0},\n\t\t\tinds:     make([]int, 3),\n\t\t\texpectedInds: []int{0, 1, 2},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Reset inds for each test\n\t\tcopy(test.inds, make([]int, len(test.dst)))\n\t\tArgsortStable(test.dst, test.inds)\n\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Expected dst %v, got %v\", test.expected, test.dst)\n\t\t}\n\t\tif !reflect.DeepEqual(test.inds, test.expectedInds) {\n\t\t\tt.Errorf(\"Expected inds %v, got %v\", test.expectedInds, test.inds)\n\t\t}\n\t}\n\n\t// Test with mismatched lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for mismatched lengths did not occur\")\n\t\t}\n\t}()\n\tArgsortStable([]float64{1, 2, 3}, []int{0, 1})\n}","74b6c2682cd0091c2b1d38011061c6ec":"// file: add_to_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\twantPanic bool // Indicates if we expect a panic due to length mismatch\n\t}{\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{5, 7, 9},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"length mismatch dst\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"length mismatch s and t\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif !tt.wantPanic {\n\t\t\t\t\t\tt.Errorf(\"AddTo() panicked unexpectedly: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddTo(tt.dst, tt.s, tt.t)\n\t\t\tif tt.wantPanic {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","7531e22078872885620137b8f10e36fa":"// File: addto_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\ts       []float64\n\t\tt       []float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\twant: []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{0, 0},\n\t\t\ts:    []float64{1, 2},\n\t\t\tt:    []float64{3, 4},\n\t\t\twant: []float64{4, 6},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1},\n\t\t\tt:       []float64{4},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantErr {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for inputs %v, %v, %v but did not get one\", tt.dst, tt.s, tt.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tgot := AddTo(tt.dst, tt.s, tt.t)\n\t\tif !mathEqual(got, tt.want) {\n\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t}\n\t}\n}\n\n// Helper function to compare two float64 slices for equality.\nfunc mathEqual(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Helper function to check if two float64 values are approximately equal.\nfunc floatEqual(x, y float64) bool {\n\treturn math.Abs(x-y) \u003c 1e-9\n}","75568582d0db1dd3b3d9aaadf9b871d7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.5, 1}, // 2.5 is between 2.0 and 3.0\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 4.0, 3}, // 4.0 is equal to s[3] but not less than s[4], so index 3\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 1.0, 0}, // 1.0 is equal to s[0]\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 0.5, -1}, // 0.5 is less than the first element\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 5.0, -1}, // 5.0 is greater than the last element\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, math.NaN(), -1}, // NaN should return -1\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for short slice\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0}, 0.5) // should panic\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0}, 2.0) // should panic\n}","764003bc0b16664630dab25d0a7361f9":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 4},\n\t\t\tL:        1,\n\t\t\texpected: 1,\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // √((4-1)² + (5-2)² + (6-3)²)\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3, // max(3, 3, 3)\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{1},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t\tpanic:    true, // Lengths do not match\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","7775eae90044d2b83c4ba237a18e6524":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // Closest to index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1}, // Exact match at index 1\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0}, // Closest to index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // Closest to index 2\n\t\t{[]float64{5.0, 5.0, 5.0}, 5.0, 0}, // All same value, returns first\n\t\t{[]float64{0.0, math.NaN(), 2.0}, 1.0, 0}, // Ignore NaN, closest to 0.0\n\t\t{[]float64{math.Inf(1), math.Inf(2), 3.0}, math.Inf(1), 0}, // Inf handling\n\t\t{[]float64{}, 0.0, -1}, // Should panic for zero length slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tif len(tt.s) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdx(%v, %f) did not panic\", tt.s, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := NearestIdx(tt.s, tt.v)\n\n\t\tif got != tt.wantIdx {\n\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d; want %d\", tt.s, tt.v, got, tt.wantIdx)\n\t\t}\n\t}\n}","77b93326ee7c291bfa127d16988aa7d8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 3, 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    1,\n\t\t\tu:    1,\n\t\t\twant: []float64{1, 1},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tfor i := range got {\n\t\t\tif got[i] != tt.want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic for dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\t\n\t// Test NaN cases\n\tdst := make([]float64, 5)\n\tSpan(dst, math.NaN(), 1)\n\tfor _, v := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(v) {\n\t\t\tt.Errorf(\"Expected NaN in dst with l being NaN; got %v\", v)\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected last element to be 1; got %v\", dst[len(dst)-1])\n\t}\n\t\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.NaN())\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN in dst with u being NaN; got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected first element to be 0; got %v\", dst[0])\n\t}\n\t\n\t// Test Inf cases\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), 1)\n\tfor i, v := range dst[:len(dst)-1] {\n\t\tif v != math.Inf(-1) {\n\t\t\tt.Errorf(\"Expected %v at index %d; got %v\", math.Inf(-1), i, v)\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected last element to be 1; got %v\", dst[len(dst)-1])\n\t}\n\t\n\tdst = make([]float64, 5)\n\tSpan(dst, 0, math.Inf(1))\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif dst[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected %v at index %d; got %v\", math.Inf(1), i, dst[i])\n\t\t}\n\t}\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected first element to be 0; got %v\", dst[0])\n\t}\n}","79104be89c9c1a79798d2bc6dce60d34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl         float64\n\t\tu         float64\n\t\texpected  []float64\n\t\texpectPanic bool\n\t}{\n\t\t{dst: make([]float64, 5), l: 0, u: 10, expected: []float64{0, 2.5, 5, 7.5, 10}, expectPanic: false},\n\t\t{dst: make([]float64, 3), l: 1, u: 1, expected: []float64{1, 1, 1}, expectPanic: false},\n\t\t{dst: make([]float64, 4), l: -2, u: 2, expected: []float64{-2, -1, 0, 2}, expectPanic: false},\n\t\t{dst: make([]float64, 2), l: 5, u: 15, expected: []float64{5, 15}, expectPanic: false},\n\t\t{dst: make([]float64, 1), l: 0, u: 1, expected: nil, expectPanic: true}, // Panic case: length \u003c 2\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input l=%v, u=%v with dst length %d, but did not panic\", test.l, test.u, len(test.dst))\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 { // Allow a small tolerance due to floating point precision\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","79ba96a414ec58600a22cf4d6a65c7d9":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},         // Test exact middle\n\t\t{5, 0, 10, 0, 0},         // Test at lower bound\n\t\t{5, 0, 10, 10, 4},        // Test at upper bound\n\t\t{5, 0, 10, -1, 0},        // Test below lower bound\n\t\t{5, 0, 10, 11, 4},        // Test above upper bound\n\t\t{5, 0, 10, 7.5, 3},       // Test between bounds\n\t\t{3, 1, 2, 1.5, 1},        // Minimum case with closer mid\n\t\t{3, 2, 1, 1.5, 2},        // Case where lower and upper bounds are reversed\n\t\t{4, 0, 1, 0.5, 1},        // Test middle with an even span\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 2}, // Special case of infinities\n\t\t{4, math.NaN(), 1, 0, 5}, // Special case with NaN lower\n\t\t{4, 1, math.NaN(), 0, 0}, // Special case with NaN upper\n\t\t{4, -1, -math.Inf(1), -0.5, 0}, // Test negative infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"Expected %d, got %d\", tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on short span\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(1, 0, 1, 0) // This should panic\n\t})\n\n\tt.Run(\"Test NaN input\", func(t *testing.T) {\n\t\tresult := NearestIdxForSpan(5, 0, 10, math.NaN())\n\t\tif result != 0 {\n\t\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t\t}\n\t})\n}","79f3aca3977491f8d5f9776daa658477":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Same bounds\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{5, 5, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative span\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -10,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{-10, -7, -4, -1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Large span\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1e10,\n\t\t\tu:        1e11,\n\t\t\texpected: []float64{1e10, 5.5e10, 1e11},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on short dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil, // We're expecting a panic, so no expected value.\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.name == \"Panic on short dst\" {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for test %s, but did not panic\", tt.name)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tif tt.name != \"Panic on short dst\" {\n\t\t\tfor i, v := range result {\n\t\t\t\tif math.Abs(v-tt.expected[i]) \u003e 1e-9 {\n\t\t\t\t\tt.Errorf(\"Test %s failed: expected %v, got %v\", tt.name, tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","7ae0b412168e3741e885695e100e10dc":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tname:     \"Basic span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Single point span\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        -1.0,\n\t\t\tu:        1.0,\n\t\t\texpected: []float64{-1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic for length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf to Inf should include a finite value if bounds are different\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 1.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.panic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for %s, but did not panic\", tt.name)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Unexpected result for %s: got %v, want %v\", tt.name, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}","7ba6c1a9d9cfc826feb1c6cc29a7d1d5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, 1, 1e-10},\n\t\t\texpected: 1e10 + 1,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, -1e10, 1, 1e-10},\n\t\t\texpected: 1 + 1e-10,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.MaxFloat64, 1, -math.MaxFloat64},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.NaN(), 1, 2},\n\t\t\texpected: 3, // NaN should not affect the sum, as we just ignore it\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0, // Sum of an empty slice\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif !almostEqual(result, test.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","7be2cfa5773f77e57f0b52a902a37906":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\ttarget int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, -5, -7.5, 2},\n\t\t{5, -10, -5, -11, 0},\n\t\t{5, -10, -5, -4, 4},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.target {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.target)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(1, 0, 1, 0), but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test for NaN input\n\tif got := NearestIdxForSpan(5, 0, 10, math.NaN()); got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %d; want 0\", got)\n\t}\n}","7ce7e0ff5d5a26e4ace3cfba39e5cd75":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 matching elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all matching elements (k \u003c 0)\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, 2, -3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not enough matching elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Find zero elements requested\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, 2, -3, -4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first matching element\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{0, 1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{0},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !errors.Is(err, tt.err) {\n\t\t\t\tt.Fatalf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Fatalf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Fatalf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","7dbdc50dd0c7ca092a6eb33c2b115cb4":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\texpect bool\n\t}{\n\t\t{\"No slices\", [][]float64{}, true},\n\t\t{\"Equal lengths\", [][]float64{{1.0}, {2.0}, {3.0}}, true},\n\t\t{\"Unequal lengths\", [][]float64{{1.0, 2.0}, {3.0}}, false},\n\t\t{\"Unequal lengths multiple\", [][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false},\n\t\t{\"All slices are empty\", [][]float64{{}, {}, {}}, true},\n\t\t{\"Mixed empty and non-empty\", [][]float64{{1.0}, {}, {3.0}}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tt.slices...)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expect, result)\n\t\t\t}\n\t\t})\n\t}\n}","7dee733e37d1cd403fa43e560561b44b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Normal case with positive l and u\n\tdst := make([]float64, 5)\n\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tresult := Span(dst, 1.0, 5.0)\n\tfor i, val := range result {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v at index %d\", expected[i], val, i)\n\t\t}\n\t}\n\n\t// Test case 2: Normal case with negative l and u\n\tdst = make([]float64, 4)\n\texpected = []float64{-3.0, -2.0, -1.0, 0.0}\n\tresult = Span(dst, -3.0, 0.0)\n\tfor i, val := range result {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v at index %d\", expected[i], val, i)\n\t\t}\n\t}\n\n\t// Test case 3: Normal case with zero l and u\n\tdst = make([]float64, 3)\n\texpected = []float64{0.0, 0.0, 0.0}\n\tresult = Span(dst, 0.0, 0.0)\n\tfor i, val := range result {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v at index %d\", expected[i], val, i)\n\t\t}\n\t}\n\n\t// Test case 4: Panic case (length of dst \u003c 2)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tdst = make([]float64, 1)\n\tSpan(dst, 0.0, 1.0)\n\n\t// Test case 5: Handle NaN l and u\n\tdst = make([]float64, 5)\n\tresult = Span(dst, math.NaN(), 5.0)\n\tfor _, val := range result {\n\t\tif !math.IsNaN(val) {\n\t\t\tt.Errorf(\"Expected NaN, got %v\", val)\n\t\t}\n\t}\n\n\t// Test case 6: Handle Inf for l and u\n\tdst = make([]float64, 5)\n\tresult = Span(dst, math.Inf(-1), math.Inf(1))\n\tfor i := 0; i \u003c len(result)-1; i++ {\n\t\tif result[i] != math.Inf(-1) {\n\t\t\tt.Errorf(\"Expected %v, got %v at index %d\", math.Inf(-1), result[i], i)\n\t\t}\n\t}\n\tif result[len(result)-1] != math.Inf(1) {\n\t\tt.Errorf(\"Expected %v, got %v at index %d\", math.Inf(1), result[len(result)-1], len(result)-1)\n\t}\n}","7e067ec2eec8c0ce92a797561684a201":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t{3, 0, 1, 0.5, 1}, // Test normal case\n\t\t{5, 0, 10, 5, 2},  // v is exactly in the middle\n\t\t{3, 0, 10, 0, 0},  // v is at the lower bound\n\t\t{3, 0, 10, 10, 2}, // v is at the upper bound\n\t\t{3, 1, 1, 1, 0},   // Edge case where l == u\n\t\t{4, 1, 4, 2.5, 1}, // Normal case, v between l and u\n\t\t{4, 0, 10, -1, 0}, // v \u003c l\n\t\t{4, 0, 10, 11, 3}, // v \u003e u\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n\t// Test NaN case\n\tgot := NearestIdxForSpan(3, 0, 10, math.NaN())\n\tif got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 10, NaN) = %d; want 0\", got)\n\t}\n}","7e0e584ee99bb04f534bf4a061567134":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\texpected  []int\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find first k elements satisfying f\",\n\t\t\tinds: nil,\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 2\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements when k is negative\",\n\t\t\tinds: nil,\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003c 3\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Not enough elements found\",\n\t\t\tinds: nil,\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 5\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"K is zero\",\n\t\t\tinds: nil,\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003c 3\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectErr, err)\n\t\t\t}\n\t\t\tif !equalSlices(actual, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalSlices checks if two slices are equal\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","7e338ea1edf5d53d16546d7262adfbf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tcases := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{10, 0, 1, 0.5, 4},\n\t\t{10, -1, 1, 0.5, 4},\n\t\t{10, 0, 1, 0, 0},\n\t\t{10, 0, 1, 1, 9},\n\t\t{10, 1, 0, 0, 9},\n\t\t{10, 1, 0, 1, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), 2, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), -2, 0}, \n\t\t{2, 0, 1, 0.5, 0}, // edge case for 2 elements\n\t\t{5, 2, 4, 3, 2},\n\t\t{5, 4, 2, 3, 2},\n\t\t{5, math.NaN(), 5, 3, 4}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 3, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(-1), -1, 0}, // Inf case\n\t\t{5, math.Inf(1), math.Inf(1), 1, 0}, // Inf case\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 c.n \u003c 2 {\n\t\t\t\t\treturn // expected panic\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(c.n, c.l, c.u, c.v)\n\t\t\tif got != c.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", c.n, c.l, c.u, c.v, got, c.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatal(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}","7f25d22513ef6e04b64a192ed3cfc5b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},                   // Midpoint case\n\t\t{3, 0, 10, 7, 2},                   // Closer to upper bound\n\t\t{4, -10, 10, -10, 0},               // Exactly equal to lower bound\n\t\t{4, -10, 10, 10, 3},                 // Exactly equal to upper bound\n\t\t{5, 0, 10, 0, 0},                    // Lower bound with more intervals\n\t\t{5, 0, 10, 10, 4},                   // Upper bound with more intervals\n\t\t{5, 0, 10, 5, 2},                    // Exactly midpoint with more intervals\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Infinite bounds with midpoint\n\t\t{5, math.Inf(0), math.Inf(1), 0, 0}, // Lower infinite bounds case\n\t\t{5, math.Inf(-1), math.Inf(0), 0, 4}, // Upper infinite bounds case\n\t\t{2, 0, 1, 1, 1},                     // Edge case for n=2 upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", \n\t\t\t\ttest.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test NaN case\n\tresult := NearestIdxForSpan(3, 0, 10, math.NaN())\n\tif result != 0 {\n\t\tt.Errorf(\"Expected 0 when v is NaN, got %d\", result)\n\t}\n}","7f3a126a386b9ed26bfb0769fd5122a4":"// maxidx_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Single positive\", []float64{2.0}, 0},\n\t\t{\"Multiple positives\", []float64{1.0, 3.0, 2.0}, 1},\n\t\t{\"Negative values\", []float64{-1.0, -3.0, -2.0}, 0},\n\t\t{\"Mixed values\", []float64{-1.0, 2.5, 2.5, 1.0}, 1},\n\t\t{\"Same values\", []float64{5.0, 5.0, 5.0}, 0},\n\t\t{\"NaN values\", []float64{math.NaN(), 2.0, 1.5}, 1},\n\t\t{\"Mixed NaN and values\", []float64{2.0, math.NaN(), 1.5}, 0},\n\t\t{\"All NaN\", []float64{math.NaN(), math.NaN()}, 0}, // For the sake of argument, we expect panic\n\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.input) == 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for zero length slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","7f6810e613aee48e70477e69512564f4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tslices     [][]float64\n\t\texpectTrue bool\n\t}{\n\t\t{[][]float64{}, true}, // No slices\n\t\t{[][]float64{{1.0}, {2.0}}, false}, // Different lengths\n\t\t{[][]float64{{1.0}, {2.0}, {3.0}}, true}, // Same length\n\t\t{[][]float64{{1.0, 2.0}, {3.0, 4.0}}, true}, // Same length with two elements\n\t\t{[][]float64{{1.0, 2.0}, {3.0}}, false}, // Different lengths\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}}, true}, // Same length with three elements\n\t\t{[][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}}, false}, // Different lengths\n\t\t{[][]float64{{}, {}, {}}, true}, // All empty slices\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := EqualLengths(test.slices...)\n\t\tif result != test.expectTrue {\n\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", test.slices, result, test.expectTrue)\n\t\t}\n\t}\n}","7f69ce5884584bab680bef849c1ae2aa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\texpectsPanic bool\n\t}{\n\t\t{\n\t\t\tdst:          make([]float64, 5),\n\t\t\tl:            0,\n\t\t\tu:            4,\n\t\t\twant:         []float64{0, 1, 2, 3, 4},\n\t\t\texpectsPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 3),\n\t\t\tl:            -3,\n\t\t\tu:            3,\n\t\t\twant:         []float64{-3, 0, 3},\n\t\t\texpectsPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 6),\n\t\t\tl:            2,\n\t\t\tu:            2,\n\t\t\twant:         []float64{2, 2, 2, 2, 2, 2},\n\t\t\texpectsPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 0),\n\t\t\tl:            1,\n\t\t\tu:            5,\n\t\t\twant:         nil,\n\t\t\texpectsPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 1),\n\t\t\tl:            1,\n\t\t\tu:            5,\n\t\t\twant:         nil,\n\t\t\texpectsPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 4),\n\t\t\tl:            math.NaN(),\n\t\t\tu:            3,\n\t\t\twant:         []float64{math.NaN(), math.NaN(), math.NaN(), 3},\n\t\t\texpectsPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 4),\n\t\t\tl:            1,\n\t\t\tu:            math.NaN(),\n\t\t\twant:         []float64{1, math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectsPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:          make([]float64, 4),\n\t\t\tl:            math.Inf(1),\n\t\t\tu:            math.Inf(1),\n\t\t\twant:         []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\texpectsPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectsPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !tt.expectsPanic {\n\t\t\tfor i, v := range got {\n\t\t\t\tif !equalFloat(v, tt.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc equalFloat(a, b float64) bool {\n\treturn (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || a == b\n}","806936f5d9d784f8306b0ac2a5943872":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"No slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"One empty slice\",\n\t\t\tslices: [][]float64{{}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"One non-empty slice\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Two equal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0, 4.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Two unequal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Three equal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Three unequal length slices\",\n\t\t\tslices: [][]float64{{1.0}, {2.0, 3.0}, {4.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Multiple slices of varying lengths\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0, 4.0, 5.0}, {6.0}},\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","809daefdfb910db4c42b0f1b1277fcbe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"valid span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, 10)\n\t\texpected := []float64{0, 2.5, 5, 7.5, 10}\n\n\t\tfor i := range result {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"panics if dst length is less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic but did not occur\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 10)\n\t})\n\n\tt.Run(\"span with NaN start\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 10)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}\n\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"span with NaN end\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"span with infinity\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\n\t\tfor i := range result {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n}","80ffe1ef1dc80434c8321ba0d2fb1c7c":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl, u float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       -1,\n\t\t\tu:       1,\n\t\t\texpected: []float64{-1, 0, 1},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 2),\n\t\t\tl:       -5,\n\t\t\tu:       5,\n\t\t\texpected: []float64{-5, 5},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif !isEqual(result[i], test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for invalid destination size\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Span did not panic for insufficient length of dst\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc isEqual(a, b float64) bool {\n\treturn (a == b) || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}","8164f904edbace0e687a6eb1a01a3af5":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tpanics   bool\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // L2 distance\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, -2, 3},\n\t\t\tt:       []float64{4, -5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9, // L1 distance\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{1, 2},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 0, // L-inf distance\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{},\n\t\t\tt:       []float64{},\n\t\t\tL:       1,\n\t\t\texpected: 0, // edge case, empty slices\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2},\n\t\t\tL:       2,\n\t\t\texpected: 0, // Should panic due to length mismatch\n\t\t\tpanics:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panics {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for s:%v t:%v L:%v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.panics \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","820e22f4df79d99e681e83421197f3ad":"// norm_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 6},                   // L1 norm\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},      // L2 norm\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3)}, // L3 norm\n\t\t{[]float64{1, -2, 3}, 1, 6},                  // Includes negative\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},   // L2 norm with negatives\n\t\t{[]float64{}, 2, -1},                         // Empty slice\n\t\t{[]float64{0, 0, 0}, 2, 0},                   // Zero slice\n\t\t{[]float64{1, -1, 1}, math.Inf(1), 1},       // Infinity norm (max abs value)\n\t\t{[]float64{5, 6, 7, -8}, math.Inf(1), 8},    // Infinity norm (max abs value)\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Norm(test.slice, test.L)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.slice, test.L, got, test.want)\n\t\t}\n\t}\n}","8237b765f07159af3926d27949397523":"package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    tests := []struct {\n        name     string\n        dst      []float64\n        l, u     float64\n        expected []float64\n        shouldPanic bool\n    }{\n        {\n            name:     \"Basic Span\",\n            dst:      make([]float64, 5),\n            l:        0,\n            u:        4,\n            expected: []float64{0, 1, 2, 3, 4},\n            shouldPanic: false,\n        },\n        {\n            name:     \"Panic on length less than 2\",\n            dst:      make([]float64, 1),\n            l:        0,\n            u:        4,\n            expected: nil,\n            shouldPanic: true,\n        },\n        {\n            name:     \"Span with NaN start\",\n            dst:      make([]float64, 5),\n            l:        math.NaN(),\n            u:        4,\n            expected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n            shouldPanic: false,\n        },\n        {\n            name:     \"Span with NaN end\",\n            dst:      make([]float64, 5),\n            l:        0,\n            u:        math.NaN(),\n            expected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n            shouldPanic: false,\n        },\n        {\n            name:     \"Span with infinite bounds\",\n            dst:      make([]float64, 5),\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            expected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n            shouldPanic: false,\n        },\n        {\n            name:     \"Span where l equals u\",\n            dst:      make([]float64, 5),\n            l:        2,\n            u:        2,\n            expected: []float64{2, 2, 2, 2, 2},\n            shouldPanic: false,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if tt.shouldPanic {\n                defer func() {\n                    if r := recover(); r == nil {\n                        t.Errorf(\"expected panic but did not occur\")\n                    }\n                }()\n            }\n\n            result := Span(tt.dst, tt.l, tt.u)\n\n            if !equalSlices(result, tt.expected) {\n                t.Errorf(\"expected %v, got %v\", tt.expected, result)\n            }\n        })\n    }\n}\n\nfunc equalSlices(a, b []float64) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if !float64Equal(a[i], b[i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc float64Equal(a, b float64) bool {\n    return (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","82cfd02b37e335e4d6d30fe85596f5fc":"package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n    tests := []struct {\n        s       []float64\n        L       float64\n        expected float64\n    }{\n        // Test case for L = 1\n        {[]float64{1, 2, -3}, 1, 6},\n        {[]float64{}, 1, 0}, // edge case: empty slice\n        \n        // Test case for L = 2\n        {[]float64{1, 2, -3}, 2, math.Sqrt(14)},\n        \n        // Test case for L = math.Inf(1)\n        {[]float64{1, 2, -3}, math.Inf(1), 3},\n\n        // Test case for general L \u003e 0\n        {[]float64{1, 2, 3}, 3, math.Pow(36, 1.0/3.0)},\n        \n        // Test case for negative values\n        {[]float64{-1, -2, -3}, 1, 6},\n\n        // Test case for mixed values\n        {[]float64{-1, 0, 1}, 2, 1.4142135623730951}, // sqrt(2)\n\n        // Test case for large values\n        {[]float64{1e10, 1e10, 1e10}, 1, 3e10},\n    }\n\n    for _, test := range tests {\n        result := Norm(test.s, test.L)\n        if !almostEqual(result, test.expected) {\n            t.Errorf(\"Norm(%v, %v) = %v; want %v\", test.s, test.L, result, test.expected)\n        }\n    }\n}\n\n// Helper function to check for floating point equality\nfunc almostEqual(a, b float64) bool {\n    const epsilon = 1e-9\n    return math.Abs(a-b) \u003c epsilon\n}","8316756719bd266dc16a02ec38ac71fe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, expectedIdx int\n\t\tl, u, v       float64\n\t\texpectPanic   bool\n\t}{\n\t\t{5, 2, 0, 10, 5, false},             // Middle value\n\t\t{5, 0, 0, 10, -1, false},            // Outside lower bound\n\t\t{5, 4, 0, 10, 11, false},            // Outside upper bound\n\t\t{5, 2, 0, 10, 5.0, false},           // Exact middle\n\t\t{5, 1, 0, 10, 2.5, false},           // Closer to mid (2.5)\n\t\t{5, 3, 0, 10, 7.5, false},           // Closer to mid (7.5)\n\t\t{5, 2, 0, 10, math.NaN(), false},    // v is NaN\n\t\t{3, 1, 0, 10, 5, false},             // Another valid case\n\t\t{5, 2, math.Inf(-1), math.Inf(1), 0, false}, // Inf case\n\t\t{5, 0, math.Inf(-1), math.Inf(0), -1, false}, // Inf lower bound\n\t\t{5, 0, math.Inf(0), math.Inf(1), 1, false},  // Inf upper bound\n\t\t{5, 0, math.Inf(1), math.Inf(1), 2, false},  // Both bounds are Inf\n\t\t{1, 0, 0, 10, 5, true},                // Panic case: n \u003c 2\n\t\t{0, 0, 0, 10, 5, true},                // Panic case: n \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: %v, %v, %v, %v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expectedIdx {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expectedIdx)\n\t\t}\n\t}\n}","833b21a0075c577fde94c189898f66a9":"// swap_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\ntype argsort struct {\n\ts    []float64\n\tinds []int\n}\n\nfunc TestSwap(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\ti, j int\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic swap\",\n\t\t\ta:    argsort{s: []float64{1.0, 2.0, 3.0}, inds: []int{0, 1, 2}},\n\t\t\ti:    0,\n\t\t\tj:    2,\n\t\t\twant: []float64{3.0, 2.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Same index swap\",\n\t\t\ta:    argsort{s: []float64{4.0, 5.0, 6.0}, inds: []int{0, 1, 2}},\n\t\t\ti:    1,\n\t\t\tj:    1,\n\t\t\twant: []float64{4.0, 5.0, 6.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Consecutive swap\",\n\t\t\ta:    argsort{s: []float64{7.0, 8.0, 9.0}, inds: []int{0, 1, 2}},\n\t\t\ti:    1,\n\t\t\tj:    2,\n\t\t\twant: []float64{7.0, 9.0, 8.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.a.Swap(tt.i, tt.j)\n\t\t\tif !equalSlices(tt.a.s, tt.want) {\n\t\t\t\tt.Errorf(\"Swap() = %v, want %v\", tt.a.s, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","84cba209de73be9fc8a65c3115cd478d":"// File: find_test.go\npackage floats\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"no elements requested\",\n\t\t\tinds:     []int{0, 0, 0},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first k elements\",\n\t\t\tinds:     []int{0, 0, 0},\n\t\t\tf:        func(x float64) bool { return x \u003e 1 },\n\t\t\ts:        []float64{1, 2, 3, 0, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k less than available elements\",\n\t\t\tinds:     []int{0, 0, 0},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k greater than available elements\",\n\t\t\tinds:     []int{0, 0, 0},\n\t\t\tf:        func(x float64) bool { return x \u003e 5 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"k negative, return all\",\n\t\t\tinds:     []int{0, 0, 0},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 0, -1, 2, 3},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 3, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"no valid elements\",\n\t\t\tinds:     []int{0, 0, 0},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(got, tt.expected) || !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; expected %v, %v\", got, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","84cf1db0881ba9374d11a631125e887c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value in normal range\n\t\t{5, 0, 10, 11, 4},          // Above upper bound\n\t\t{5, 0, 10, -1, 0},          // Below lower bound\n\t\t{3, math.NaN(), 10, 5, 2}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Negative inf to positive inf range\n\t\t{3, -10, -5, -7.5, 1},      // Negative value in normal range\n\t\t{3, -10, -5, -15, 0},       // Below lower negative bound\n\t\t{3, -10, -5, -2, 2},        // Above upper negative bound\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d,l=%v,u=%v,v=%v\", tt.n, tt.l, tt.u, tt.v), func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"got %d, want %d\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","84fc49945a232770c24f21a053cee5a1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\texpectPanic bool\n\t}{\n\t\t{2, 0, 10, 5, 1, false},  // Middle value\n\t\t{2, 0, 10, 0, 0, false},  // Lower bound\n\t\t{2, 0, 10, 10, 1, false}, // Upper bound\n\t\t{3, 0, 10, 5, 1, false},  // Middle value with odd n\n\t\t{3, 0, 10, 0, 0, false},  // Lower bound with odd n\n\t\t{3, 0, 10, 10, 2, false}, // Upper bound with odd n\n\t\t{2, 0, 10, -5, 0, false}, // Below lower bound\n\t\t{2, 0, 10, 15, 1, false}, // Above upper bound\n\t\t{2, math.NaN(), 10, 5, 1, false}, // Test NaN lower bound\n\t\t{2, 0, math.NaN(), 5, 0, false}, // Test NaN upper bound\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0, false}, // Test negative infinity and positive infinity\n\t\t// Test cases for panic\n\t\t{1, 0, 10, 5, 0, true}, // Panic with n \u003c 2\n\t\t{0, 0, 10, 5, 0, true}, // Panic with n \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic, but didn't\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8660c16f640958be268b424125fc3fec":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\texpected float64\n\t}{\n\t\t// Test case for L1 norm\n\t\t{[]float64{1, -1, 2, -2}, 1, 6},\n\t\t// Test case for L2 norm\n\t\t{[]float64{3, 4}, 2, 5}, // sqrt(3^2 + 4^2)\n\t\t// Test case for infinity norm\n\t\t{[]float64{1, -10, 2, -3}, math.Inf(1), 10},\n\t\t// Test case for empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t// Test case for higher L norms\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(1+8+27, 1/3)}, // (1^3 + 2^3 + 3^3)^(1/3)\n\t\t// Test case with negative numbers\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(1 + 4 + 9)}, // sqrt((-1)^2 + (-2)^2 + (-3)^2)\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := Norm(test.slice, test.L); !floatEquals(got, test.expected) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.slice, test.L, got, test.expected)\n\t\t}\n\t}\n}\n\n// floatEquals checks if two float64 numbers are approximately equal\nfunc floatEquals(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","876a136b2371b18a843f206bffeb3c2a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\texp int\n\t}{\n\t\t{5, 0, 10, 5, 2},            // v is exactly in the middle\n\t\t{5, 0, 10, 0, 0},            // v is the lower bound\n\t\t{5, 0, 10, 10, 4},           // v is the upper bound\n\t\t{5, -10, 10, 5, 2},          // v is in the middle of bounds\n\t\t{5, -10, 10, -10, 0},        // v is the lower bound\n\t\t{5, -10, 10, 10, 4},         // v is the upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // v is in middle of -Inf and Inf\n\t\t{3, 0, 1, 0.5, 1},           // testing minimum size n\n\t\t{2, 1, 2, 1.5, 1},           // testing minimum size n with non-zero range\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.exp {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.exp)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic on n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // Should panic\n}","88a0193ded84b9e893d23ff426b1843c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm\",\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{2, 2},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(2),\n\t\t},\n\t\t{\n\t\t\tname:     \"L-infinity norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"General L-norm with L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(9, 1.0/3.0), // (9^(1/3))\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif !floatsEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on length mismatch\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Distance should panic on length mismatch\")\n\t\t\t}\n\t\t}()\n\t\t_ = Distance([]float64{1}, []float64{1, 2}, 1)\n\t})\n}\n\nfunc floatsEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9 // Adjust tolerance as needed\n}","8900aa68771056c6d140df5d1c575cfa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst        []float64\n\t\tl          float64\n\t\tu          float64\n\t\texpected   []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0,\n\t\t\tu:          10,\n\t\t\texpected:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          1,\n\t\t\tu:          5,\n\t\t\texpected:   []float64{1, 3, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 10),\n\t\t\tl:          -5,\n\t\t\tu:          5,\n\t\t\texpected:   []float64{-5, -4, -3, -2, -1, 0, 1, 2, 3, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          3,\n\t\t\tu:          3,\n\t\t\texpected:   []float64{3, 3},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0,\n\t\t\tu:          1,\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for dst length %d, l %v, u %v\", len(test.dst), test.l, test.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(test.dst, test.l, test.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := Span(test.dst, test.l, test.u)\n\t\t\tfor i, v := range got {\n\t\t\t\tif math.IsNaN(v) || v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"unexpected value at index %d: got %v, want %v\", i, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","8957cbfb628c000e6a23a0af86dc0e6d":"// distance_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tisPanic bool\n\t}{\n\t\t// Test L1 norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{1, 2, 2}, L: 1, expected: 1},\n\t\t// Test L2 norm\n\t\t{s: []float64{1, 0}, t: []float64{0, 0}, L: 2, expected: 1},\n\t\t// Test L-infinity norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: math.Inf(1), expected: 3},\n\t\t// Test general L-norm\n\t\t{s: []float64{1, 2, 3}, t: []float64{4, 5, 6}, L: 3, expected: math.Pow(3*3*3, 1.0/3.0)},\n\t\t// Test empty slices\n\t\t{s: []float64{}, t: []float64{}, L: 1, expected: 0},\n\t\t// Test mismatched lengths (should panic)\n\t\t{s: []float64{1, 2}, t: []float64{1}, L: 1, isPanic: true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.isPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: s=%v, t=%v, L=%v\", tt.s, tt.t, tt.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\tif !tt.isPanic \u0026\u0026 result != tt.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t}\n\t}\n}","8a268a807febdd1589044723d42783f7":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpIdx int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 2.5, 1},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, 0, 10, -1, 0},\n\t\t{5, 0, 10, 11, 4},\n\t\t{5, -10, -5, -8, 1},\n\t\t{5, -5, 0, -2.5, 2},\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 1, 1},\n\t\t{3, math.NaN(), math.NaN(), 0, 0},\n\t\t{3, math.Inf(-1), math.NaN(), 0, 0},\n\t\t{3, math.NaN(), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), math.NaN(), 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(1, 0, 10, 5), but did not panics\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","8d7bf8dcb492c4994dab8bf626b97ed0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative span\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 0, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Single element span\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        2,\n\t\t\tu:        4,\n\t\t\texpected: []float64{2, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panics when dst length \u003c 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity lower bound\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity upper bound\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Both bounds infinity\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic for length \u003c 2\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","8db84bf8b529bb0fc69aa47c2d3ac7c6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 2.5, 3.0}, 2.2, 2},\n\t\t{[]float64{-1.0, 0.0, 1.0}, 0.5, 2},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.0, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0},\n\t\t{[]float64{math.Inf(1), 100, 200}, math.Inf(1), 0},\n\t\t{[]float64{-100, -50, 0, 50, 100}, -60, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif len(test.s) == 0 {\n\t\t\t\t\t\t// Expecting a panic for zero-length slice\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Expected no panic, but got: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := NearestIdx(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Testing for panic on zero length\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero-length slice, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","8f9e9416d8c0aaecb379aacadcf67c50":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl       float64\n\t\tu       float64\n\t\tv       float64\n\t\twantIdx int\n\t\twantPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 0, 10, -1, 0, false},\n\t\t{5, 0, 10, 11, 4, false},\n\t\t{5, 0, 10, 0.5, 1, false},\n\t\t{5, 0, 10, 7.5, 3, false},\n\t\t{5, math.NaN(), 10, 5, 4, false},\n\t\t{5, 0, math.NaN(), 5, 0, false},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4, false},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0, false},\n\t\t{1, 0, 10, 5, 0, true}, // This case should panic\n\t\t{2, 0, 10, math.NaN(), 0, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil \u0026\u0026 tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Expected panic but did not get one\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotIdx := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}","9012a9920bb033f073d1054b802c5912":"// file: find_test.go\n\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Sample slice for testing\n\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\n\t// Sample test function that returns true for even numbers\n\tisEven := func(x float64) bool {\n\t\treturn int(x)%2 == 0\n\t}\n\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 even numbers\",\n\t\t\tinds:     []int{},\n\t\t\tf:        isEven,\n\t\t\ts:        s,\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3}, // index of 2.0 and 4.0\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all even numbers\",\n\t\t\tinds:     []int{},\n\t\t\tf:        isEven,\n\t\t\ts:        s,\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3}, // index of 2.0 and 4.0\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find more than available even numbers\",\n\t\t\tinds:     []int{},\n\t\t\tf:        isEven,\n\t\t\ts:        s,\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 3}, // index of 2.0 and 4.0\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find zero elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        isEven,\n\t\t\ts:        s,\n\t\t\tk:        0,\n\t\t\texpected: []int{}, // no indices\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"No even numbers found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        s,\n\t\t\tk:        1,\n\t\t\texpected: []int{}, // no indices\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif !equal(inds, tt.expected) {\n\t\t\t\tt.Fatalf(\"expected: %v, got: %v\", tt.expected, inds)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// helper function to compare two slices for equality\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","90eda1a8282de7144480b0cef156e607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2},               // Regular case\n\t\t{[]float64{3.0, 2.0, 1.0}, 0},               // Max at the start\n\t\t{[]float64{2.0, 3.0, 3.0}, 1},               // Max at the middle (first occurrence)\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 2},       // Skip NaN\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 2},       // Max after NaN\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},            // Negative values\n\t\t{[]float64{math.NaN(), math.NaN()}, 0},     // All NaN, should return the first index\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MaxIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %d; expected %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Testing panic condition for zero-length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MaxIdx did not panic for zero-length slice\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","9303356005fcdaa7752836a212c96a6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice   []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t// Case: L = 1 (Manhattan norm)\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t// Case: L = 2 (Euclidean norm)\n\t\t{[]float64{3, 4}, 2, 5},\n\t\t// Case: L = 3 (general case)\n\t\t{[]float64{1, 2, 2}, 3, math.Pow(9, 1.0/3.0)},\n\t\t// Case: L = Infinity (maximum absolute value norm)\n\t\t{[]float64{-1, -2, 3}, math.Inf(1), 3},\n\t\t// Case: Empty slice\n\t\t{[]float64{}, 2, 0},\n\t\t// Case: L = 0 (should not compute zero norm, use Count instead)\n\t\t{[]float64{1, 2, 3}, 0, math.NaN()},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.slice, test.L)\n\t\tif math.IsNaN(test.expected) \u0026\u0026 !math.IsNaN(result) {\n\t\t\tt.Errorf(\"Expected NaN but got %v for input %v and L=%v\", result, test.slice, test.L)\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.slice, test.L, result, test.expected)\n\t\t}\n\t}\n}","930bfa10b6dc4b7a361ff5e9c117915b":"// log_sum_exp_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: math.Log(math.Exp(1.0) + math.Exp(2.0) + math.Exp(3.0)),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{0.0, 0.0, 0.0},\n\t\t\texpected: 0.0, // ln(3) since e^0 + e^0 + e^0 = 3\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{-1.0, -2.0, -3.0},\n\t\t\texpected: math.Log(math.Exp(-1.0) + math.Exp(-2.0) + math.Exp(-3.0)),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Log(math.MaxFloat64), 0},\n\t\t\texpected: math.Log(math.Exp(math.Log(math.MaxFloat64)) + math.Exp(0)), // should not overflow\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 0},\n\t\t\texpected: math.Inf(1), // The result should be +Inf\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(-1), math.Inf(-1)},\n\t\t\texpected: math.Inf(-1), // The result should be -Inf\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v\", tt.input), func(t *testing.T) {\n\t\t\tresult := LogSumExp(tt.input)\n\t\t\tif !math.IsNaN(tt.expected) {\n\t\t\t\tif math.Abs(result-tt.expected) \u003e 1e-9 {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t} else if !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"expected NaN, got %v\", result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for empty slice\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic when passing an empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}","93bb65f0c24933e8c6e5822ca34a87d6":"package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{3.0, 2.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: []float64{42.0},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tReverse(test.input)\n\t\tif !reflect.DeepEqual(test.input, test.expected) {\n\t\t\tt.Errorf(\"Reverse(%v) = %v; want %v\", test.input, test.input, test.expected)\n\t\t}\n\t}\n}","95db695f7002f97cfcc763d5f131bde2":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, -10, -5, -7.5, 2},\n\t\t{5, -10, -5, -10, 0},\n\t\t{5, -10, -5, -5, 4},\n\t\t{5, 10, 20, 15, 2},\n\t\t{5, 10, 20, 10, 0},\n\t\t{5, 10, 20, 20, 4},\n\t\t{3, 0, 100, 50, 1},\n\t\t{2, 0, 100, 50, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test panic on n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test handling NaN\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"Expected 0 for NaN input, got %d\", result)\n\t}\n}","971cdb9966ab10f3b6a66f22cf666530":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts1      []float64\n\t\ts2      []float64\n\t\ttol     float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices with zero tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.0},\n\t\t\ttol:     0.0,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices within tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0001, 3.0},\n\t\t\ttol:     0.001,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not equal slices outside tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.5, 3.0},\n\t\t\ttol:     0.1,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\ts1:      []float64{1.0, 2.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.0},\n\t\t\ttol:     0.1,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices with relative tolerance\",\n\t\t\ts1:      []float64{1.0, 1.0, 1.0},\n\t\t\ts2:      []float64{1.0, 1.01, 1.0},\n\t\t\ttol:     0.02,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices with negative values\",\n\t\t\ts1:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts2:      []float64{-1.0, -2.0001, -3.0},\n\t\t\ttol:     0.001,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not equal slices with negative values\",\n\t\t\ts1:      []float64{-1.0, -2.0, -3.0},\n\t\t\ts2:      []float64{-1.0, -2.5, -3.0},\n\t\t\ttol:     0.1,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualApprox(tt.s1, tt.s2, tt.tol)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %v) = %v; want %v\", tt.s1, tt.s2, tt.tol, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","97f6a508a005bcc949f1573f054387f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t\texpectPanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},        // Midpoint\n\t\t{5, 0, 10, 0, 0, false},        // Lower bound\n\t\t{5, 0, 10, 10, 4, false},       // Upper bound\n\t\t{5, 10, 0, 0, 4, false},        // Reverse bounds with midpoint\n\t\t{5, 10, 0, 10, 0, false},       // Edge case on upper bound\n\t\t{5, -10, 10, 0, 2, false},      // Zero in a symmetric range\n\t\t{5, -5, 5, 6, 4, false},         // Above upper bound\n\t\t{5, -5, 5, -6, 0, false},        // Below lower bound\n\t\t{3, 0, 1, 0.5, 1, false},        // Edge case with minimum n\n\t\t{2, 0, 1, 0.5, 1, false},        // Edge case with minimum n\n\t\t{1, 0, 1, 0.5, 0, true},         // Panic case with n \u003c 2\n\t\t{5, 0, 0, math.NaN(), 0, false}, // NaN for v\n\t\t{5, math.NaN(), 10, 5, 4, false}, // NaN for l\n\t\t{5, 0, math.NaN(), 5, 0, false},  // NaN for u\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2, false}, // +/- Inf\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for input n=%d, l=%f, u=%f, v=%f\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"for n=%d, l=%f, u=%f, v=%f: expected %d, got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}","98455f52f62b2e50bb908d3d0ed0a1ec":"// prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                       // case for empty slice\n\t\t{[]float64{2, 3, 4}, 24},               // normal case\n\t\t{[]float64{1, 5, 3}, 15},                // normal case\n\t\t{[]float64{-1, 5, 3}, -15},              // case with negative number\n\t\t{[]float64{-1, -5, 3}, 15},              // case with two negative numbers\n\t\t{[]float64{2, 0, 3}, 0},                 // case with zero\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9968eecfdf30082706212c97588e7293":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, // Basic test case\n\t\t{[]float64{0}, 0}, // Single element\n\t\t{[]float64{-1, -2}, math.Log(math.Exp(-1) + math.Exp(-2))}, // Negative values\n\t\t{[]float64{}, math.NaN()}, // Empty slice, expect panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tif len(tt.input) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, but did not get one\", tt.input)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := LogSumExp(tt.input)\n\t\tif !math.IsNaN(tt.expected) \u0026\u0026 result != tt.expected {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v, expected %v\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}","99d6db2036d4ac3edc0116983f0e560d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\texpectPanic bool\n\t}{\n\t\t// Test with L1 norm\n\t\t{s: []float64{1.0, 2.0, 3.0}, t: []float64{1.0, 2.0, 3.0}, L: 1.0, expected: 0.0, expectPanic: false},\n\t\t{s: []float64{1.0, 2.0, 3.0}, t: []float64{4.0, 5.0, 6.0}, L: 1.0, expected: 9.0, expectPanic: false},\n\t\t\n\t\t// Test with L2 norm\n\t\t{s: []float64{1.0, 2.0, 3.0}, t: []float64{1.0, 2.0, 3.0}, L: 2.0, expected: 0.0, expectPanic: false},\n\t\t{s: []float64{1.0, 2.0, 3.0}, t: []float64{4.0, 5.0, 6.0}, L: 2.0, expected: math.Sqrt(27), expectPanic: false},\n\t\t\n\t\t// Test with L-infinity norm\n\t\t{s: []float64{1.0, 2.0, 3.0}, t: []float64{4.0, 5.0, 6.0}, L: math.Inf(1), expected: 3.0, expectPanic: false},\n\t\t\n\t\t// Test with L-norm for L=3\n\t\t{s: []float64{1.0, 2.0, 3.0}, t: []float64{4.0, 5.0, 6.0}, L: 3.0, expected: math.Pow(27, 1.0/3.0), expectPanic: false},\n\t\t\n\t\t// Test panic cases\n\t\t{s: []float64{1.0, 2.0}, t: []float64{1.0}, L: 2.0, expected: 0.0, expectPanic: true},  // different lengths\n\t\t{s: []float64{}, t: []float64{}, L: 1.0, expected: 0.0, expectPanic: false},  // both slices empty\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tDistance(test.s, test.t, test.L)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Distance(test.s, test.t, test.L)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","9a496ba17ec527d8f006609f6f843ff6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst   []float64\n\t\ts     []float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tdst:  []float64{4, 4, 4},\n\t\t\ts:    []float64{2, 2, 2},\n\t\t\twant: []float64{2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{10, 20, 30},\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: []float64{10, 10, 10},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{0, 2, 3},\n\t\t\twant: []float64{1, 1, 1}, // Will cause panic for division by zero if not handled.\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{10, 20},\n\t\t\ts:    []float64{5, 10},\n\t\t\twant: []float64{2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{1, 2}, // Different lengths\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, s: %v\", tt.dst, tt.s)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tDiv(tt.dst, tt.s)\n\t\t\t}()\n\t\t} else {\n\t\t\tDiv(tt.dst, tt.s)\n\t\t\tfor i, v := range tt.want {\n\t\t\t\tif tt.dst[i] != v {\n\t\t\t\t\tt.Errorf(\"Div() = %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","9a6f496faafe107e1f1f8261c46d7bf1":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twantIdx int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},  // First nearest is 2.0\n\t\t{[]float64{1.0, 2.0, 3.0, 3.0}, 3.1, 2}, // Among two 3s, return the first\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2},  // Exact match at the end\n\t\t{[]float64{5.0, 10.0}, 7.5, 0},      // Nearest is 5.0\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 1.5, 0}, // Nearest is 1.0\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0},  // Multiple same values, expect first index\n\t\t{[]float64{1.0, 2.0, 2.5}, 2.4, 1},  // Between 2 and 2.5, expect 2.0\n\t\t{[]float64{math.NaN(), 3.0, 4.0}, 3.1, 1}, // NaN should be ignored\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // NaN for v should return 1 not 0\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // +Inf expects last index\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // -Inf expects first index\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.s, tt.v); got != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdx_PanicsOnZeroLength(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdx did not panic on zero length slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","9a98ff29fee4e9f72e766486242fbc11":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Normal case\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 0.0, 10.0\n\t\tresult := Span(dst, l, u)\n\n\t\texpected := []float64{0, 2.5, 5, 7.5, 10}\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Panic on short length\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif recover() == nil {\n\t\t\t\tt.Errorf(\"Expected panic for length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 10)\n\t})\n\n\tt.Run(\"NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 10.0)\n\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0}\n\t\tfor i, v := range expected {\n\t\t\tif (math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(v)) || result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0.0, math.NaN())\n\n\t\texpected := []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i, v := range expected {\n\t\t\tif (math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(v)) || result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Positive infinity lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(1), math.Inf(-1))\n\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1)}\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Negative infinity upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(0))\n\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(0)}\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n}","9ab1d4dcd4e6e4dd07be351879e21a61":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 100, 25, 2},        // Testing a case within bounds\n\t\t{10, 0, 100, 50, 5},        // Testing a case exactly in the middle\n\t\t{10, 0, 100, 75, 7},        // Testing a case within bounds\n\t\t{10, 0, 100, 0, 0},         // Testing lower bound\n\t\t{10, 0, 100, 100, 9},       // Testing upper bound\n\t\t{10, 0, 100, -10, 0},       // Testing below lower bound\n\t\t{10, 0, 100, 110, 9},       // Testing above upper bound\n\t\t{5, 10, 20, 15, 2},         // Testing a smaller span\n\t\t{5, 20, 10, 15, 2},         // Testing reversed bounds\n\t\t{10, math.NaN(), 100, 50, 9}, // Testing lower bound NaN\n\t\t{10, 0, math.NaN(), 50, 0},  // Testing upper bound NaN\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0}, // Testing infinity bounds\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 9}, // Testing reverse infinity bounds\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 tt.n \u003c 2 {\n\t\t\t\t\tt.Errorf(\"Expected panic for n = %d\", tt.n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Panic test case for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","9b77ccabddafb9d8dc5b4b9224996375":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst         []float64\n\t\ty           []float64\n\t\talpha       float64\n\t\ts           []float64\n\t\texpected    []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tdst:         []float64{1, 2, 3},\n\t\t\ty:           []float64{4, 5, 6},\n\t\t\talpha:       2,\n\t\t\ts:           []float64{1, 1, 1},\n\t\t\texpected:    []float64{6, 7, 8},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         []float64{0, 0, 0},\n\t\t\ty:           []float64{0, 0, 0},\n\t\t\talpha:       3,\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\texpected:    []float64{3, 6, 9},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         []float64{1, 1},\n\t\t\ty:           []float64{2, 2, 2},\n\t\t\talpha:       1,\n\t\t\ts:           []float64{1, 1, 1},\n\t\t\texpected:    nil, // should panic\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         []float64{1, 2, 3, 4},\n\t\t\ty:           []float64{1, 2, 3},\n\t\t\talpha:       2,\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\texpected:    nil, // should panic\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         []float64{2, 4},\n\t\t\ty:           []float64{0, 0},\n\t\t\talpha:       0,\n\t\t\ts:           []float64{5, 6},\n\t\t\texpected:    []float64{2, 4},\n\t\t\tshouldPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.shouldPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic for input: %+v\", test)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif math.Abs(result[i]-v) \u003e 1e-9 {\n\t\t\t\t\tt.Errorf(\"Unexpected result for input %+v: got %v, want %v\", test, result, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","9c55932632ea7107edec31327f638aa7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"value within range\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value equals lower bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"value equals upper bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than the first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than the last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted array with duplicates\",\n\t\t\ts:        []float64{1.0, 1.0, 2.0, 3.0},\n\t\t\tv:        1.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == -1 {\n\t\t\t\t// Test for the expected panic cases\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for input: %v, %v\", tt.s, tt.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Additional tests for panic conditions\n\ttestsPanic := []struct {\n\t\tname string\n\t\ts    []float64\n\t}{\n\t\t{name: \"empty slice\", s: []float64{}},\n\t\t{name: \"single element slice\", s: []float64{1.0}},\n\t\t{name: \"unsorted slice\", s: []float64{3.0, 2.0, 1.0}},\n\t}\n\n\tfor _, tt := range testsPanic {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for input: %v\", tt.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t\t_ = Within(tt.s, 1.0) // Just to trigger the function\n\t\t})\n\t}\n}","9cb0d360d85ad376bf2194447eafd178":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{input: []float64{1.0, 2.0, 3.0}, expected: false},        // No NaN\n\t\t{input: []float64{math.NaN(), 1.0, 2.0}, expected: true},  // NaN present\n\t\t{input: []float64{1.0, math.NaN(), 3.0}, expected: true},  // NaN present\n\t\t{input: []float64{math.NaN(), math.NaN()}, expected: true}, // All NaNs\n\t\t{input: []float64{}, expected: false},                      // Empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := HasNaN(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"HasNaN(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9d291a0a7219e71f1248386c72c4ebdd":"// File: norm_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t// Test L = 1\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{}, 1, 0}, // empty slice\n\n\t\t// Test L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3-4-5 triangle\n\n\t\t// Test L = math.Inf(1)\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -5, 2}, math.Inf(1), 5},\n\n\t\t// Test L \u003e 2\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(14, 1.0/3.0)}, // (1^3 + 2^3 + 3^3)^(1/3)\n\n\t\t// Test with zeros\n\t\t{[]float64{0, 0, 0}, 1, 0},\n\t\t{[]float64{0, 0, 0}, 2, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Norm(test.input, test.L)\n\t\tif !floatEquals(result, test.expected) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", test.input, test.L, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc floatEquals(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","9d4ab18a2d3be262fae27fe7439bf295":"// File: find_test.go\n\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinds        []int\n\t\tf           func(float64) bool\n\t\ts           []float64\n\t\tk           int\n\t\texpected    []int\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tname:        \"No elements found\",\n\t\t\tinds:        nil,\n\t\t\tf:           func(x float64) bool { return x \u003e 10 },\n\t\t\ts:           []float64{1, 2, 3, 4},\n\t\t\tk:           2,\n\t\t\texpected:    []int{},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One element found\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x == 2 },\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tk:    1,\n\t\t\texpected: []int{\n\t\t\t\t1,\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements found, limit is satisfied\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003e 1 },\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tk:    2,\n\t\t\texpected: []int{\n\t\t\t\t1, 2,\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"More results than expected\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003e 1 },\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tk:    1,\n\t\t\texpected: []int{\n\t\t\t\t1,\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Request all elements with k \u003c 0\",\n\t\t\tinds:        nil,\n\t\t\tf:           func(x float64) bool { return x \u003e 0 },\n\t\t\ts:           []float64{1, 2, 3, 4},\n\t\t\tk:           -1,\n\t\t\texpected:    []int{0, 1, 2, 3},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Insufficient elements found with positive k\",\n\t\t\tinds: nil,\n\t\t\tf:    func(x float64) bool { return x \u003e 5 },\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tk:    2,\n\t\t\texpected: []int{},\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"expected length: %d, got: %d\", len(tt.expected), len(result))\n\t\t\t}\n\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","9e6b0f9dd9f49f75a5ba370e3a417163":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\thasPanic bool\n\t}{\n\t\t// Test cases for L1 norm\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, 1.0, 9.0, false},\n\t\t{[]float64{-1.0, -2.0}, []float64{-1.0, -5.0}, 1.0, 3.0, false},\n\n\t\t// Test cases for L2 norm\n\t\t{[]float64{3.0, 4.0}, []float64{0.0, 0.0}, 2.0, 5.0, false},\n\t\t{[]float64{1.0}, []float64{1.0}, 2.0, 0.0, false},\n\n\t\t// Test cases for infinity norm\n\t\t{[]float64{1.0, -2.0, 3.0}, []float64{4.0, 5.0, 6.0}, math.Inf(1), 3.0, false},\n\n\t\t// Test cases for arbitrary L norms\n\t\t{[]float64{1.0, 2.0}, []float64{2.0, 3.0}, 3.0, math.Pow(1+1, 1/3.0), false},\n\n\t\t// Test case for mismatched lengths (should panic)\n\t\t{[]float64{1.0, 2.0}, []float64{1.0}, 2.0, 0.0, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.hasPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v, but didn't get one\", test.s, test.t)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tDistance(test.s, test.t, test.L)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Distance(test.s, test.t, test.L)\n\t\t\tif math.Abs(result-test.expected) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","a016dbc2f0d6caf11e2cb0a3b863ab48":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, expected int\n\t\tl, u, v     float64\n\t\tpanic       bool\n\t}{\n\t\t{5, 2, 0, 10, 5, false}, // Middle value\n\t\t{5, 0, 0, 10, -1, false}, // Below lower bound\n\t\t{5, 4, 0, 10, 11, false}, // Above upper bound\n\t\t{5, 2, 0, 10, 5.1, false}, // Close to middle value\n\t\t{3, 1, 0, 10, 3, false}, // Between bounds\n\t\t{5, 0, 0, 0, 0, false}, // Lower bound equals value\n\t\t{5, 4, 10, 10, 10, false}, // Upper bound equals value\n\t\t{5, 0, math.Inf(-1), math.Inf(1), 0, false}, // Inf limits\n\t\t{5, 0, math.Inf(-1), math.Inf(1), math.Inf(-1), false}, // v is negative Inf\n\t\t{5, 4, math.Inf(-1), math.Inf(1), math.Inf(1), false}, // v is positive Inf\n\t\t{5, 2, 10, 0, 5, false}, // Bounds reversed\n\t\t{2, 0, 0, 10, 5, false}, // Edge case with n=2\n\t\t{1, 0, 0, 10, 5, true}, // Panic case n \u003c 2\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() { recover() }()\n\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tt.Errorf(\"Expected panic for n=%d, l=%f, u=%f, v=%f but did not panic\", test.n, test.l, test.u, test.v)\n\t\t} else {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","a27f6a53f7ef837c6a2016083242e078":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Valid span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{1, 2, 3, 4, 5}\n\t\tresult := Span(dst, 1, 5)\n\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Empty slice panics\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic, got none\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 1, 5)\n\t})\n\n\tt.Run(\"NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5}\n\t\tresult := Span(dst, math.NaN(), 5)\n\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 !math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got NaN\", expected[i])\n\t\t\t} else if !math.IsNaN(v) \u0026\u0026 math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{1, 2, 3, 4, math.NaN()}\n\t\tresult := Span(dst, 1, math.NaN())\n\n\t\tfor i, v := range result {\n\t\t\tif math.IsNaN(v) \u0026\u0026 !math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got NaN\", expected[i])\n\t\t\t} else if !math.IsNaN(v) \u0026\u0026 math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinite lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 5}\n\t\tresult := Span(dst, math.Inf(-1), 5)\n\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinite upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{1, 2, 3, 4, math.Inf(1)}\n\t\tresult := Span(dst, 1, math.Inf(1))\n\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Equal bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{3, 3, 3, 3, 3}\n\t\tresult := Span(dst, 3, 3)\n\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n}","a2bf07ba250a0365f9ac0b0f63d41c94":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts     []float64\n\t\tt     []float64\n\t\tL     float64\n\t\twant  float64\n\t\thasPanic bool\n\t}{\n\t\t{\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{4, 5, 6},\n\t\t\tL:     1,\n\t\t\twant:  9,\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{4, 5, 6},\n\t\t\tL:     2,\n\t\t\twant:  5.196152422706632, // expected L2 distance\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{1, 2, 3},\n\t\t\tL:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{4, 5},\n\t\t\tL:     1,\n\t\t\twant:  0,\n\t\t\thasPanic: true, // Expecting panic due to mismatched lengths\n\t\t},\n\t\t{\n\t\t\ts:     []float64{},\n\t\t\tt:     []float64{},\n\t\t\tL:     1,\n\t\t\twant:  0,\n\t\t\thasPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:     []float64{5, 9, 2},\n\t\t\tt:     []float64{1, 3, 5},\n\t\t\tL:     3,\n\t\t\twant:  4.641588834,\n\t\t\thasPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.hasPanic {\n\t\t\tt.Run(\"Panic\", func(t *testing.T) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v, but did not panic\", tt.s, tt.t)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tDistance(tt.s, tt.t, tt.L)\n\t\t\t})\n\t\t} else {\n\t\t\tt.Run(\"No Panic\", func(t *testing.T) {\n\t\t\t\tgot := Distance(tt.s, tt.t, tt.L)\n\t\t\t\tif !almostEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", tt.s, tt.t, tt.L, got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\n// Helper function to check for approximate equality of floats\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","a3fe2ed40acd3b91aacc802c7c7b7333":"package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n    tests := []struct {\n        s         []float64\n        v         float64\n        expected  int\n        shouldPanic bool\n    }{\n        {[]float64{1.0, 2.0, 3.0}, 2.5, 1, false},  // Nearest to 2.5 is 2.0 at index 1\n        {[]float64{1.0, 2.0, 3.0}, 1.5, 0, false},  // Nearest to 1.5 is 1.0 at index 0\n        {[]float64{1.0, 2.0, 3.0}, 3.5, 2, false},  // Nearest to 3.5 is 3.0 at index 2\n        {[]float64{1.0, 2.0, 3.0, 5.0}, 4.0, 2, false}, // Nearest to 4.0 is 3.0 at index 2\n        {[]float64{-1.0, -2.0, -3.0}, -1.5, 0, false}, // Nearest to -1.5 is -1.0 at index 0\n        {[]float64{}, 1.0, -1, true},                // Should panic due to zero length\n        {[]float64{math.NaN()}, math.NaN(), 0, false}, // Nearest to NaN returns index 0\n        {[]float64{1.0, 2.0, math.Inf(1)}, math.Inf(1), 2, false}, // Nearest to positive infinity returns index of max\n        {[]float64{1.0, 2.0, math.Inf(-1)}, math.Inf(-1), 0, false}, // Nearest to negative infinity returns index of min\n    }\n\n    for _, test := range tests {\n        if test.shouldPanic {\n            defer func() {\n                if r := recover(); r == nil {\n                    t.Errorf(\"Expected panic for input %v and %v, but did not panic\", test.s, test.v)\n                }\n            }()\n        }\n        \n        result := NearestIdx(test.s, test.v)\n        if !test.shouldPanic \u0026\u0026 result != test.expected {\n            t.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n        }\n    }\n}","a41f57f74af72aeefcd635aa831db8f0":"// File: within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.5, 2},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 0.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 4.0, -1},\n\t\t{[]float64{-3.0, -1.0, 0.0, 1.0}, -2.0, 1},\n\t\t{[]float64{-3.0, -1.0, 0.0, 1.0}, 0.0, 2},\n\t\t{[]float64{0.0, 0.0, 0.0, 0.0}, 0.0, -1}, // Edge case with duplicates\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Within(tt.s, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.want)\n\t\t}\n\t}\n\n\t// Test for panic when len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within did not panic when len(s) \u003c 2\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test for panic when s is not sorted\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within did not panic when s is not sorted\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0, 3.0, 2.0})\n\n\t// Test for boundaries with NaN\n\tif got := Within([]float64{1.0, 2.0}, math.NaN()); got != -1 {\n\t\tt.Errorf(\"Expected -1 for NaN input, got %d\", got)\n\t}\n\n\t// Test for value less than the first element\n\tif got := Within([]float64{1.0, 2.0}, 0.0); got != -1 {\n\t\tt.Errorf(\"Expected -1 for input less than the first element, got %d\", got)\n\t}\n\n\t// Test for value greater than or equal to the last element\n\tif got := Within([]float64{1.0, 2.0}, 2.0); got != -1 {\n\t\tt.Errorf(\"Expected -1 for input equal to last element, got %d\", got)\n\t}\n}","a47dd1cdc3dc83bbdb439193cd64f607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tpanic bool\n\t}{\n\t\t{2, 0, 1, 0.5, 1},          // Middle position\n\t\t{5, 0, 10, 5, 2},           // Middle of a broader range\n\t\t{3, 1, 2, 1, 0},            // Value equal to lower bound\n\t\t{3, 1, 2, 2, 2},            // Value equal to upper bound\n\t\t{4, 0, 10, 11, 3},          // Value above range\n\t\t{4, 0, 10, -1, 0},          // Value below range\n\t\t{5, 0, math.Inf(1), 100, 4}, // Value well within positive infinity\n\t\t{5, math.Inf(-1), 0, -100, 0}, // Value well outside negative infinity\n\t\t{5, math.NaN(), 10, 5, 4},   // Lower bound NaN\n\t\t{5, 0, math.NaN(), 5, 0},    // Upper bound NaN\n\t\t{2, 3, 3, 3, 0},              // l == u\n\t\t{1, 0, 10, 5, 0, true},      // Panic case: n \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","a497dd8b46bc2c813c600319f2b295de":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantPanic bool\n\t}{\n\t\t{[]float64{1, 2, 3}, 2, 1, false},\n\t\t{[]float64{1, 2, 3}, 3, -1, false},\n\t\t{[]float64{1, 2, 3}, 0, -1, false},\n\t\t{[]float64{1, 2, 3}, math.NaN(), -1, false},\n\t\t{[]float64{1, 2, 3}, 2.5, 1, false},\n\t\t{[]float64{1, 2, 3}, 1, 0, false},\n\t\t{[]float64{1, 2, 3}, 4, -1, false},\n\t\t{[]float64{1, 2}, 1.5, 0, false},\n\t\t{[]float64{1, 2}, 3, -1, false},\n\t\t{[]float64{}, 1, -1, true},\n\t\t{[]float64{3, 2, 1}, 1, -1, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v, but did not panic\", tt.s, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := Within(tt.s, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.want)\n\t\t}\n\t}\n}","a4b60974e46bfdf6e006c7d82aaa379c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},                // Middle value\n\t\t{5, 0, 10, 0, 0},                // Lower bound\n\t\t{5, 0, 10, 10, 4},               // Upper bound\n\t\t{5, 0, 10, -5, 0},               // Below lower bound\n\t\t{5, 0, 10, 15, 4},               // Above upper bound\n\t\t{5, -10, -5, -7.5, 1},           // Negative range\n\t\t{5, -10, -5, -4, 4},             // Outside negative range\n\t\t{5, math.NaN(), 10, 5, 4},      // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},       // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), -3, 0}, // Negative infinity to positive infinity\n\t\t{5, math.Inf(-1), math.Inf(1), 3, 4}, // Positive value\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Infinity\n\t\t{5, -math.Inf(1), math.Inf(1), math.Inf(-1), 0}, // Negative infinity\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but function did not panic.\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","a4d1d307540cd4a4d2ac0b2fb9d31721":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\ts   []float64\n\t\tL   float64\n\t\texpected float64\n\t}{\n\t\t// Test cases for L = 1\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{0, 0, 0}, 1, 0},\n\t\t{[]float64{1, -1, 1}, 1, 3},\n\n\t\t// Test cases for L = 2\n\t\t{[]float64{3, 4}, 2, 5}, // 3-4-5 triangle, should return 5\n\t\t{[]float64{1, 2, 2}, 2, 3}, // sqrt(1^2 + 2^2 + 2^2)\n\t\t{[]float64{-5, -12}, 2, 13}, // sqrt((-5)^2 + (-12)^2)\n\n\t\t// Test cases for L = math.Inf(1)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, 0}, math.Inf(1), 2},\n\n\t\t// Test cases for other values of L\n\t\t{[]float64{1, 2, 3}, 3, math.Pow(3*math.Pow(1, 3)+math.Pow(2, 3)+math.Pow(3, 3), 1/3)},\n\t\t{[]float64{-1, 2, 3}, 3, math.Pow(3*math.Pow(1, 3)+math.Pow(2, 3)+math.Pow(3, 3), 1/3)},\n\t\t{[]float64{0, 0, 0}, 3, 0},\n\n\t\t// Edge cases\n\t\t{nil, 2, 0}, // nil slice\n\t\t{[]float64{}, 2, 0}, // empty slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Norm(tt.s, tt.L)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v, want %v\", tt.s, tt.L, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","a521218401b9b8dba09f0819080b73d1":"// distance_test.go\npackage floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n    tests := []struct {\n        s       []float64\n        t       []float64\n        L       float64\n        expected float64\n        shouldPanic bool\n    }{\n        {\n            s:       []float64{1, 2, 3},\n            t:       []float64{1, 2, 3},\n            L:       1,\n            expected: 0,\n            shouldPanic: false,\n        },\n        {\n            s:       []float64{1, 2, 3},\n            t:       []float64{4, 5, 6},\n            L:       1,\n            expected: 9, // |4-1| + |5-2| + |6-3| = 3 + 3 + 3 = 9\n            shouldPanic: false,\n        },\n        {\n            s:       []float64{1, 2},\n            t:       []float64{1},\n            L:       1,\n            expected: 0,\n            shouldPanic: true,\n        },\n        {\n            s:       []float64{0, 0},\n            t:       []float64{0, 0},\n            L:       2,\n            expected: 0,\n            shouldPanic: false,\n        },\n        {\n            s:       []float64{1, 1},\n            t:       []float64{2, 2},\n            L:       math.Inf(1),\n            expected: 1,\n            shouldPanic: false,\n        },\n        {\n            s:       []float64{-1, 2, 3},\n            t:       []float64{4, 5, 6},\n            L:       2,\n            expected: math.Sqrt(27), // √((4 - (-1))^2 + (5 - 2)^2 + (6 - 3)^2)\n            shouldPanic: false,\n        },\n        // Add more test cases as needed\n    }\n\n    for _, test := range tests {\n        if test.shouldPanic {\n            defer func() {\n                if r := recover(); r == nil {\n                    t.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", test.s, test.t, test.L)\n                }\n            }()\n        }\n\n        result := Distance(test.s, test.t, test.L)\n\n        if result != test.expected {\n            t.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n        }\n    }\n}","a54d54664865f2c31b2989b19aa1f707":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    6,\n\t\t\twant: []float64{0, 3, 6},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\twant: []float64{-1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\twant: []float64{0, 0},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    1,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: nil, // expect panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.want == nil {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic for dst: %v, l: %v, u: %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\n\t\tif tt.want != nil \u0026\u0026 !Equal(got, tt.want) {\n\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t}\n\t}\n}","a5e41a7195939f58c03fbd26820a8ba7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Test cases with normal values\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.1, 1},\n\t\t{[]float64{1.0, 3.0, 5.0}, 4.5, 2},\n\t\t{[]float64{1.0, 2.0, 2.0, 3.0}, 2.0, 1}, // Tests tie case\n\n\t\t// Test cases with extreme values\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // Testing with NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Positive infinity\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Negative infinity\n\n\t\t// Test cases with single element\n\t\t{[]float64{5.0}, 5.0, 0}, // Should not panic and return index 0\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Testing panic for empty slice\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for empty slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0.0)\n}","a69b30c54f2b14f26c3f18c8767573b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9}, // L1 distance\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)}, // L2 distance\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3}, // L-infinity distance\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, 1, 0}, // both slices are zero\n\t\t{[]float64{-1, -2, -3}, []float64{1, 2, 3}, 1, 12}, // L1 with negative values\n\t\t{[]float64{1.5, 2.5, 3.5}, []float64{4.5, 5.5, 6.5}, 2, math.Sqrt(27)}, // L2 with floats\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for different lengths\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Fatal(\"Expected panic for unequal lengths, but did not happen\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}","a7d15f2cc559aa317134a3b5cf5abf3b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\t// Test case 1: Typical case\n\tdst := []float64{5.0, 6.0, 7.0}\n\ts := []float64{1.0, 2.0, 3.0}\n\texpected := []float64{4.0, 4.0, 4.0}\n\tSub(dst, s)\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Expected %v at index %d, got %v\", expected[i], i, v)\n\t\t}\n\t}\n\n\t// Test case 2: Length mismatch case\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Sub did not panic on length mismatch\")\n\t\t}\n\t}()\n\tdst = []float64{5.0, 6.0}\n\ts = []float64{1.0, 2.0, 3.0}\n\tSub(dst, s)\n}","a9d4441a857e403200ecd0cceab9906d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\"Basic Span\", make([]float64, 5), 0, 4, []float64{0, 1, 2, 3, 4}},\n\t\t{\"Negative Span\", make([]float64, 5), -4, 0, []float64{-4, -3, -2, -1, 0}},\n\t\t{\"Single Point Span\", make([]float64, 2), 3, 3, []float64{3, 3}},\n\t\t{\"Inf Span\", make([]float64, 3), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{\"NaN Span\", make([]float64, 3), math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{\"Invalid Length\", make([]float64, 1), 0, 1, nil}, // Should panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expected == nil {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for test case: %s\", tt.name)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tif !equalSlice(result, tt.expected) {\n\t\t\tt.Errorf(\"test case %s: expected %v, got %v\", tt.name, tt.expected, result)\n\t\t}\n\t}\n}\n\nfunc equalSlice(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","aaf32cd17c4604ddafa4458bb47ea3c4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        1,\n\t\t\tu:        2,\n\t\t\texpected: []float64{1, 1.3333333333333333, 1.6666666666666667, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 0, 1},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        10,\n\t\t\tu:        10,\n\t\t\texpected: []float64{10, 10},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(test.expected[i]) {\n\t\t\t\tcontinue // Consider NaN values equal\n\t\t\t}\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length \u003c 2\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"expected panic for dst length less than 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","ab7dc606c0b084ab5d94a2ed91fc6c4b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, t []float64\n\t\twant      []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst: []float64{0, 0, 0},\n\t\t\ts:   []float64{4, 8, 12},\n\t\t\tt:   []float64{2, 4, 6},\n\t\t\twant: []float64{2, 2, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst: []float64{0, 0, 0},\n\t\t\ts:   []float64{4, 8},\n\t\t\tt:   []float64{2, 4, 6},\n\t\t\twant: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst: []float64{0, 0, 0},\n\t\t\ts:   []float64{4, 8, 12},\n\t\t\tt:   []float64{0, 4, 6},\n\t\t\twant: []float64{math.Inf(1), 2, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst: []float64{0, 0},\n\t\t\ts:   []float64{4, 8, 12},\n\t\t\tt:   []float64{2, 4, 6},\n\t\t\twant: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: dst=%v, s=%v, t=%v\", tt.dst, tt.s, tt.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := DivTo(tt.dst, tt.s, tt.t)\n\t\t\n\t\tif !equal(got, tt.want) {\n\t\t\tt.Errorf(\"DivTo(%v, %v, %v) = %v; want %v\", tt.dst, tt.s, tt.t, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue // Treat NaNs as equal\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","abb812288b8de738509d66c3ec95412e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple closest values\",\n\t\t\ts:        []float64{1.0, 2.0, 2.4, 2.6},\n\t\t\tv:        2.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf value higher\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3, // MaxIdx(s)\n\t\t},\n\t\t{\n\t\t\tname:     \"inf value lower\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0, // MinIdx(s)\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0, // Returns 0 if v is NaN\n\t\t},\n\t\t{\n\t\t\tname:     \"zero length array\",\n\t\t\ts:        []float64{},\n\t\t\tv:        2.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.wantPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"%s: expected panic but did not occur\", test.name)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\t_ = NearestIdx(test.s, test.v)\n\t\t\t}()\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"%s: expected %d, got %d\", test.name, test.expected, result)\n\t\t}\n\t}\n}","adc5acf237e9d9e0b0eaa3cab7609c7a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\t// Initialize test cases\n\ttests := []struct {\n\t\tinds    []int\n\t\ti, j    int\n\t\twant    []int\n\t}{\n\t\t{\n\t\t\tinds: []int{0, 1, 2, 3, 4},\n\t\t\ti:    1,\n\t\t\tj:    3,\n\t\t\twant: []int{0, 3, 2, 1, 4},\n\t\t},\n\t\t{\n\t\t\tinds: []int{10, 20, 30, 40, 50},\n\t\t\ti:    0,\n\t\t\tj:    4,\n\t\t\twant: []int{50, 20, 30, 40, 10},\n\t\t},\n\t\t{\n\t\t\tinds: []int{5, 4, 3, 2, 1},\n\t\t\ti:    2,\n\t\t\tj:    2,\n\t\t\twant: []int{5, 4, 3, 2, 1}, // No change when swapping the same index\n\t\t},\n\t\t{\n\t\t\tinds: []int{100, 200, 300, 400, 500},\n\t\t\ti:    0,\n\t\t\tj:    1,\n\t\t\twant: []int{200, 100, 300, 400, 500},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ta := argsort{inds: test.inds}\n\t\ta.Swap(test.i, test.j)\n\n\t\t// Check the result\n\t\tfor k, v := range test.want {\n\t\t\tif a.inds[k] != v {\n\t\t\t\tt.Errorf(\"Swap(%v, %v) = %v; want %v\", test.i, test.j, a.inds, test.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}","af54b607219a486ffb62bfa2478b3568":"// equal_lengths_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"No slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Single empty slice\",\n\t\t\tslices: [][]float64{{}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Multiple empty slices\",\n\t\t\tslices: [][]float64{{}, {}, {}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths\",\n\t\t\tslices: [][]float64{{1, 2}, {3, 4, 5}, {6}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths (1 longer)\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6, 7}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths (2 longer)\",\n\t\t\tslices: [][]float64{{1}, {2}, {3, 4}},\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","af91ec866fc2f872635e8cfdd90e66fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices of different lengths\",\n\t\t\ts1:     []float64{1.0, 2.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices with different elements\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 4.0},\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts1:     []float64{},\n\t\t\ts2:     []float64{},\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"one empty slice\",\n\t\t\ts1:     []float64{1.0},\n\t\t\ts2:     []float64{},\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Equal(tt.s1, tt.s2)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v; want %v\", tt.s1, tt.s2, result, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n}","afb6691cc094d2b363d8525e14a19ac8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestCumSum(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t// Normal case\n\t\t{dst: make([]float64, 5), s: []float64{1, 2, 3, 4, 5}, expected: []float64{1, 3, 6, 10, 15}, panic: false},\n\t\t{dst: make([]float64, 3), s: []float64{2, 3, 5}, expected: []float64{2, 5, 10}, panic: false},\n\t\t{dst: make([]float64, 0), s: []float64{}, expected: []float64{}, panic: false},\n\t\t\n\t\t// Edge cases\n\t\t{dst: []float64{0}, s: []float64{0}, expected: []float64{0}, panic: false},\n\t\t{dst: make([]float64, 1), s: []float64{math.NaN()}, expected: []float64{math.NaN()}, panic: false},\n\n\t\t// Panic cases\n\t\t{dst: []float64{1, 2}, s: []float64{1, 2, 3}, expected: nil, panic: true}, // Wrong length\n\t\t{dst: []float64{1, 2, 3}, s: []float64{1}, expected: nil, panic: true},    // Wrong length\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst: %v, s: %v, but did not panic\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tCumSum(test.dst, test.s)\n\t\tif !test.panic {\n\t\t\tfor i := range test.expected {\n\t\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"for dst: %v, s: %v, expected %v but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","afc5e1b592f391571a48959e2f9e490f":"package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"Count positives\",\n\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\ts:    []float64{-1, 2, 3, -4, 5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Count negatives\",\n\t\t\tf:    func(x float64) bool { return x \u003c 0 },\n\t\t\ts:    []float64{-1, 2, 3, -4, 5},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Count zeros\",\n\t\t\tf:    func(x float64) bool { return x == 0 },\n\t\t\ts:    []float64{-1, 0, 3, 0, 5},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Count all\",\n\t\t\tf:    func(x float64) bool { return true },\n\t\t\ts:    []float64{1, 1, 1, 1},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Count none\",\n\t\t\tf:    func(x float64) bool { return x \u003c 0 },\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Count(tt.f, tt.s)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","b023a706762e4bc46743e63893e9d4ca":"// mul_to_test.go\n\npackage floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tdst:    make([]float64, 3),\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\texpect: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 2),\n\t\t\ts:      []float64{10, 20},\n\t\t\tt:      []float64{1, 2},\n\t\t\texpect: []float64{10, 40},\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 3),\n\t\t\ts:      []float64{0, 0, 0},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\texpect: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 1),\n\t\t\ts:      []float64{1},\n\t\t\tt:      []float64{1},\n\t\t\texpect: []float64{1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"MulTo %#v, %#v\", test.s, test.t), func(t *testing.T) {\n\t\t\tresult := MulTo(test.dst, test.s, test.t)\n\t\t\tfor i, v := range result {\n\t\t\t\tif math.Abs(v-test.expect[i]) \u003e 1e-9 {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expect, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for mismatched lengths, but did not\")\n\t\t}\n\t}()\n\tMulTo(make([]float64, 3), []float64{1, 2}, []float64{3, 4, 5})\n}","b057253b10925d31efe70b9b96fdeb78":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\n// TestWithin tests the Within function.\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Test cases where the value is within the span of the slice\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // Edge case where v == s[n-1]\n\n\t\t// Test cases for numbers less than the first element\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1},\n\n\t\t// Test cases for numbers greater than or equal to the last element\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // Test case with NaN\n\n\t\t// Edge cases\n\t\t{[]float64{1.0}, 1.0, -1}, // Panics due to len(s) \u003c 2\n\t\t{[]float64{5.0, 2.0, 3.0}, 2.5, -1}, // Panics due to unsorted slice\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%v,%v\", tt.s, tt.v), func(t *testing.T) {\n\t\t\tif len(tt.s) \u003c 2 || !sort.Float64sAreSorted(tt.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for s=%v and v=%v\", tt.s, tt.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\t\n\t\t\tgot := Within(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b0f9a3504d61dd97d7d30c129c71d603":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\ts     []float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t// Test normal cases\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.5, 1},\n\t\t{[]float64{1.0, 3.0, 5.0, 7.0}, 4.0, 2},\n\t\t{[]float64{0.0, 5.0}, 5.0, -1}, // v == s[len(s)-1]\n\n\t\t// Test edge cases\n\t\t{[]float64{1.0, 2.0}, 1.0, 0},\n\t\t{[]float64{0.0, 0.0, 0.0}, 0.0, 0}, // All elements equal\n\n\t\t// Test case for values outside the range\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 5.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 0.5, -1},\n\n\t\t// Test NaN\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, math.NaN(), -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Within(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic conditions\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within did not panic on unsorted slice\")\n\t\t}\n\t}()\n\tWithin([]float64{2.0, 1.0}, 1.5) // unsorted slice\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within did not panic on length \u003c 2\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0}) // length \u003c 2\n}","b1237c007a154e7551e96e4abef395ac":"// nearestidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\tExpect int\n\t}{\n\t\t// Test with normal values\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},  // Nearest to 2.5 is 2.0 at index 1\n\t\t{[]float64{1.0, 1.5, 2.5}, 1.1, 1},  // Nearest to 1.1 is 1.0 at index 0\n\t\t{[]float64{1.0, 2.1, 3.0}, 2.0, 1},  // Nearest to 2.0 is 2.1 at index 1\n\n\t\t// Test with edge cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, 2},  // Nearest to 3.0 is 3.0 at index 2\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, 0},  // Nearest to 1.0, first occurrence at index 0\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.0, 0},  // Nearest to 0.0 is 1.0 at index 0\n\n\t\t// Test with NaN case\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), 0}, // Nearest NaN returns first index\n\n\t\t// Test with Inf values\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), 2}, // Nearest positive inf returns index of max value\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // Nearest negative inf returns index of min value\n\n\t\t// Test for zero length slice (should panic)\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.v == math.NaN() { // Special handling for NaN test case\n\t\t\tcontinue\n\t\t}\n\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.s == nil || len(test.s) != 0 {\n\t\t\t\t\t\tt.Fatalf(\"Expected not to panic for input: %v\", test)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdx(test.s, test.v)\n\t\t\tif got != test.Expect {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", test.s, test.v, got, test.Expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for zero length slice\n\tif !t.Failed() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for empty slice\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 1.0)\n\t}\n}","b171a68a65a0482c47261417a55b4971":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\thasErr bool\n\t}{\n\t\t{10, 0, 9, 4.5, 4},                  // within bounds\n\t\t{10, 0, 9, 0, 0},                    // at lower bound\n\t\t{10, 0, 9, 9, 9},                    // at upper bound\n\t\t{10, 0, 9, 4.9, 4},                  // just below midpoint\n\t\t{10, 0, 9, 5.1, 5},                  // just above midpoint\n\t\t{5, -5, 5, 0, 2},                    // negative bounds and zero in the middle\n\t\t{10, math.NaN(), 9, 4.5, 9},        // NaN lower bound\n\t\t{10, 0, math.NaN(), 4.5, 0},        // NaN upper bound\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0}, // negative to positive infinity\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 9}, // positive to negative infinity\n\t\t{3, 0, 0, 0, 0},                     // all zero (span)\n\t\t{3, 1, 1, 1, 1},                     // all identical values\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.n \u003c 2 \u0026\u0026 !tt.hasErr {\n\t\t\tt.Panic(\"You must expect a panic when n \u003c 2\")\n\t\t}\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tif !tt.hasErr {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan() panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","b19603c719cd669e4b4e7417b1673a44":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\tpanic    bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1, false},\n\t\t{[]float64{1.0, 2.0}, 1.0, 0, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, -1, false},\n\t\t\n\t\t// Test cases that should panic\n\t\t{[]float64{1.0}, 1.0, -1, true},                                 // Less than two elements\n\t\t{[]float64{3.0, 2.0, 1.0}, 2.0, -1, true},                      // Not sorted\n\t\t{[]float64{}, 1.0, -1, true},                                   // Empty slice\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, math.NaN(), -1, false}, // NaN value\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(1), -1, false},          // Out of range\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for s=%v, v=%v\", test.s, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Within(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; expected %d\", test.s, test.v, result, test.expected)\n\t\t}\n\t}\n}","b1c211d15e5b97db52c1164cf02ab259":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Test typical spans\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 8, 3},\n\t\t{5, 0, 10, 1, 0},\n\t\t{5, 0, 10, 11, 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{5, 10, 0, 1, 4},\n\t\t{5, 10, 0, -1, 0},\n\t\t{5, 10, 0, 12, 0},\n\n\t\t// Test NaN values\n\t\t{5, 0, 10, math.NaN(), 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.NaN(), math.NaN(), 5, 0},\n\n\t\t// Test infinite limits\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 0},\n\n\t\t// Test span length edge case (less than 2 should panic)\n\t\t// These should be run in a separate subtest to catch panic\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.n \u003c 2 {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t}\n\t}\n}","b213bf54d996e0039fda47719746bfab":"// sum_compensated_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{1.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"two elements\",\n\t\t\tinput:    []float64{1.5, 2.5},\n\t\t\texpected: 4.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"large numbers\",\n\t\t\tinput:    []float64{1e100, 1e100, 1e100},\n\t\t\texpected: 3e100,\n\t\t},\n\t\t{\n\t\t\tname:     \"small differences\",\n\t\t\tinput:    []float64{1.0, 1e-10, -1.0, -1e-10},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{math.NaN(), 1.0, 2.0},\n\t\t\texpected: 3.0, // Only consider non-NaN values\n\t\t},\n\t\t{\n\t\t\tname:     \"infinity\",\n\t\t\tinput:    []float64{math.Inf(1), 1.0, 2.0},\n\t\t\texpected: math.Inf(1), // Sum with positive infinity\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\tinput:    []float64{math.Inf(-1), -1.0, -2.0},\n\t\t\texpected: math.Inf(-1), // Sum with negative infinity\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif !equal(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to check equality within a tolerance\nfunc equal(a, b float64) bool {\n\tconst tol = 1e-9\n\treturn math.Abs(a-b) \u003c tol\n}","b24730c325c23f8e9cf5a440666a54cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic for length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        4,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic.\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !tt.expectPanic \u0026\u0026 !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b247c18384f0d8daf42cbf9e1815e8cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0e10, 1.0, 1.0e-10},\n\t\t\texpected: 1.0e10 + 1.0 + 1.0e-10,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0e-10, 1.0e-10, 1.0e-10},\n\t\t\texpected: 3.0e-10,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.NaN()},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 1.0},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(-1), -1.0},\n\t\t\texpected: math.Inf(-1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif (math.IsNaN(result) \u0026\u0026 !math.IsNaN(test.expected)) || (!math.IsNaN(result) \u0026\u0026 result != test.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","b274b8c757536346f03da55ed0a60c98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},           // Middle value in the span\n\t\t{5, 0, 10, 0, 0},           // Lower bound\n\t\t{5, 0, 10, 10, 4},          // Upper bound\n\t\t{5, 10, 0, 5, 2},           // Reversed bounds\n\t\t{5, 10, 0, 0, 0},           // Outside span\n\t\t{5, 10, 0, 15, 4},          // Outside span upper\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds\n\t\t{2, 0, 10, 5, 1},           // Edge case with 2 elements\n\t\t{3, 0, 10, math.NaN(), 0}, // NaN value\n\t\t{3, math.NaN(), 10, 5, 2}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(-1), -1, 0}, // Inf lower\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for invalid n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","b2b41c0984a6fc130569c29ce9ac8aed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantPan bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       10,\n\t\t\tu:       20,\n\t\t\twant:    []float64{10, 15, 20},\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       5,\n\t\t\tu:       5,\n\t\t\twant:    []float64{5, 5, 5, 5, 5},\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    nil,\n\t\t\twantPan: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twant:    nil,\n\t\t\twantPan: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 4),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 6),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\twantPan: false, // Specific values for Infs can be checked if needed\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 6),\n\t\t\tl:       10,\n\t\t\tu:       math.Inf(1),\n\t\t\twantPan: false, // Specific values for Infs can be checked if needed\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 6),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       10,\n\t\t\twantPan: false, // Specific values for Infs can be checked if needed\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPan {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !tt.wantPan \u0026\u0026 !equal(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b39b4e92d68ff04931e1f9c49dce0d52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        1,\n\t\t\texpected: 0.0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{4.0, 5.0, 6.0},\n\t\t\tL:        1,\n\t\t\texpected: 9.0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{4.0, 5.0},  // Different lengths\n\t\t\tL:        1,\n\t\t\texpected: 0.0,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0.0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0.0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\tL:        2,\n\t\t\texpected: 0.0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        2,\n\t\t\texpected: 0.0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.1, 2.2, 3.3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(0.3),\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v, %v with L=%v, but did not panic\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","b40f3129f28d9f1eeaeb9805d894b2d5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tpanicExpected bool\n\t}{\n\t\t{\n\t\t\ts: []float64{1, 2, 3},\n\t\t\tt: []float64{4, 5, 6},\n\t\t\tL: 1,\n\t\t\texpected: 9,\n\t\t\tpanicExpected: false,\n\t\t},\n\t\t{\n\t\t\ts: []float64{1, 2, 3},\n\t\t\tt: []float64{4, 5, 6},\n\t\t\tL: 2,\n\t\t\texpected: math.Sqrt(27), // √((4-1)² + (5-2)² + (6-3)²) = √27\n\t\t\tpanicExpected: false,\n\t\t},\n\t\t{\n\t\t\ts: []float64{1, 2, 3},\n\t\t\tt: []float64{4, 5, 6},\n\t\t\tL: math.Inf(1),\n\t\t\texpected: 3, // max(abs(4-1), abs(5-2), abs(6-3)) = 3\n\t\t\tpanicExpected: false,\n\t\t},\n\t\t{\n\t\t\ts: []float64{1, 2},\n\t\t\tt: []float64{3},\n\t\t\tL: 1,\n\t\t\texpected: 0,\n\t\t\tpanicExpected: true,\n\t\t},\n\t\t{\n\t\t\ts: []float64{},\n\t\t\tt: []float64{},\n\t\t\tL: 2,\n\t\t\texpected: 0,\n\t\t\tpanicExpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panicExpected {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input s: %v, t: %v, L: %v\", tt.s, tt.t, tt.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\tif !tt.panicExpected \u0026\u0026 result != tt.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t}\n\t}\n}","b453eeefaf291a83ffcb9e4516aac460":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},               // middle value\n\t\t{5, 0, 10, 9, 4},               // close to upper bound\n\t\t{5, 0, 10, 1, 1},               // close to lower bound\n\t\t{5, 0, 10, -1, 0},              // below lower bound\n\t\t{5, 0, 10, 11, 4},              // above upper bound\n\t\t{3, -5, 5, 0, 1},               // middle value with negative bounds\n\t\t{3, -5, 5, -6, 0},              // below lower with negative bounds\n\t\t{3, -5, 5, 6, 2},               // above upper with negative bounds\n\t\t{4, 9, 10, 9.5, 1},             // even count of points\n\t\t{2, -1, 1, 0, 0},               // minimum valid points\n\t\t{2, -1, 1, -1, 0},              // equal to lower bound\n\t\t{2, -1, 1, 1, 1},               // equal to upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // Inf case\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0},  // Inf case\n\t\t{3, -1, math.Inf(1), 0, 0},    // Inf case with -1 as low\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Fatalf(\"Expected panic for n = %d, but did not panic\", test.n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t} else {\n\t\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t\tif got != test.expect {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","b4b092207079221ea52e0eecea53fb6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts          []float64\n\t\tt          []float64\n\t\tL          float64\n\t\twant       float64\n\t\texpectPanic bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9, false},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27), false},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3, false},\n\t\t{[]float64{1}, []float64{1}, 1, 0, false},\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, 1, 0, true}, // Different lengths\n\t\t{[]float64{}, []float64{}, 1, 0, false},        // Both slices empty\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for s: %v, t: %v, L: %v\", tt.s, tt.t, tt.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Distance(tt.s, tt.t, tt.L)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", tt.s, tt.t, tt.L, got, tt.want)\n\t\t}\n\t}\n}","b517facd54cabc2f4032e18bd4d107cd":"// File: mul_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{3.0, 4.0, 5.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{2.0},\n\t\t\texpected: []float64{2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10.0, 20.0},\n\t\t\ts:        []float64{1.0, 0.5},\n\t\t\texpected: []float64{10.0, 10.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v and s: %v\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i := range test.expected {\n\t\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"For dst: %v and s: %v, expected %v, but got %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","b62580acc0fe992fad3b01981ef69e94":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\ts          []float64\n\t\tt          []float64\n\t\texpected   []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:       \"Basic addition\",\n\t\t\tdst:        []float64{0, 0, 0},\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{4, 5, 6},\n\t\t\texpected:   []float64{5, 7, 9},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Different lengths - dst\",\n\t\t\tdst:        []float64{0, 0},\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{4, 5, 6},\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Different lengths - s and t\",\n\t\t\tdst:        []float64{0, 0, 0},\n\t\t\ts:          []float64{1, 2},\n\t\t\tt:          []float64{3, 4, 5},\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Zero slices\",\n\t\t\tdst:        []float64{},\n\t\t\ts:          []float64{},\n\t\t\tt:          []float64{},\n\t\t\texpected:   []float64{},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Negative numbers\",\n\t\t\tdst:        []float64{0, 0, 0},\n\t\t\ts:          []float64{-1, -2, -3},\n\t\t\tt:          []float64{-4, -5, -6},\n\t\t\texpected:   []float64{-5, -7, -9},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.expectPanic {\n\t\t\t\t\tt.Errorf(\"AddTo() panic = %v, expectPanic %v\", r, tt.expectPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddTo(tt.dst, tt.s, tt.t)\n\t\t\tif !tt.expectPanic \u0026\u0026 !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b62c0496f8758e4bda8819180b790391":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27), // √((4-1)² + (5-2)² + (6-3)²) = √(27)\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 7},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 3, // max(|4-1|, |5-2|, |7-3|) = max(3, 3, 4)\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       1,\n\t\t\tpanic:   true, // lengths do not match\n\t\t},\n\t\t{\n\t\t\ts:       []float64{},\n\t\t\tt:       []float64{},\n\t\t\tL:       2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %v, but did not panic\", test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","b7f2edbdc613f82d19b5b99c215ff5f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         4,\n\t\t\texpected:  []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         1,\n\t\t\tu:         5,\n\t\t\texpected:  []float64{1, 3, 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 0),\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\texpected:  nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         math.NaN(),\n\t\t\tu:         1,\n\t\t\texpected:  []float64{math.NaN(), 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\texpected:  []float64{0, math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(-1),\n\t\t\texpected:  []float64{math.Inf(1), math.Inf(-1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(1),\n\t\t\texpected:  []float64{math.Inf(1), 0, math.Inf(1)},\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, l: %v, u: %v\", test.dst, test.l, test.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !test.expectPanic \u0026\u0026 !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b89f9f1089868798b9e02bcd5e68794b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdesc     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdesc:     \"basic span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"span with negative bounds\",\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        -3,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{-3, -2, -1, -1},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"span with zero range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"infinity bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(result[i]) {\n\t\t\t\t\tif !math.IsNaN(tt.expected[i]) {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\t}\n\t\t\t\t} else if result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panics on short slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on short slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}","b8a05ba3a712e311a1d2e9009147f26b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Test cases where the value v is within the range defined by slice s.\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 2.5, 2},\n\t\t{[]float64{1.0, 1.5, 2.0, 2.5, 3.0}, 1.5, 1},\n\t\t{[]float64{0.0, 1.0, 2.0, 3.0}, 0.5, 1},\n\n\t\t// Test cases where v is equal to s[i]\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 1.0, 1},\n\t\t{[]float64{1.0, 1.5, 2.0, 2.5, 3.0}, 2.0, 2},\n\n\t\t// Test cases where v is outside the range defined by slice s\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 5.0, -1},           // v \u003e max\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 0.0, -1},           // v \u003c min\n\t\t{[]float64{10.0, 20.0}, 5.0, -1},                    // single case with v \u003c min\n\t\t{[]float64{10.0, 20.0}, 25.0, -1},                   // single case with v \u003e max\n\n\t\t// Test cases with NaN\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Within(tt.s, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.want)\n\t\t}\n\t}\n\n\t// Panic tests\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for short span\")\n\t\t}\n\t}()\n\t_ = Within([]float64{1.0}, 0.0) // should panic\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice\")\n\t\t}\n\t}()\n\t_ = Within([]float64{3.0, 1.0, 2.0}, 2.0) // should panic\n}","b90b25d30caac34e602553815fe2c041":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1e-10, 1e-10}, 1e10}, // Test with large and small values\n\t\t{[]float64{1.0, 2.0, -3.0}, 0.0},      // Test with a negative value\n\t\t{[]float64{math.MaxFloat64, -math.MaxFloat64}, 0.0}, // Test with max float values\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, math.NaN()}, // Test with NaN\n\t\t{[]float64{}, 0.0}, // Test with an empty slice\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"For input %v, expected NaN but got %v\", test.input, result)\n\t\t\t}\n\t\t} else if result != test.expected {\n\t\t\tt.Errorf(\"For input %v, expected %v but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","ba6c5492461668b1361d8b51e520bf52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         10,\n\t\t\tu:         20,\n\t\t\texpected:  []float64{10, 15, 20},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{1, 1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 6),\n\t\t\tl:         -1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{-1, -0.5, 0, 0.5, 1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range test.expected {\n\t\t\tif math.Abs(result[i]-test.expected[i]) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for slices with length less than 2\n\tdefer func() { recover() }() // We want to catch the panic\n\tif got := Span(make([]float64, 1), 0, 1); got != nil {\n\t\tt.Errorf(\"Span(\u003c1 element\u003e) = %v; expected panic\", got)\n\t}\n}","bd09c4b3139e4799017cb559fa235589":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t// Normal case\n\t\t{dst: make([]float64, 5), l: 0, u: 10, expected: []float64{0, 2.5, 5, 7.5, 10}, expectPanic: false},\n\t\t{dst: make([]float64, 3), l: 1, u: 5, expected: []float64{1, 3, 5}, expectPanic: false},\n\t\t\n\t\t// Case where dst contains less than 2 elements (should panic)\n\t\t{dst: make([]float64, 1), l: 0, u: 1, expectPanic: true},\n\t\t{dst: nil, l: 0, u: 1, expectPanic: true}, // nil slice should also panic\n\n\t\t// Special cases for Inf and NaN\n\t\t{dst: make([]float64, 5), l: math.Inf(-1), u: math.Inf(1), expected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}, expectPanic: false},\n\t\t{dst: make([]float64, 5), l: math.NaN(), u: 10, expected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}, expectPanic: false},\n\t\t{dst: make([]float64, 5), l: 0, u: math.NaN(), expected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}, expectPanic: false},\n\n\t\t// Case where l and u are both NaN (should return all NaN elements)\n\t\t{dst: make([]float64, 5), l: math.NaN(), u: math.NaN(), expected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}, expectPanic: false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() { recover() }() // recover from panic to test the panic behavior\n\t\t\t\tSpan(test.dst, test.l, test.u)\n\t\t\t\tt.Errorf(\"expected panic for input l=%v, u=%v, but did not panic\", test.l, test.u)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !equalSlices(result, test.expected) {\n\t\t\t\tt.Errorf(\"unexpected result for input l=%v, u=%v: got %v, want %v\", test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function to check equality of float64 slices\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] { // Consider using math.Abs(a[i]-b[i]) \u003c tolerance for float comparison in practice.\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","bd0baf941d695935d5dc6dc476aff106":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tpanic bool\n\t}{\n\t\t{5, 0, 10, 5, 2, false},\n\t\t{5, 0, 10, 0, 0, false},\n\t\t{5, 0, 10, 10, 4, false},\n\t\t{5, 10, 0, 5, 2, false},\n\t\t{5, 10, 0, 10, 0, false},\n\t\t{5, 10, 0, 0, 4, false},\n\t\t{5, math.NaN(), 10, 5, 4, false}, // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0, false}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0, false}, // -Inf to Inf\n\t\t{5, 0, math.Inf(1), 5, 0, false}, // finite v in Inf range\n\t\t{5, math.Inf(-1), 0, -5, 0, false}, // finite v in -Inf range\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4, false}, // v is +Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0, false}, // v is -Inf\n\t\t{1, 0, 10, 5, 0, true},              // panic case: n \u003c 2\n\t\t{0, 0, 10, 5, 0, true},              // panic case: n \u003c 2\n\t\t{2, 0, 10, math.NaN(), 0, false},   // v is NaN\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n = %d, l = %f, u = %f, v = %f\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","bdbac0eb9fce9bd1874ee7d0e7ca5d5a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\talpha    float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\talpha:    2,\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\texpected: []float64{9, 12, 15},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\talpha:    1,\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\texpected: []float64{4, 5, 6},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, -1, 0},\n\t\t\talpha:    -1,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{0, 1, -3},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := make([]float64, len(test.dst))\n\t\tcopy(result, test.dst) // copy dst to result\n\t\tAddScaled(result, test.alpha, test.s)\n\t\tfor i := range result {\n\t\t\tif math.Abs(result[i]-test.expected[i]) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"AddScaled(%v, %v, %v) = %v; want %v\", test.dst, test.alpha, test.s, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for length mismatch did not occur\")\n\t\t}\n\t}()\n\tAddScaled([]float64{1, 2}, 1.0, []float64{1, 2, 3}) // lengths do not match\n}","bf076eed918d7c3223f67e7e25518cf2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts, t []float64\n\t\twant bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true},\n\t\t{[]float64{math.NaN(), 2, 3}, []float64{math.NaN(), 2, 3}, true},\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{[]float64{1, math.NaN()}, []float64{1, 2}, false},\n\t\t{[]float64{math.NaN()}, []float64{math.NaN()}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.s, tt.t)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfda35f3c18a5baeca503393dbab6526":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic Span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        5,\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with negative\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -5,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{-5, -4, -3, -2, -1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with zero\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        0,\n\t\t\texpected: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Very small span\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        1.0001,\n\t\t\texpected: []float64{1, 1.00005, 1.0001},\n\t\t},\n\t\t{\n\t\t\tname:     \"Single step span\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        2,\n\t\t\tu:        3,\n\t\t\texpected: []float64{2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on small dst (length 1)\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil, // Expect panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in start\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in end\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in start\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        5,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in end\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1, 1, 1, 1, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"Panic on small dst (length 1)\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for %s, but did not\", tt.name)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i, v := range result {\n\t\t\t\tif math.IsNaN(tt.expected[i]) \u0026\u0026 math.IsNaN(v) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif v != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","c0ec03dca8cd07a84c9284fb4860376c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{5, -10, 0, -5, 2},\n\t\t{5, -10, -5, -7, 1},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 0},\n\t\t{2, 0, 1, 0.5, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d l=%f u=%f v=%f\", tt.n, tt.l, tt.u, tt.v), func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on too small n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 but did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// Test with NaN as input\n\tif result := NearestIdxForSpan(5, 0, 10, math.NaN()); result != 0 {\n\t\tt.Errorf(\"expected 0 for NaN, got %d\", result)\n\t}\n}","c0edc28b0bb8ad039cd83dc2899be0c1":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\ts       []float64\n\t\tt       []float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\twant: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{0, 0},\n\t\t\ts:    []float64{1, 2},\n\t\t\tt:    []float64{3, 4},\n\t\t\twant: []float64{3, 8},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1},\n\t\t\tt:       []float64{3},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif !tt.wantErr {\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tfor i, v := range got {\n\t\t\t\tif v != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"MulTo() did not panic for input: dst=%v, s=%v, t=%v\", tt.dst, tt.s, tt.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tMulTo(tt.dst, tt.s, tt.t)\n\t\t}\n\t}\n}","c219c9759b2b913ab17a36a30c8a5282":"// equal_lengths_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test case 1: No slices provided\n\tresult := EqualLengths()\n\tif result != true {\n\t\tt.Errorf(\"Expected true, got %v\", result)\n\t}\n\n\t// Test case 2: One empty slice\n\tresult = EqualLengths([]float64{})\n\tif result != true {\n\t\tt.Errorf(\"Expected true, got %v\", result)\n\t}\n\n\t// Test case 3: Multiple empty slices\n\tresult = EqualLengths([]float64{}, []float64{}, []float64{})\n\tif result != true {\n\t\tt.Errorf(\"Expected true, got %v\", result)\n\t}\n\n\t// Test case 4: Different lengths of slices\n\tresult = EqualLengths([]float64{1.0, 2.0}, []float64{1.0}, []float64{1.0, 2.0, 3.0})\n\tif result != false {\n\t\tt.Errorf(\"Expected false, got %v\", result)\n\t}\n\n\t// Test case 5: All slices have the same length\n\tresult = EqualLengths([]float64{1.0, 2.0}, []float64{3.0, 4.0}, []float64{5.0, 6.0})\n\tif result != true {\n\t\tt.Errorf(\"Expected true, got %v\", result)\n\t}\n\n\t// Test case 6: One slice is longer than the others\n\tresult = EqualLengths([]float64{1.0, 2.0}, []float64{3.0, 4.0}, []float64{5.0})\n\tif result != false {\n\t\tt.Errorf(\"Expected false, got %v\", result)\n\t}\n}","c245931e3d9384bd8814b85c1d7c28c5":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0}, // nearest to 1.0\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1}, // nearest to 2.0\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2}, // nearest to 3.0\n\t\t{[]float64{1.0, 2.0, 3.0}, 0.5, 0}, // nearest to 1.0\n\t\t{[]float64{-1.0, -2.0, -10.0}, -3.0, 1}, // nearest to -2.0\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 2.5, 1}, // ignore NaN\n\t\t{[]float64{math.Inf(1), 2.0, 3.0}, math.Inf(1), 2}, // nearest to 3.0 (max)\n\t\t{[]float64{1.0, 2.0, 3.0}, math.Inf(-1), 0}, // nearest to 1.0 (min)\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expect {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on zero length slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic, but did not get one\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 1.0)\n\t})\n}","c319c9163393d0f1a232cc36990f80f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic Span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative Range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -10,\n\t\t\tu:        0,\n\t\t\texpected: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero Range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        0,\n\t\t\texpected: []float64{0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Large Range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        100,\n\t\t\tu:        200,\n\t\t\texpected: []float64{100, 150, 200},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf Range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN Lower Bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN Upper Bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range result {\n\t\t\t\tif !floatEqual(result[i], tt.expected[i]) {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on Short Slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic, but did not get one\")\n\t\t\t}\n\t\t}()\n\t\t_ = Span(make([]float64, 1), 0, 1)\n\t})\n}\n\n// floatEqual checks for equality considering NaN values as equal\nfunc floatEqual(a, b float64) bool {\n\treturn a == b || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}","c36fad062905512cad6644b00bea6fb9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 0, 10, 0, 0},\n\t\t{5, 0, 10, 10, 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{5, 10, 0, 10, 0},\n\t\t{5, 10, 0, 0, 4},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 1, 2},\n\t\t{5, math.Inf(-1), math.Inf(1), 2, 3},\n\t\t{5, math.Inf(1), math.Inf(-1), 0, 4},\n\t\t{2, 0, 10, 5, 0}, // Edge case: n == 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.n \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n=%d, l=%f, u=%f, v=%f\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif result != tt.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, result, tt.expect)\n\t\t}\n\t}\n}","c424d8a35f7c8b05e45733b34ada50f6":"// nearest_idx_for_span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 1.0, 5.0, 3.0, 2}, // Normal case\n\t\t{5, 1.0, 5.0, 1.0, 0}, // Exact lower bound\n\t\t{5, 1.0, 5.0, 5.0, 4}, // Exact upper bound\n\t\t{5, 1.0, 5.0, 0.0, 0}, // Out of bounds (low)\n\t\t{5, 1.0, 5.0, 6.0, 4}, // Out of bounds (high)\n\t\t{5, 5.0, 1.0, 3.0, 2}, // Reversed bounds\n\t\t{5, 5.0, 1.0, 5.0, 0}, // Exact upper bound for reversed\n\t\t{5, 5.0, 1.0, 1.0, 4}, // Exact lower bound for reversed\n\t\t{5, math.NaN(), 5.0, 3.0, 4}, // NaN lower bound\n\t\t{5, 1.0, math.NaN(), 3.0, 0}, // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0.0, 0}, // Infinity bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 10.0, 4}, // Infinity bounds\n\t\t{5, 1.0, 2.0, 1.5, 2}, // Midpoint case\n\t\t{3, 0, 10, 5, 1}, // Simple case with minimum n\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For NearestIdxForSpan(%d, %v, %v, %v), expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n\n\t// Test for panic on invalid input\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // Should panic\n}","c4347345bb3b757aabbc440dd959adf5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 3},           // Test case with distinct values\n\t\t{[]float64{4.0, 3.0, 2.0, 1.0}, 0},           // Test case with values in descending order\n\t\t{[]float64{1.0, 3.0, 5.0, 5.0, 4.0}, 2},     // Test case with repeated max value\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 2},         // Test case with NaN at the beginning\n\t\t{[]float64{1.0, math.NaN(), 2.0}, 2},         // Test case with NaN in the middle\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 1},          // Test case with NaN at the end\n\t\t{[]float64{math.NaN(), math.NaN(), 2.0}, 2}, // Test case with NaN values only\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\t// Ensure the function does not panic\n\t\t\tdefer func() { recover() }()\n\t\t\tresult := MaxIdx(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panicking on zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice, but did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}","c44e095c6325fd9ca41dd7c3957a9234":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"No Input Slices\", [][]float64{}, true},\n\t\t{\"One Empty Slice\", [][]float64{{}}, true},\n\t\t{\"Multiple Empty Slices\", [][]float64{{}, {}, {}}, true},\n\t\t{\"Different Lengths\", [][]float64{{1.0, 2.0}, {1.0}}, false},\n\t\t{\"All Lengths Equal\", [][]float64{{1.0}, {2.0}, {3.0}}, true},\n\t\t{\"Mixed Lengths\", [][]float64{{1.0, 2.0}, {3.0, 4.0}}, true},\n\t\t{\"Two Equal, One Different\", [][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0}}, false},\n\t\t{\"All Large Equal Lengths\", [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v; want %v\", tt.slices, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c50cc8843b4580e570dbf84f66a3386f":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\n// TestFind tests the Find function.\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"No match, k negative\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Two matches, k positive\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x%2 == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Insufficient matches, k positive\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Exact matches, k matches found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero elements requested\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Multiple matches, k greater than available\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 5 },\n\t\t\ts:        []float64{1, 2, 3, 6, 7},\n\t\t\tk:        10,\n\t\t\texpected: []int{0, 1, 2},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Fatalf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif !equalSlices(inds, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, inds)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalSlices compares two integer slices for equality.\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c5390b0747a0390f595f5a93fd3be797":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst       []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:       make([]float64, 5),\n\t\t\tl:         1,\n\t\t\tu:         5,\n\t\t\texpected:  []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 3),\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 4),\n\t\t\tl:         -1,\n\t\t\tu:         1,\n\t\t\texpected:  []float64{-1, -0.33333333, 0.33333333, 1},\n\t\t},\n\t\t{\n\t\t\tdst:       make([]float64, 2),\n\t\t\tl:         10,\n\t\t\tu:         20,\n\t\t\texpected:  []float64{10, 20},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif !floatEqual(result[i], test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panic when length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 1)\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","c63de35547795507c7e26f34c81f2123":"package floats\n\nimport \"testing\"\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\ts       []float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:  []float64{5, 6, 7},\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: []float64{4, 4, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  []float64{-10, 10, 0},\n\t\t\ts:    []float64{-5, -5, -5},\n\t\t\twant: []float64{-5, 15, 5},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1, 2},\n\t\t\ts:       []float64{3, 4, 5}, // length mismatch\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1}, \n\t\t\ts:       []float64{1}, \n\t\t\twant:    []float64{0}, \n\t\t},\n\t\t{\n\t\t\tdst:     []float64{}, \n\t\t\ts:       []float64{}, \n\t\t\twant:    []float64{}, \n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif tt.wantErr {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tSub(tt.dst, tt.s)\n\t\t\tif !tt.wantErr \u0026\u0026 !equalSlices(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c66f332326724bc488067fc1ae2dee45":"// logspan_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{1, 3.1622776601683795, 10, 31.622776601683793, 100},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 0, 0, 0, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"length of dst less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic, but did not happen\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tLogSpan(tt.dst, tt.l, tt.u)\n\t\t\t} else {\n\t\t\t\tresult := LogSpan(tt.dst, tt.l, tt.u)\n\t\t\t\tfor i, v := range result {\n\t\t\t\t\tif !almostEqual(v, tt.expected[i]) {\n\t\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected[i], v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}","c67238fc1cdc7f32abd6e8a9759afd8f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -1,\n\t\t\tu:      1,\n\t\t\twant:   []float64{-1, 0, 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      1,\n\t\t\tu:      1,\n\t\t\twant:   []float64{1, 1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 1), // should panic\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !tt.wantPanic \u0026\u0026 !equal(got, tt.want) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !almostEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc almostEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9 // Use a tolerance for floating point comparison\n}","c68f0eeab1152e158103052b21dc3f6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, expected []float64\n\t\texpectPanic      bool\n\t}{\n\t\t{\n\t\t\tdst:          []float64{1, 2, 3},\n\t\t\ts:            []float64{4, 5, 6},\n\t\t\texpected:     []float64{4, 10, 18},\n\t\t\texpectPanic:  false,\n\t\t},\n\t\t{\n\t\t\tdst:          []float64{0, 0, 0},\n\t\t\ts:            []float64{1, 2, 3},\n\t\t\texpected:     []float64{0, 0, 0},\n\t\t\texpectPanic:  false,\n\t\t},\n\t\t{\n\t\t\tdst:          []float64{1, 2},\n\t\t\ts:            []float64{1, 2, 3},\n\t\t\texpected:     nil, // We expect panic, so no need to fill this\n\t\t\texpectPanic:  true,\n\t\t},\n\t\t{\n\t\t\tdst:          []float64{},\n\t\t\ts:            []float64{},\n\t\t\texpected:     []float64{},\n\t\t\texpectPanic:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic but did not panic for dst: %v, s: %v\", test.dst, test.s)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tMul(test.dst, test.s)\n\t\t\t}()\n\t\t} else {\n\t\t\tMul(test.dst, test.s)\n\t\t\tfor i := range test.expected {\n\t\t\t\tif math.Abs(test.dst[i]-test.expected[i]) \u003e 1e-10 {\n\t\t\t\t\tt.Errorf(\"For dst: %v, s: %v; expected: %v, got: %v\", test.dst, test.s, test.expected, test.dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","c6e905e1ad53e35ccd01273d9f1d7878":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpIdx int\n\t}{\n\t\t{5, 0, 10, 5, 2},               // Middle value\n\t\t{5, 0, 10, 0, 0},               // Lower bound\n\t\t{5, 0, 10, 10, 4},              // Upper bound\n\t\t{5, 0, 10, -5, 0},              // Below lower bound\n\t\t{5, 0, 10, 15, 4},              // Above upper bound\n\t\t{5, math.NaN(), 10, 5, 4},      // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},       // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Lower and upper bounds at Inf\n\t\t{5, -10, 0, -5, 2},              // Negative bounds\n\t\t{4, 1, 5, 3, 1},               // Valid case pans for length 4\n\t\t// Edge cases for panics\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.n \u003c 2 \u0026\u0026 test.expIdx != 0 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input n=%d, l=%v, u=%v, v=%v\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif idx != test.expIdx {\n\t\t\tt.Errorf(\"For n=%d, l=%v, u=%v, v=%v: expected %d, got %d\", test.n, test.l, test.u, test.v, test.expIdx, idx)\n\t\t}\n\t}\n}","c70bd4226e4382659ab756194d226ddb":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Test valid cases\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1}, // v == s[len(s)-1], should return -1\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1}, // v \u003e s[len(s)-1], should return -1\n\n\t\t// Test edge cases\n\t\t{[]float64{1.0, 3.0, 2.0}, 2.0, -1}, // unsorted slice, should panic\n\t\t{[]float64{1.0}, 1.0, -1}, // len(s) \u003c 2, should panic\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1}, // v is NaN, should return -1\n\t\t{[]float64{math.NaN(), 2.0, 3.0}, 1.0, -1}, // s contains NaN, should not panic, return -1\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif tc.expect == -1 {\n\t\t\t\t// We expect a return of -1, directly test without panic\n\t\t\t\tif result := Within(tc.s, tc.v); result != -1 {\n\t\t\t\t\tt.Errorf(\"expected -1, got %d\", result)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult := Within(tc.s, tc.v)\n\t\t\t\tif result != tc.expect {\n\t\t\t\t\tt.Errorf(\"expected %d, got %d\", tc.expect, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic cases\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for len(s) \u003c 2\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unsorted slice\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","c84004bbf3a69183c622f48e660f5b13":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:   \"L1 distance\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"L2 distance\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:   \"L-infinity distance\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"L2 distance with zeros\",\n\t\t\ts:      []float64{0, 0, 0},\n\t\t\tt:      []float64{0, 0, 0},\n\t\t\tL:      2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif !almostEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, expected %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic on different lengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Distance did not panic on different lengths\")\n\t\t\t}\n\t\t}()\n\t\tDistance([]float64{1, 2}, []float64{1}, 1)\n\t})\n}\n\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","c9072aa3fc2774f4553a579a976d9871":"// file: span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Normal case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Same l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -4,\n\t\t\tu:        0,\n\t\t\texpected: []float64{-4, -3, -2, -1, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinite l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil, // This will cause a panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic for dst length less than 2\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif tt.expected != nil \u0026\u0026 !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c9a488ed3661683813cdc9acf0983fe4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        4,\n\t\t\texpected: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        1,\n\t\t\tu:        3,\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 4),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        -3,\n\t\t\tu:        3,\n\t\t\texpected: []float64{-3, -2.5, -2, -1.5, -1, -0.5, 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range result {\n\t\t\tif v != test.expected[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test for panics with dst length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for dst length less than 2, got none\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","ca0939efcf7f3a8da4f08dbb68580e05":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\ts     []float64\n\t\tt     []float64\n\t\twant  bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},           // same elements\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},          // different elements\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true}, // both contain NaN\n\t\t{[]float64{1, math.NaN(), 3}, []float64{1, 3, math.NaN()}, false}, // different order with NaN\n\t\t{[]float64{}, []float64{}, true},                           // both slices empty\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, false},               // different lengths\n\t\t{[]float64{math.NaN()}, []float64{math.NaN()}, true}, // single NaN\n\t\t{[]float64{math.NaN(), math.NaN()}, []float64{math.NaN(), math.NaN()}, true}, // two NaNs\n\t\t{[]float64{1, 2, 3}, []float64{math.NaN(), math.NaN(), math.NaN()}, false}, // mixed with NaN\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Same(tt.s, tt.t)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v; want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ca5c8d4320f117c218de35798e287ba6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, expectedIdx int\n\t\tl, u, v       float64\n\t}{\n\t\t{10, 0, 0, 9, 0},           // Closest to the lower bound\n\t\t{10, 9, 0, 9, 9},           // Closest to the upper bound\n\t\t{10, 5, 0, 10, 5},          // Exactly in the middle\n\t\t{10, 5, 0, 10, 5.0000001},  // Near the middle\n\t\t{10, 0, -10, 10, -10},      // Outside the range (lower)\n\t\t{10, 9, -10, 10, 20},       // Outside the range (upper)\n\t\t{5, 2, 0, 10, 5},           // Simple range with fewer elements\n\t\t{3, 0, 5, 5, 5},            // Edge case: v equals the midpoint\n\t\t{4, 1, 5, 15, 10},          // Midpoint in an even number of points\n\t\t{6, 3, 1, 5, 3},            // Tests with more points\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.n \u003c 2 {\n\t\t\t\t\t\t// Expected panic for n \u003c 2\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expectedIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expectedIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(1, 0, 1, 1) but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 1)\n}","cad7b02fd7a43024f9e31aaa000ba4d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},            // Middle of the span\n\t\t{5, 0, 10, 0, 0},            // Lower bound, should be first index\n\t\t{5, 0, 10, 10, 4},           // Upper bound, should be last index\n\t\t{5, -10, 0, -5, 2},          // Middle of negative span\n\t\t{3, -10, -5, -7.5, 1},       // Middle of a small negative span\n\t\t{4, 5, 15, 10, 1},           // Middle of a positive span\n\t\t{5, 1, 4, 100, 4},           // Value out of upper bounds\n\t\t{5, -100, -95, -110, 0},     // Value out of lower bounds\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // Middle of infinite span\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2}, // Value equal to upper infinity\n\t\t{4, math.NaN(), 10, 5, 3}, // NaN lower bound\n\t\t{4, 0, math.NaN(), 5, 0},  // NaN upper bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for n=%d\", test.n)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}","cb2f4ecce6f8ce30d05a1cb5dedc4149":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 4.0, -1},\n\t\t{[]float64{1.0, 1.0, 1.0}, 1.0, -1},\n\t\t{[]float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Within(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic due to len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within() did not panic on short span\")\n\t\t}\n\t}()\n\tWithin([]float64{1.0})\n\n\t// Test for panic due to unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Within() did not panic on unsorted slice\")\n\t\t}\n\t}()\n\tWithin([]float64{3.0, 1.0, 2.0})\n}","cb50929c3d31ad17a3f460bf88000ad7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\texpected: 10.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e10, 1e-10, 1.0},\n\t\t\texpected: 1e10 + 1.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1e-10, 1e-5, 1e5},\n\t\t\texpected: 1e5 + 1e-5 + 1e-10,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.NaN()},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{math.Inf(1), 1.0},\n\t\t\texpected: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tinput:    []float64{1.0, math.Inf(-1)},\n\t\t\texpected: math.Inf(-1),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := SumCompensated(test.input)\n\t\tif math.IsNaN(test.expected) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Expected NaN, but got %v for input %v\", result, test.input)\n\t\t\t}\n\t\t} else if !almostEqual(result, test.expected) {\n\t\t\tt.Errorf(\"For input %v, expected %v, but got %v\", test.input, test.expected, result)\n\t\t}\n\t}\n}\n\n// almostEqual checks if two float64 numbers are approximately equal\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","cb535218c3f70cf84aad141358af65fc":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tt       []float64\n\t\tL       float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\tL:       1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\tL:       math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\ts:       []float64{},\n\t\t\tt:       []float64{},\n\t\t\tL:       1,\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !floatEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic with mismatched lengths\")\n\t\t}\n\t}()\n\n\tDistance([]float64{1, 2}, []float64{1}, 1)\n}\n","cba9f4ddaeffe47ca5b276cb857f5a91":"// File: norm_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L1 norm of positive numbers\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm of positive numbers\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(14), // √(1²+2²+3²)\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm with negative numbers\",\n\t\t\tslice:    []float64{-1, -2, -3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm with negative numbers\",\n\t\t\tslice:    []float64{-1, -2, -3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname:     \"L-Infinity norm of mixed numbers\",\n\t\t\tslice:    []float64{-1, 2, -3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm of zeros\",\n\t\t\tslice:    []float64{0, 0, 0},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-Infinity norm of zeros\",\n\t\t\tslice:    []float64{0, 0, 0},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"High L norm\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        4,\n\t\t\texpected: math.Pow(1 + math.Pow(2, 4) + math.Pow(3, 4), 1.0/4.0),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif !floatEquals(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// A helper function to compare floating-point numbers\nfunc floatEquals(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","cbb8d4e698be7f05734f9a6261da1335":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Valid span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, 10)\n\n\t\texpected := []float64{0, 2.5, 5, 7.5, 10}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Valid span with negative bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tresult := Span(dst, -10, -5)\n\n\t\texpected := []float64{-10, -7.5, -5}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Valid span with identical bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\tresult := Span(dst, 5, 5)\n\n\t\texpected := []float64{5, 5, 5, 5}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Panics on short slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic on short slice\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 10)\n\t})\n\n\tt.Run(\"Handles NaN for lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 10)\n\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Handles NaN for upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, math.NaN())\n\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range result {\n\t\t\tif math.IsNaN(result[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Handles infinite bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Handles mix of finite and infinite bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tresult := Span(dst, 0, math.Inf(1))\n\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1)}\n\t\tfor i := range expected {\n\t\t\tif result[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", expected[i], result[i])\n\t\t\t}\n\t\t}\n\t})\n}","cd1af6b4b2cac1a9911a1fa1e5f63565":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2}, // Middle value case\n\t\t{5, 0, 10, 0, 0}, // Lower bound case\n\t\t{5, 0, 10, 10, 4}, // Upper bound case\n\t\t{5, -10, -5, -7.5, 1}, // Negative range case\n\t\t{5, -10, 10, -5, 3}, // Mid negative value case\n\t\t{5, 10, 0, 5, 2}, // Reversed bounds\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound case\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound case\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Inf bounds case\n\t\t{5, -math.Inf(1), math.Inf(1), 0, 2}, // Negative Inf bounds case\n\t\t{2, 0, 10, 5, 1}, // Edge case with minimum n\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Tests for panics\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // Should panic\n}","cd2551357bf5a4761b1d93b27199cd8e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{-1.0, 1.0}, 0.0},\n\t\t{[]float64{math.MaxFloat64, 1.0}, math.MaxFloat64 + 1.0},\n\t\t{[]float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{[]float64{}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif !equal(result, tt.expected) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v; want %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9 // Tolerance for floating point comparison\n}","cd59b1cd0bb3ec2ddb479fb44184b611":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts         []float64\n\t\tt         []float64\n\t\tL         float64\n\t\texpected  float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\tL:         1,\n\t\t\texpected:  9,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\tL:         2,\n\t\t\texpected:  5.196152422706632, // √((4-1)² + (5-2)² + (6-3)²)\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5, 6},\n\t\t\tL:         math.Inf(1),\n\t\t\texpected:  3, // max(|4-1|, |5-2|, |6-3|)\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:         []float64{1},\n\t\t\tt:         []float64{1},\n\t\t\tL:         1,\n\t\t\texpected:  0,\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\ts:         []float64{1, 2},\n\t\t\tt:         []float64{1},\n\t\t\tL:         1,\n\t\t\texpected:  1,\n\t\t\texpectPanic: true, // Length mismatch\n\t\t},\n\t\t{\n\t\t\ts:         []float64{},\n\t\t\tt:         []float64{},\n\t\t\tL:         1,\n\t\t\texpected:  0,\n\t\t\texpectPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for inputs: %v, %v, %v\", test.s, test.t, test.L)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !test.expectPanic \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}","cdbdf12b54f31cf75f3fe8b5f104b1b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"basic span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, 5.0)\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"span with NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 5.0)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\n\t\tfor i, v := range expected {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(v) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"span with NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, math.NaN())\n\t\texpected := []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\n\t\tfor i, v := range expected {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 math.IsNaN(v) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"span with Inf bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"span panic on short length\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic when calling Span with length \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1) // Length is 1, should panic\n\t\t_ = Span(dst, 0.0, 1.0)\n\t})\n\n\tt.Run(\"span with negative step\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 5.0, 1.0)\n\t\texpected := []float64{5.0, 4.0, 3.0, 2.0, 1.0}\n\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"Expected %v at index %d, but got %v\", v, i, result[i])\n\t\t\t}\n\t\t}\n\t})\n}","cec8ccef0f30afa2aa52c89fdd1aaf3a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t// Test cases for L = 1 ( Manhattan Norm )\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\t\t{[]float64{}, 1, 0},\n\n\t\t// Test cases for L = 2 ( Euclidean Norm )\n\t\t{[]float64{3, 4}, 2, 5},               // 3-4-5 triangle\n\t\t{[]float64{-3, -4}, 2, 5},             // Same distance in the negative quadrant\n\t\t{[]float64{1, 2, 2}, 2, math.Sqrt(9)}, // (1^2 + 2^2 + 2^2)^(1/2) = 3\n\n\t\t// Test case for L = math.Inf(1) (Max Norm)\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// Test cases for L = 0 (Not applicable but testing behavior)\n\t\t{[]float64{1, 2, 3}, 0, 0}, // Expect either panic or return a default value\n\t\t{[]float64{}, 0, 0},        // Expect either panic or return a default value\n\n\t\t// Test cases for large L values\n\t\t{[]float64{1, 2, 3}, 10, math.Pow(3, 1.0/10)}, // Expect close to the max value raised to 1/L\n\n\t\t// Edge case for negative and positive mix\n\t\t{[]float64{-1, 2, -3}, 1, 6},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Norm(tt.slice, tt.L)\n\t\tif !floatEquals(got, tt.want) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.slice, tt.L, got, tt.want)\n\t\t}\n\t}\n}\n\n// Helper function to compare float64 values for equality within a tolerance\nfunc floatEquals(a, b float64) bool {\n\tconst tolerance = 1e-9\n\treturn math.Abs(a-b) \u003c= tolerance\n}","ced77cd244892a4bc6b7d487dd1b6d4a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tc        float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tc:        2,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tc:        -1,\n\t\t\ts:        []float64{1, 1, 1, 1},\n\t\t\texpected: []float64{-1, -1, -1, -1},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 1, 1},\n\t\t\tc:        3,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{3, 6, 9},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{2, 4, 6},\n\t\t\tc:        0.5,\n\t\t\ts:        []float64{2, 4, 6},\n\t\t\texpected: []float64{1, 2, 3},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := ScaleTo(test.dst, test.c, test.s)\n\t\tfor i := range result {\n\t\t\tif result[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) = %v; expected %v\", test.dst, test.c, test.s, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ScaleTo did not panic on length mismatch\")\n\t\t}\n\t}()\n\tScaleTo([]float64{1}, 2, []float64{1, 2})\n}","cee9aea2c702fc18ba210f59a68d56ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst         []float64\n\t\tl, u       float64\n\t\texpected    []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:         make([]float64, 5),\n\t\t\tl:           0,\n\t\t\tu:           4,\n\t\t\texpected:    []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           1,\n\t\t\tu:           1,\n\t\t\texpected:    []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           0,\n\t\t\tu:           math.NaN(),\n\t\t\texpected:    []float64{0, math.NaN(), math.NaN()},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 3),\n\t\t\tl:           math.NaN(),\n\t\t\tu:           5,\n\t\t\texpected:    []float64{math.NaN(), math.NaN(), 5},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 0),\n\t\t\tl:           1,\n\t\t\tu:           10,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:         make([]float64, 1),\n\t\t\tl:           -3,\n\t\t\tu:           3,\n\t\t\texpected:    nil,\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for dst %v, l %v, u %v, but did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\tif !tt.expectPanic {\n\t\t\tfor i, v := range result {\n\t\t\t\tif v != tt.expected[i] \u0026\u0026 !(math.IsNaN(v) \u0026\u0026 math.IsNaN(tt.expected[i])) {\n\t\t\t\t\tt.Errorf(\"unexpected value at index %d: got %v, want %v\", i, v, tt.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","cf3d2ac834f186c8f0097e850e7bbbbe":"package floats\n\nimport \"testing\"\n\n// Custom comparison function to be passed to EqualFunc\nfunc floatEquals(a, b float64) bool {\n\treturn a == b\n}\n\nfunc TestEqualFunc_SameLengthAndEqualElements(t *testing.T) {\n\ts1 := []float64{1.0, 2.0, 3.0}\n\ts2 := []float64{1.0, 2.0, 3.0}\n\n\tresult := EqualFunc(s1, s2, floatEquals)\n\tif !result {\n\t\tt.Errorf(\"EqualFunc failed: expected true, got false\")\n\t}\n}\n\nfunc TestEqualFunc_SameLengthDifferentElements(t *testing.T) {\n\ts1 := []float64{1.0, 2.0, 3.0}\n\ts2 := []float64{1.0, 2.0, 4.0}\n\n\tresult := EqualFunc(s1, s2, floatEquals)\n\tif result {\n\t\tt.Errorf(\"EqualFunc failed: expected false, got true\")\n\t}\n}\n\nfunc TestEqualFunc_DifferentLengths(t *testing.T) {\n\ts1 := []float64{1.0, 2.0}\n\ts2 := []float64{1.0, 2.0, 3.0}\n\n\tresult := EqualFunc(s1, s2, floatEquals)\n\tif result {\n\t\tt.Errorf(\"EqualFunc failed: expected false, got true\")\n\t}\n}\n\nfunc TestEqualFunc_EmptySlices(t *testing.T) {\n\ts1 := []float64{}\n\ts2 := []float64{}\n\n\tresult := EqualFunc(s1, s2, floatEquals)\n\tif !result {\n\t\tt.Errorf(\"EqualFunc failed: expected true, got false\")\n\t}\n}\n\nfunc TestEqualFunc_OneEmptySlice(t *testing.T) {\n\ts1 := []float64{}\n\ts2 := []float64{1.0}\n\n\tresult := EqualFunc(s1, s2, floatEquals)\n\tif result {\n\t\tt.Errorf(\"EqualFunc failed: expected false, got true\")\n\t}\n}","cfbb4651815b01c03980fee9bcea668b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 3, 1}, // Closest to 3 in the span [0, 10] with 5 points =\u003e [0, 2.5, 5, 7.5, 10]\n\t\t{5, 0, 10, 0, 0}, // Closest to 0\n\t\t{5, 0, 10, 10, 4}, // Closest to 10\n\t\t{3, 0, 10, 5, 1}, // Closest to 5 in the span [0, 10] with 3 points =\u003e [0, 5, 10]\n\t\t{4, 1, 5, 2, 0}, // Closest to 2 in the span [1, 5] with 4 points =\u003e [1, 2, 3, 4]\n\t\t{4, 5, 1, 3, 3}, // Closest to 3 in the span [5, 1] with 4 points in decreasing order\n\t\t{6, -10, -5, -7, 2}, // Closest to -7 in span [-10, -5]\n\t\t{6, math.NaN(), -5, -7, 5}, // l is NaN, return last index\n\t\t{6, -10, math.NaN(), -7, 0}, // u is NaN, return first index\n\t\t{6, math.Inf(1), math.Inf(-1), -7, 3}, // Both l and u are infinite\n\t\t{2, 0, 1, 0.5, 0}, // Test edge case with n == 2\n\t\t{2, 0, 0, 0, 0}, // Special case where l == u\n\t\t{3, 0, math.Inf(1), 2, 2}, // Inf as upper bound\n\t\t{3, math.Inf(-1), 0, -1, 0}, // Inf as lower bound\n\t}\n\n\tfor i, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Test %d: expected %d, got %d\", i, test.expect, result)\n\t\t}\n\t}\n\n\t// Test for panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0) // Should panic\n}","cfc03b5acebd84a7b4d5789bde286391":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tf        func(float64) bool\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"find first k elements matching f\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tf:        func(x float64) bool { return x \u003e 2.0 },\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all elements matching f when k is negative\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tf:        func(x float64) bool { return x \u003e 2.0 },\n\t\t\tk:        -1,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"not enough elements matching f\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(x float64) bool { return x \u003e 3.0 },\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"k is zero\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tf:        func(x float64) bool { return x \u003e 0.0 },\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tinds := []int{}\n\t\t\tgot, err := Find(inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(got, tt.expected) || !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"Find() = %v, %v; want %v, %v\", got, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d00820bb1a4bd89672dcb2c82326bc12":"// mul_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\ts:        []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{4.0, 10.0, 18.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0.0, 0.0, 0.0},\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0},\n\t\t\ts:        []float64{2.0},\n\t\t\texpected: []float64{2.0},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1.0, 2.0},\n\t\t\ts:        []float64{1.0},\n\t\t\texpected: nil,\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t\tpanic:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for dst: %v, s: %v, but did not panic\", test.dst, test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tMul(test.dst, test.s)\n\n\t\tif !test.panic {\n\t\t\tfor i, val := range test.expected {\n\t\t\t\tif test.dst[i] != val {\n\t\t\t\t\tt.Errorf(\"For dst: %v and s: %v, expected dst[%d] = %v, got %v\", test.dst, test.s, i, val, test.dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","d03fbbedb07ba59353ee3aa2469554c4":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x \u003e 2 },\n\t\t\ts:       []float64{1, 2, 3, 4, 5},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x \u003c 0 },\n\t\t\ts:       []float64{-1, -2, 3, 4, 5},\n\t\t\tk:       1,\n\t\t\twant:    []int{0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x == 3 },\n\t\t\ts:       []float64{1, 2, 3, 4, 5},\n\t\t\tk:       1,\n\t\t\twant:    []int{2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x \u003e 5 },\n\t\t\ts:       []float64{1, 2, 3, 4, 5},\n\t\t\tk:       1,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x \u003c 0 },\n\t\t\ts:       []float64{1, 2, 3, 4, 5},\n\t\t\tk:       -1,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x \u003c 6 },\n\t\t\ts:       []float64{1, 2, 3, 4, 5},\n\t\t\tk:       10,\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d0618cf3772a1cbdb3f414697491934f":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\ts         []float64\n\t\tf         func(float64) bool\n\t\tk         int\n\t\texpected  []int\n\t\twantErr   bool\n\t}{\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tf:        func(x float64) bool { return x \u003e 3 },\n\t\t\tk:        2,\n\t\t\texpected: []int{3, 4},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tf:        func(x float64) bool { return x \u003e 6 },\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tf:        func(x float64) bool { return x%2 == 0 },\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tinds := []int{}\n\t\t\tgot, err := Find(inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equal(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d1ae84045c77da5ac561a7f186238cb5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{3, 0, 1, 0.5, 1},        // v is in the middle of the span\n\t\t{5, 0, 10, 5, 2},          // v is exactly in the middle\n\t\t{4, -10, -5, -7, 1},       // v in the span\n\t\t{4, 1, 4, 5, 3},           // v is greater than u\n\t\t{4, 1, 4, 0, 0},           // v is less than l\n\t\t{4, math.NaN(), 4, 1, 3}, // l is NaN\n\t\t{4, 1, math.NaN(), 3, 0}, // u is NaN\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // span is between -Inf and Inf\n\t\t{2, 1, 1, 1, 0},           // All values are the same\n\t\t{2, 1, math.Inf(1), 2, 1}, // v is between l and u\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t}\n\t}\n\n\t// Test for panic on short spans\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(1, 0, 1, 0), but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","d1e51f3ebef2601345a50316d8222b28":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))},\n\t\t{[]float64{-1, 0, 1}, math.Log(math.Exp(-1) + math.Exp(0) + math.Exp(1))},\n\t\t{[]float64{0, 0, 0}, 0}, // log(3) in this case, should be adjusted for expected value\n\t\t{[]float64{1000, 1001, 1002}, 1002}, // To check for large numbers avoiding overflow\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"input=%v\", test.input), func(t *testing.T) {\n\t\t\tactual := LogSumExp(test.input)\n\t\t\tif math.Abs(actual-test.expected) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}","d21d94f17836ef34ef6e24fe8f5c1794":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"one empty slice\",\n\t\t\tslices: [][]float64{{}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"two equal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"two unequal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"three equal length slices\",\n\t\t\tslices: [][]float64{{1.0}, {2.0}, {3.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"three unequal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0}, {4.0, 5.0}},\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tt.slices...)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d2d4683e15ed6c7820e9cc788de1ae6c":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        3,\n\t\t\texpected: []int{2, 3, 4}, // Indices of first 3 elements \u003e 0\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        5,\n\t\t\texpected: []int{2, 3, 4}, // All matching indices returned\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, -2, -3, -4},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1}, // Indices of first 2 elements \u003c 0\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tk:        1,\n\t\t\texpected: []int{}, // No matching indices\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{0, 0, 0},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2}, // All matching indices since k \u003c 0\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tinds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\tif (err != nil) != tt.err {\n\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t}\n\n\t\tif !equalSlices(inds, tt.expected) {\n\t\t\tt.Fatalf(\"expected: %v, got: %v\", tt.expected, inds)\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d3f731fcec5e030b686db890c77b0152":"// nearest_idx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"exact match\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0},\n\t\t\tvalue:    2.0,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"closest lower\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0},\n\t\t\tvalue:    1.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"closest higher\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0},\n\t\t\tvalue:    2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple closest\",\n\t\t\tslice:    []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\tvalue:    2.0,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative values\",\n\t\t\tslice:    []float64{-3.0, -2.0, -1.0},\n\t\t\tvalue:    -2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"inf value high\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0},\n\t\t\tvalue:    math.Inf(1),\n\t\t\texpected: 2, // The index of the maximum value\n\t\t},\n\t\t{\n\t\t\tname:     \"inf value low\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0},\n\t\t\tvalue:    math.Inf(-1),\n\t\t\texpected: 0, // The index of the minimum value\n\t\t},\n\t\t{\n\t\t\tname:     \"nan value\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0},\n\t\t\tvalue:    math.NaN(),\n\t\t\texpected: 0, // Returns 0 if value is NaN\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tslice:    []float64{},\n\t\t\tvalue:    1.0,\n\t\t\texpected: -1, // Expect a panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.slice) == 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := NearestIdx(tt.slice, tt.value)\n\t\t\tif len(tt.slice) \u003e 0 \u0026\u0026 got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d; want %d\", tt.slice, tt.value, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","d472e2d93552a6c0dda8754ae8121fc6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tl, u float64      // bounds\n\t\tdst []float64    // destination slice\n\t\texpected []float64 // expected result\n\t}{\n\t\t{0, 10, make([]float64, 5), []float64{0, 2.5, 5, 7.5, 10}},\n\t\t{1, 2, make([]float64, 3), []float64{1, 1.5, 2}},\n\t\t{-10, 10, make([]float64, 6), []float64{-10, -5, 0, 5, 10}},\n\t\t{math.Inf(-1), math.Inf(1), make([]float64, 3), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{0, 0, make([]float64, 4), []float64{0, 0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tfor i := range result {\n\t\t\tif !floatEquals(result[i], test.expected[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, %v) = %v; want %v\", test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Span did not panic for dst length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1) // should panic\n}\n\nfunc floatEquals(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","d54d5f470d5f7010a1f68fb43aacbcd4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Test case 1: Normal range\n\t\t{5, 0, 10, 5, 2}, // Closest to 5 is at index 2\n\n\t\t// Test case 2: Value less than the lower bound\n\t\t{5, 0, 10, -1, 0}, // Closest to -1 is at index 0\n\n\t\t// Test case 3: Value greater than the upper bound\n\t\t{5, 0, 10, 11, 4}, // Closest to 11 is at index 4\n\n\t\t// Test case 4: Edge case where v equals the lower bound\n\t\t{5, 0, 10, 0, 0}, // Closest to 0 is at index 0\n\n\t\t// Test case 5: Edge case where v equals the upper bound\n\t\t{5, 0, 10, 10, 4}, // Closest to 10 is at index 4\n\n\t\t// Test case 6: Negative range\n\t\t{5, -10, -5, -7.5, 2}, // Closest to -7.5 is at index 2\n\n\t\t// Test case 7: Invalid input (n \u003c 2)\n\t\t{1, 0, 10, 5, -1}, // Should panic\n\n\t\t// Test case 8: Value is NaN\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN should return index 0\n\n\t\t// Test case 9: Value equals lower bound, negative range flipped\n\t\t{5, -5, -10, -5, 0}, // Closest to -5 is at index 0\n\n\t\t// Test case 10: Value equals upper bound, negative range flipped\n\t\t{5, -5, -10, -10, 4}, // Closest to -10 is at index 4\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.n \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","d54f36e019297f6ad65085cc8a881991":"// equal_approx_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\ttol  float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices with zero tolerance\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  0.0,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with positive tolerance\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0 + 1e-10, 2.0 - 1e-10, 3.0},\n\t\t\ttol:  1e-9,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Slices with different lengths\",\n\t\t\ts1:   []float64{1.0, 2.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\ttol:  1e-9,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values within tolerance\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.2, 3.0},\n\t\t\ttol:  0.1,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Values outside of tolerance\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.5, 3.0},\n\t\t\ttol:  0.1,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Both slices are empty\",\n\t\t\ts1:   []float64{},\n\t\t\ts2:   []float64{},\n\t\t\ttol:  1e-9,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice is empty\",\n\t\t\ts1:   []float64{1.0},\n\t\t\ts2:   []float64{},\n\t\t\ttol:  1e-9,\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualApprox(tt.s1, tt.s2, tt.tol)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %v) = %v; want %v\", tt.s1, tt.s2, tt.tol, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d7391925b9ae35074c2ad1cdf8cee8b0":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ts1    []float64\n\t\ts2    []float64\n\t\twant  bool\n\t}{\n\t\t{\n\t\t\tname:  \"equal slices\",\n\t\t\ts1:    []float64{1.0, 2.0, 3.0},\n\t\t\ts2:    []float64{1.0, 2.0, 3.0},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"different lengths\",\n\t\t\ts1:    []float64{1.0, 2.0},\n\t\t\ts2:    []float64{1.0, 2.0, 3.0},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"equal slices with negative numbers\",\n\t\t\ts1:    []float64{-1.0, -2.0, -3.0},\n\t\t\ts2:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"different values\",\n\t\t\ts1:    []float64{1.0, 2.0, 3.0},\n\t\t\ts2:    []float64{1.0, 2.0, 4.0},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty slices\",\n\t\t\ts1:    []float64{},\n\t\t\ts2:    []float64{},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tname:  \"one empty slice\",\n\t\t\ts1:    []float64{1.0},\n\t\t\ts2:    []float64{},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tname:  \"slices with NaN values\",\n\t\t\ts1:    []float64{1.0, 2.0, 3.0, float64(0.0/0.0)}, // NaN\n\t\t\ts2:    []float64{1.0, 2.0, 3.0, float64(0.0/0.0)}, // NaN\n\t\t\twant:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Equal(tt.s1, tt.s2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v; want %v\", tt.s1, tt.s2, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d799b91a3bd21a0eb9863753a3943661":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 3, 1}, // Nearest to 3 in [0, 10] with 5 points\n\t\t{5, 0, 10, 0, 0}, // Nearest to 0 in [0, 10] with 5 points\n\t\t{5, 0, 10, 10, 4}, // Nearest to 10 in [0, 10] with 5 points\n\t\t{3, 0, 10, 5, 1}, // Nearest to 5 in [0, 10] with 3 points\n\t\t{4, -2, 2, 0, 2}, // Nearest to 0 in [-2, 2] with 4 points\n\t\t{10, 0, 1, 0.5, 5}, // Nearest to 0.5 in [0, 1] with 10 points\n\t\t{10, -1, 1, -0.5, 3}, // Nearest to -0.5 in [-1, 1] with 10 points\n\t\t{2, -1, 1, -0.5, 1}, // Nearest to -0.5 in [-1, 1] with 2 points\n\t\t{2, 5, 5, 5, 0}, // Edge case: l == u\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // Edge case: Both bounds are infinity\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d,l=%f,u=%f,v=%f\", tt.n, tt.l, tt.u, tt.v), func(t *testing.T) {\n\t\t\tactual := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","d7b6ea6bd6829ec9f86229042aa6cc5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},  // Exact middle\n\t\t{5, 0, 10, 2, 1},  // Closer to lower bound\n\t\t{5, -10, 10, 0, 2}, // Closer to middle\n\t\t{3, 0, 1, 0.5, 1}, // Exact middle\n\t\t{4, 1, 2, 2, 3},   // Exact upper bound\n\t\t{4, 1, 2, 1, 0},   // Exact lower bound\n\t\t{5, -5, -1, -3, 2}, // Inside bounds\n\t\t{5, 1, 1, 1, 0},   // Constant span\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // Infinity bounds\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 0}, // Reverse infinity bounds\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test for NaN\n\ttestsNaN := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN handling\n\t\t{5, math.NaN(), 10, 5, 0}, // Upper bound NaN\n\t\t{5, 0, math.NaN(), 5, 1},  // Lower bound NaN\n\t\t{5, math.NaN(), math.NaN(), 5, 0}, // Both bounds NaN\n\t}\n\n\tfor _, tt := range testsNaN {\n\t\tt.Run(\"NaNTest\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","d8099fc547bc3e0cba409e34e0be5d49":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic Span\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero Length\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Span\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    -1.0,\n\t\t\twant: []float64{-3.0, -2.0, -1.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Single Element Span with NaN\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Single Element Span with Inf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0.0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) {\n\t\t\t\t\tif !math.IsNaN(tt.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"got[%d] = NaN, want[%d] = %v\", i, i, tt.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"got[%d] = %v, want[%d] = %v\", i, got[i], i, tt.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on Short Slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on short slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}","d91536c4291955fa1cb968ab179e0f7a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 100, 50, 5},\n\t\t{10, 0, 100, 0, 0},\n\t\t{10, 0, 100, 100, 9},\n\t\t{10, 0, 100, 25, 2},\n\t\t{10, 0, 100, 75, 7},\n\t\t{10, -100, -50, -75, 2},\n\t\t{10, -100, -50, -100, 0},\n\t\t{10, -100, -50, -50, 9},\n\t\t{5, 0, 10, 5, 2},\n\t\t{5, 10, 0, 5, 2}, // testing reversed bounds\n\t\t{3, 0, 2, 1, 1},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // External value at -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // External value at +Inf\n\t\t{5, 0, 0, 0, 0}, // Edge case: all values the same\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for panic situations\n\tpanics := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 10, 5},\n\t\t{0, 0, 10, 5},\n\t}\n\n\tfor _, test := range panics {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(%d, %f, %f, %f) but did not\", test.n, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t})\n\t}\n}","d9c055ec104c56718a9f735546ef9f34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t// Test case for simple span\n\t\t{5, 0, 10, 5, 2}, // Closest to midpoint\n\t\t{5, 0, 10, 0, 0}, // Closest to lower bound\n\t\t{5, 0, 10, 10, 4}, // Closest to upper bound\n\t\t{5, 0, 10, 3, 1}, // Closest between lower and next\n\t\t{5, 0, 10, 7, 3}, // Closest between upper and second last\n\n\t\t// Test case for NaN\n\t\t{5, 0, 10, math.NaN(), 0}, // Should return 0 for NaN value\n\n\t\t// Test case for bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Closest to -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Closest to Inf\n\n\t\t// Test cases for valid range with equal bounds\n\t\t{5, 5, 5, 5, 0}, // All equal, return index 0\n\t\t{5, 5, 5, 6, 0}, // Greater than equal, return 0\n\t\t{5, 5, 5, 4, 0}, // Less than equal, return 0\n\n\t\t// Edge case for span less than 2\n\t\t{1, 0, 1, 0, 0}, // Should panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.n \u003c 2 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for n = %d\", tt.n)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expect)\n\t\t}\n\t}\n}","db0efa97eac5aa38beace3d862c72995":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\twant    int\n\t}{\n\t\t// Test case with a normal range\n\t\t{5, 0, 10, 5, 2}, // 5 is closest to middle of 0 to 10\n\t\t// Test case for values at the bounds\n\t\t{5, 0, 10, 0, 0}, // 0 is the closest to the lower bound\n\t\t{5, 0, 10, 10, 4}, // 10 is the closest to the upper bound\n\t\t// Test case where v is outside the bounds\n\t\t{5, 0, 10, -1, 0}, // -1 is below the lower bound\n\t\t{5, 0, 10, 11, 4}, // 11 is above the upper bound\n\t\t// Test case with negative range\n\t\t{5, -10, 0, -5, 2}, // -5 is closest to middle of -10 to 0\n\t\t// Test case with NaN input\n\t\t{5, 0, 10, math.NaN(), 0}, // NaN input should return 0\n\t\t// Test cases with Inf\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // v is 0, closest to -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // v is Inf, closest to Inf\n\t\t// Edge case\n\t\t{2, 1, 5, 3, 1}, // Exactly halfway\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","dc0c51f114dd31f4e8df118530ca14e5":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},          // Middle case\n\t\t{5, 0, 10, 0, 0},          // Lower bound\n\t\t{5, 0, 10, 10, 4},         // Upper bound\n\t\t{5, 0, 10, -1, 0},         // Below lower bound\n\t\t{5, 0, 10, 11, 4},         // Above upper bound\n\t\t{3, 1, 2, 1.5, 1},         // Closer to lower with fewer elements\n\t\t{4, 1, 2, 1.5, 1},         // Even case\n\t\t{4, -10, -5, -7.5, 2},     // Negative range\n\t\t{3, math.NaN(), 1, 0, 2},  // NaN lower bound\n\t\t{3, 0, math.NaN(), 0, 0},  // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 0}, // Inf range\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif test.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Fatal(\"expected panic for n \u003c 2, but got none\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\",\n\t\t\t\t\ttest.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","dc352efe1934cd3627e87fc74681474a":"// maxidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0}, 3},           // maximum at last index\n\t\t{[]float64{4.0, 3.0, 2.0, 1.0}, 0},           // maximum at first index\n\t\t{[]float64{1.0, 2.0, 2.0, 1.0}, 1},           // first occurrence of max\n\t\t{[]float64{NaN, 1.0, 2.0, NaN}, 2},           // maximum is 2, ignore NaNs\n\t\t{[]float64{NaN, NaN, NaN}, 0},                // should panic or return 0 as no valid max\n\t\t{[]float64{-1.0, -2.0, -3.0}, 0},              // maximum negative value\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"MaxIdx(%v)\", test.input), func(t *testing.T) {\n\t\t\tif test.input == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for input %v but did not get one\", test.input)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := MaxIdx(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %d but got %d\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","dcd2c202fca790496c6f66029cca00a0":"// spans_test.go\npackage floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    tests := []struct {\n        dst     []float64\n        l, u    float64\n        want    []float64\n        shouldPanic bool\n    }{\n        {\n            dst: []float64{0, 0, 0},\n            l: 0,\n            u: 10,\n            want: []float64{0, 5, 10},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0, 0},\n            l: 1,\n            u: 1,\n            want: []float64{1, 1},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0, 0, 0, 0},\n            l: 1,\n            u: 4,\n            want: []float64{1, 2, 3, 4},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0},\n            l: 1,\n            u: 10,\n            shouldPanic: true,\n        },\n        {\n            dst: []float64{},\n            l: 0,\n            u: 0,\n            shouldPanic: true,\n        },\n        {\n            dst: []float64{math.NaN(), 0},\n            l: math.NaN(),\n            u: 10,\n            want: []float64{math.NaN(), 10},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0, 0},\n            l: 0,\n            u: math.NaN(),\n            want: []float64{0, math.NaN()},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0, 0},\n            l: math.Inf(1),\n            u: math.Inf(1),\n            want: []float64{math.Inf(1), math.Inf(1)},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0, 0},\n            l: math.Inf(-1),\n            u: math.Inf(-1),\n            want: []float64{math.Inf(-1), math.Inf(-1)},\n            shouldPanic: false,\n        },\n        {\n            dst: []float64{0, 0, 0},\n            l: 0,\n            u: math.Inf(1),\n            want: []float64{0, math.Inf(1), math.Inf(1)},\n            shouldPanic: false,\n        },\n    }\n\n    for _, tt := range tests {\n        if tt.shouldPanic {\n            func() {\n                defer func() {\n                    if r := recover(); r == nil {\n                        t.Errorf(\"expected panic for input %v, %v, %v\", tt.dst, tt.l, tt.u)\n                    }\n                }()\n                Span(tt.dst, tt.l, tt.u)\n            }()\n        } else {\n            got := Span(tt.dst, tt.l, tt.u)\n            if !equal(got, tt.want) {\n                t.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n            }\n        }\n    }\n}\n\nfunc equal(a, b []float64) bool {\n    if len(a) != len(b) {\n        return false\n    }\n    for i := range a {\n        if !floatEqual(a[i], b[i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunc floatEqual(a, b float64) bool {\n    return (math.IsNaN(a) \u0026\u0026 math.IsNaN(b)) || (a == b)\n}","dcfe3ecfae6fa288d7bcd0d33508722c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal bounds\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -1,\n\t\t\tu:        -5,\n\t\t\texpected: []float64{-1, -1.75, -2.5, -3.25, -5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, expected %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n\n\t// Add more panic tests for other cases if needed\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !(math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) || a[i] == b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","de0f41c026a90025ceeee7a8b47d9b51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\twant   int\n\t\twantP  bool // indicates whether we expect a panic\n\t}{\n\t\t// Valid cases\n\t\t{5, 0, 10, 3, 1, false},     // 0, 2, 4, 6, 8 (index 1 is closest to 3)\n\t\t{5, 0, 10, 0, 0, false},     // Exactly at lower bound\n\t\t{5, 0, 10, 10, 4, false},    // Exactly at upper bound\n\t\t{5, -10, -1, -5, 2, false},   // Span from -10 to -1\n\t\t{5, 0, 1, 0.5, 2, false},     // Span from 0 to 1\n\n\t\t// Edge cases\n\t\t{3, 1, 5, 6, 2, false},       // Greater than upper bound\n\t\t{3, 1, 5, 0, 0, false},       // Less than lower bound\n\n\t\t// Special cases\n\t\t{3, math.NaN(), 10, 1, 2, false}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 1, 0, false}, // NaN upper bound\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1, false}, // Infinity bounds\n\t\t{3, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, false}, // Infinity lower bound equal to v\n\t\t{3, math.Inf(1), math.Inf(1), math.Inf(1), 2, false}, // Infinity upper bound equal to v\n\n\t\t// Panic cases\n\t\t{1, 0, 1, 0, 0, true}, // n \u003c 2\n\t\t{0, 0, 1, 0, 0, true}, // n \u003c 2\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantP {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(%d, %f, %f, %f), but did not panic\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t}\n\t}\n}","df7fb887ea18e4ff6789fa276836ed07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 3, 5},\n\t\t},\n\t\t{\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tdst:     make([]float64, 0),\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\twantErr: true,\n\t\t},\n        {\n            dst:  make([]float64, 5),\n            l:    math.NaN(),\n            u:    4,\n            want: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n        },\n        {\n            dst:  make([]float64, 5),\n            l:    -math.Inf(1),\n            u:    math.Inf(1),\n            want: []float64{-math.Inf(1), -math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n        },\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif !test.wantErr {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(test.dst, test.l, test.u)\n\n\t\t\tif test.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !equalSlices(got, test.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !floatEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc floatEqual(a, b float64) bool {\n\tif math.IsNaN(a) || math.IsNaN(b) {\n\t\treturn math.IsNaN(a) \u0026\u0026 math.IsNaN(b)\n\t}\n\treturn a == b\n}","e0511d81fad1093714fcf21a2a02a933":"// prod_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},                         // Test for empty slice\n\t\t{[]float64{2}, 2},                        // Test for single element\n\t\t{[]float64{2, 3}, 6},                     // Test for two elements\n\t\t{[]float64{-2, 3}, -6},                   // Test for negative and positive elements\n\t\t{[]float64{0, 3, 5}, 0},                  // Test for zero in the slice\n\t\t{[]float64{1, 2, 3, 4}, 24},              // Test for multiple elements\n\t\t{[]float64{1, -1, 1}, -1},                // Test for alternating positive and negative\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e0de08f91bb8621093aea8a6f6895828":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tdestination []float64\n\t\texpected    []float64\n\t\tinds        []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdestination: []float64{3.0, 1.0, 2.0},\n\t\t\texpected:    []float64{1.0, 2.0, 3.0},\n\t\t\tinds:        make([]int, 3),\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdestination: []float64{5.5, 2.2, 4.4, 3.3},\n\t\t\texpected:    []float64{2.2, 3.3, 4.4, 5.5},\n\t\t\tinds:        make([]int, 4),\n\t\t\texpectedInds: []int{1, 3, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdestination: []float64{1.0, 0.0, -1.0},\n\t\t\texpected:    []float64{-1.0, 0.0, 1.0},\n\t\t\tinds:        make([]int, 3),\n\t\t\texpectedInds: []int{2, 1, 0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tArgsort(test.destination, test.inds)\n\t\n\t\tif !Equal(test.destination, test.expected) {\n\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, test.destination)\n\t\t}\n\t\n\t\tif !EqualInts(test.inds, test.expectedInds) {\n\t\t\tt.Errorf(\"Expected indices %v but got %v\", test.expectedInds, test.inds)\n\t\t}\n\t}\n}\n\n// Helper function for comparing two integer slices\nfunc EqualInts(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","e23f0499b54dde9b7d452678e119f319":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{3, 0, 10, 5, 1},           // Normal case, value is in the middle\n\t\t{3, 0, 10, 0, 0},           // Value equals lower bound\n\t\t{3, 0, 10, 10, 2},          // Value equals upper bound\n\t\t{5, 0, 10, -5, 0},          // Value below the range\n\t\t{5, 0, 10, 15, 4},          // Value above the range\n\t\t{5, -5, -1, -3, 2},         // Negative range, value in the middle\n\t\t{2, 1, 1, 1, 0},            // Edge case with same bounds\n\t\t{2, 1, 1, 2, 1},            // Edge case with same bounds, value above\n\t\t{2, 1, 1, 0, 0},            // Edge case with same bounds, value below\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; expected %d\", test.n, test.l, test.u, test.v, result, test.expect)\n\t\t}\n\t}\n\n\t// Test for panic condition\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // This should panic\n}","e25ace83e9153cf53faa9bc86e8579de":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, -1, 1, 0.5, 5},\n\t\t{10, 0, 1, 1, 9},\n\t\t{10, 0, 1, 0, 0},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 9},\n\t\t{5, -math.Inf(1), -math.Inf(-1), -1, 0},\n\t\t{5, math.NaN(), 1, 0.5, 4},\n\t\t{5, 0, math.NaN(), 0.5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; expected %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}","e36e2d6500656f6ab7d05eebfb5207f7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts       []float64\n\t\tv       float64\n\t\texpIdx  int\n\t\texpectPanic bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.0, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1.5, 0, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 3.5, 2, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2.5, 1, false},\n\t\t{[]float64{1.0, 2.0, 2.0, 3.0}, 2.0, 1, false},\n\t\t{[]float64{1.0, 2.0, 3.0, math.NaN()}, 2.0, 1, false},\n\t\t{[]float64{}, 1.0, 0, true}, // Expecting panic\n\t\t{[]float64{math.Inf(1), math.Inf(-1)}, math.Inf(1), 0, false},\n\t\t{[]float64{math.Inf(1), math.Inf(-1)}, math.Inf(-1), 1, false},\n\t\t{[]float64{math.NaN(), 1.0}, 1.0, 1, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.expectPanic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input %v and %f, but did not panic.\", test.s, test.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdx(test.s, test.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := NearestIdx(test.s, test.v)\n\t\t\tif got != test.expIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d; expected %d\", test.s, test.v, got, test.expIdx)\n\t\t\t}\n\t\t}\n\t}\n}","e3d4b6f7a4af707bc819ae7f7d99fff2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tslice      []float64\n\t\tL          float64\n\t\texpected   float64\n\t\tdescription string\n\t}{\n\t\t{[]float64{1, 2, 3}, 1, 6, \"L1 norm\"},\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14), \"L2 norm\"},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3, \"L∞ norm\"},\n\t\t{[]float64{}, 1, 0, \"empty slice\"},\n\t\t{[]float64{1, 2, 3}, 0, 3.7416573867739413, \"L = 0, power not defined\"}, // though the function does not handle this case\n\t\t{[]float64{-1, -2, -3}, 1, 6, \"L1 norm with negative values\"},\n\t\t{[]float64{0, 0, 0}, 2, 0, \"L2 norm with zero values\"},\n\t\t{[]float64{-1, 2, -3}, math.Inf(1), 3, \"L∞ norm with mixed values\"},\n\t\t{[]float64{5}, 1, 5, \"single element L1 norm\"},\n\t\t{[]float64{-5}, 2, 5, \"single element L2 norm\"},\n\t\t{[]float64{math.NaN()}, 2, math.NaN(), \"L2 norm with NaN\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.description, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif math.IsNaN(tt.expected) {\n\t\t\t\tif !math.IsNaN(result) {\n\t\t\t\t\tt.Errorf(\"expected NaN, got %v\", result)\n\t\t\t\t}\n\t\t\t} else if result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","e3debfe533834eb7a925993f5da8abed":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdst:       []float64{3.0, 1.0, 2.0},\n\t\t\texpected:  []float64{1.0, 2.0, 3.0},\n\t\t\tinds:      make([]int, 3),\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{5.5, 3.3, 4.4, 2.2},\n\t\t\texpected:  []float64{2.2, 3.3, 4.4, 5.5},\n\t\t\tinds:      make([]int, 4),\n\t\t\texpectedInds: []int{3, 1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:       []float64{1.0, 1.0, 1.0},\n\t\t\texpected:  []float64{1.0, 1.0, 1.0},\n\t\t\tinds:      make([]int, 3),\n\t\t\texpectedInds: []int{0, 1, 2},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tArgsort(test.dst, test.inds)\n\n\t\t// Check if dst is sorted\n\t\tfor i := 1; i \u003c len(test.dst); i++ {\n\t\t\tif test.dst[i] \u003c test.dst[i-1] {\n\t\t\t\tt.Errorf(\"dst is not sorted: %v\", test.dst)\n\t\t\t}\n\t\t}\n\n\t\t// Check if inds contains original indices\n\t\tfor i, ind := range test.inds {\n\t\t\tif ind != test.expectedInds[i] {\n\t\t\t\tt.Errorf(\"expected inds[%d] = %d, got %d\", i, test.expectedInds[i], ind)\n\t\t\t}\n\t\t}\n\n\t\t// Check if dst matches expected sorted values\n\t\tfor i, val := range test.expected {\n\t\t\tif test.dst[i] != val {\n\t\t\t\tt.Errorf(\"expected dst[%d] = %f, got %f\", i, val, test.dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test with length mismatch\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic on length mismatch, but did not panic\")\n\t\t}\n\t}()\n\tArgsort([]float64{1.0}, []int{0, 1})\n}","e46741c04a2ae3e8fb5d63a0dfcf1389":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 2.5, 1},  // 2.5 is between 2 and 3\n\t\t{[]float64{1, 2, 3, 4}, 4, -1},    // 4 is not less than 4\n\t\t{[]float64{1, 2, 3, 4}, 1, -1},    // 1 is not greater than 1\n\t\t{[]float64{1, 2, 3, 4}, 0, -1},    // 0 is not greater than 1\n\t\t{[]float64{1, 1, 1, 1}, 1.5, -1},  // all elements are the same\n\t\t{[]float64{1, 2}, 1.5, 0},          // edge case with two elements\n\t\t{[]float64{1, 2}, 2, -1},            // edge case with two elements\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif len(test.s) \u003c 2 {\n\t\t\t\t\t\t// Expected panic for short slices\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Within(test.s, test.v)\n\t\t\tif result != test.expect {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", test.s, test.v, result, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic due to unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unsorted slice\")\n\t\t}\n\t}()\n\tWithin([]float64{2, 1}, 1.5) // expect panic due to unsorted input\n\n\t// Test for panic due to length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic due to short slice\")\n\t\t}\n\t}()\n\tWithin([]float64{1}, 1.5) // expect panic due to short input\n}","e4b1a35bdcaef67e0246950a70f8a28b":"// nearest_idx_for_span_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value\n\t\t{5, 0, 10, 0, 0},        // Lower bound\n\t\t{5, 0, 10, 10, 4},       // Upper bound\n\t\t{5, 0, 10, 15, 4},       // Beyond upper bound\n\t\t{5, -10, -5, -8, 2},     // Middle in negative range\n\t\t{5, -10, -5, -12, 0},    // Below lower bound in negative range\n\t\t{5, -10, -5, -4, 4},     // Above upper bound in negative range\n\t\t{2, 0, 1, 0.5, 0},        // Lower bound for n=2\n\t\t{2, 0, 1, 1.5, 1},        // Upper bound for n=2\n\t\t{3, math.NaN(), 10, 5, 2}, // NaN lower bound\n\t\t{3, 0, math.NaN(), 5, 0}, // NaN upper bound\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0}, // Both bounds are +Inf\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 0}, // Both bounds are -Inf\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","e551b450b466d5af6639a408ad6d1cd2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Same points\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        2,\n\t\t\tu:        2,\n\t\t\texpected: []float64{2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative to positive\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\texpected: []float64{-1, 0, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf to Inf\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Handling NaN\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        2,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Panic on short dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\texpected: nil, // Expect panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for dst length \u003c 2, but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","e56decab21bda765dea786add27026fb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\twant    int\n\t}{\n\t\t{5, 0, 10, 5, 2},                // Middle value should return index 2\n\t\t{5, 0, 10, 0, 0},                // Lower bound\n\t\t{5, 0, 10, 10, 4},               // Upper bound\n\t\t{5, 0, 10, -1, 0},               // Below range\n\t\t{5, 0, 10, 11, 4},               // Above range\n\t\t{5, 5, 5, 5, 0},                 // All values the same\n\t\t{5, 10, 0, 5, 4},                // Reversed bounds\n\t\t{5, math.NaN(), 10, 5, 4},      // NaN lower bound\n\t\t{5, 0, math.NaN(), 5, 0},        // NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // -Inf lower, +Inf upper\n\t\t{3, 1, 0, 0, 2},                 // Case with reversed bounds\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil \u0026\u0026 tt.n \u003c 2 {\n\t\t\t\t\tt.Errorf(\"Expected panic for n \u003c 2, got none\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e5e9fa216268e609baeb416605b77cd2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t{5, 0, 10, 5, 2},        // Middle value test\n\t\t{5, 0, 10, 0, 0},        // Lower bound test\n\t\t{5, 0, 10, 10, 4},       // Upper bound test\n\t\t{5, 0, 10, 11, 4},       // Above upper bound test\n\t\t{5, 0, 10, -1, 0},       // Below lower bound test\n\t\t{5, 2, 8, 5, 1},         // Custom bounds test\n\t\t{5, 2, 8, 2, 0},         // Lower bound exact test\n\t\t{5, 2, 8, 8, 4},         // Upper bound exact test\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 0}, // Inf bounds test\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Inf upper test\n\t\t{5, math.NaN(), 10, 5, 4}, // NaN lower bound test\n\t\t{5, 0, math.NaN(), 5, 0}, // NaN upper bound test\n\t\t{3, 0, 10, 5, 1},        // Minimum n value test\n\t\t{1, 0, 10, 5, 0},        // Panic on n \u003c 2 (this test will fail as expected)\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"n=%d_l=%v_u=%v_v=%v\", tt.n, tt.l, tt.u, tt.v), func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7908f6ba9246e52947f0c450542ee07":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 1},\n\t\t{[]float64{1, 2, 3, 4}, 24},\n\t\t{[]float64{1, 0, 3}, 0},\n\t\t{[]float64{-1, -2, -3}, -6},\n\t\t{[]float64{2.5, 4.0, 4.0}, 40.0},\n\t\t{[]float64{1.5, 2.0, 2.0, 0.5}, 3.0},\n\t\t{[]float64{1.2, 2.2, 3.3}, 8.784},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Prod(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Prod(%v) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e7de2bec59d8d297fc181da6f481f74b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ty        []float64\n\t\talpha    float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ty:        []float64{1, 2, 3},\n\t\t\talpha:    2,\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\texpected: []float64{9, 12, 15}, // 1 + 2*4, 2 + 2*5, 3 + 2*6\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{1, 1, 1},\n\t\t\ty:        []float64{1, 1, 1},\n\t\t\talpha:    0,\n\t\t\ts:        []float64{1, 1, 1},\n\t\t\texpected: []float64{1, 1, 1}, // 1 + 0*1, ...\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{5, 5, 5},\n\t\t\ty:        []float64{1, 2, 3},\n\t\t\talpha:    -1,\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\texpected: []float64{2, 0, -2}, // 1-4, 2-5, 3-6\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tif !EqualApprox(result, test.expected, 1e-9) {\n\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %f, %v) = %v; want %v\", test.dst, test.y, test.alpha, test.s, result, test.expected)\n\t\t}\n\t}\n\n\t// Testing panic for length mismatch in dst and y.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected AddScaledTo to panic for length mismatch but it did not\")\n\t\t}\n\t}()\n\tAddScaledTo([]float64{1}, []float64{1, 2}, 1, []float64{1, 2}) // should panic\n\n\t// Testing panic for length mismatch in y and s.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected AddScaledTo to panic for length mismatch but it did not\")\n\t\t}\n\t}()\n\tAddScaledTo([]float64{1, 2}, []float64{1}, 1, []float64{1, 2}) // should panic\n}","e8244b76a457320d0ab3b95b58a6c2da":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Regular case\n\tdst := make([]float64, 5)\n\tresult := Span(dst, 1.0, 5.0)\n\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tfor i := range expected {\n\t\tif result[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 2: Handling NaN in lower bound\n\tdst = make([]float64, 5)\n\tresult = Span(dst, math.NaN(), 5.0)\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\tfor i := range expected {\n\t\tif math.IsNaN(result[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 3: Handling NaN in upper bound\n\tdst = make([]float64, 5)\n\tresult = Span(dst, 1.0, math.NaN())\n\texpected = []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tfor i := range expected {\n\t\tif math.IsNaN(result[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 4: Lower bound is -Inf and upper bound is Inf\n\tdst = make([]float64, 5)\n\tresult = Span(dst, math.Inf(-1), math.Inf(1))\n\texpected = []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\tfor i := range expected {\n\t\tif result[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 5: Panics for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","e846085b6c4d3e90047c324e42424143":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"BasicCase\", []float64{1.0, 2.0, 3.0}, 2.5, 1},\n\t\t{\"AtLowerBound\", []float64{1.0, 2.0, 3.0}, 1.0, 0},\n\t\t{\"AtUpperBound\", []float64{1.0, 2.0, 3.0}, 3.0, 2},\n\t\t{\"ValueOutsideUpper\", []float64{1.0, 2.0, 3.0}, 4.0, 2},\n\t\t{\"ValueOutsideLower\", []float64{1.0, 2.0, 3.0}, 0.5, 0},\n\t\t{\"NegativeValues\", []float64{-3.0, -2.0, -1.0}, -2.5, 0},\n\t\t{\"NaNValue\", []float64{1.0, 2.0, 3.0}, math.NaN(), -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.slice, tt.value); got != tt.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v; want %v\", tt.slice, tt.value, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for short slice\")\n\t\t\t}\n\t\t}()\n\t\tWithin([]float64{1.0}, 0.0)\n\t})\n\n\tt.Run(\"PanicOnUnsortedSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for unsorted slice\")\n\t\t\t}\n\t\t}()\n\t\tWithin([]float64{3.0, 1.0, 2.0}, 2.0)\n\t})\n}","e84c735c076f2f8bd8d768404cfa6161":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\tidx int\n\t}{\n\t\t{10, 0, 100, 50, 5},\n\t\t{10, 0, 100, 0, 0},\n\t\t{10, 0, 100, 100, 9},\n\t\t{10, 0, 100, 25, 2},\n\t\t{10, -100, 0, -50, 5},\n\t\t{10, -100, -50, -75, 2},\n\t\t{10, 50, 100, 75, 2},\n\t\t{10, math.NaN(), 100, 50, 9}, // l is NaN\n\t\t{10, 0, math.NaN(), 50, 0},   // u is NaN\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0}, // Both bounds are Inf\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 0}, // u \u003c l\n\t\t{5, 0, 10, 5, 2},               // normal case\n\t\t{5, 0, 10, 9, 4},               // near upper bound\n\t\t{5, 0, 10, 1, 0},               // near lower bound\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.idx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.idx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 but did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0) // This should panic\n}","eaffafaa2e0ca1f7561e224cb9d3208c":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1},\n\t\t{\"Single element\", []float64{5}, 5},\n\t\t{\"Two elements\", []float64{2, 3}, 6},\n\t\t{\"Multiple elements\", []float64{1, 2, 3, 4}, 24},\n\t\t{\"With zero\", []float64{1, 0, 3}, 0},\n\t\t{\"Negative numbers\", []float64{2, -3, 4}, -24},\n\t\t{\"All negative\", []float64{-1, -2, -3}, -6},\n\t\t{\"Mixed numbers\", []float64{-2, 2, 1}, -4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v; want %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","eb2979221b37e0bc94da0f2b22cd5473":"// distance_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L2 norm with positive numbers\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{4.0, 5.0, 6.0},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // √((4-1)² + (5-2)² + (6-3)²)\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm with positive numbers\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{4.0, 5.0, 6.0},\n\t\t\tL:        1,\n\t\t\texpected: 9.0, // |4-1| + |5-2| + |6-3|\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity norm with positive numbers\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{4.0, 5.0, 6.0},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3.0, // max(|4-1|, |5-2|, |6-3|)\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm with negative numbers\",\n\t\t\tslice1:   []float64{-1.0, -2.0, -3.0},\n\t\t\tslice2:   []float64{-4.0, -5.0, -6.0},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27), // same as before\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm with mixed numbers\",\n\t\t\tslice1:   []float64{-1.0, 2.0, -3.0},\n\t\t\tslice2:   []float64{4.0, -5.0, 6.0},\n\t\t\tL:        1,\n\t\t\texpected: 9.0, // |-1-4| + |2+5| + |-3-6|\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.slice1, tt.slice2, tt.L)\n\t\t\tif !almostEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Distance() = %v; want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Mismatched lengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif recover() == nil {\n\t\t\t\tt.Error(\"Expected panic due to mismatched lengths, but did not panic.\")\n\t\t\t}\n\t\t}()\n\t\tDistance([]float64{1, 2, 3}, []float64{1, 2}, 2)\n\t})\n}\n\n// almostEqual checks if two float64 numbers are \"close enough\" to be considered equal.\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-9\n\treturn math.Abs(a-b) \u003c epsilon\n}","ed4c3249384c384098afcc70d1b2cbca":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{input: []float64{1.0, 2.0, 3.0}, want: 6.0},\n\t\t{input: []float64{1.1, 2.2, 3.3}, want: 6.6},\n\t\t{input: []float64{1e10, 1e10, 1e10}, want: 3e10},\n\t\t{input: []float64{-1.0, -2.0, -3.0}, want: -6.0},\n\t\t{input: []float64{1e20, 1e-20}, want: 1e20},\n\t\t{input: []float64{}, want: 0.0},\n\t\t{input: []float64{math.NaN(), 1.0}, want: math.NaN()},\n\t\t{input: []float64{math.Inf(1), 1.0}, want: math.Inf(1)},\n\t\t{input: []float64{math.Inf(-1), -1.0}, want: math.Inf(-1)},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.input)\n\t\t\tif math.IsNaN(got) \u0026\u0026 !math.IsNaN(tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t} else if !math.IsNaN(got) \u0026\u0026 !math.IsNaN(tt.want) \u0026\u0026 !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.input, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// floatEqual checks if two float64 values are approximately equal.\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-9\n}","edd6222fcf0881ddecd2e6230084c628":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"valid span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, 10)\n\t\texpected := []float64{0, 2.5, 5, 7.5, 10}\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"short slice panics\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t\t}\n\t\t}()\n\t\t_ = Span(make([]float64, 1), 0, 10)\n\t})\n\n\tt.Run(\"NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 10)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(expected[i])) || v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i, v := range result {\n\t\t\tif (math.IsNaN(v) \u0026\u0026 !math.IsNaN(expected[i])) || v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinite lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)}\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Infinite upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, 0, 0, 0, math.Inf(1)}\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Equal bounds\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 5, 5)\n\t\texpected := []float64{5, 5, 5, 5, 5}\n\t\tfor i, v := range result {\n\t\t\tif v != expected[i] {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected[i], v)\n\t\t\t}\n\t\t}\n\t})\n}","ede839d8aa21a2a990793caf464a7fa3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn, l, u, v float64\n\t\texpected   int\n\t}{\n\t\t{5, 0, 10, 5, 2},      // Middle value\n\t\t{5, 0, 10, 0, 0},      // Lower bound\n\t\t{5, 0, 10, 10, 4},     // Upper bound\n\t\t{5, -10, 0, -5, 2},    // Middle negative value\n\t\t{5, -10, -5, -6, 2},   // Inside negative range\n\t\t{5, 1, 2, 1.5, 2},     // Border case; spans are equal\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Zero case with infinities\n\t\t{3, math.Inf(-1), math.Inf(1), 10, 2}, // Zero case out of bound with infinities\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(int(test.n), test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v; want %v\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test for NaN value of v\n\tresult := NearestIdxForSpan(5, 0, 10, math.NaN())\n\tif result != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(5, 0, 10, NaN) = %v; want 0\", result)\n\t}\n}","ee11c775a2b30640658618f6276f10f9":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\ts1      []float64\n\t\ts2      []float64\n\t\ttol     float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.0},\n\t\t\ttol:     1e-5,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.1},\n\t\t\ttol:     0.1,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 4.0},\n\t\t\ttol:     0.1,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0},\n\t\t\ttol:     1e-5,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\ttol:     1e-5,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\ts1:      []float64{},\n\t\t\ts2:      []float64{},\n\t\t\ttol:     1e-5,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := EqualApprox(test.s1, test.s2, test.tol)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"EqualApprox(%v, %v, %v) = %v; expected %v\", test.s1, test.s2, test.tol, result, test.expected)\n\t\t}\n\t}\n}","eee73366a6b12e52db5a164b7574ac06":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 2\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{2, 3, 4}, // indices of 3, 4, and 5\n\t\t\terr:     nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all with k \u003c 0\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x%2 == 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3, 5}, // indices of 2, 4, and 6\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Not enough elements found\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 10\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname: \"k is zero\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{}, // should return empty slice\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\tinds: []int{},\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !equalSlices(got, tt.expected) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, tt.expected)\n\t\t\t}\n\n\t\t\tif (err == nil) != (tt.err == nil) || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"got error %v, want %v\", err, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices\nfunc equalSlices(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","ef173baae917f51659bbeea6f5a88278":"// within_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\ts     []float64\n\t\tv     float64\n\t\tindex int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 2.5, 1},\n\t\t{[]float64{1, 2, 3, 4}, 1.0, 0},\n\t\t{[]float64{1, 2, 3, 4}, 4.0, -1},\n\t\t{[]float64{1, 2, 3, 4}, 3.0, 2},\n\t\t{[]float64{1, 2, 3, 4}, 5.0, -1},\n\t\t{[]float64{1, 2, 3, 4}, 0.5, -1},\n\t\t{[]float64{math.NaN(), 1, 2, 3}, 1, -1},\n\t\t{[]float64{1, 2, 3, math.NaN()}, 2, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Within(tt.s, tt.v); got != tt.index {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d; want %d\", tt.s, tt.v, got, tt.index)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panic due to insufficient length\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for short slice but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1}) // Should panic\n\n\t// Test case for panic due to unsorted slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unsorted slice but did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{3, 1, 2}) // Should panic\n}","f000ba2650b7d541450f4670b4290607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"Valid span\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Valid span with negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      -1,\n\t\t\twant:   []float64{-5, -3, -1},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Panic on single element slice\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Panic on empty slice\",\n\t\t\tdst:    make([]float64, 0),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Span with NaN lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Span with NaN upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Span with Infinite lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Span with Infinite upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic, but did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !tt.wantPanic \u0026\u0026 !equalSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","f0b30df2d6d93e47dff67646e0ce6c10":"// nearest_idx_for_span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},                 // Middle of the span\n\t\t{5, 0, 10, 0, 0},                 // Lower bound\n\t\t{5, 0, 10, 10, 4},                // Upper bound\n\t\t{5, 0, 10, -1, 0},                // Below lower bound\n\t\t{5, 0, 10, 11, 4},                // Above upper bound\n\t\t{5, 1, 5, 3, 2},                  // Middle with different bounds\n\t\t{5, -5, 5, 0, 2},                 // Zero in negative to positive span\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Infinity bounds with zero\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 2}, // Reverse infinity bounds\n\t\t{3, 0, 0, 0, 0},                  // All values same at zero\n\t}\n\n\tfor _, tt := range tests {\n\t\tactual := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, actual, tt.expected)\n\t\t}\n\t}\n\n\t// Test for panic when n is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for NearestIdxForSpan(1, 0, 10, 5) but did not happen\")\n\t\t}\n\t}()\n\t_ = NearestIdxForSpan(1, 0, 10, 5)\n\n\t// Test for NaN value of v\n\tresult := NearestIdxForSpan(5, 0, 10, math.NaN())\n\tif result != -1 {\n\t\tt.Errorf(\"Expected -1 for NaN input, got %d\", result)\n\t}\n}","f15c3362d300b641bf4f7188dbe271b2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Valid span\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 0, 10)\n\t\texpected := []float64{0, 2.5, 5, 7.5, 10}\n\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Panics on length less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic but did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 10)\n\t})\n\n\tt.Run(\"Handles NaN values\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 10)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10}\n\n\t\tfor i, v := range expected {\n\t\t\tif math.IsNaN(result[i]) \u0026\u0026 !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t} else if result[i] != v {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Handles Inf values\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\n\t\t// l is -Inf, u is Inf\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\texpected := []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)}\n\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\n\t\t// l is Inf, u is 10\n\t\tresult = Span(dst, math.Inf(1), 10)\n\t\texpected = []float64{math.Inf(1), 10, 10, 10, 10}\n\n\t\tfor i, v := range expected {\n\t\t\tif result[i] != v {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", expected, result)\n\t\t\t}\n\t\t}\n\t})\n}","f2c99ede0b70b8c7222aa22af27455ed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1},\n\t\t{[]float64{1.0, 2.0, 3.0}, 0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2},\n\t\t{[]float64{math.NaN(), 1.0, 2.0}, 1},\n\t\t{[]float64{1.0, 2.0, math.NaN()}, 0},\n\t\t{[]float64{1.0, 1.0, 1.0}, 0},\n\t\t{[]float64{}, -1}, // This case should panic\n\t}\n\n\tfor _, test := range tests {\n\t\tif len(test.input) == 0 {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic for input: %v\", test.input)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tresult := MinIdx(test.input)\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f2d0a4e0607696b81d0f7831b78f1a69":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst     []float64\n\t\ts       []float64\n\t\tt       []float64\n\t\twant    []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tdst:     make([]float64, 3),\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\twant:    []float64{4, 10, 18},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0, 0},\n\t\t\ts:       []float64{0, 0, 0},\n\t\t\tt:       []float64{1, 2, 3},\n\t\t\twant:    []float64{0, 0, 0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2, 3},\n\t\t\tt:       []float64{4, 5, 6},\n\t\t\twant:    nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0},\n\t\t\ts:       []float64{1},\n\t\t\tt:       []float64{2},\n\t\t\twant:    []float64{2},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0, 0},\n\t\t\ts:       []float64{1, 2},\n\t\t\tt:       []float64{3},\n\t\t\twant:    nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic but did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\n\t\tif !tt.wantPanic \u0026\u0026 !equal(got, tt.want) {\n\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t}\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-9 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","f2f791bd017a2c0391ee414f8e34deb6":"// less_test.go\npackage floats\n\nimport (\n\t\"testing\"\n)\n\ntype argsort struct {\n\ts []float64\n}\n\nfunc (a argsort) Less(i, j int) bool {\n\treturn a.s[i] \u003c= a.s[j]\n}\n\nfunc TestLess(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\ti, j   int\n\t\texpect bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, 0, 1, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, 1, 0, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, 2, 1, false},\n\t\t{[]float64{1.0, 2.0, 2.0}, 1, 2, true},\n\t\t{[]float64{3.0, 2.0, 1.0}, 1, 2, false},\n\t}\n\n\tfor _, test := range tests {\n\t\ta := argsort{s: test.s}\n\t\tresult := a.Less(test.i, test.j)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"Less(%v, %d, %d) = %v; want %v\", test.s, test.i, test.j, result, test.expect)\n\t\t}\n\t}\n}","f4050e94ad42ab51bda296b51cea2843":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\tl, u   float64\n\t\texpected []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0,\n\t\t\tu:          4,\n\t\t\texpected:   []float64{0, 1, 2, 3, 4},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 3),\n\t\t\tl:          1,\n\t\t\tu:          1,\n\t\t\texpected:   []float64{1, 1, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          -1,\n\t\t\tu:          1,\n\t\t\texpected:   []float64{-1, -0.5, 0, 0.5, 1},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          2,\n\t\t\tu:          2,\n\t\t\texpected:   []float64{2, 2},\n\t\t\texpectPanic: false,\n\t\t},\n\t\t{\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0,\n\t\t\tu:          1,\n\t\t\texpected:   nil,\n\t\t\texpectPanic: true, // Should panic since length of dst \u003c 2\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.expectPanic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"expected panic for input %v, %v, %v\", tt.dst, tt.l, tt.u)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\tif !tt.expectPanic {\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc equalSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !equalFloat(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalFloat(a, b float64) bool {\n\treturn (a == b) || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}","f51a1aaeae1dd7bf0c8e26f89b8b78ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tl, u   float64\n\t\tdstLen int\n\t\twant   []float64\n\t}{\n\t\t{\n\t\t\tl:      1,\n\t\t\tu:      10,\n\t\t\tdstLen: 10,\n\t\t\twant:   []float64{1, 1.291549665014884, 1.668100537200059, 2.154434690031884, 2.782559402207126, 3.593813663804625, 4.641588834001045, 6.09075022600044, 7.742636826811269, 10},\n\t\t},\n\t\t{\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tdstLen: 10,\n\t\t\twant:   []float64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tdstLen: 10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tl:      -1,\n\t\t\tu:      10,\n\t\t\tdstLen: 10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tl:      1,\n\t\t\tu:      -10,\n\t\t\tdstLen: 10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tdst := make([]float64, tt.dstLen)\n\t\tgot := LogSpan(dst, tt.l, tt.u)\n\n\t\tfor i, v := range got {\n\t\t\tif math.IsNaN(tt.want[i]) {\n\t\t\t\tif !math.IsNaN(v) {\n\t\t\t\t\tt.Errorf(\"LogSpan(%v, %v) = %v; want NaN at index %d\", tt.l, tt.u, v, i)\n\t\t\t\t}\n\t\t\t} else if v != tt.want[i] {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %v) = %v; want %v at index %d\", tt.l, tt.u, v, tt.want[i], i)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic on dst length \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSpan must panic if dst length is less than 2\")\n\t\t}\n\t}()\n\tLogSpan(make([]float64, 1), 1, 10)\n}","f5730e5037fa3baa3a7797e3cf5e3a11":"// minidx_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{3.0, 1.0, 2.0}, 1}, // Min value is 1.0 at index 1\n\t\t{[]float64{2.0, 2.0, 2.0}, 0}, // All values are the same; return the first index\n\t\t{[]float64{1.5, 0.5, 2.5, 0.5}, 1}, // Min value is 0.5 at index 1\n\t\t{[]float64{-1.0, -2.0, -3.0}, 2}, // Min value is -3.0 at index 2\n\t\t{[]float64{math.NaN(), 1.0, math.NaN()}, 1}, // Min value is 1.0 at index 1 (ignores NaN)\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := MinIdx(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"MinIdx(%v) = %d; want %d\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for zero length slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for zero length slice but did not receive one\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}","f5bab763ada8fe7c36081efa09724629":"package floats\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst, s, expected []float64\n\t}{\n\t\t{\n\t\t\tdst:     []float64{1.0, 2.0, 3.0},\n\t\t\ts:       []float64{4.0, 5.0, 6.0},\n\t\t\texpected: []float64{5.0, 7.0, 9.0},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{0.0, 0.0},\n\t\t\ts:       []float64{1.0, 1.0},\n\t\t\texpected: []float64{1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{-1.0, -2.0, -3.0},\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tdst:     []float64{1.5, 2.5, 3.5, 4.5},\n\t\t\ts:       []float64{4.5, 3.5, 2.5, 1.5},\n\t\t\texpected: []float64{6.0, 6.0, 6.0, 6.0},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdstCopy := make([]float64, len(test.dst))\n\t\t\tcopy(dstCopy, test.dst)\n\t\t\tAdd(dstCopy, test.s)\n\t\t\tfor i, v := range dstCopy {\n\t\t\t\tif v != test.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, dstCopy)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on mismatched lengths.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Add did not panic on mismatched lengths\")\n\t\t}\n\t}()\n\tAdd([]float64{1.0, 2.0}, []float64{1.0})\n}","f609d4620b7ad1d4e4f0ba7a78ef6ae8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tpanic bool\n\t}{\n\t\t{2, 0, 10, 5, 1, false},\n\t\t{10, 0, 10, 5, 5, false},\n\t\t{10, 0, 10, 11, 9, false},  // v is outside u\n\t\t{10, 0, 10, -1, 0, false},  // v is outside l\n\t\t{10, 10, 0, 5, 5, false},    // reversed bounds\n\t\t{10, 0, 10, math.NaN(), 0, false}, // v is NaN\n\t\t{10, math.NaN(), 10, 5, 9, false}, // l is NaN\n\t\t{10, 0, math.NaN(), 5, 0, false},  // u is NaN\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5, false}, // both bounds are ±Inf\n\t\t{2, 0, 1, 0.5, 0, false},    // testing edge case\n\t\t{1, 0, 10, 5, 0, true},      // panic case: n \u003c 2\n\n\t\t// You can add additional test cases here...\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tfunc() {\n\t\t\t\tdefer func() { recover() }()\n\t\t\t\tNearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\t\tt.Errorf(\"Expected panic but did not panic for n=%d, l=%v, u=%v, v=%v\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t}()\n\t\t} else {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d; want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t}\n\t}\n}","f6c14f0baeb9d56eb54d29effcc34ad0":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ts         []float64\n\t\tv         float64\n\t\texpectIdx int\n\t\texpectPanic bool\n\t}{\n\t\t{\"valid lower bound\", []float64{1, 2, 3, 4}, 1.5, 1, false},\n\t\t{\"valid upper bound\", []float64{1, 2, 3, 4}, 3, 2, false},\n\t\t{\"valid upper limit\", []float64{1, 2, 3, 4}, 4, -1, false},\n\t\t{\"valid exact lower edge\", []float64{1, 2, 3, 4}, 1, 0, false},\n\t\t{\"valid exact upper edge\", []float64{1, 2, 3, 4}, 3, 2, false},\n\t\t{\"after last element\", []float64{1, 2, 3, 4}, 5, -1, false},\n\t\t{\"below first element\", []float64{1, 2, 3, 4}, 0, -2, false},\n\t\t{\"NaN value\", []float64{1, 2, 3, 4}, math.NaN(), -2, false},\n\t\t{\"panic on short span\", []float64{1}, 1.5, -1, true}, // len(s) \u003c 2\n\t\t{\"panic on unsorted input\", []float64{2, 1, 3, 4}, 2, -1, true}, // not sorted\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"expected panic for input %v and %v, but didn't\", tt.s, tt.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tidx := Within(tt.s, tt.v)\n\n\t\t\tif idx != tt.expectIdx {\n\t\t\t\tt.Errorf(\"expected index %d, got %d\", tt.expectIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}","f8164ef3c4d50b252e6a8135c40a0ab5":"// file: log_sum_exp_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t// Test with a typical case\n\t\t{[]float64{1, 2, 3}, math.Log(math.Exp(1) + math.Exp(2) + math.Exp(3))}, \n\n\t\t// Test with negative numbers\n\t\t{[]float64{-1, -2, -3}, math.Log(math.Exp(-1) + math.Exp(-2) + math.Exp(-3))},\n\n\t\t// Test with a mix of positive and negative numbers\n\t\t{[]float64{-1, 0, 1}, math.Log(math.Exp(-1) + math.Exp(0) + math.Exp(1))},\n\n\t\t// Test with large values\n\t\t{[]float64{1000, 1001, 1002}, math.Log(math.Exp(1000) + math.Exp(1001) + math.Exp(1002))},\n\n\t\t// Test with small values\n\t\t{[]float64{-1000, -1001, -1002}, math.Log(math.Exp(-1000) + math.Exp(-1001) + math.Exp(-1002))},\n\n\t\t// Test with a single value\n\t\t{[]float64{5}, 5},\n\n\t\t// Test with infinity\n\t\t{[]float64{math.Inf(1)}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1)}, math.Inf(-1)},\n\t\t\n\t\t// Test with an empty slice to ensure it panics\n\t}\n\n\tfor _, test := range tests {\n\t\tif len(test.input) == 0 {\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif recover() == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for input: %#v\", test.input)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tLogSumExp(test.input)\n\t\t\t}()\n\t\t} else {\n\t\t\tresult := LogSumExp(test.input)\n\t\t\tif !almostEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"For input: %#v, expected: %v, got: %v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function to compare float64 values for equality within a tolerance\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-10\n\treturn math.Abs(a-b) \u003c epsilon\n}","f8a59234d5fba12b9c07d35cf59640d8":"package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\texpected []float64\n\t\tinds     []int\n\t\texpectedInds []int\n\t}{\n\t\t{\n\t\t\tdst:      []float64{3.0, 1.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 3.0},\n\t\t\tinds:     []int{0, 0, 0}, // need to initialize inds to the same length as dst\n\t\t\texpectedInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{10.0, 1.0, 5.0, 2.0},\n\t\t\texpected: []float64{1.0, 2.0, 5.0, 10.0},\n\t\t\tinds:     []int{0, 0, 0, 0},\n\t\t\texpectedInds: []int{1, 3, 2, 0},\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{-2.0, -1.0, 0.0, 1.0},\n\t\t\texpected: []float64{-2.0, -1.0, 0.0, 1.0},\n\t\t\tinds:     []int{0, 0, 0, 0},\n\t\t\texpectedInds: []int{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Initialize inds with the correct size\n\t\tinds := make([]int, len(test.dst))\n\t\tfor i := range inds {\n\t\t\tinds[i] = i\n\t\t}\n\n\t\t// Call Argsort\n\t\tArgsort(test.dst, inds)\n\n\t\t// Check dst and inds against expected values\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, test.dst)\n\t\t}\n\t\tif !reflect.DeepEqual(inds, test.expectedInds) {\n\t\t\tt.Errorf(\"expected %v, got %v\", test.expectedInds, inds)\n\t\t}\n\t}\n}","fbcec84a399d16e857a04dd4101ba926":"// span_test.go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\tl, u   float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      4,\n\t\t\tresult: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      1,\n\t\t\tu:      1,\n\t\t\tresult: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 10),\n\t\t\tl:      0,\n\t\t\tu:      9,\n\t\t\tresult: []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t},\n\t\t{\n\t\t\tdst:    make([]float64, 4),\n\t\t\tl:      -4,\n\t\t\tu:      0,\n\t\t\tresult: []float64{-4, -3, -2, -1},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tfor i, v := range got {\n\t\t\tif v != test.result[i] {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v; want %v\", test.dst, test.l, test.u, got, test.result)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic for len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for Span with dst length \u003c 2, but did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test special case with NaN\n\tdst := make([]float64, 5)\n\tspanResult := Span(dst, math.NaN(), 5)\n\tfor i, v := range spanResult {\n\t\tif i \u003c 4 \u0026\u0026 !math.IsNaN(v) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, v)\n\t\t}\n\t\tif i == 4 \u0026\u0026 v != 5 {\n\t\t\tt.Errorf(\"Expected 5 at the last index, got %v\", v)\n\t\t}\n\t}\n\n\t// Test special case with Inf\n\tdst = make([]float64, 3)\n\tspanResult = Span(dst, math.Inf(-1), 1)\n\texpectedResult := []float64{math.Inf(-1), math.Inf(-1), 1}\n\tfor i, v := range spanResult {\n\t\tif v != expectedResult[i] {\n\t\t\tt.Errorf(\"For Inf test: expected %v at index %d, got %v\", expectedResult[i], i, v)\n\t\t}\n\t}\n}","fdddd85e91abddc251b9da767bee01fa":"// File: addto_test.go\n\npackage floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\tpanic    bool\n\t}{\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{5, 7, 9},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{3, 4},\n\t\t\texpected: []float64{4, 6},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{3, 4},\n\t\t\texpected: nil, // Should panic\n\t\t\tpanic:    true,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{0},\n\t\t\ts:        []float64{5},\n\t\t\tt:        []float64{10},\n\t\t\texpected: []float64{15},\n\t\t\tpanic:    false,\n\t\t},\n\t\t{\n\t\t\tdst:      []float64{},\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: nil, // Should panic\n\t\t\tpanic:    true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif tt.panic {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic, but did not panick\")\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tresult := AddTo(tt.dst, tt.s, tt.t)\n\t\tif !tt.panic \u0026\u0026 !equal(result, tt.expected) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; expected %v\", tt.dst, tt.s, tt.t, result, tt.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare slices\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","fe478ab38e642e30157bc134e5ad80b3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 2, 1}, // Middle of the range\n\t\t{5, 0, 10, -1, 0}, // Below the range\n\t\t{5, 0, 10, 11, 4}, // Above the range\n\t\t{5, 0, 10, 10, 4}, // Upper bound\n\t\t{5, 0, 10, 0, 0},  // Lower bound\n\t\t{5, -5, 5, 0, 2},  // Middle of a negative to positive range\n\t\t{3, -3, 3, -1, 1}, // Negative range, closer to zero\n\t\t{3, -3, -1, -2, 1}, // Negative range, negative value\n\t\t{3, 1, 3, 1, 0},   // Lower bound at positive limit\n\t\t{3, 1, 3, 3, 2},   // Upper bound at positive limit\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1}, // Inf range\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 0}, // Negative Inf range\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.expect {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t}\n\t}\n\n\t// Test panic for invalid input\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2 did not occur\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5) // This should panic\n}","fffbfad0db7ae393fa0704ea9b316d33":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{5, 0, 10, 5, 2},     // Test in the middle\n\t\t{5, 0, 10, 0, 0},     // Test at lower bound\n\t\t{5, 0, 10, 10, 4},    // Test at upper bound\n\t\t{5, 0, 10, -1, 0},    // Test below lower bound\n\t\t{5, 0, 10, 11, 4},    // Test above upper bound\n\t\t{3, -5, 5, 0, 1},     // Test with negative bounds\n\t\t{3, -5, -1, -3, 1},   // Test with negative v inside bounds\n\t\t{3, -5, -1, -6, 0},   // Test with negative v outside lower bound\n\t\t{3, -5, -1, 0, 2},    // Test with positive v outside upper bound\n\t\t{5, math.NaN(), 5, 3, 4}, // Test NaN lower bound\n\t\t{5, 0, math.NaN(), 3, 0}, // Test NaN upper bound\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // Test +/- Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // Test v == -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // Test v == Inf\n\t\t{2, 0, 1, 0.5, 0}, // Edge case: n==2\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(test.n, test.l, test.u, test.v); got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d; want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}"}