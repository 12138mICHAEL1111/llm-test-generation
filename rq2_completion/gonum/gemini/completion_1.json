{
    "0026966f482687b357882089f4e9ee0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// n = 2\n\tif out := NearestIdxForSpan(2, 0, 1, 0.1); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(2, 0, 1, 0.1) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(2, 0, 1, 0.9); out != 1 {\n\t\tt.Errorf(\"NearestIdxForSpan(2, 0, 1, 0.9) = %v, want %v\", out, 1)\n\t}\n\n\t// n = 3\n\tif out := NearestIdxForSpan(3, 0, 1, 0.1); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 1, 0.1) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(3, 0, 1, 0.4); out != 1 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 1, 0.4) = %v, want %v\", out, 1)\n\t}\n\tif out := NearestIdxForSpan(3, 0, 1, 0.6); out != 1 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 1, 0.6) = %v, want %v\", out, 1)\n\t}\n\tif out := NearestIdxForSpan(3, 0, 1, 0.9); out != 2 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 1, 0.9) = %v, want %v\", out, 2)\n\t}\n\n\t// n = 4, l = -1, u = 1\n\tif out := NearestIdxForSpan(4, -1, 1, -1.1); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -1, 1, -1.1) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(4, -1, 1, -0.6); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -1, 1, -0.6) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(4, -1, 1, -0.4); out != 1 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -1, 1, -0.4) = %v, want %v\", out, 1)\n\t}\n\tif out := NearestIdxForSpan(4, -1, 1, 0.4); out != 2 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -1, 1, 0.4) = %v, want %v\", out, 2)\n\t}\n\tif out := NearestIdxForSpan(4, -1, 1, 0.6); out != 3 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -1, 1, 0.6) = %v, want %v\", out, 3)\n\t}\n\tif out := NearestIdxForSpan(4, -1, 1, 1.1); out != 3 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -1, 1, 1.1) = %v, want %v\", out, 3)\n\t}\n\n\t// Test cases for Inf and NaN.\n\tif out := NearestIdxForSpan(3, math.NaN(), 1, 0.5); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, NaN, 1, 0.5) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(3, 0, math.NaN(), 0.5); out != 2 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, NaN, 0.5) = %v, want %v\", out, 2)\n\t}\n\tif out := NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0.5); out != 1 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, -Inf, Inf, 0.5) = %v, want %v\", out, 1)\n\t}\n\tif out := NearestIdxForSpan(4, math.Inf(-1), math.Inf(1), 0.5); out != 1 {\n\t\tt.Errorf(\"NearestIdxForSpan(4, -Inf, Inf, 0.5) = %v, want %v\", out, 1)\n\t}\n\n\t// Test cases for v outside (l, u).\n\tif out := NearestIdxForSpan(3, 0, 1, -0.5); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 1, -0.5) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(3, 0, 1, 1.5); out != 2 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 0, 1, 1.5) = %v, want %v\", out, 2)\n\t}\n\n\t// Test cases for v outside (u, l).\n\tif out := NearestIdxForSpan(3, 1, 0, 1.5); out != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 1, 0, 1.5) = %v, want %v\", out, 0)\n\t}\n\tif out := NearestIdxForSpan(3, 1, 0, -0.5); out != 2 {\n\t\tt.Errorf(\"NearestIdxForSpan(3, 1, 0, -0.5) = %v, want %v\", out, 2)\n\t}\n\n\t// Test cases for floating point weirdness.\n\tif out := NearestIdxForSpan(1000, 0, 1, 0.5); math.Abs(float64(out)-499.5) \u003e tol {\n\t\tt.Errorf(\"NearestIdxForSpan(1000, 0, 1, 0.5) = %v, want %v\", out, 499.5)\n\t}\n}\n",
    "00ff8da04f0e838382a81a82fbe07efe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases: different slices and L values\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4}, 3.5, 4.696395639884438},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Loop through test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the norm using the function being tested\n\t\tgot := Norm(tc.s, tc.L)\n\n\t\t// Compare the calculated norm with the expected value\n\t\tif math.Abs(got-tc.want) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Test case %d failed: Norm(%v, %v) = %v, want %v\", i, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}\n",
    "013e5ee407fb258d6a8c3fda98af7c6a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Regular span\n\tdst := make([]float64, 5)\n\tl := 0.0\n\tu := 1.0\n\tgot := Span(dst, l, u)\n\twant := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tfor i := range got {\n\t\tif got[i] != want[i] {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 2: Span with NaN for lower bound\n\tdst = make([]float64, 4)\n\tl = math.NaN()\n\tu = 2.0\n\tgot = Span(dst, l, u)\n\twant = []float64{math.NaN(), math.NaN(), math.NaN(), 2.0}\n\tfor i := range got {\n\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 3: Span with NaN for upper bound\n\tdst = make([]float64, 4)\n\tl = 0.0\n\tu = math.NaN()\n\tgot = Span(dst, l, u)\n\twant = []float64{0.0, math.NaN(), math.NaN(), math.NaN()}\n\tfor i := range got {\n\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 4: Span with both bounds as +Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(1)\n\tu = math.Inf(1)\n\tgot = Span(dst, l, u)\n\twant = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tfor i := range got {\n\t\tif math.IsInf(got[i], 1) != math.IsInf(want[i], 1) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 5: Span with both bounds as -Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(-1)\n\tu = math.Inf(-1)\n\tgot = Span(dst, l, u)\n\twant = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\tfor i := range got {\n\t\tif math.IsInf(got[i], -1) != math.IsInf(want[i], -1) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 6: Span with lower bound as +Inf\n\tdst = make([]float64, 4)\n\tl = math.Inf(1)\n\tu = 2.0\n\tgot = Span(dst, l, u)\n\twant = []float64{math.Inf(1), math.Inf(1), math.Inf(1), 2.0}\n\tfor i := range got {\n\t\tif math.IsInf(got[i], 1) != math.IsInf(want[i], 1) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 7: Span with upper bound as +Inf\n\tdst = make([]float64, 4)\n\tl = 0.0\n\tu = math.Inf(1)\n\tgot = Span(dst, l, u)\n\twant = []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1)}\n\tfor i := range got {\n\t\tif math.IsInf(got[i], 1) != math.IsInf(want[i], 1) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 8: Span with lower bound as -Inf\n\tdst = make([]float64, 4)\n\tl = math.Inf(-1)\n\tu = 2.0\n\tgot = Span(dst, l, u)\n\twant = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 2.0}\n\tfor i := range got {\n\t\tif math.IsInf(got[i], -1) != math.IsInf(want[i], -1) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n\t// Test case 9: Span with upper bound as -Inf\n\tdst = make([]float64, 4)\n\tl = 0.0\n\tu = math.Inf(-1)\n\tgot = Span(dst, l, u)\n\twant = []float64{0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\tfor i := range got {\n\t\tif math.IsInf(got[i], -1) != math.IsInf(want[i], -1) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f)[%d] = %f, want %f\", dst, l, u, i, got[i], want[i])\n\t\t}\n\t}\n\n}",
    "0215348bb87bbfbf266f19937ec2247e": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestSub(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\ts:    []float64{1, 3, 4, 2},\n\t\t\tt:    []float64{0, 2, 1, 1},\n\t\t\twant: []float64{1, 1, 3, 1},\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, -1, 0.5, -0.5},\n\t\t\tt:    []float64{-1, -1, -1, -1},\n\t\t\twant: []float64{2, 0, 1.5, 0.5},\n\t\t},\n\t} {\n\t\tdst := make([]float64, len(test.s))\n\t\tcopy(dst, test.s)\n\t\tSub(dst, test.t)\n\t\tif !testlapack.EqualApprox(dst, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Case %v: unexpected result, want %v, got %v\", i, test.want, dst)\n\t\t}\n\t}\n\t// Test panic\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"Did not panic with mismatched lengths\")\n\t\t}\n\t}()\n\tSub([]float64{1}, nil)\n}",
    "028e90cbce778d1961c87aa647c65dad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor _, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 0, 10, 10, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, 10, 0},\n\n\t\t// Cases where v is outside the range [l, u] or [u, l].\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, -1, 9},\n\t\t{10, 1, 0, 2, 0},\n\n\t\t// Cases with NaN and Inf.\n\t\t{10, math.NaN(), 1, 0, 9},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", test.n, test.l, test.u, test.v, have, test.want)\n\t\t}\n\n\t\t// Test against the naive implementation.\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\twant := naiveNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", test.n, test.l, test.u, test.v, got, want)\n\t\t}\n\t}\n}\n\nfunc naiveNearestIdxForSpan(n int, l, u, v float64) int {\n\ts := make([]float64, n)\n\tSpan(s, l, u)\n\treturn NearestIdx(s, v)\n}",
    "02c76544e44aa50c3890e81b07f8e90f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"EmptySlice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaNValue\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"PositiveInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"NegativeInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"ExactMatch\", args{[]float64{1, 2, 3}, 2}, 1},\n\t\t{\"NearestMatch\", args{[]float64{1, 2, 3}, 1.1}, 0},\n\t\t{\"MultipleNearestMatches\", args{[]float64{1, 2, 2, 3}, 1.9}, 1},\n\t\t{\"NaNInSlice\", args{[]float64{1, math.NaN(), 3}, 2}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"EmptySlice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked unexpectedly\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "02d05743532d1daecf41e66d43e30cae": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Closer to the first element\n\n\t\t// Cases with NaN and Inf\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\n\t\t// Cases with v outside (l, u)\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Cases with l \u003e u\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tgotIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif gotIdx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, gotIdx, tc.expectedIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\n// sf is a helper function to format strings.\nfunc sf(format string, a ...any) string {\n\treturn fmt.Sprintf(format, a...)\n}\n",
    "02dace20380755f8b679152b01cb1c37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"LargeRange\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    100.0,\n\t\t\twant: []float64{0.0, 50.0, 100.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-10 {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for special cases (Inf and NaN).\n\tspecialCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInfinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfiniteLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfiniteUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tc := range specialCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when dst length is less than 2.\n\tt.Run(\"PanicsOnShortDst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n",
    "02fbbeaf9207bbe077f089b5539b257d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slice contents.\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2, math.Sqrt(55)},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 1, 15},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 2, math.Sqrt(55)},\n\t\t{[]float64{-1, -2, -3, -4, -5}, math.Inf(1), 5},\n\t\t{[]float64{1, -2, 3, -4, 5}, 1, 15},\n\t\t{[]float64{1, -2, 3, -4, 5}, 2, math.Sqrt(55)},\n\t\t{[]float64{1, -2, 3, -4, 5}, math.Inf(1), 5},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over the test cases and compare the expected and actual results.\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.want, got)\n\t\t}\n\t}\n}",
    "0448c285f2fcbc79b86a5077593f1471": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tif !EqualApprox(test.want, have, tol) {\n\t\t\tt.Errorf(\"Case %d: Expected %v, got %v\", i, test.want, have)\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tfor j := range have {\n\t\t\tif !match(have[j], test.want[j]) {\n\t\t\t\tt.Errorf(\"Case %d: Expected %v, got %v\", i, test.want, have)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanNan(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 3.14, []float64{math.NaN(), 3.14}},\n\t\t{[]float64{0, 0}, 3.14, math.NaN(), []float64{3.14, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 3.14, []float64{math.NaN(), math.NaN(), 3.14}},\n\t\t{[]float64{0, 0, 0}, 3.14, math.NaN(), []float64{3.14, math.NaN(), math.NaN()}},\n\t} {\n\t\thave := Span(test.dst, test.l, test.u)\n\t\tfor j := range have {\n\t\t\tif !match(have[j], test.want[j]) {\n\t\t\t\tt.Errorf(\"Case %d: Expected %v, got %v\", i, test.want, have)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc match(a, b float64) bool {\n\tif math.IsNaN(a) {\n\t\treturn math.IsNaN(b)\n\t}\n\treturn a == b\n}\n",
    "0481378a1b09214b71ea7267f94d33e1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, test := range []struct {\n\t\ts        []float64\n\t\twant     int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\ts:        nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{0, 1, 2, 3},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{3, 2, 1, 0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{0, 1, 0, 3},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{3, 0, 1, 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{math.NaN(), 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tif test.wantPanic {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"MinIdx(%v) did not panic\", test.s)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", test.s, got, test.want)\n\t\t}\n\n\t}\n\n}",
    "049bf5e147c76a4cefac4edd03539ef1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases with n = 10, l = -5, u = 5\n\tn, l, u := 10, -5.0, 5.0\n\ttestCases := []struct {\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{-math.Inf(), 0},\n\t\t{-5.1, 0},\n\t\t{-5.0, 0},\n\t\t{-4.9, 0},\n\t\t{-2.5, 2},\n\t\t{0.0, 5},\n\t\t{2.5, 7},\n\t\t{4.9, 9},\n\t\t{5.0, 9},\n\t\t{5.1, 9},\n\t\t{math.Inf(1), 9},\n\t\t{math.NaN(), 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(n=%v, l=%v, u=%v, v=%v) = %v, want %v\", n, l, u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases with n = 5, l = 10, u = 20\n\tn, l, u = 5, 10.0, 20.0\n\ttestCases = []struct {\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{9.9, 0},\n\t\t{10.0, 0},\n\t\t{12.5, 1},\n\t\t{15, 2},\n\t\t{17.5, 3},\n\t\t{20, 4},\n\t\t{20.1, 4},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(n=%v, l=%v, u=%v, v=%v) = %v, want %v\", n, l, u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases with  l \u003e u\n\tn, l, u = 10, 5.0, -5.0\n\ttestCases = []struct {\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{-math.Inf(), 9},\n\t\t{-5.1, 9},\n\t\t{-5.0, 9},\n\t\t{-4.9, 9},\n\t\t{-2.5, 7},\n\t\t{0.0, 5},\n\t\t{2.5, 2},\n\t\t{4.9, 0},\n\t\t{5.0, 0},\n\t\t{5.1, 0},\n\t\t{math.Inf(1), 0},\n\t\t{math.NaN(), 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(n=%v, l=%v, u=%v, v=%v) = %v, want %v\", n, l, u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases with special values for l and u\n\tn = 10\n\ttestCases = []struct {\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{math.Inf(1), math.Inf(1), 0.0, 0},\n\t\t{math.Inf(1), math.Inf(-1), 1.0, 9},\n\t\t{math.Inf(-1), math.Inf(1), -1.0, 0},\n\t\t{math.NaN(), 0.0, 0.0, 9},\n\t\t{0.0, math.NaN(), 0.0, 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(n=%v, l=%v, u=%v, v=%v) = %v, want %v\", n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "0509e0638a4b45d441f01d4ba3e331eb": "package floats\n\nimport \"testing\"\n\nfunc TestScale(t *testing.T) {\n\t// Test cases.\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tc    float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple\",\n\t\t\tc:    2.0,\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\twant: []float64{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tname: \"Empty\",\n\t\t\tc:    2.0,\n\t\t\tdst:  []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\tc:    0,\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\twant: []float64{0, 0, 0},\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tScale(tc.c, tc.dst)\n\t\t\tfor i, want := range tc.want {\n\t\t\t\tif got := tc.dst[i]; got != want {\n\t\t\t\t\tt.Errorf(\"Scale() dst[%d] = %v, want %v\", i, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "078c692d78e6f34adcf892727898b8a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Span should panic if the length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when dst length is less than 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n\n\t// Test cases for normal input\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{make([]float64, 2), 0, 1, []float64{0, 1}},\n\t\t{make([]float64, 3), 0, 1, []float64{0, 0.5, 1}},\n\t\t{make([]float64, 4), 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{make([]float64, 5), 1, 3, []float64{1, 1.5, 2, 2.5, 3}},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tfor j := range got {\n\t\t\tif math.Abs(got[j]-tc.want[j]) \u003e 1e-14 {\n\t\t\t\tt.Errorf(\"Test case %v fail, got %v, want %v\", i, got, tc.want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for NaN input\n\tnanCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{make([]float64, 2), math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{make([]float64, 3), 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t}\n\tfor i, tc := range nanCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tfor j := range got {\n\t\t\tif j == len(got)-1 {\n\t\t\t\t// Check last element\n\t\t\t\tif math.IsNaN(got[j]) != math.IsNaN(tc.want[j]) {\n\t\t\t\t\tt.Errorf(\"Test case %v fail, got %v, want %v\", i, got, tc.want)\n\t\t\t\t}\n\t\t\t} else if !math.IsNaN(got[j]) {\n\t\t\t\tt.Errorf(\"Test case %v fail, got %v, want %v\", i, got, tc.want)\n\t\t\t}\n\t\t}\n\t}\n}",
    "07a3669a4df39454690361c55d14ee12": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 2, i: 1},\n\t\t{n: 3, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, i: 2},\n\n\t\t{n: 2, l: 1, u: -1, v: -2, i: 1},\n\t\t{n: 2, l: 1, u: -1, v: 0, i: 1},\n\t\t{n: 2, l: 1, u: -1, v: 2, i: 0},\n\t\t{n: 3, l: 1, u: -1, v: -2, i: 2},\n\t\t{n: 3, l: 1, u: -1, v: -1, i: 2},\n\t\t{n: 3, l: 1, u: -1, v: 0, i: 1},\n\t\t{n: 3, l: 1, u: -1, v: 1, i: 0},\n\t\t{n: 3, l: 1, u: -1, v: 2, i: 0},\n\n\t\t{n: 10, l: -1, u: 1, v: -1.1, i: 0},\n\t\t{n: 10, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 10, l: -1, u: 1, v: -0.9, i: 0},\n\t\t{n: 10, l: -1, u: 1, v: -0.6, i: 2},\n\t\t{n: 10, l: -1, u: 1, v: -0.5, i: 2},\n\t\t{n: 10, l: -1, u: 1, v: -0.4, i: 3},\n\t\t{n: 10, l: -1, u: 1, v: 0, i: 5},\n\t\t{n: 10, l: -1, u: 1, v: 0.4, i: 7},\n\t\t{n: 10, l: -1, u: 1, v: 0.5, i: 7},\n\t\t{n: 10, l: -1, u: 1, v: 0.6, i: 8},\n\t\t{n: 10, l: -1, u: 1, v: 0.9, i: 9},\n\t\t{n: 10, l: -1, u: 1, v: 1, i: 9},\n\t\t{n: 10, l: -1, u: 1, v: 1.1, i: 9},\n\t} {\n\t\ttest.Expect(t, NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v), tc.i, \"n=%d, l=%v, u=%v, v=%v\",\n\t\t\ttc.n, tc.l, tc.u, tc.v)\n\t}\n}\n\nfunc TestNearestIdxForSpanInf(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: -1, i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: -1, i: 2},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, i: 2},\n\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 1, i: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 1, i: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, i: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 2},\n\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), i: 2},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t} {\n\t\ttest.Expect(t, NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v), tc.i, \"n=%d, l=%v, u=%v, v=%v\",\n\t\t\ttc.n, tc.l, tc.u, tc.v)\n\t}\n}\n\nfunc TestNearestIdxForSpanNaN(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 0, v: math.NaN(), i: 0},\n\t\t{n: 2, l: math.NaN(), u: 0, v: 0, i: 1},\n\t\t{n: 3, l: math.NaN(), u: 0, v: math.NaN(), i: 0},\n\t\t{n: 3, l: math.NaN(), u: 0, v: 0, i: 2},\n\n\t\t{n: 2, l: 0, u: math.NaN(), v: math.NaN(), i: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, i: 0},\n\t\t{n: 3, l: 0, u: math.NaN(), v: math.NaN(), i: 0},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 0, i: 0},\n\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN(), i: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, i: 0},\n\t\t{n: 3, l: math.NaN(), u: math.NaN(), v: math.NaN(), i: 0},\n\t\t{n: 3, l: math.NaN(), u: math.NaN(), v: 0, i: 0},\n\t} {\n\t\ttest.Expect(t, NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v), tc.i, \"n=%d, l=%v, u=%v, v=%v\",\n\t\t\ttc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "082fe751a23930a68a019f44025e09cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.5, 0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerInf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperInf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"ShortSpanPanic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with dst length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n\nconst eps = 1e-10\n\nfunc closeEnough(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c eps\n}",
    "08367c21374f71c8896f648b0805835b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that the returned slice has the correct values and that\n\t// the destination is correctly mutated.\n\tfor i, c := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t}{\n\t\t{5, 0, 1},\n\t\t{10, 1, 5},\n\t\t{7, -1, 1},\n\t\t{5, -10, -1},\n\t\t{11, -5, 5},\n\t\t{1, 1, 1},\n\t\t{2, 1, 1},\n\t\t{3, 1, 1},\n\t} {\n\t\tdst := make([]float64, c.n)\n\t\tact := Span(dst, c.l, c.u)\n\n\t\t// Make sure the slice was mutated.\n\t\tif dst != act {\n\t\t\tt.Errorf(\"Case %v: did not mutate dst\", i)\n\t\t}\n\n\t\t// Check the length.\n\t\tif len(dst) != c.n {\n\t\t\tt.Errorf(\"Case %v: unexpected length got %v want %v\", i, len(dst), c.n)\n\t\t}\n\n\t\t// Check the endpoints\n\t\tif dst[0] != c.l || dst[c.n-1] != c.u {\n\t\t\tt.Errorf(\"Case %v: incorrect endpoints got [%v,%v] want [%v,%v]\", i, dst[0], dst[c.n-1], c.l, c.u)\n\t\t}\n\n\t\t// Check that elements are equally spaced.\n\t\tstep := 0.0\n\t\tif c.n \u003e 2 {\n\t\t\tstep = (c.u - c.l) / float64(c.n-1)\n\t\t}\n\t\tfor j := 1; j \u003c c.n; j++ {\n\t\t\twant := c.l + float64(j)*step\n\t\t\tif dst[j] != want {\n\t\t\t\tt.Errorf(\"Case %v: unexpected element at %v: got %v want %v\", i, j, dst[j], want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Verify that a panic occurs when n \u003c 2\n\tfor i, c := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t}{\n\t\t{0, 0, 1},\n\t\t{1, 1, 5},\n\t} {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Case %v: did not panic with n = %v\", i, c.n)\n\t\t\t}\n\t\t}()\n\n\t\tdst := make([]float64, c.n)\n\t\tSpan(dst, c.l, c.u)\n\t}\n}\n\n// Test various special cases for the Span function.\nfunc TestSpanSpecial(t *testing.T) {\n\t// l = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 2)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 2 {\n\t\t\tt.Errorf(\"Expected last element to be 2, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// u = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, math.NaN())\n\t\tif dst[0] != 1 {\n\t\t\tt.Errorf(\"Expected first element to be 1, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i+1]) {\n\t\t\t\tt.Errorf(\"Expected NaN at %d, got %v\", i+1, dst[i+1])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf, u = Inf (same sign)\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf, u = Inf (opposite sign)\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tfor i := range dst[len(dst)/2:] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 2)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at %d, got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 2 {\n\t\t\tt.Errorf(\"Expected last element to be 2, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// u = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, math.Inf(-1))\n\t\tif dst[0] != 1 {\n\t\t\tt.Errorf(\"Expected first element to be 1, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i+1], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at %d, got %v\", i+1, dst[i+1])\n\t\t\t}\n\t\t}\n\t}\n}",
    "0843ef585b873a1a79ee4ad7a8360783": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d\", i, tc.want, got)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "08d82e43185b5ac68d847ab24ea6f61b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.7, 2},\n\t\t{5, -1, 1, -0.5, 1},\n\t\t{6, -1, 1, 0.5, 4},\n\t\t{7, -10, 10, -5, 1},\n\t\t{8, -10, 10, 5, 6},\n\t\t// Add more test cases here as needed.\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for special values like NaN and Inf.\n\tspecialCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, math.NaN(), 1, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 0},\n\t\t{2, math.Inf(1), 1, 0, 1},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), 1, 0, 0},\n\t\t{2, 0, math.Inf(-1), 0, 1},\n\t\t// Add more special cases here as needed.\n\t}\n\n\tfor i, tc := range specialCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Special case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tpanicCases := []struct {\n\t\tn int\n\t\tl, u, v float64\n\t}{\n\t\t{1, 0, 1, 0.5},\n\t\t{0, 0, 1, 0.5},\n\t\t{-1, 0, 1, 0.5},\n\t}\n\n\tfor i, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Panic case %d: NearestIdxForSpan(%d, %v, %v, %v) did not panic\", i, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}\n",
    "092d969bdc8d331e1383b09ae960574d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{0, 2, 3, 4}, 1, 9},\n\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3, 4}, 2, math.Sqrt(30)},\n\t\t{[]float64{-1, -2, -3, -4}, 2, math.Sqrt(30)},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\n\t\t// L = other values\n\t\t{[]float64{1, 2, 3, 4}, 3, math.Pow(100, 1.0/3.0)},\n\t\t{[]float64{1, 2, 3, 4}, 2.5, math.Pow(54.7722557505, 1.0/2.5)},\n\n\t\t// Edge cases\n\t\t{[]float64{}, 2, 0},                // Empty slice\n\t\t{[]float64{1, 2, 3, 4}, -1, -1},    // Negative L (invalid)\n\t\t{[]float64{1, 2, math.NaN()}, 2, -1}, // NaN values\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := Norm(tc.s, tc.L)\n\n\t\t// Handle invalid L values separately\n\t\tif tc.L \u003c= 0 || math.IsNaN(tc.L) {\n\t\t\tif !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"Norm({s}, {L}): expected NaN, got %v\", tc.s, tc.L, result)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif !EqualApprox([]float64{result}, []float64{tc.expect}, 1e-6) {\n\t\t\tt.Errorf(\"Norm({s}, {L}): expected %v, got %v\", tc.s, tc.L, result)\n\t\t}\n\t}\n}",
    "0a4296a1d29592be5b3cbae3eddad4e4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with two elements\n\t// 4. Slice with odd number of elements\n\t// 5. Slice with even number of elements\n\t// 6. l \u003e u\n\t// 7. l = u\n\t// 8. l and u are NaN\n\t// 9. l is NaN, u is not NaN\n\t// 10. l is not NaN, u is NaN\n\t// 11. l and u are Inf\n\t// 12. l is Inf, u is not Inf\n\t// 13. l is not Inf, u is Inf\n\n\t// 1. Empty slice\n\t{\n\t\tvar dst []float64\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// 2. Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// 3. Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// 4. Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// 5. Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// 6. l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// 7. l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// 8. l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// 9. l is NaN, u is not NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif i == len(dst)-1 {\n\t\t\t\tif dst[i] != want[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 10. l is not NaN, u is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif i == 0 {\n\t\t\t\tif dst[i] != want[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 11. l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// 12. l is Inf, u is not Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// 13. l is not Inf, u is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "0a81dba7d0fdfeb9b2ee90d5fffab1ef": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor _, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{2, 0, 1, 0.1, 0},\n\t\t{2, 0, 1, 0.9, 1},\n\t\t{2, 0, 1, -1e-10, 0},\n\t\t{2, 0, 1, 1 + 1e-10, 1},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{11, 0, 1, 0.5, 5},\n\t\t{11, 0, 1, 0.4, 4},\n\t\t{11, 0, 1, 0.6, 6},\n\t\t{10, -1, 1, 0.5, 7},\n\t\t{11, -1, 1, 0.5, 6},\n\t\t{11, -1, 1, 0.4, 5},\n\t\t{11, -1, 1, 0.6, 7},\n\t\t{10, 1, -1, 0.5, 2},\n\t\t{11, 1, -1, 0.5, 3},\n\t\t{11, 1, -1, 0.4, 3},\n\t\t{11, 1, -1, 0.6, 2},\n\t\t{11, 1, 1, 1, 5},\n\t\t{10, 1, 1, 1, 4},\n\t\t{100, 0, 1, 0.37, 37},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.NaN(), 1, 0.5, 9},\n\t\t{10, 0, math.NaN(), 0.5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 1, 9},\n\t\t{11, math.Inf(-1), math.Inf(1), 1, 10},\n\t\t{10, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{11, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), 0, 4},\n\t\t{11, math.Inf(1), math.Inf(-1), 0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), 1, 0},\n\t\t{11, math.Inf(1), math.Inf(-1), 1, 0},\n\t\t{10, math.Inf(1), math.Inf(-1), -1, 9},\n\t\t{11, math.Inf(1), math.Inf(-1), -1, 10},\n\t\t{10, math.Inf(-1), 1, 1, 9},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, 0, math.Inf(-1), 0, 9},\n\t\t{10, math.Inf(1), 0, 0, 0},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t} {\n\t\ti := NearestIdxForSpan(c.n, c.l, c.u, c.v)\n\t\tif i != c.i {\n\t\t\tt.Errorf(\"Case (n, l, u, v) = (%v, %v, %v, %v): got %v, want %v\", c.n, c.l, c.u, c.v, i, c.i)\n\t\t\tcontinue\n\t\t}\n\t\tif c.n \u003c 2 {\n\t\t\tcontinue\n\t\t}\n\t\t// Check against direct calculation\n\t\ts := make([]float64, c.n)\n\t\tSpan(s, c.l, c.u)\n\t\tj := NearestIdx(s, c.v)\n\t\tif i != j {\n\t\t\tt.Errorf(\"Case (n, l, u, v) = (%v, %v, %v, %v): index from Span: %v, direct: %v\", c.n, c.l, c.u, c.v, i, j)\n\t\t\tcontinue\n\t\t}\n\t\t// Check that the identified index is actually the closest\n\t\tif math.IsNaN(s[i]) {\n\t\t\tif !math.IsNaN(c.v) {\n\t\t\t\tt.Errorf(\"Case (n, l, u, v) = (%v, %v, %v, %v): got NaN at index %v, want a real number because v is real\", c.n, c.l, c.u, c.v, i)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tdv := math.Abs(s[i] - c.v)\n\t\tfor k, sv := range s {\n\t\t\tdu := math.Abs(sv - c.v)\n\t\t\tif k != i \u0026\u0026 du \u003c dv \u0026\u0026 math.Abs(dv-du) \u003e tol*math.Max(dv, du) {\n\t\t\t\tt.Errorf(\"Case (n, l, u, v) = (%v, %v, %v, %v): element %v is closer to v than element %v\", c.n, c.l, c.u, c.v, k, i)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "0b097e9900feb8b9e641c792209cf25f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\t// Test cases for MinIdx.\n\ttype testCase struct {\n\t\ts        []float64\n\t\texpected int\n\t}\n\ttestCases := []testCase{\n\t\t{[]float64{1, 2, 3, 4, 5}, 0},\n\t\t{[]float64{5, 4, 3, 2, 1}, 4},\n\t\t{[]float64{1, 5, 2, 4, 3}, 0},\n\t\t{[]float64{1, math.NaN(), 3, 4, 5}, 0},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, 0},\n\t\t{[]float64{5, 4, 3, 2, 1, 1}, 4},\n\t}\n\t// Run the test cases.\n\tfor i, tc := range testCases {\n\t\tactual := MinIdx(tc.s)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n\t// Test case for panic when s is empty.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when s is an empty slice\")\n\t\t}\n\t}()\n\tMinIdx([]float64{})\n}",
    "0b471cefc5359254a2f629459fb3aade": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l and u are a mix of NaN and Inf\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are a mix of NaN and Inf\n\tt.Run(\"MixedNaNandInfValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.Inf(1))\n\t\tif !math.IsNaN(dst[0]) {\n\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"InfinityCases\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\tname     string\n\t\t\tn        int\n\t\t\tl, u     float64\n\t\t\texpected []float64\n\t\t}{\n\t\t\t{\n\t\t\t\tname:     \"InfMinusInf\",\n\t\t\t\tn:        5,\n\t\t\t\tl:        math.Inf(-1),\n\t\t\t\tu:        math.Inf(1),\n\t\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"InfMinusInfEven\",\n\t\t\t\tn:        4,\n\t\t\t\tl:        math.Inf(-1),\n\t\t\t\tu:        math.Inf(1),\n\t\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"InfInf\",\n\t\t\t\tn:        5,\n\t\t\t\tl:        math.Inf(1),\n\t\t\t\tu:        math.Inf(1),\n\t\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"MinusInfMinusInf\",\n\t\t\t\tn:        5,\n\t\t\t\tl:        math.Inf(-1),\n\t\t\t\tu:        math.Inf(-1),\n\t\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"MinusInfRegular\",\n\t\t\t\tn:        5,\n\t\t\t\tl:        math.Inf(-1),\n\t\t\t\tu:        1,\n\t\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 1},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"RegularInf\",\n\t\t\t\tn:        5,\n\t\t\t\tl:        0,\n\t\t\t\tu:        math.Inf(1),\n\t\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tdst := make([]float64, tc.n)\n\t\t\t\tSpan(dst, tc.l, tc.u)\n\t\t\t\tfor i := range dst {\n\t\t\t\t\tif dst[i] != tc.expected[i] {\n\t\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, dst)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n",
    "0c3582a382574f253a9d3e2de6f04b2e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\t// Test cases for slices with same length and values\n\ts1 := []float64{1.0, 2.0, math.NaN(), 4.0}\n\ts2 := []float64{1.0, 2.0, math.NaN(), 4.0}\n\tif !Same(s1, s2) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be true\", s1, s2)\n\t}\n\n\t// Test cases for slices with different lengths\n\ts3 := []float64{1.0, 2.0, 3.0}\n\ts4 := []float64{1.0, 2.0}\n\tif Same(s3, s4) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s3, s4)\n\t}\n\n\t// Test cases for slices with different values\n\ts5 := []float64{1.0, 2.0, 3.0}\n\ts6 := []float64{1.0, 2.0, 4.0}\n\tif Same(s5, s6) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s5, s6)\n\t}\n\n\t// Test cases for slices with NaN values at different positions\n\ts7 := []float64{1.0, math.NaN(), 3.0}\n\ts8 := []float64{1.0, 2.0, math.NaN()}\n\tif Same(s7, s8) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s7, s8)\n\t}\n}",
    "0cbfee12334c61b215b68e7039d3e04c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Regular case\n\tdst := make([]float64, 5)\n\tl := 1.0\n\tu := 5.0\n\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 1: Expected %v at index %v, but got %v\", expected[i], i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 2: Length of dst is less than 2\n\tdst = make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case 2: The code did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, l, u)\n\n\t// Test case 3: l is NaN\n\tdst = make([]float64, 5)\n\tl = math.NaN()\n\tu = 5.0\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Test case 3: Expected NaN at index %v, but got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 4: u is NaN\n\tdst = make([]float64, 5)\n\tl = 1.0\n\tu = math.NaN()\n\texpected = []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Test case 4: Expected NaN at index %v, but got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 5: both l and u are Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(1)\n\tu = math.Inf(1)\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Test case 5: Expected Inf at index %v, but got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 6: l is Inf\n\tdst = make([]float64, 5)\n\tl = math.Inf(1)\n\tu = 5.0\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Test case 6: Expected Inf at index %v, but got %v\", i, dst[i])\n\t\t}\n\t}\n\n\t// Test case 7: u is Inf\n\tdst = make([]float64, 5)\n\tl = 1.0\n\tu = math.Inf(1)\n\texpected = []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Test case 7: Expected Inf at index %v, but got %v\", i, dst[i])\n\t\t}\n\t}\n}",
    "0d144bb389e3e2f7fce75bb9ab4c36ba": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: {n, l, u, v, expected index}\n\tcases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t{2, 0, 1, 0.5, 0},   // Exactly in the middle\n\t\t{3, 0, 1, 0.3, 0},   // Closer to the lower bound\n\t\t{3, 0, 1, 0.7, 1},   // Closer to the upper bound\n\t\t{4, 0, 1, 0.25, 0},  // Closer to the lower bound\n\t\t{4, 0, 1, 0.75, 2},  // Closer to the upper bound\n\t\t{10, 0, 1, 0.1, 0},  // Many elements\n\t\t{10, 0, 1, 0.9, 8},  // Many elements\n\t\t{10, -1, 1, 0, 4},  // Negative lower bound\n\t\t{10, -1, 1, -0.5, 2}, // Negative value\n\t\t{2, 1, 0, 0.5, 1},   // l \u003e u\n\t\t{3, 1, 0, 0.7, 0},   // l \u003e u\n\t\t{3, 1, 0, 0.3, 2},   // l \u003e u\n\t\t{2, 0, 1, math.Inf(1), 1}, // v = Inf\n\t\t{2, 0, 1, math.Inf(-1), 0}, // v = -Inf\n\t\t{3, math.Inf(1), 0, 0.5, 0}, // l = Inf\n\t\t{3, 0, math.Inf(1), 0.5, 2}, // u = Inf\n\t\t{3, math.NaN(), 0, 0.5, 0}, // l = NaN\n\t\t{3, 0, math.NaN(), 0.5, 2}, // u = NaN\n\t\t{3, 0, 1, math.NaN(), 0}, // v = NaN\n\t}\n\n\tfor i, c := range cases {\n\t\tt.Run(string(rune(i)), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(c.n, c.l, c.u, c.v)\n\t\t\tif idx != c.expectedIdx {\n\t\t\t\tt.Errorf(\"For case %+v: Expected index %d, got %d\", c, c.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d37d4ebe8ea732945906d799178ed91": "package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"All true\",\n\t\t\targs: args{\n\t\t\t\tf: func(v float64) bool { return v \u003e 0 },\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Some true\",\n\t\t\targs: args{\n\t\t\t\tf: func(v float64) bool { return v \u003e 2 },\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"None true\",\n\t\t\targs: args{\n\t\t\t\tf: func(v float64) bool { return v \u003e 10 },\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d38cf851eedbeb3bf60880a2ff1cb98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\ts3 := []float64{1, 2}\n\ts4 := []float64{}\n\n\t// Test cases for L = 2\n\tif got, want := Distance(s1, s2, 2), 8; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = 1\n\tif got, want := Distance(s1, s2, 1), 16; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = math.Inf(1)\n\tif got, want := Distance(s1, s2, math.Inf(1)), 4; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for other L values\n\tif got, want := Distance(s1, s2, 3), math.Pow(96, 1.0/3.0); got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for empty slices\n\tif got, want := Distance(s4, s4, 2), 0; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s4, s4, got, want)\n\t}\n\n\t// Test cases for slices with different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic with different slice lengths\")\n\t\t}\n\t}()\n\tDistance(s1, s3, 2)\n}\n",
    "0e04172c6c2d5d231457bf49bbcc2001": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular floats\n\t// - l and u are NaNs\n\t// - l and u are Infs\n\t// - l or u are Infs\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsOnShortDst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular floats\n\tt.Run(\"RegularFloats\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaNs\n\tt.Run(\"NaNs\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Infs\n\tt.Run(\"Infs\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := 0; i \u003c len(dst)/2; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t\tif !math.IsInf(dst[len(dst)-i-1], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[len(dst)-i-1])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u are Infs\n\tt.Run(\"OneInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n}\n",
    "0e9561493f6229f9472a0d33b0425509": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-15\n\n\t// Test basic usage\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, 0, 1) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\t// Test with different length\n\tdst = make([]float64, 10)\n\tSpan(dst, -1, 1)\n\texpected = []float64{-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, -1, 1) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\t// Test with NaN values\n\tdst = make([]float64, 3)\n\tSpan(dst, math.NaN(), 1)\n\texpected = []float64{math.NaN(), math.NaN(), 1}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, NaN, 1) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, math.NaN())\n\texpected = []float64{0, math.NaN(), math.NaN()}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, 0, NaN) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\t// Test with Inf values\n\tdst = make([]float64, 4)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, Inf(1), Inf(-1)) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\tdst = make([]float64, 3)\n\tSpan(dst, math.Inf(1), 0)\n\texpected = []float64{math.Inf(1), math.Inf(1), 0}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, Inf(1), 0) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, math.Inf(-1))\n\texpected = []float64{0, math.Inf(-1), math.Inf(-1)}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, 0, Inf(-1)) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n\n\t// Test edge case with length 2\n\tdst = make([]float64, 2)\n\tSpan(dst, 0, 1)\n\texpected = []float64{0, 1}\n\tfor i := range dst {\n\t\tif !almostEqual(dst[i], expected[i], tol) {\n\t\t\tt.Errorf(\"Span(%v, 0, 1) returned %v, expected %v\", dst, dst, expected)\n\t\t}\n\t}\n}\n\nfunc almostEqual(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c= tol\n}\n",
    "0f3a51095de34ca23f6513dd63718b5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\t// Test that panics if dst is less than 2\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{\n\t\t\tdst: []float64{},\n\t\t\tl:   0.0,\n\t\t\tu:   1.0,\n\t\t},\n\t\t{\n\t\t\tdst: []float64{0.0},\n\t\t\tl:   0.0,\n\t\t\tu:   1.0,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tLogSpan(tc.dst, tc.l, tc.u)\n\t}\n\n\ttestCases2 := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"SimpleSpan\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1,\n\t\t\tu:    100,\n\t\t\twant: []float64{1, 10, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeValues\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    -100,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tc := range testCases2 {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := LogSpan(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !EqualWithinAbsOrRel(got[i], tc.want[i], 1e-14, 1e-14) {\n\t\t\t\t\tt.Errorf(\"Got: %v, Want: %v\", got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nconst absDiff = 1e-6\n\n// EqualWithinAbsOrRel returns true if the difference between a and b is less than absTol,\n// or the relative difference is less than relTol.\nfunc EqualWithinAbsOrRel(a, b, absTol, relTol float64) bool {\n\tif math.Abs(a-b) \u003c absTol {\n\t\treturn true\n\t}\n\n\trelativeDifference := math.Abs((a - b) / a)\n\n\treturn relativeDifference \u003c= relTol\n}",
    "0fd11dba8dbc082251b5cc7acfffe5cd": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{5, 7, 9}\n\n\tgot := AddTo(dst, s, t)\n\tassert.Equal(t, want, got)\n}",
    "10520592a0f56f200f0a6b8fc4e6f903": "package floats\n\nimport \"testing\"\n\nfunc TestEqualFunc(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\n\tif !EqualFunc(s1, s2, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be true\", s1, s2)\n\t}\n\n\tif EqualFunc(s1, s3, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be false\", s1, s3)\n\t}\n}\n",
    "11f572eb365996ad3a7cf07e62825761": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\n\t\t// L1 norm\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{-1, -2, -3}, 1, 6},\n\t\t{[]float64{1, -2, 3}, 1, 6},\n\n\t\t// L2 norm\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, -2, 3}, 2, math.Sqrt(14)},\n\n\t\t// L-infinity norm\n\t\t{[]float64{1, 2, 3}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, math.Inf(1), 3},\n\t\t{[]float64{1, -2, 3}, math.Inf(1), 3},\n\t}\n\n\t// Iterate over test cases\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "1233b208bd7b9681685f0e7a71169e0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.75, 7},\n\t\t{10, 0, 1, -0.1, 0},\n\t\t{10, 0, 1, 1.1, 9},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, 1, 0, 0.75, 2},\n\t\t{10, 1, 0, -0.1, 9},\n\t\t{10, 1, 0, 1.1, 0},\n\t\t{11, 0, 1, 0.25, 2},\n\t\t{11, 0, 1, 0.5, 5},\n\t\t{11, 0, 1, 0.75, 8},\n\t\t{11, 0, 1, -0.1, 0},\n\t\t{11, 0, 1, 1.1, 10},\n\t\t{11, 1, 0, 0.25, 8},\n\t\t{11, 1, 0, 0.5, 5},\n\t\t{11, 1, 0, 0.75, 2},\n\t\t{11, 1, 0, -0.1, 10},\n\t\t{11, 1, 0, 1.1, 0},\n\t\t{2, -1, 1, -1.1, 0},\n\t\t{2, -1, 1, -1, 0},\n\t\t{2, -1, 1, 0, 0},\n\t\t{2, -1, 1, 1, 1},\n\t\t{2, -1, 1, 1.1, 1},\n\t\t{2, 1, -1, -1.1, 1},\n\t\t{2, 1, -1, -1, 1},\n\t\t{2, 1, -1, 0, 1},\n\t\t{2, 1, -1, 1, 0},\n\t\t{2, 1, -1, 1.1, 0},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, 1, 1, 1, 0},\n\t\t{10, -1, -1, -1, 0},\n\t\t{10, 0, 0, 1, 0},\n\t\t{10, 1, 1, 0, 0},\n\t\t{10, -1, -1, 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, 0, math.Inf(1), 1, 0},\n\t\t{10, math.Inf(-1), 0, 0, 9},\n\t\t{10, math.Inf(-1), 0, -1, 9},\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Case %d - n = %v, l = %v, u = %v, v = %v: have %v, want %v\\n\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, have, test.want)\n\t\t}\n\t}\n\n\t// Test for nans\n\tfor i := 2; i \u003c 10; i++ {\n\t\tnaninds := []int{\n\t\t\tNearestIdxForSpan(i, 0, 1, math.NaN()),\n\t\t\tNearestIdxForSpan(i, 1, 0, math.NaN()),\n\t\t\tNearestIdxForSpan(i, 1, 1, math.NaN()),\n\t\t\tNearestIdxForSpan(i, 0, 0, math.NaN()),\n\t\t}\n\t\tfor _, j := range naninds {\n\t\t\tif j != 0 {\n\t\t\t\tt.Errorf(\"NaN index should be zero, got %v\", j)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "128299297328105251c94c426bd401ac": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of elements in the hypothetical span\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\"BasicCase1\", 10, 0, 10, 5, 5},\n\t\t{\"BasicCase2\", 5, 1, 6, 3.5, 2},\n\t\t{\"BasicCase3\", 7, -3, 3, -1, 2},\n\n\t\t// Edge cases\n\t\t{\"LowerBound\", 10, 0, 10, 0, 0},\n\t\t{\"UpperBound\", 10, 0, 10, 10, 9},\n\t\t{\"LessThanLowerBound\", 10, 0, 10, -1, 0},\n\t\t{\"GreaterThanUpperBound\", 10, 0, 10, 11, 9},\n\n\t\t// Special cases with Inf and NaN\n\t\t{\"InfLowerBound\", 10, math.Inf(-1), 10, 5, 0},\n\t\t{\"InfUpperBound\", 10, 0, math.Inf(1), 5, 9},\n\t\t{\"InfValue\", 10, 0, 10, math.Inf(1), 9},\n\t\t{\"NaNValue\", 10, 0, 10, math.NaN(), 0},\n\t\t{\"NaNLowerBound\", 10, math.NaN(), 10, 5, 9},\n\t\t{\"NaNUpperBound\", 10, 0, math.NaN(), 5, 0},\n\n\t\t// Cases with reversed bounds\n\t\t{\"ReversedBounds1\", 10, 10, 0, 5, 4},\n\t\t{\"ReversedBounds2\", 10, 10, 0, 11, 0},\n\t\t{\"ReversedBounds3\", 10, 10, 0, -1, 9},\n\n\t\t// Cases with equal bounds\n\t\t{\"EqualBounds\", 10, 5, 5, 5, 0},\n\t\t{\"EqualBoundsInf\", 10, math.Inf(1), math.Inf(1), 5, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tassert.Equal(t, tc.want, got, \"For span with n=%v, l=%v, u=%v, and v=%v\", tc.n, tc.l, tc.u, tc.v)\n\t\t})\n\t}\n\n\t// Test panics for n \u003c 2\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 10, 5) }, \"The code did not panic with n \u003c 2\")\n\tassert.Panics(t, func() { NearestIdxForSpan(0, 0, 10, 5) }, \"The code did not panic with n \u003c 2\")\n}\n",
    "156e9026367d2431fbba36241809755c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{dst: []float64{0, 0}, l: 0, u: 1, want: []float64{0, 1}},\n\t\t{dst: []float64{0, 0, 0}, l: 0, u: 2, want: []float64{0, 1, 2}},\n\t\t{dst: []float64{0, 0, 0, 0}, l: -1, u: 3, want: []float64{-1, 0, 1, 3}},\n\t\t{dst: []float64{0, 0, 0, 0, 0}, l: -1, u: 3, want: []float64{-1, -0.2, 0.6, 1.4, 3}},\n\n\t\t// Test cases with Infs\n\t\t{dst: []float64{0, 0}, l: math.Inf(1), u: math.Inf(1), want: []float64{math.Inf(1), math.Inf(1)}},\n\t\t{dst: []float64{0, 0}, l: math.Inf(-1), u: math.Inf(-1), want: []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{dst: []float64{0, 0}, l: math.Inf(1), u: math.Inf(-1), want: []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{dst: []float64{0, 0}, l: math.Inf(-1), u: math.Inf(1), want: []float64{math.Inf(-1), math.Inf(1)}},\n\t\t{dst: []float64{0, 0, 0}, l: math.Inf(1), u: math.Inf(1), want: []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{dst: []float64{0, 0, 0}, l: math.Inf(-1), u: math.Inf(-1), want: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{dst: []float64{0, 0, 0}, l: math.Inf(1), u: math.Inf(-1), want: []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{dst: []float64{0, 0, 0}, l: math.Inf(-1), u: math.Inf(1), want: []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{dst: []float64{0, 0, 0, 0}, l: math.Inf(1), u: math.Inf(1), want: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{dst: []float64{0, 0, 0, 0}, l: math.Inf(-1), u: math.Inf(-1), want: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{dst: []float64{0, 0, 0, 0}, l: math.Inf(1), u: math.Inf(-1), want: []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t\t{dst: []float64{0, 0, 0, 0}, l: math.Inf(-1), u: math.Inf(1), want: []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)}},\n\n\t\t{dst: []float64{0, 0, 0}, l: math.Inf(-1), u: 1, want: []float64{math.Inf(-1), math.Inf(-1), 1}},\n\t\t{dst: []float64{0, 0, 0}, l: 0, u: math.Inf(-1), want: []float64{0, math.Inf(-1), math.Inf(-1)}},\n\n\t\t// Test cases with NaN\n\t\t{dst: []float64{0, 0}, l: math.NaN(), u: math.NaN(), want: []float64{math.NaN(), math.NaN()}},\n\t\t{dst: []float64{0, 0}, l: math.NaN(), u: 1, want: []float64{math.NaN(), 1}},\n\t\t{dst: []float64{0, 0}, l: 1, u: math.NaN(), want: []float64{1, math.NaN()}},\n\t\t{dst: []float64{0, 0, 0}, l: math.NaN(), u: math.NaN(), want: []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t{dst: []float64{0, 0, 0}, l: math.NaN(), u: 1, want: []float64{math.NaN(), math.NaN(), 1}},\n\t\t{dst: []float64{0, 0, 0}, l: 1, u: math.NaN(), want: []float64{1, math.NaN(), math.NaN()}},\n\t} {\n\t\tSpan(tc.dst, tc.l, tc.u)\n\t\tif !test.Same(tc.dst, tc.want) {\n\t\t\tt.Errorf(\"unexpected result for test case %d: got %v, want %v\", i, tc.dst, tc.want)\n\t\t}\n\t}\n}\n\n// This test ensures that it is safe to take the address of the return value\nfunc TestSpanReturn(t *testing.T) {\n\ts := Span([]float64{0, 0}, 0, 1)\n\ttest.CheckSame(t, []float64{0, 1}, s)\n}",
    "16389cca552661e959b771ae10933bd1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Single element slice\n\t// - Multiple element slice\n\t// - Value exists in slice\n\t// - Value doesn't exist in slice\n\t// - Multiple values with same nearest distance\n\t// - NaN values in slice\n\t// - NaN value as target\n\t// - Inf values in slice\n\t// - Inf value as target\n\n\tt.Run(\"Empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 0)\n\t})\n\n\tt.Run(\"Single element slice\", func(t *testing.T) {\n\t\ts := []float64{1.0}\n\t\twant := 0\n\t\tgot := NearestIdx(s, 0.5)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 0.5) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Multiple element slice\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\twant := 1\n\t\tgot := NearestIdx(s, 1.6)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 1.6) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Value exists in slice\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\twant := 2\n\t\tgot := NearestIdx(s, 3.0)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 3.0) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Multiple values with same nearest distance\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0}\n\t\twant := 1\n\t\tgot := NearestIdx(s, 2.5)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 2.5) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NaN values in slice\", func(t *testing.T) {\n\t\ts := []float64{1.0, math.NaN(), 3.0}\n\t\twant := 0\n\t\tgot := NearestIdx(s, 2.0)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 2.0) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NaN value as target\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\twant := 0\n\t\tgot := NearestIdx(s, math.NaN())\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, NaN) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Inf values in slice\", func(t *testing.T) {\n\t\ts := []float64{1.0, math.Inf(1), 3.0}\n\t\twant := 1\n\t\tgot := NearestIdx(s, 1000.0)\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, 1000.0) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Inf value as target\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\twant := 2\n\t\tgot := NearestIdx(s, math.Inf(1))\n\t\tif got != want {\n\t\t\tt.Errorf(\"NearestIdx(%v, Inf) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n}\n",
    "16b961141bad023dbcab537e8956f070": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Regular span with positive step.\n\tdst1 := make([]float64, 5)\n\tSpan(dst1, 1, 5)\n\texpected1 := []float64{1, 2, 3, 4, 5}\n\tif !Equal(dst1, expected1) {\n\t\tt.Errorf(\"Span test case 1 failed: expected %v, got %v\", expected1, dst1)\n\t}\n\n\t// Test case 2: Regular span with negative step.\n\tdst2 := make([]float64, 5)\n\tSpan(dst2, 5, 1)\n\texpected2 := []float64{5, 4, 3, 2, 1}\n\tif !Equal(dst2, expected2) {\n\t\tt.Errorf(\"Span test case 2 failed: expected %v, got %v\", expected2, dst2)\n\t}\n\n\t// Test case 3: Span with length 2.\n\tdst3 := make([]float64, 2)\n\tSpan(dst3, 0, 1)\n\texpected3 := []float64{0, 1}\n\tif !Equal(dst3, expected3) {\n\t\tt.Errorf(\"Span test case 3 failed: expected %v, got %v\", expected3, dst3)\n\t}\n\n\t// Test case 4: Span with NaN lower bound.\n\tdst4 := make([]float64, 4)\n\tSpan(dst4, math.NaN(), 4)\n\texpected4 := []float64{math.NaN(), math.NaN(), math.NaN(), 4}\n\tif !Equal(dst4, expected4) {\n\t\tt.Errorf(\"Span test case 4 failed: expected %v, got %v\", expected4, dst4)\n\t}\n\n\t// Test case 5: Span with NaN upper bound.\n\tdst5 := make([]float64, 4)\n\tSpan(dst5, 1, math.NaN())\n\texpected5 := []float64{1, math.NaN(), math.NaN(), math.NaN()}\n\tif !Equal(dst5, expected5) {\n\t\tt.Errorf(\"Span test case 5 failed: expected %v, got %v\", expected5, dst5)\n\t}\n\n\t// Test case 6: Span with both bounds being infinite.\n\tdst6 := make([]float64, 5)\n\tSpan(dst6, math.Inf(1), math.Inf(-1))\n\texpected6 := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\tif !Equal(dst6, expected6) {\n\t\tt.Errorf(\"Span test case 6 failed: expected %v, got %v\", expected6, dst6)\n\t}\n\n\t// Test case 7: Span with infinite lower bound.\n\tdst7 := make([]float64, 4)\n\tSpan(dst7, math.Inf(1), 4)\n\texpected7 := []float64{math.Inf(1), math.Inf(1), math.Inf(1), 4}\n\tif !Equal(dst7, expected7) {\n\t\tt.Errorf(\"Span test case 7 failed: expected %v, got %v\", expected7, dst7)\n\t}\n\n\t// Test case 8: Span with infinite upper bound.\n\tdst8 := make([]float64, 4)\n\tSpan(dst8, 1, math.Inf(-1))\n\texpected8 := []float64{1, math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\tif !Equal(dst8, expected8) {\n\t\tt.Errorf(\"Span test case 8 failed: expected %v, got %v\", expected8, dst8)\n\t}\n}",
    "175bec1e74ac88c0ebf6618319ad2aea": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with two elements\n\t// 4. Slice with odd number of elements\n\t// 5. Slice with even number of elements\n\t// 6. l \u003e u\n\t// 7. l = u\n\t// 8. l and u are NaN\n\t// 9. l is NaN, u is not NaN\n\t// 10. l is not NaN, u is NaN\n\t// 11. l and u are Inf\n\t// 12. l is Inf, u is not Inf\n\t// 13. l is not Inf, u is Inf\n\n\tt.Run(\"TestSpanEmptySlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"TestSpanLessThanTwoElements\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"TestSpanTwoElements\", func(t *testing.T) {\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\tassert.Equal(t, dst[0], 0.0)\n\t\tassert.Equal(t, dst[1], 1.0)\n\t})\n\n\tt.Run(\"TestSpanOddElements\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 0, 2)\n\t\tassert.Equal(t, dst[0], 0.0)\n\t\tassert.Equal(t, dst[1], 1.0)\n\t\tassert.Equal(t, dst[2], 2.0)\n\t})\n\n\tt.Run(\"TestSpanEvenElements\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, 3)\n\t\tassert.Equal(t, dst[0], 0.0)\n\t\tassert.Equal(t, dst[1], 1.0)\n\t\tassert.Equal(t, dst[2], 2.0)\n\t\tassert.Equal(t, dst[3], 3.0)\n\t})\n\n\tt.Run(\"TestSpanLGreaterThanU\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 2, 0)\n\t\tassert.Equal(t, dst[0], 2.0)\n\t\tassert.Equal(t, dst[1], 1.0)\n\t\tassert.Equal(t, dst[2], 0.0)\n\t})\n\n\tt.Run(\"TestSpanLEqualToU\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 1, 1)\n\t\tassert.Equal(t, dst[0], 1.0)\n\t\tassert.Equal(t, dst[1], 1.0)\n\t\tassert.Equal(t, dst[2], 1.0)\n\t})\n\n\tt.Run(\"TestSpanLAndUNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tassert.True(t, math.IsNaN(dst[0]))\n\t\tassert.True(t, math.IsNaN(dst[1]))\n\t\tassert.True(t, math.IsNaN(dst[2]))\n\t})\n\n\tt.Run(\"TestSpanLIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tassert.True(t, math.IsNaN(dst[0]))\n\t\tassert.True(t, math.IsNaN(dst[1]))\n\t\tassert.Equal(t, dst[2], 1.0)\n\t})\n\n\tt.Run(\"TestSpanUIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 0, math.NaN())\n\t\tassert.Equal(t, dst[0], 0.0)\n\t\tassert.True(t, math.IsNaN(dst[1]))\n\t\tassert.True(t, math.IsNaN(dst[2]))\n\t})\n\n\tt.Run(\"TestSpanLAndUAreInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tassert.Equal(t, dst[0], math.Inf(1))\n\t\tassert.Equal(t, dst[1], 0.0)\n\t\tassert.Equal(t, dst[2], math.Inf(-1))\n\t})\n\n\tt.Run(\"TestSpanLIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tassert.Equal(t, dst[0], math.Inf(1))\n\t\tassert.Equal(t, dst[1], math.Inf(1))\n\t\tassert.Equal(t, dst[2], 1.0)\n\t})\n\n\tt.Run(\"TestSpanUIsInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tassert.Equal(t, dst[0], 0.0)\n\t\tassert.Equal(t, dst[1], math.Inf(1))\n\t\tassert.Equal(t, dst[2], math.Inf(1))\n\t})\n}\n",
    "178631791ebe40ac3e37a083dbafcaf0": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\texpect := []float64{-3, -3, -3}\n\tgot := SubTo(dst, s, t)\n\tassert.Equal(t, expect, got)\n}",
    "17b48362ee126933a53c1a193c164509": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ty := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\talpha := 2.0\n\tAddScaledTo(dst, y, alpha, s)\n\tassert.Equal(t, []float64{9, 12, 15}, dst)\n}\n\nfunc TestAddScaledToPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 2)\n\ty := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\talpha := 2.0\n\tAddScaledTo(dst, y, alpha, s)\n}",
    "1830f8f917008a5af3ab25c87b2ae2dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.1,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"simpleReverse\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    1.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"boundaryLow\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"boundaryHigh\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"outsideLow\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"outsideHigh\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"oneElement\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\tv:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"spanInf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"spanNegInf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"InfV\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NegInfV\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t// This test fails at the moment, because of the int conversion.\n\t\t// {\n\t\t// \tname: \"upperBoundary\",\n\t\t// \tn: 10,\n\t\t// \tl: 0,\n\t\t// \tu: 1,\n\t\t// \tv: 0.9,\n\t\t// \twant: 9,\n\t\t// },\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%v,%v,%v,%v): got: %v want: %v\",\n\t\t\t\t\ttest.n, test.l, test.u, test.v, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n\tpanics := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t}{\n\t\t{\n\t\t\tname: \"smallN\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t}\n\tfor _, test := range panics {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttestlapack.Panics(t, \"NearestIdxForSpan\", func() {\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t})\n\t\t})\n\t}\n}\n",
    "18f63684bb35c6121ee813332812b6fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for Norm function.\n\t// Each tuple represents (input slice, L value, expected norm).\n\ttestCases := []([]float64, float64, float64){\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},                                           // L1 norm\n\t\t{[]float64{1, 2, 3, 4}, 2, 7.0710678118654755},                         // L2 norm\n\t\t{[]float64{1, 2, 3, 4}, 3, 5.382581733982976,},                       // L3 norm\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},                             // L-infinity norm\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},                            // L-infinity norm (negative values)\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4}, 2, 5.813776741909306},                  // L2 norm (floating-point values)\n\t\t{[]float64{}, 2, 0},                                                   // Empty slice\n\t\t{[]float64{0, 0, 0, 0}, 2, 0},                                          // All zeros\n\t\t{[]float64{math.NaN(), 2, 3}, 2, math.NaN()},                          // NaN input\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc[0], tc[1])\n\t\twant := tc[2]\n\n\t\t// Use math.Abs for comparing floating-point numbers.\n\t\tif ! (math.IsNaN(got) \u0026\u0026 math.IsNaN(want)) \u0026\u0026  math.Abs(got-want) \u003e 1e-9 {\n\t\t\tt.Errorf(\"Test case %d failed: Norm(%v, %v) = %v, want %v\", i, tc[0], tc[1], got, want)\n\t\t}\n\t}\n}\n",
    "1968ed211494d5115fccc7fbe0d9b841": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Test case 1: Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 7: l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 8: l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 9: l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// Test case 10: u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 11: l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 12: l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// Test case 13: u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "19b2aa9741f579897b5c9a00dec4d507": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\tt.Parallel()\n\tfor i, tc := range []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tres []float64\n\t}{\n\t\t{\n\t\t\tdst: []float64{1, 2, 3},\n\t\t\ts:   []float64{1, 2, 3},\n\t\t\tres: []float64{1, 1, 1},\n\t\t},\n\t\t{\n\t\t\tdst: []float64{1, 2, 3},\n\t\t\ts:   []float64{0.5, 1, 1.5},\n\t\t\tres: []float64{2, 2, 2},\n\t\t},\n\t\t{\n\t\t\tdst: []float64{1, -2, 3},\n\t\t\ts:   []float64{-1, -1, -1},\n\t\t\tres: []float64{-1, 2, -3},\n\t\t},\n\t} {\n\t\tMul(tc.dst, tc.s)\n\t\tfor j, val := range tc.dst {\n\t\t\tif !closeEnough(val, tc.res[j], 1e-5) {\n\t\t\t\tt.Errorf(\"Test %d: Expected %v but got %v\", i, tc.res, tc.dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}\n",
    "1ad9c3bf09c1a9d8050c0ee5abf9560b": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\twant        []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:        \"length mismatch\",\n\t\t\tdst:         []float64{1, 2, 3},\n\t\t\ts:           []float64{1, 2},\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"basic test\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\twant: []float64{5, 7, 9},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.shouldPanic {\n\t\t\t\tassert.Panics(t, func() { Add(tt.dst, tt.s) })\n\t\t\t} else {\n\t\t\t\tassert.NotPanics(t, func() { Add(tt.dst, tt.s) })\n\t\t\t\tassert.Equal(t, tt.want, tt.dst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c4cb9f8a7e88f9578abe483cfc61f88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{1, 2, 3, 4, 5, 5}, 4},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{-5, -4, -3, -2, -1}, 4},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0},\n\t\t{[]float64{1, math.NaN(), 3}, 2},\n\t\t{[]float64{1, math.NaN(), 3, math.NaN()}, 2},\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range tests {\n\t\t// Execute MaxIdx for the current test case\n\t\tgot := MaxIdx(tc.input)\n\n\t\t// Compare the result with the expected output\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: input %v, got %d, want %d\", i, tc.input, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case for panic when input slice is empty\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when input slice is empty\")\n\t\t}\n\t}()\n\n\t// This should cause a panic\n\tMaxIdx([]float64{})\n}",
    "1c5f72f2d5979de07ba7baa8000ca229": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that panics occur when expected.\n\ttestPanic := func(t *testing.T, dst []float64, l, u float64) {\n\t\tdefer func() {\n\t\t\tr := recover()\n\t\t\tif r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, l, u)\n\t}\n\tt.Run(\"TestPanics\", func(t *testing.T) {\n\t\ttestPanic(t, make([]float64, 0), 0, 10)\n\t\ttestPanic(t, make([]float64, 1), 0, 10)\n\t})\n\n\t// Verify dst is modified in place.\n\tt.Run(\"TestInPlace\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\torigDst := make([]float64, len(dst))\n\t\tcopy(origDst, dst)\n\t\tSpan(dst, 0, 10)\n\t\tfor i := range dst {\n\t\t\tif dst[i] == origDst[i] {\n\t\t\t\tt.Errorf(\"Span failed to modify dst in place\")\n\t\t\t}\n\t\t}\n\n\t})\n\t// Verify spacing is correct for various combinations of l, u, len(dst).\n\ttestSpans := []struct {\n\t\tname string\n\t\tl    float64\n\t\tu    float64\n\t\tn    int\n\t}{\n\t\t{\"TwoElements\", 0, 10, 2},\n\t\t{\"OddElements\", 0, 10, 5},\n\t\t{\"EvenElements\", 0, 10, 4},\n\t\t{\"ZeroSpan\", 0, 0, 10},\n\t\t{\"NegativeL\", -10, 10, 5},\n\t\t{\"LargeSpan\", -1e6, 1e6, 10},\n\t}\n\tfor _, ts := range testSpans {\n\t\tt.Run(ts.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, ts.n)\n\t\t\tSpan(dst, ts.l, ts.u)\n\t\t\t// Verify first and last element.\n\t\t\tif dst[0] != ts.l || dst[ts.n-1] != ts.u {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v) = %v, want first = %v, last = %v\",\n\t\t\t\t\tdst, ts.l, ts.u, dst, ts.l, ts.u)\n\t\t\t}\n\t\t\t// Verify equal spacing.\n\t\t\texpectedStep := (ts.u - ts.l) / float64(ts.n-1)\n\t\t\tfor i := 1; i \u003c ts.n; i++ {\n\t\t\t\tstep := dst[i] - dst[i-1]\n\t\t\t\tif math.Abs(step-expectedStep) \u003e 1e-14 {\n\t\t\t\t\tt.Errorf(\"Unequal step size: got %v, want %v\", step, expectedStep)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\t// Verify proper handling of Inf and NaN.\n\ttestInfNan := []struct {\n\t\tname string\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\t\"NaNBegin\", math.NaN(), 10,\n\t\t\t[]float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\t\"NaNEnd\", 0, math.NaN(),\n\t\t\t[]float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\t\"InfBegin\", math.Inf(1), 10,\n\t\t\t[]float64{math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\t\"InfEnd\", 0, math.Inf(1),\n\t\t\t[]float64{0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\t\"InfInf\", math.Inf(1), math.Inf(1),\n\t\t\t[]float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\t\"NegInfInf\", math.Inf(-1), math.Inf(1),\n\t\t\t[]float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\t\"InfNegInf\", math.Inf(1), math.Inf(-1),\n\t\t\t[]float64{math.Inf(1), 0, 0, math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range testInfNan {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tn := len(tt.want)\n\t\t\tdst := make([]float64, n)\n\t\t\tSpan(dst, tt.l, tt.u)\n\t\t\tfor i := range dst {\n\t\t\t\tif !Same([]float64{dst[i]}, []float64{tt.want[i]}) {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) = %v, want %v\", dst, tt.l, tt.u, dst, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "1ca3cc76bc3280f4036eb5e02262113a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (panics)\n\t// - Slice with one element (panics)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and/or u are NaN\n\t// - l and/or u are Inf\n\n\t// Empty slice (panics)\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element (panics)\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and/or u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and/or u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "1d6ce67971a15d6b9f8427cb2884ae20": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases for SumCompensated.\n\t// Each test case is a tuple of:\n\t//   (input slice, expected sum)\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1e10, 1, -1e10}, 1},\n\t\t{[]float64{-1e-10, -1e-10, -1e-10, -1e-10}, -4e-10},\n\t\t{[]float64{}, 0},\n\t}\n\n\t// Iterate over the test cases.\n\tfor i, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within the acceptable tolerance.\n\t\tif !EqualApprox(actual, tc.expected, 1e-14) {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n}",
    "1fdd45a9c18c7c68f389281bb34338b8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of points in the span\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\t\t{2, 0, 1, 0.5, 1},\n\n\t\t// Special cases for Inf and NaN\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\n\t\t// Special cases for v outside (l, u) and (u, l)\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "1fe92cb8cfb822ebbb0cb855c24a048d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases for NearestIdx.\n\ttype testCase struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}\n\n\ttestCases := []testCase{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 3.5, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, 2.5, 1}, // NaN in input\n\t\t{[]float64{1, 2, 3, 4, 5}, math.NaN(), 0},    // NaN as target\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdx(tc.s, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "200507033a4953d93b579d69ed390e88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases:\n\t// - Normal case: max value in the middle\n\t// - Normal case: max value at the beginning\n\t// - Normal case: max value at the end\n\t// - Normal case: multiple max values, return the first index\n\t// - Edge case: all elements are NaN\n\t// - Edge case: slice contains NaN\n\tt.Run(\"Normal case: max value in the middle\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 5, 3, 4}\n\t\twant := 2\n\t\tgot := MaxIdx(s)\n\t\tif got != want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Normal case: max value at the beginning\", func(t *testing.T) {\n\t\ts := []float64{5, 4, 3, 2, 1}\n\t\twant := 0\n\t\tgot := MaxIdx(s)\n\t\tif got != want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Normal case: max value at the end\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\twant := 4\n\t\tgot := MaxIdx(s)\n\t\tif got != want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Normal case: multiple max values, return the first index\", func(t *testing.T) {\n\t\ts := []float64{1, 5, 3, 5, 2}\n\t\twant := 1\n\t\tgot := MaxIdx(s)\n\t\tif got != want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Edge case: all elements are NaN\", func(t *testing.T) {\n\t\ts := []float64{math.NaN(), math.NaN(), math.NaN()}\n\t\twant := 0\n\t\tgot := MaxIdx(s)\n\t\tif got != want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Edge case: slice contains NaN\", func(t *testing.T) {\n\t\ts := []float64{1, math.NaN(), 3, 4, 5}\n\t\twant := 4\n\t\tgot := MaxIdx(s)\n\t\tif got != want {\n\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", s, got, want)\n\t\t}\n\t})\n}\n",
    "20b1c7750ca546302f3faea997b5b38d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(f\"TestCase_%d\", func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Case %d: Expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\", i, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics\n\tt.Run(\"TestPanic_ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(1, 0, 1, 0.5)\n\t})\n}\n",
    "210f3b2cc25d3852c35a761e34477c91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2 should panic\n\t// - Regular case: l \u003c u, n \u003e 2\n\t// - l == u\n\t// - l \u003e u\n\t// - NaN cases for l and u\n\t// - Inf cases for l and u\n\n\t// len(dst) \u003c 2 should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n\n\t// Regular case: l \u003c u, n \u003e 2\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, 2)\n\tif dst[0] != 0 || dst[1] != 1 || dst[2] != 2 {\n\t\tt.Errorf(\"Span failed for regular case: %v\", dst)\n\t}\n\n\t// l == u\n\tdst = make([]float64, 4)\n\tSpan(dst, 1, 1)\n\tfor i := range dst {\n\t\tif dst[i] != 1 {\n\t\t\tt.Errorf(\"Span failed for l == u: %v\", dst)\n\t\t}\n\t}\n\n\t// l \u003e u\n\tdst = make([]float64, 3)\n\tSpan(dst, 2, 0)\n\tif dst[0] != 2 || dst[1] != 1 || dst[2] != 0 {\n\t\tt.Errorf(\"Span failed for l \u003e u: %v\", dst)\n\t}\n\n\t// NaN cases\n\t// l is NaN\n\tdst = make([]float64, 3)\n\tSpan(dst, math.NaN(), 2)\n\tif !math.IsNaN(dst[0]) || !math.IsNaN(dst[1]) || dst[2] != 2 {\n\t\tt.Errorf(\"Span failed for l == NaN: %v\", dst)\n\t}\n\t// u is NaN\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 || !math.IsNaN(dst[1]) || !math.IsNaN(dst[2]) {\n\t\tt.Errorf(\"Span failed for u == NaN: %v\", dst)\n\t}\n\n\t// Inf cases\n\t// l and u are both Inf\n\tdst = make([]float64, 4)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := 0; i \u003c len(dst)/2; i++ {\n\t\tif dst[i] != math.Inf(1) || dst[len(dst)-i-1] != math.Inf(-1) {\n\t\t\tt.Errorf(\"Span failed for l == Inf and u == Inf: %v\", dst)\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := 0; i \u003c len(dst)/2; i++ {\n\t\tif dst[i] != math.Inf(1) || dst[len(dst)-i-1] != math.Inf(-1) {\n\t\t\tt.Errorf(\"Span failed for l == Inf and u == Inf: %v\", dst)\n\t\t}\n\t}\n\tif dst[2] != 0 {\n\t\tt.Errorf(\"Span failed for l == Inf and u == Inf: %v\", dst)\n\t}\n\n\t// l is Inf\n\tdst = make([]float64, 3)\n\tSpan(dst, math.Inf(1), 2)\n\tif dst[2] != 2 || dst[0] != math.Inf(1) || dst[1] != math.Inf(1) {\n\t\tt.Errorf(\"Span failed for l == Inf: %v\", dst)\n\t}\n\t// u is Inf\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 || dst[1] != math.Inf(1) || dst[2] != math.Inf(1) {\n\t\tt.Errorf(\"Span failed for u == Inf: %v\", dst)\n\t}\n}\n",
    "213b596d12483bcacb7cf3ba03419666": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-1, -0.1, 0, 1, 1.2, 1.5, 2, 10}\n\n\t// Test cases where v is within the bounds of s.\n\tfor i := 1; i \u003c len(s)-1; i++ {\n\t\tv := (s[i] + s[i+1]) / 2\n\t\tif k := Within(s, v); k != i {\n\t\t\tt.Errorf(\"Within(s, %v) = %v, want %v\", v, k, i)\n\t\t}\n\t}\n\n\t// Test cases where v is outside the bounds of s.\n\ttestCases := []float64{-2, -1 - tol, 10 + tol, math.Inf(1), math.Inf(-1)}\n\tfor _, v := range testCases {\n\t\tif k := Within(s, v); k != -1 {\n\t\t\tt.Errorf(\"Within(s, %v) = %v, want -1\", v, k)\n\t\t}\n\t}\n\n\t// Test case where v is NaN.\n\tif k := Within(s, math.NaN()); k != -1 {\n\t\tt.Errorf(\"Within(s, NaN) = %v, want -1\", k)\n\t}\n}\n",
    "226111ab2928dc905e44814f6f9015be": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms and slice values\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 1},                  // Empty slice\n\t\t{[]float64{}, 2, 0},                  // Empty slice\n\t\t{[]float64{}, math.Inf(1), 0},         // Empty slice\n\t\t{[]float64{0, 0, 0}, 1, 0},            // All zeros\n\t\t{[]float64{0, 0, 0}, 2, 0},            // All zeros\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 0}, // All zeros\n\t}\n\n\t// Iterate through test cases\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif math.Abs(got-tc.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test case %d failed: Norm(%v, %v) = %v, want: %v\", i, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "22bd207af381f87686834da5d600c1ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}, 0}, 0},\n\t\t{\"NaN Value\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"+Inf Value\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"-Inf Value\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"General Case\", args{[]float64{1, 2, 3, 4, 5}, 2.3}, 1},\n\t\t{\"Duplicate Values\", args{[]float64{1, 2, 2, 3, 4}, 2.1}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 tt.name != \"Empty Slice\" {\n\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "252ed22fd9f5304c94adacddc06a1137": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1, 2, 3}, false},\n\t\t{[]float64{1, math.NaN(), 3}, true},\n\t\t{[]float64{math.NaN(), math.NaN(), math.NaN()}, true},\n\t\t{[]float64{}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := HasNaN(test.s)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"For s = %v, expected %v but got %v\", test.s, test.expected, actual)\n\t\t}\n\t}\n}",
    "253f0b1f1c4b549501d40eca15d5eced": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.25, 0},\n\t\t{2, 0, 1, 0.75, 1},\n\t\t{3, 0, 1, 0.25, 0},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.75, 2},\n\n\t\t// Cases with n \u003e 2\n\t\t{4, 0, 1, 0.125, 0},\n\t\t{4, 0, 1, 0.375, 1},\n\t\t{4, 0, 1, 0.625, 2},\n\t\t{4, 0, 1, 0.875, 3},\n\t\t{5, 0, 1, 0.1, 0},\n\t\t{5, 0, 1, 0.3, 1},\n\t\t{5, 0, 1, 0.5, 2},\n\t\t{5, 0, 1, 0.7, 3},\n\t\t{5, 0, 1, 0.9, 4},\n\n\t\t// Cases with negative bounds\n\t\t{3, -1, 1, -0.5, 0},\n\t\t{3, -1, 1, 0, 1},\n\t\t{3, -1, 1, 0.5, 2},\n\n\t\t// Cases with v outside (l, u)\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\n\t\t// Cases with reversed bounds (u \u003c l)\n\t\t{3, 1, -1, 0.5, 0},\n\t\t{3, 1, -1, 0, 1},\n\t\t{3, 1, -1, -0.5, 2},\n\t\t{3, 1, -1, 2, 0},\n\t\t{3, 1, -1, -1, 2},\n\n\t\t// Special cases for Inf and NaN\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 0}, // n is even\n\t\t{3, math.Inf(-1), math.Inf(1), 1, 0},\n\t\t{3, math.Inf(1), math.Inf(-1), 1, 2},\n\t\t{3, math.Inf(-1), 0, 0, 2},\n\t\t{3, 0, math.Inf(1), 0, 0},\n\t\t{3, 0, 1, math.Inf(-1), 0},\n\t\t{3, 1, 0, math.Inf(-1), 2},\n\t\t{3, 0, 1, math.Inf(1), 2},\n\t\t{3, 1, 0, math.Inf(1), 0},\n\t\t{3, math.NaN(), 1, 0, 2},\n\t\t{3, 0, math.NaN(), 0, 0},\n\t\t{3, 0, 1, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.i {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.i)\n\t\t}\n\t}\n}",
    "25ce682804023f9a12509c8ac3f9216a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0}, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.name == \"ShortSpan\" {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic with short dst\")\n\t\t\t\t\t}\n\t\t\t\t} else if r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Span panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tfor i, wantVal := range tc.want {\n\t\t\t\tif !EqualWithinAbsOrRel(got[i], wantVal, 1e-15, 1e-15) {\n\t\t\t\t\tt.Errorf(\"Index %d: got %v, want %v\", i, got[i], wantVal)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// EqualWithinAbsOrRel checks if a and b are equal within an absolute tolerance\n// tol or a relative tolerance tol.\nfunc EqualWithinAbsOrRel(a, b, tolAbs, tolRel float64) bool {\n\tif math.Abs(a-b) \u003c= tolAbs {\n\t\treturn true\n\t}\n\tif math.Abs(b) \u003e math.Abs(a) {\n\t\ta, b = b, a\n\t}\n\treturn math.Abs(a-b) \u003c= math.Abs(a)*tolRel\n}",
    "26a35a13561a9794e4226386d82986f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\t// Test L = 1\n\texpected := 16.0\n\tactual := Distance(s, t, 1)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test L = 2\n\texpected = math.Sqrt(64)\n\tactual = Distance(s, t, 2)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test L = Inf\n\texpected = 4.0\n\tactual = Distance(s, t, math.Inf(1))\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test empty slices\n\ts = []float64{}\n\tt = []float64{}\n\texpected = 0.0\n\tactual = Distance(s, t, 2)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test panic on different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\ts = []float64{1, 2, 3}\n\tt = []float64{1, 2}\n\tDistance(s, t, 2)\n}\n",
    "273f0a878b8e6f3562e9f28f044dc394": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases for SumCompensated.\n\t// Each test case includes a slice of float64 values and the expected sum.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t\t{[]float64{1e10, 1, 1e10}, 2e10},\n\t\t{[]float64{math.Inf(1), 1, 2, 3}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), 1, 2, 3}, math.Inf(-1)},\n\t\t{[]float64{math.NaN(), 1, 2, 3}, math.NaN()},\n\t}\n\n\t// Iterate over the test cases.\n\tfor i, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tsum := SumCompensated(tc.input)\n\n\t\t// Check if the calculated sum matches the expected sum.\n\t\tif math.IsNaN(tc.expected) {\n\t\t\tif !math.IsNaN(sum) {\n\t\t\t\tt.Errorf(\"Test case %d failed: Expected NaN, got %v\", i, sum)\n\t\t\t}\n\t\t} else if sum != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: Expected %v, got %v\", i, tc.expected, sum)\n\t\t}\n\t}\n}",
    "275967bd3d165d6f5e107ac14d6101cc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, -1, 1, 0, 5},\n\t\t{10, -1, 1, -1, 0},\n\t\t{10, -1, 1, 1, 9},\n\t\t// Test cases for Inf and NaN.\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.NaN(), 1, 0, 9},\n\t\t{10, -1, math.NaN(), 0, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n=%v, l=%v, u=%v, and v=%v\", tc.n, tc.l, tc.u, tc.v)\n\t}\n\n\t// Test cases for panics.\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) }, \"Should panic for n \u003c 2\")\n}\n",
    "27980de3e3145bbf91a6bce006ce4d0c": "package floats\n\nimport \"testing\"\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, test := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1, 2, 3, 4}, wantIdx: 0},\n\t\t{s: []float64{4, 3, 2, 1}, wantIdx: 3},\n\t\t{s: []float64{2, 2, 1, 1}, wantIdx: 2},\n\t\t{s: []float64{1}, wantIdx: 0},\n\t\t{s: []float64{}, wantPanic: true},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tif !test.wantPanic \u0026\u0026 err != nil {\n\t\t\t\t\tt.Errorf(\"MinIdx(%v) panicked: %v\", test.s, err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := MinIdx(test.s)\n\t\t\tif test.wantPanic {\n\t\t\t\tt.Errorf(\"MinIdx(%v) did not panic\", test.s)\n\t\t\t}\n\t\t\tif got != test.wantIdx {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", test.s, got, test.wantIdx)\n\t\t\t}\n\t\t}()\n\t}\n}",
    "2799b7f6d5b93f89992e821705bebff0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{10, 0, 1, 0.99, 9},\n\t\t{10, 0, 1, -0.1, 0},\n\t\t{10, 0, 1, 1.1, 9},\n\t\t{10, 1, 0, 0.5, 0},\n\t\t{10, 1, 0, 1.1, 0},\n\t\t{10, 1, 0, -0.1, 9},\n\t\t{10, -1, -1, -1, 0},\n\t\t{10, 1, 1, 1, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 1, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 1, 10},\n\t\t{11, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), math.NaN(), 0},\n\t\t{10, math.NaN(), 0, math.NaN(), 0},\n\t\t{10, 0, math.NaN(), math.NaN(), 0},\n\t\t{10, math.NaN(), math.NaN(), math.NaN(), 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test for panic when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}",
    "28520fc1a5692c9c87d9da5daba3a32d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{[]float64{}}, -1},\n\t\t{\"one\", args{[]float64{1}}, 0},\n\t\t{\"two\", args{[]float64{1, 2}}, 0},\n\t\t{\"three\", args{[]float64{3, 2, 1}}, 2},\n\t\t{\"twoMin\", args{[]float64{1, 1, 2}}, 0},\n\t\t{\"NaN\", args{[]float64{math.NaN(), 2, 3}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tt.args.s == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif len(tt.args.s) \u003e 0 {\n\t\t\t\t\t\tt.Errorf(\"MinIdx() recover() = %v, want no panic\", r)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif len(tt.args.s) == 0 {\n\t\t\t\t\t\tt.Errorf(\"MinIdx() expected panic, got no panic\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "288f617c62576d3f1a88038094c17195": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{nil, 0, true},\n\t\t{[]float64{1}, 0, false},\n\t\t{[]float64{1, 2, 3}, 0, false},\n\t\t{[]float64{3, 2, 1}, 2, false},\n\t\t{[]float64{1, 3, 2}, 0, false},\n\t\t{[]float64{math.NaN(), 2, 3}, 1, false},\n\t\t{[]float64{2, math.NaN(), 3}, 0, false},\n\t\t{[]float64{2, 3, math.NaN()}, 0, false},\n\t} {\n\t\tf := func() int {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif !c.wantPanic \u0026\u0026 r != nil {\n\t\t\t\t\tt.Errorf(\"MinIdx(%v) panicked: %v\", c.s, r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\treturn MinIdx(c.s)\n\t\t}\n\t\tgot := f()\n\t\tif c.wantPanic {\n\t\t\treturn\n\t\t}\n\t\tif got != c.wantIdx {\n\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", c.s, got, c.wantIdx)\n\t\t}\n\t}\n\n}",
    "28ebcdc9ba99fb1af3edf4495a630a68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 4, 2, 3}, 0},\n\t\t{[]float64{1, 1, 2, 2}, 0},\n\t\t{[]float64{math.NaN(), 2, 3}, 1},\n\t\t{[]float64{2, 3, math.NaN()}, 0},\n\t\t{[]float64{2, math.NaN(), 3}, 0},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: MinIdx(%v) = %v, want %v\", i, test.s, got, test.want)\n\t\t}\n\t}\n}",
    "28f9800a7a4182bbc7af30b587ca4260": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for Norm function.\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, -4}, 1, 10},\n\t\t{[]float64{1, 2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := Norm(tc.s, tc.L)\n\t\tif !close(got, tc.want) || math.IsNaN(got) != math.IsNaN(tc.want) {\n\t\t\tt.Errorf(\"Test case %v: Norm(%v, %v) == %v, want %v\", i+1, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}\n\nconst epsilon float64 = 1e-15\nfunc close(a, b float64) bool {\n\treturn math.Abs(a - b) \u003c= epsilon\n}",
    "29038392105c5bc234f760656fcb22e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5, 4, 3, 2, 1}, 4},\n\t\t{[]float64{1, 2, 3, 4, 5, 5, 4, 3, 2, 1}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{-5, -4, -3, -2, -1}, 4},\n\t\t{[]float64{-math.MaxFloat64, -math.MaxFloat64 + 1}, 1},\n\t\t{[]float64{math.NaN(), 1}, 1},\n\t\t{[]float64{1, math.NaN()}, 0},\n\t\t{[]float64{math.NaN(), math.NaN(), 1}, 2},\n\t} {\n\t\tgot := MaxIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: MaxIdx(%v) = %v, want %v\", i, test.s, got, test.want)\n\t\t}\n\t}\n}",
    "2912766f5fa08aadae1282284cedee38": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with length 1 (should panic)\n\t// - Slice with length 2\n\t// - Slice with even length\n\t// - Slice with odd length\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l or u is Inf\n\t// - l or u is -Inf\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with length 1\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with slice of length 1\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with length 2\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", i, dst, expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even length\n\t{\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, 0, 3)\n\t\texpected := []float64{0, 1, 2, 3}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", i, dst, expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd length\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\texpected := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", i, dst, expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 4, 0)\n\t\texpected := []float64{4, 3, 2, 1, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", i, dst, expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", i, dst, expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want NaN\", i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want NaN\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", len(dst)-1, dst[len(dst)-1], 1)\n\t\t}\n\t}\n\n\t// u is NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", 0, dst[0], 0)\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want NaN\", i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l or u is Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want Inf\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", len(dst)-1, dst[len(dst)-1], 1)\n\t\t}\n\t}\n\n\t// l or u is -Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want %v\", 0, dst[0], 0)\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Span mismatch at index %d: got %v, want -Inf\", i, dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "29321ecf0482984dd39ea3b7ce875e3b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that we panic with lengths less than 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\ttemp := make([]float64, 1)\n\tSpan(temp, 0, 1)\n}\n\nfunc TestSpanBasic(t *testing.T) {\n\ttol := 1e-14\n\tfor n := 2; n \u003c 20; n++ {\n\t\tfor l := -5.0; l \u003c 5; l++ {\n\t\t\tfor u := -5.0; u \u003c 5; u += 1 {\n\t\t\t\tdst := make([]float64, n)\n\t\t\t\tSpan(dst, l, u)\n\t\t\t\tif math.Abs(dst[0]-l) \u003e tol {\n\t\t\t\t\tt.Errorf(\"First element is wrong. Expected %v, got %v\", l, dst[0])\n\t\t\t\t}\n\t\t\t\tif math.Abs(dst[len(dst)-1]-u) \u003e tol {\n\t\t\t\t\tt.Errorf(\"Last element is wrong. Expected %v, got %v\", u, dst[len(dst)-1])\n\t\t\t\t}\n\t\t\t\tif len(dst) \u003e 2 {\n\t\t\t\t\texpectedStep := (u - l) / float64(n-1)\n\t\t\t\t\tfor i := 1; i \u003c len(dst)-1; i++ {\n\t\t\t\t\t\tif math.Abs((dst[i]-dst[i-1])-expectedStep) \u003e tol {\n\t\t\t\t\t\t\tt.Errorf(\"Step size is wrong. Expected %v, got %v\", expectedStep, dst[i]-dst[i-1])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\t// Cases with infinity\n\tinf := math.Inf(1)\n\ttests := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{5, 0, inf, []float64{0, 0, 0, inf, inf}},\n\t\t{5, inf, 0, []float64{inf, inf, 0, 0, 0}},\n\t\t{5, 0, -inf, []float64{0, 0, 0, -inf, -inf}},\n\t\t{5, -inf, 0, []float64{-inf, -inf, 0, 0, 0}},\n\t\t{5, inf, inf, []float64{inf, inf, inf, inf, inf}},\n\t\t{5, -inf, -inf, []float64{-inf, -inf, -inf, -inf, -inf}},\n\t\t{4, 0, inf, []float64{0, 0, inf, inf}},\n\t\t{4, inf, 0, []float64{inf, inf, 0, 0}},\n\t\t{4, 0, -inf, []float64{0, 0, -inf, -inf}},\n\t\t{4, -inf, 0, []float64{-inf, -inf, 0, 0}},\n\t}\n\tfor i, test := range tests {\n\t\tdst := make([]float64, test.n)\n\t\tSpan(dst, test.l, test.u)\n\t\tfor j := range dst {\n\t\t\tif dst[j] != test.expected[j] {\n\t\t\t\tt.Errorf(\"Test %d: Expected %v, got %v\", i, test.expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\t// Cases with NaN\n\tnan := math.NaN()\n\ttests := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{5, 0, nan, []float64{0, 0, 0, 0, nan}},\n\t\t{5, nan, 0, []float64{nan, 0, 0, 0, 0}},\n\t\t{5, nan, nan, []float64{nan, nan, nan, nan, nan}},\n\t}\n\tfor i, test := range tests {\n\t\tdst := make([]float64, test.n)\n\t\tSpan(dst, test.l, test.u)\n\t\tfor j := range dst {\n\t\t\tif !(math.IsNaN(dst[j]) \u0026\u0026 math.IsNaN(test.expected[j])) \u0026\u0026 dst[j] != test.expected[j] {\n\t\t\t\tt.Errorf(\"Test %d: Expected %v, got %v\", i, test.expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "29360998acd13b342952710bb8afacf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLengthSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{1.0, 1.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch, got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\tt.Errorf(\"Mismatch at index %d, got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tinfCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LeftInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"RightInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range infCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch, got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif math.IsNaN(got[i]) != math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"Mismatch at index %d, got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else if math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\tt.Errorf(\"Mismatch at index %d, got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panic when len(dst) \u003c 2\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n",
    "295ed50fd8578a673bb2e3fcc8350d9c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, multiple elements,\n\t// large numbers, small numbers.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, 3e-10},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "29b9b1c0f0123acdc4bd5a5dcb577350": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{1, 2, 5, 3, 4}, 2},\n\t\t{[]float64{-1, -2, -3, -5, -4}, 0},\n\t\t{[]float64{math.NaN(), 2, 3, 4, 5}, 0},\n\t\t{[]float64{1, math.NaN(), 3, 4, 5}, 0},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, 0},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 0},\n\t} {\n\t\tgot := MaxIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"test %d: MaxIdx(%v) = %v, want %v\", i, test.s, got, test.want)\n\t\t}\n\t}\n}",
    "2a86c48c0b34e51f7e81c07ad226cfc8": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\texpected := []float64{-3, -3, -3}\n\tgot := SubTo(dst, s, t)\n\tassert.Equal(t, expected, got)\n}",
    "2adf7865b18d991dea53dc6df7a87df3": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\tvar tests = []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{2, 2, 2}, 0.125},\n\t\t{[]float64{1, 2, 3, 4}, 1.0 / 24},\n\t\t{[]float64{-2}, -0.5},\n\t\t{[]float64{}, 1},\n\t}\n\tfor _, test := range tests {\n\t\tgot := Prod(test.input)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Prod(%v) = %v, want %v\\n\", test.input, got, test.want)\n\t\t}\n\t}\n}\n",
    "2c01766532bd63aa2abc38cc94eb14e6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0}, // This should panic, but we're checking for it\n\t\t},\n\t\t{\n\t\t\tname: \"NaNInputL\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNInputU\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfInputL\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfInputU\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\t// Iterate through test cases\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.name != \"ShortSpan\" {\n\t\t\t\t\t\tt.Errorf(\"Span paniced unexpectedly for case %s\", tc.name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeTo(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak // No need to print multiple errors for the same test case\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare float64 values within a tolerance\nconst epsilon = 1e-5\n\nfunc closeTo(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c epsilon || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}\n",
    "2c0b11a375fc921998c1c9c945a1e821": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5}, // v in the middle\n\t\t{10, 0, 10, -1, 0}, // v less than l\n\t\t{10, 0, 10, 11, 9}, // v greater than u\n\t\t{10, 0, 10, 2.5, 2}, // v closer to lower index\n\t\t{10, 0, 10, 7.5, 7}, // v closer to upper index\n\t\t{10, 10, 0, 5, 5}, // l \u003e u\n\t\t{10, 10, 0, 11, 0}, // l \u003e u, v greater than l\n\t\t{10, 10, 0, -1, 9}, // l \u003e u, v less than u\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2}, // l = -Inf, u = Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // l = -Inf, u = Inf, v = -Inf\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4}, // l = -Inf, u = Inf, v = Inf\n\t\t{5, 0, math.Inf(1), -1, 0}, // l = 0, u = Inf\n\t\t{5, 0, math.Inf(1), 1, 1}, // l = 0, u = Inf\n\t\t{5, math.Inf(-1), 0, -1, 4}, // l = -Inf, u = 0\n\t\t{5, math.Inf(-1), 0, 1, 0}, // l = -Inf, u = 0\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5}, // l = -Inf, u = Inf, odd n\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // l = -Inf, u = Inf, v = -Inf, odd n\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(1), 10}, // l = -Inf, u = Inf, v = Inf, odd n\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, test.n, test.l, test.u, test.v, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "2d185405319948d8cbedc6a6a50ab7fc": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/internal/f64\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{1, 2, 3}, []float64{2, 2, 2}, []float64{0.5, 1, 1.5}},\n\t\t{[]float64{1, -2, 3}, []float64{-2, 2, -2}, []float64{-0.5, -1, -1.5}},\n\t} {\n\t\tdst := make([]float64, len(test.s))\n\t\tgot := DivTo(dst, test.s, test.t)\n\t\tif !f64.Equal(got, test.want) {\n\t\t\tt.Errorf(\"Case %v: unexpected result, got: %v, want: %v\", i, got, test.want)\n\t\t}\n\t}\n\n\t// Mismatching lengths\n\ts := make([]float64, 10)\n\tt1 := make([]float64, 5)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"The code did not panic\")\n\t\t}\n\t}()\n\tDivTo(s, s, t1)\n}",
    "2d9592ac59a1a355ee03def9ab0094c3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Infinities\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d: n=%d, l=%v, u=%v, v=%v\", i, tc.n, tc.l, tc.u, tc.v), func(t *testing.T) {\n\t\t\tgotIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif gotIdx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Incorrect index returned. Expected %d, got %d\", tc.expectedIdx, gotIdx)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// sf is a helper function to format strings.\nfunc sf(format string, a ...interface{}) string {\n\treturn fmt.Sprintf(format, a...)\n}\n",
    "2e64769798a5cc94d729f8d90e29adfd": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\tt.Parallel()\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tc := 2.0\n\twant := []float64{2, 4, 6}\n\tScaleTo(dst, c, s)\n\tassert.Equal(t, want, dst, \"ScaleTo() failed\")\n}",
    "2e8f04b46a7cc612ea38ffd806e2eb04": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l = Inf, u = Inf\n\t// - l = -Inf, u = Inf\n\t// - l = Inf, u = -Inf\n\t// - l = NaN, u = NaN\n\t// - l = NaN, u = float64\n\t// - l = float64, u = NaN\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\twant := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 5)\n\t\twant := []float64{0, 1, 2, 3, 4, 5}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 4, 0)\n\t\twant := []float64{4, 3, 2, 1, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf, u = Inf\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = -Inf, u = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\twant := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf, u = -Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = NaN, u = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = NaN, u = float64\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsNaN(dst[i]) \u0026\u0026 math.IsNaN(want[i])) \u0026\u0026 dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = float64, u = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsNaN(dst[i]) \u0026\u0026 math.IsNaN(want[i])) \u0026\u0026 dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "2f1a12d46d26c88d281ab17f5d43f813": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ts := []float64{10, 2, 1, 4, 5}\n\ttol := 1e-15\n\tif NearestIdx(s, -1) != 2 {\n\t\tt.Errorf(\"Expected nearest to -1 to be at index 2\")\n\t}\n\tif NearestIdx(s, 0) != 2 {\n\t\tt.Errorf(\"Expected nearest to 0 to be at index 2\")\n\t}\n\tif NearestIdx(s, 1.1) != 2 {\n\t\tt.Errorf(\"Expected nearest to 1.1 to be at index 2\")\n\t}\n\tif NearestIdx(s, 3) != 3 {\n\t\tt.Errorf(\"Expected nearest to 3 to be at index 3\")\n\t}\n\tif math.Abs(s[NearestIdx(s, 2.6)]-2.6) \u003e tol {\n\t\tt.Errorf(\"Expected nearest to 2.6 to be 2\")\n\t}\n\tif NearestIdx(s, 100) != 0 {\n\t\tt.Errorf(\"Expected nearest to 100 to be at index 0\")\n\t}\n}",
    "3089a094a99d51ef78034874e78c9a53": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 3.4076059573070574},\n\t\t{[]float64{-10, -11, -12, -13}, -9.539602433388297},\n\t\t{[]float64{100, 100, 100}, 103.61972385689365},\n\t} {\n\t\tgot := LogSumExp(test.s)\n\t\tif math.Abs(got-test.expected) \u003e tol {\n\t\t\tt.Errorf(\"Test %d: Expected %f, got %f\\n\", i, test.expected, got)\n\t\t}\n\t}\n}",
    "30dee26f57fa90a8a53794231ce2c69e": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    [][]float64\n\t\texpected bool\n\t}{\n\t\t{[][]float64{}, true},                                                    // No input slices\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}}, true},                                // Equal lengths\n\t\t{[][]float64{{1, 2}, {3, 4}, {5, 6}}, true},                              // Equal lengths\n\t\t{[][]float64{{1, 2, 3}, {4, 5}}, false},                               // Unequal lengths\n\t\t{[][]float64{{1, 2}, {3, 4, 5}, {6, 7, 8, 9}}, false},                    // Unequal lengths\n\t\t{[][]float64{{1}, {2, 3}, {4, 5, 6}}, false},                             // Unequal lengths\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}}, true}, // Equal lengths\n\t}\n\n\t// Iterate over test cases\n\tfor i, tc := range testCases {\n\t\t// Execute the function with the current input\n\t\tactual := EqualLengths(tc.input...)\n\n\t\t// Check if the result matches the expected value\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d: Expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "310cb20bedefcc5ffc221258026fc89f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -3.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-3.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCasePositive\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseNegative\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseMixed\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleL\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    2.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleU\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-2.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-15) {\n\t\t\t\t\tt.Errorf(\"Mismatch at index %d: got %v, want %v\\n\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Span should have panicked for len(dst) \u003c 2, but it didn't.\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc closeEnough(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c tol\n}",
    "315d479ff232fd65956f9b3da7e0e12b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn     int\n\t\tl, u float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 0}, // Exact midpoint is weird.\n\t\t{n: 2, l: 0, u: 1, v: 0.9, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.4, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.6, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.9, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 0.9, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.1, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.4, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.6, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 0.9, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 2, l: 0, u: 0, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 0, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: 0, v: 1, want: 0},\n\n\t\t{n: 3, l: 0, u: 0, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 0, v: 0, want: 0},\n\t\t{n: 3, l: 0, u: 0, v: 1, want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d- NearestIdxForSpan(%d,%v,%v,%v) = %d, want %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanSpecial(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn     int\n\t\tl, u float64\n\t\tv     float64\n\t\twant  int\n\t}{\n\t\t// Cases with NaN\n\t\t{n: 2, l: math.NaN(), u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, want: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, want: 0},\n\n\t\t// Cases with +Inf\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0, want: 1},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: math.Inf(1), want: 0},\n\n\t\t// Cases with -Inf\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, want: 1},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: 0, want: 1},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: 0, want: 0},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: math.Inf(-1), want: 2},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d- NearestIdxForSpan(%d,%v,%v,%v) = %d, want %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn     int\n\t\tl, u float64\n\t\tv     float64\n\t}{\n\t\t{n: 1, l: 0, u: 1, v: 0.5},\n\t\t{n: 0, l: 0, u: 1, v: 0.5},\n\t\t{n: -1, l: 0, u: 1, v: 0.5},\n\t} {\n\t\ttest.ShouldPanic(t, \"shortSpan\", func() {\n\t\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t}, \"Case %d: Did not panic with length %d\", i, tc.n)\n\t}\n}\n",
    "31da813b746c7eabd381b135198484d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{5, 0, 1, 0.5, 2},\n\t\t{5, 1, 0, 0.5, 2},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{10, -5, 5, 2.5, 7},\n\t\t{2, 0, 1, 0.5, 0}, // Test case for n = 2\n\t\t{2, 1, 0, 0.5, 1}, // Test case for n = 2, l \u003e u\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 4},\n\t\t{10, math.Inf(1), math.Inf(-1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(-1), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d\", i, tc.expected, actual)\n\t\t}\n\t}\n\n\t// Test case for panic when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "32bb0402b219e3687bbce36b83414407": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Single Element Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Less Than Minimum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Greater Than Maximum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Within Span\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value On Boundary\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want != -1 {\n\t\t\t\t\t\tt.Errorf(\"Within() panicked when it should not have for %v\", tt.args.s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "345c9a3be0ead2a6bb443889e1480273": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Normal case\n\t// 2. dst len \u003c 2\n\t// 3. l is NaN\n\t// 4. u is NaN\n\t// 5. Both l and u are Inf with same sign\n\t// 6. Both l and u are Inf with different sign\n\t// 7. l is Inf\n\t// 8. u is Inf\n\n\t// Normal case\n\tdst := make([]float64, 5)\n\tSpan(dst, 1, 5)\n\texpected := []float64{1, 2, 3, 4, 5}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span() failed. Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// dst len \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic with dst length less than 2\")\n\t\t}\n\t}()\n\tdst = make([]float64, 1)\n\tSpan(dst, 1, 5)\n\n\t// l is NaN\n\tdst = make([]float64, 5)\n\tSpan(dst, math.NaN(), 5)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span() failed. Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 5 {\n\t\tt.Errorf(\"Span() failed. Expected 5, got %v\", dst[len(dst)-1])\n\t}\n\n\t// u is NaN\n\tdst = make([]float64, 5)\n\tSpan(dst, 1, math.NaN())\n\tif dst[0] != 1 {\n\t\tt.Errorf(\"Span() failed. Expected 1, got %v\", dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsNaN(dst[i+1]) {\n\t\t\tt.Errorf(\"Span() failed. Expected NaN, got %v\", dst[i+1])\n\t\t}\n\t}\n\n\t// Both l and u are Inf with same sign\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := range dst {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Span() failed. Expected Inf, got %v\", dst[i])\n\t\t}\n\t}\n\n\t// Both l and u are Inf with different sign\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\tfor i := range dst[:len(dst)/2] {\n\t\tif !math.IsInf(dst[i], -1) || !math.IsInf(dst[len(dst)-i-1], 1) {\n\t\t\tt.Errorf(\"Span() failed. Expected -Inf and Inf, got %v and %v\", dst[i], dst[len(dst)-i-1])\n\t\t}\n\t}\n\tif dst[len(dst)/2] != 0 {\n\t\tt.Errorf(\"Span() failed. Expected 0, got %v\", dst[len(dst)/2])\n\t}\n\n\t// l is Inf\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), 5)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Span() failed. Expected -Inf, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 5 {\n\t\tt.Errorf(\"Span() failed. Expected 5, got %v\", dst[len(dst)-1])\n\t}\n\n\t// u is Inf\n\tdst = make([]float64, 5)\n\tSpan(dst, 1, math.Inf(1))\n\tif dst[0] != 1 {\n\t\tt.Errorf(\"Span() failed. Expected 1, got %v\", dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsInf(dst[i+1], 1) {\n\t\t\tt.Errorf(\"Span() failed. Expected Inf, got %v\", dst[i+1])\n\t\t}\n\t}\n}",
    "34830695dc149b4a5cc409e9b2a8f053": "package floats\n\nimport \"testing\"\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases for SumCompensated\n\t// You need to add test cases here.\n\t// Example:\n\tt.Run(\"EmptySlice\", func(t *testing.T) {\n\t\ts := []float64{}\n\t\tgot := SumCompensated(s)\n\t\twant := 0.0\n\t\tif got != want {\n\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, want)\n\t\t}\n\t})\n}",
    "34c0d99226cdf4b4227be15a1f145e68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0, 5},\n\t\t{11, -1, 1, -0.5, 3},\n\t\t{11, -1, 1, 0, 5},\n\t\t{10, 0, 1, 1, 9},\n\t\t{10, 1, 0, 0, 9},\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 1, 0, 2, 0},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 1, 0, 0.5, 4},\n\t\t{2, -1, 1, -10, 0},\n\t\t{2, -1, 1, 10, 1},\n\t\t{2, 1, -1, -10, 1},\n\t\t{2, 1, -1, 10, 0},\n\t\t{10, -10, -1, -1.5, 9},\n\t\t{10, -1, -10, -1.5, 0},\n\t\t{10, 0, 0, 0, 0},\n\t\t{10, 1, 1, 1, 0},\n\t\t{10, -1, -1, -1, 0},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, 0, math.Inf(1), 1, 1},\n\t\t{3, 0, math.Inf(1), 0, 0},\n\t\t{3, 0, math.Inf(1), 1, 1},\n\t\t{2, math.Inf(-1), 0, 0, 1},\n\t\t{2, math.Inf(-1), 0, -1, 0},\n\t\t{3, math.Inf(-1), 0, 0, 2},\n\t\t{3, math.Inf(-1), 0, -1, 1},\n\t\t{2, math.Inf(-1), math.Inf(1), 1, 1},\n\t\t{2, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 1, 2},\n\t\t{3, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{2, 0, math.NaN(), 1, 1},\n\t\t{2, math.NaN(), 0, -1, 0},\n\t\t{2, math.NaN(), math.NaN(), 0, 0},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Case %d: wanted %d, have %d\\n\", i, test.want, have)\n\t\t}\n\t}\n\t// NaN cases\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t}{\n\t\t{10, 0, 1, math.NaN()},\n\t\t{10, 0, math.NaN(), 0.5},\n\t\t{10, math.NaN(), 1, 0.5},\n\t\t{10, math.NaN(), math.NaN(), math.NaN()},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Case %d: unexpected panic for l=%v, u=%v, v=%v\\n\",\n\t\t\t\t\t\ti, test.l, test.u, test.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t}()\n\t}\n}\n",
    "34ff38c1847746783a7293319ecf85f8": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Define test cases.\n\ttestCases := []struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:      \"k=0_returns_empty_slice\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k_less_than_0_returns_all_indices\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k_greater_than_0_returns_first_k_indices\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k_greater_than_0_returns_error_if_not_enough_elements_found\",\n\t\t\tinds:      []int{1, 2, 3},\n\t\t\tf:         func(f float64) bool { return f \u003e 3 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{3},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\t// Iterate over the test cases.\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Call the Find function.\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\t// Check the error.\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned an error: %v\", tc.inds, tc.f, tc.s, tc.k, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) did not return an error, want: %v\", tc.inds, tc.f, tc.s, tc.k, tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned an unexpected error: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotErr, tc.wantErr)\n\t\t\t}\n\n\t\t\t// Check the indices.\n\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned unexpected number of indices: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotInds, tc.wantInds)\n\t\t\t} else {\n\t\t\t\tfor i := range gotInds {\n\t\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned unexpected indices: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotInds, tc.wantInds)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "356d6aedd0b043c46f7fcf7e3ff1cbc9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slices\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{0, 0, 0, 0}, 2, 0},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the norm using the function\n\t\tnorm := Norm(tc.s, tc.L)\n\n\t\t// Check if the calculated norm matches the expected value\n\t\tif math.Abs(norm-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Test case %d failed: Expected %v, got %v\", i, tc.expected, norm)\n\t\t}\n\t}\n}\n",
    "358cb99636fbb9e701ee9e0d5a0edac1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.3, 3},\n\t\t{10, 0, 10, 3, 3},\n\t\t{5, -1, 1, -0.5, 1},\n\t\t{5, -1, 1, 0.5, 3},\n\t\t{4, -1, 1, -0.5, 1},\n\t\t{4, -1, 1, 0.5, 2},\n\t\t{10, 1, 0, 0.3, 6},\n\t\t{10, 1, -1, -0.3, 3},\n\t\t{10, 0, 0, 0.3, 0},\n\t\t{10, 1, 1, 0.3, 0},\n\t\t{2, 0, 1, -0.5, 0},\n\t\t{2, 0, 1, 1.5, 1},\n\t\t{2, 1, 0, -0.5, 1},\n\t\t{2, 1, 0, 1.5, 0},\n\t\t{2, 0, 1, math.Inf(-1), 0},\n\t\t{2, 0, 1, math.Inf(1), 1},\n\t\t{2, 1, 0, math.Inf(-1), 1},\n\t\t{2, 1, 0, math.Inf(1), 0},\n\t\t{3, 0, 1, math.Inf(-1), 0},\n\t\t{3, 0, 1, math.Inf(1), 2},\n\t\t{3, 1, 0, math.Inf(-1), 2},\n\t\t{3, 1, 0, math.Inf(1), 0},\n\n\t\t{11, math.Inf(-1), 0, 0.0, 10},\n\t\t{11, 0, math.Inf(-1), 0.0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0.0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0.0, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), 0.0, 4},\n\t\t{11, math.Inf(1), math.Inf(-1), 0.0, 5},\n\n\t\t{11, math.NaN(), 0.0, 0.0, 0},\n\t\t{11, 0.0, math.NaN(), 0.0, 10},\n\t\t{11, math.NaN(), math.NaN(), 0.0, 0},\n\n\t\t{11, 0, 1, math.NaN(), 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: n=%d, l=%v, u=%v, v=%v\\ngot  %d\\nwant %d\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, test.want,\n\t\t\t)\n\t\t}\n\t}\n}",
    "35e4e0a40afe6a5e168783bb39d5cb1d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Single element slice\n\t// - Multiple elements, nearest at beginning\n\t// - Multiple elements, nearest at end\n\t// - Multiple elements, nearest in middle\n\t// - Multiple nearest with same value, should return first index\n\t// - NaN in slice, should be skipped\n\t// - +Inf in slice\n\t// - -Inf in slice\n\t// - NaN value\n\t// - +Inf value\n\t// - -Inf value\n\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tv     float64\n\t\twant  int\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"Empty Slice\",\n\t\t\ts:     []float64{},\n\t\t\tv:     0,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"Single Element\",\n\t\t\ts:     []float64{1},\n\t\t\tv:     0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Nearest at Beginning\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Nearest at End\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     4,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Nearest in Middle\",\n\t\t\ts:     []float64{1, 3, 5},\n\t\t\tv:     2,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname:  \"Multiple Nearest, Return First\",\n\t\t\ts:     []float64{1, 2, 3, 1},\n\t\t\tv:     0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN in Slice\",\n\t\t\ts:     []float64{1, 2, math.NaN(), 3},\n\t\t\tv:     2.5,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname:  \"+Inf in Slice\",\n\t\t\ts:     []float64{1, 2, math.Inf(1), 3},\n\t\t\tv:     math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"-Inf in Slice\",\n\t\t\ts:     []float64{1, 2, math.Inf(-1), 3},\n\t\t\tv:     math.Inf(-1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN Value\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"+Inf Value\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"-Inf Value\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panic \u0026\u0026 r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic, but got none\")\n\t\t\t\t}\n\t\t\t\tif !tc.panic \u0026\u0026 r != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v, want %v\", tc.s, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "36b46310cb1e47d0cbd345cbb5e97feb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{4, 0, 1, 0.25, 0},\n\t\t{4, 0, 1, 0.75, 3},\n\t\t{10, 0, 1, 0.1, 1},\n\t\t{10, 0, 1, 0.9, 9},\n\t\t{10, 1, 0, 0.1, 9}, // l \u003e u\n\t\t{10, 1, 0, 0.9, 1}, // l \u003e u\n\n\t\t// Special cases for Inf and NaN.\n\t\t{10, math.NaN(), 1, 0.5, 9},\n\t\t{10, 0, math.NaN(), 0.5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0.5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), 1, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0.5, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 1, 6},\n\t\t{10, math.Inf(1), 0, 0.5, 5},\n\t\t{10, math.Inf(1), 0, 0, 4},\n\t\t{10, math.Inf(1), 0, 1, 5},\n\t\t{11, math.Inf(1), 0, 0.5, 5},\n\t\t{11, math.Inf(1), 0, 0, 6},\n\t\t{11, math.Inf(1), 0, 1, 5},\n\t\t{10, 0, math.Inf(1), 0.5, 9},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), 0, 0.5, 0},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), 0, 0, 9},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\n\t\t// Special cases for v outside (l, u) and (u, l).\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, -1, 9},\n\t\t{10, 1, 0, 2, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(rune(i)), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tassert.Equal(t, tc.expectedIdx, idx)\n\t\t})\n\n\t}\n}",
    "3777da618e67948fe1f0988381d359df": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases for SumCompensated.\n\t// Each test case consists of a slice of float64 values and the expected sum.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t// Empty slice.\n\t\t{[]float64{}, 0.0},\n\t\t// Single element slice.\n\t\t{[]float64{1.0}, 1.0},\n\t\t// Positive numbers.\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t// Negative numbers.\n\t\t{[]float64{-1.0, -2.0, -3.0, -4.0, -5.0}, -15.0},\n\t\t// Mixed positive and negative numbers.\n\t\t{[]float64{-1.0, 2.0, -3.0, 4.0, -5.0}, -3.0},\n\t\t// Numbers with very different magnitudes.\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t// Test case from Wikipedia.\n\t\t{[]float64{10000.0, 3.14159, 1e-6, -10000.0}, 3.1415900000106638},\n\t}\n\n\t// Iterate over the test cases.\n\tfor i, testCase := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(testCase.input)\n\n\t\t// Compare the actual sum with the expected sum.\n\t\tif math.Abs(actual-testCase.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, testCase.expected, actual)\n\t\t}\n\t}\n}",
    "382421897ddac293a7eaf5803663f8ba": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSub(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\twant        []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:        \"panic: length mismatch\",\n\t\t\tdst:         []float64{1, 2, 3},\n\t\t\ts:           []float64{1, 2},\n\t\t\twant:        nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"subtraction\",\n\t\t\tdst:         []float64{1, 2, 3},\n\t\t\ts:           []float64{4, 5, 6},\n\t\t\twant:        []float64{-3, -3, -3},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"empty slices\",\n\t\t\tdst:         []float64{},\n\t\t\ts:           []float64{},\n\t\t\twant:        []float64{},\n\t\t\tshouldPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.shouldPanic {\n\t\t\t\tassert.Panics(t, func() { Sub(tt.dst, tt.s) })\n\t\t\t} else {\n\t\t\t\tassert.NotPanics(t, func() { Sub(tt.dst, tt.s) })\n\t\t\t\tassert.Equal(t, tt.want, tt.dst)\n\t\t\t}\n\t\t})\n\t}\n\n}\n",
    "3843bad289f379e1a739b632988424fb": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttol := 1e-15\n\ttype testCase struct {\n\t\t// Input arguments\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t\t// Expected values\n\t\twantInds []int\n\t\twantErr  error\n\t}\n\n\ttestCases := []testCase{\n\t\t// Test case 1: k = 0, should return empty slice and nil error.\n\t\t{\n\t\t\tinds:     nil,\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        0,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Test case 2: k = -1, should return all indices satisfying f.\n\t\t{\n\t\t\tinds:     make([]int, 1, 5),\n\t\t\tf:        func(f float64) bool { return f \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\twantInds: []int{2, 3, 4},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Test case 3: k = 2, should return first 2 indices satisfying f.\n\t\t{\n\t\t\tinds:     make([]int, 1, 2),\n\t\t\tf:        func(f float64) bool { return f \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\twantInds: []int{2, 3},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Test case 4: k = 3, but only 2 elements satisfying f, should return error.\n\t\t{\n\t\t\tinds:     make([]int, 1, 2),\n\t\t\tf:        func(f float64) bool { return f \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 1, 2},\n\t\t\tk:        3,\n\t\t\twantInds: []int{2},\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\t// Run test cases\n\tfor i, tc := range testCases {\n\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t// Check error\n\t\tif (gotErr == nil \u0026\u0026 tc.wantErr != nil) || (gotErr != nil \u0026\u0026 tc.wantErr == nil) {\n\t\t\tt.Errorf(\"Test case %d: Error mismatch. Expected %v, got %v\", i+1, tc.wantErr, gotErr)\n\t\t\tcontinue\n\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\tt.Errorf(\"Test case %d: Error message mismatch. Expected %v, got %v\", i+1, tc.wantErr.Error(), gotErr.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check slice length\n\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\tt.Errorf(\"Test case %d: Slice length mismatch. Expected %d, got %d\", i+1, len(tc.wantInds), len(gotInds))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check slice elements\n\t\tfor j := range tc.wantInds {\n\t\t\tif gotInds[j] != tc.wantInds[j] {\n\t\t\t\tt.Errorf(\"Test case %d: Slice element mismatch at index %d. Expected %v, got %v\", i+1, j, tc.wantInds[j], gotInds[j])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "39db05dc4a24eb9227f51017d3d973fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/internal/mathutil\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 1, i: 1},\n\t\t{n: 2, l: -1, u: 1, v: 2, i: 1},\n\n\t\t{n: 3, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, i: 2},\n\n\t\t{n: 4, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: -0.5, i: 1},\n\t\t{n: 4, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 4, l: -1, u: 1, v: 0.5, i: 2},\n\t\t{n: 4, l: -1, u: 1, v: 1, i: 3},\n\t\t{n: 4, l: -1, u: 1, v: 2, i: 3},\n\n\t\t{n: 10, l: 0, u: 10, v: -1, i: 0},\n\t\t{n: 10, l: 0, u: 10, v: 0, i: 0},\n\t\t{n: 10, l: 0, u: 10, v: 1, i: 1},\n\t\t{n: 10, l: 0, u: 10, v: 2, i: 2},\n\t\t{n: 10, l: 0, u: 10, v: 3, i: 3},\n\t\t{n: 10, l: 0, u: 10, v: 4, i: 4},\n\t\t{n: 10, l: 0, u: 10, v: 5, i: 5},\n\t\t{n: 10, l: 0, u: 10, v: 6, i: 6},\n\t\t{n: 10, l: 0, u: 10, v: 7, i: 7},\n\t\t{n: 10, l: 0, u: 10, v: 8, i: 8},\n\t\t{n: 10, l: 0, u: 10, v: 9, i: 9},\n\t\t{n: 10, l: 0, u: 10, v: 10, i: 9},\n\t\t{n: 10, l: 0, u: 10, v: 11, i: 9},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v): got: %v want: %v\", test.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\t// Explicitly test the NaN cases.\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 0, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, i: 1},\n\t\t{n: 2, l: 0, u: 0, v: math.NaN(), i: 0},\n\n\t\t{n: 3, l: math.NaN(), u: 0, v: 0, i: 0},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 0, i: 2},\n\t\t{n: 3, l: 0, u: 0, v: math.NaN(), i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v): got: %v want: %v\", test.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\t// Explicitly test the Inf cases.\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, i: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, i: 1},\n\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0, i: 0},\n\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 0},\n\n\t\t{n: 3, l: math.Inf(1), u: 0, v: 0, i: 2},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, i: 0},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: 0, i: 2},\n\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: 0, i: 0},\n\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v): got: %v want: %v\", test.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer mathutil.CapturePanic(t, shortSpan)\n\tNearestIdxForSpan(1, 0, 1, 0)\n}",
    "3a76d4dd149871d67008d88252023be3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 4, 2, 3}, 0},\n\t\t{[]float64{1, math.NaN(), 2, 3}, 0},\n\t\t{[]float64{math.NaN(), 1, 2, 3}, 1},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d:  Got %v want %v\", i, got, test.want)\n\t\t}\n\t}\n}",
    "3adb71339e22f88f256492a10f5ad403": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 2},\n\n\t\t// Edge cases\n\t\t{2, 0, 0, 0, 0},\n\t\t{2, 1, 1, 1, 0},\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\n\t\t// Cases with NaN\n\t\t{2, math.NaN(), 1, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 1},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf\n\t\t{2, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{2, math.Inf(1), 0, math.Inf(1), 1},\n\t\t{2, 0, math.Inf(-1), math.Inf(-1), 0},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\n\t\t// Cases with v outside (l, u)\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 1, 0, -1, 2},\n\t\t{3, 1, 0, 2, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif idx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "3bddc91a49dd0c307d9de0e1281590c7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and u are very large values (to test for overflow)\n\t// - l and u are very small values (to test for underflow)\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l and u are -Inf\n\n\t// len(dst) \u003c 2\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular values\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very large values (to test for overflow)\n\tt.Run(\"LargeValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.MaxFloat64-1, math.MaxFloat64)\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif dst[i] \u003c= dst[i-1] {\n\t\t\t\tt.Errorf(\"Expected increasing values, got %v\", dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very small values (to test for underflow)\n\tt.Run(\"SmallValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.SmallestNonzeroFloat64, math.SmallestNonzeroFloat64*10)\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif dst[i] \u003c= dst[i-1] {\n\t\t\t\tt.Errorf(\"Expected increasing values, got %v\", dst)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected all NaN, got %v\", dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaNLeft\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-2] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected %v, got %v\", 1, dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"NaNRight\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected %v, got %v\", 0, dst[0])\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\tt.Errorf(\"Expected all +Inf, got %v\", dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"InfLeft\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"InfRight\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t})\n\n\t// l and u are -Inf\n\tt.Run(\"NegInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, -1) {\n\t\t\t\tt.Errorf(\"Expected all -Inf, got %v\", dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NegInfLeft\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"NegInfRight\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t})\n\n\tt.Run(\"InfBothDirs\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tfor i := range dst[len(dst)/2:] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "3d239a05153f127756cc4206cf13ce2f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, positive numbers,\n\t// negative numbers, mixed positive and negative numbers,\n\t// and numbers with large differences in magnitude.\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{[]float64{-1.0, 2.0, -3.0, 4.0}, 2.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t\t{[]float64{1e-10, 1.0, -1e-10}, 1.0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := SumCompensated(tc.input)\n\t\tif math.Abs(got-tc.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, got, tc.want)\n\t\t}\n\t}\n}\n",
    "3f1fcb2afc428a0210f30e3b742123c1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twantI int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, wantI: 0},   // v \u003c l \u003c u\n\t\t{n: 2, l: 0, u: 1, v: 0.1, wantI: 0},  // l \u003c v \u003c u\n\t\t{n: 2, l: 0, u: 1, v: 0.9, wantI: 1},  // l \u003c v \u003c u\n\t\t{n: 2, l: 0, u: 1, v: 1, wantI: 1},   // l \u003c u = v\n\t\t{n: 2, l: 0, u: 1, v: 2, wantI: 1},   // l \u003c u \u003c v\n\n\t\t{n: 2, l: 1, u: 0, v: -1, wantI: 1},   // v \u003c u \u003c l\n\t\t{n: 2, l: 1, u: 0, v: 0.1, wantI: 1},  // u \u003c v \u003c l\n\t\t{n: 2, l: 1, u: 0, v: 0.9, wantI: 0},  // u \u003c v \u003c l\n\t\t{n: 2, l: 1, u: 0, v: 1, wantI: 0},   // u \u003c l = v\n\t\t{n: 2, l: 1, u: 0, v: 2, wantI: 0},   // u \u003c l \u003c v\n\n\t\t{n: 10, l: -1, u: 1, v: -2, wantI: 0},\n\t\t{n: 10, l: -1, u: 1, v: -1, wantI: 0},\n\t\t{n: 10, l: -1, u: 1, v: 0, wantI: 4},\n\t\t{n: 10, l: -1, u: 1, v: 1, wantI: 9},\n\t\t{n: 10, l: -1, u: 1, v: 2, wantI: 9},\n\n\t\t{n: 11, l: -1, u: 1, v: -2, wantI: 0},\n\t\t{n: 11, l: -1, u: 1, v: -1, wantI: 0},\n\t\t{n: 11, l: -1, u: 1, v: 0, wantI: 5},\n\t\t{n: 11, l: -1, u: 1, v: 1, wantI: 10},\n\t\t{n: 11, l: -1, u: 1, v: 2, wantI: 10},\n\n\t\t{n: 2, l: 0, u: 0, v: -1, wantI: 0},\n\t\t{n: 2, l: 0, u: 0, v: 0, wantI: 0},\n\t\t{n: 2, l: 0, u: 0, v: 1, wantI: 0},\n\n\t\t// v is NaN\n\t\t{n: 2, l: 0, u: 1, v: math.NaN(), wantI: 0},\n\t\t{n: 2, l: 1, u: 0, v: math.NaN(), wantI: 0},\n\t\t{n: 2, l: 0, u: 0, v: math.NaN(), wantI: 0},\n\n\t\t// l is NaN\n\t\t{n: 2, l: math.NaN(), u: 1, v: -1, wantI: 1},\n\t\t{n: 2, l: math.NaN(), u: 1, v: 0, wantI: 1},\n\t\t{n: 2, l: math.NaN(), u: 1, v: 1, wantI: 1},\n\t\t{n: 2, l: math.NaN(), u: 1, v: 2, wantI: 1},\n\n\t\t// u is NaN\n\t\t{n: 2, l: 1, u: math.NaN(), v: -1, wantI: 0},\n\t\t{n: 2, l: 1, u: math.NaN(), v: 0, wantI: 0},\n\t\t{n: 2, l: 1, u: math.NaN(), v: 1, wantI: 0},\n\t\t{n: 2, l: 1, u: math.NaN(), v: 2, wantI: 0},\n\n\t\t// l and u are NaN\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: -1, wantI: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 0, wantI: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 1, wantI: 0},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 2, wantI: 0},\n\n\t\t// l is -Inf\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: -1, wantI: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: 0, wantI: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: 1, wantI: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: 2, wantI: 1},\n\n\t\t// u is Inf\n\t\t{n: 2, l: 0, u: math.Inf(1), v: -1, wantI: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, wantI: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 1, wantI: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 2, wantI: 0},\n\n\t\t// l is -Inf, u is Inf\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: -1, wantI: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, wantI: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 1, wantI: 1},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 2, wantI: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: -1, wantI: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, wantI: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 1, wantI: 2},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 2, wantI: 2},\n\n\t\t// v is -Inf\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(-1), wantI: 0},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(-1), wantI: 1},\n\t\t{n: 2, l: 0, u: 0, v: math.Inf(-1), wantI: 0},\n\n\t\t// v is Inf\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(1), wantI: 1},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(1), wantI: 0},\n\t\t{n: 2, l: 0, u: 0, v: math.Inf(1), wantI: 0},\n\t} {\n\t\tgotI := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif gotI != tc.wantI {\n\t\t\tt.Errorf(\"unexpected index for testCase %d: got: %d want: %d\", i, gotI, tc.wantI)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\ttest.Panic(t, \"shortSpan\", func() { NearestIdxForSpan(1, 0, 1, 0) })\n}\n",
    "3fa7e3b95f5c707b1cf62da5c1bdb6f4": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tc    float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tc:    5.0,\n\t\t\tdst:  []float64{2, 3, 1, 7},\n\t\t\twant: []float64{7, 8, 6, 12},\n\t\t},\n\t\t{\n\t\t\tc:    -5.0,\n\t\t\tdst:  []float64{2, 3, 1, 7},\n\t\t\twant: []float64{-3, -2, -4, 2},\n\t\t},\n\t\t{\n\t\t\tc:    0,\n\t\t\tdst:  []float64{2, 3, 1, 7},\n\t\t\twant: []float64{2, 3, 1, 7},\n\t\t},\n\t\t{\n\t\t\tc:    5.3,\n\t\t\tdst:  []float64{2.2, 3.1, 1.6, 7.8},\n\t\t\twant: []float64{7.5, 8.4, 6.9, 13.1},\n\t\t},\n\t} {\n\t\t// Make a copy of dst to avoid modifying the test case.\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tAddConst(test.c, dstCopy)\n\t\tif !testlapack.EqualApprox(dstCopy, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Test %d: AddConst mismatch. Want %v, got %v.\", i, test.want, dstCopy)\n\t\t}\n\t}\n}",
    "402da2b0239a95cd0ad9382497c83698": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroSpan\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Span(%v, %v, %v) returned slice with unexpected length. Got: %v, Want: %v\", tc.dst, tc.l, tc.u, len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif !checkNaNInfEqual(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panics when len(dst) \u003c 2.\n\tt.Run(\"PanicsOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\n// checkNaNInfEqual compares two float64 values for equality,\n// considering NaN and Inf values as equal.\nfunc checkNaNInfEqual(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\tif math.IsInf(a, 0) \u0026\u0026 math.IsInf(b, 0) \u0026\u0026 math.Signbit(a) == math.Signbit(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}\n",
    "408bf5d6763678341e7519c97944b765": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case: Panics if len(dst) \u003c 2\n\tt.Run(\"Panics if len(dst) \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0.0, 1.0)\n\t})\n\n\t// Test case: Returns expected values for various inputs\n\tt.Run(\"Returns expected values for various inputs\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\tname string\n\t\t\tdst  []float64\n\t\t\tl    float64\n\t\t\tu    float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{\n\t\t\t\t\"Basic case\",\n\t\t\t\tmake([]float64, 5),\n\t\t\t\t0.0,\n\t\t\t\t4.0,\n\t\t\t\t[]float64{0.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Negative bounds\",\n\t\t\t\tmake([]float64, 3),\n\t\t\t\t-1.0,\n\t\t\t\t1.0,\n\t\t\t\t[]float64{-1.0, 0.0, 1.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"NaN lower bound\",\n\t\t\t\tmake([]float64, 4),\n\t\t\t\tmath.NaN(),\n\t\t\t\t2.0,\n\t\t\t\t[]float64{math.NaN(), math.NaN(), math.NaN(), 2.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"NaN upper bound\",\n\t\t\t\tmake([]float64, 4),\n\t\t\t\t-2.0,\n\t\t\t\tmath.NaN(),\n\t\t\t\t[]float64{-2.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Both bounds Inf\",\n\t\t\t\tmake([]float64, 4),\n\t\t\t\tmath.Inf(1),\n\t\t\t\tmath.Inf(-1),\n\t\t\t\t[]float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Lower bound Inf\",\n\t\t\t\tmake([]float64, 4),\n\t\t\t\tmath.Inf(1),\n\t\t\t\t2.0,\n\t\t\t\t[]float64{math.Inf(1), math.Inf(1), math.Inf(1), 2.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Upper bound Inf\",\n\t\t\t\tmake([]float64, 4),\n\t\t\t\t-2.0,\n\t\t\t\tmath.Inf(-1),\n\t\t\t\t[]float64{-2.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(got, tc.want) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n",
    "4171fcb628d4c71d3830d56fe113e994": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is less than 2\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) })\n\n\t// v is NaN\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, math.NaN()))\n\n\t// l is NaN, u is not NaN\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.NaN(), 1, 0.5))\n\n\t// u is NaN\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.NaN(), 0.5))\n\n\t// l and u are both +Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(1), math.Inf(1), 0.5))\n\n\t// l and u are both -Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), math.Inf(-1), 0.5))\n\n\t// l and u are both Inf but have different signs\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), -1.0))\n\tassert.Equal(t, 1, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0.0))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 1.0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 0.0))\n\n\t// l is +Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(1), 0, math.Inf(1)))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(1), 0, 0))\n\n\t// l is -Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), 0, math.Inf(-1)))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(-1), 0, 0))\n\n\t// u is +Inf\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.Inf(1), math.Inf(1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.Inf(1), 0))\n\n\t// u is -Inf\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.Inf(-1), math.Inf(-1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.Inf(-1), 0))\n\n\t// v is -Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, math.Inf(-1)))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 1, 0, math.Inf(-1)))\n\n\t// v is +Inf\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, math.Inf(1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 1, 0, math.Inf(1)))\n\n\t// l \u003c u\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, -1))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 1))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 2))\n\n\t// l \u003e u\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 1, 0, -1))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 1, 0, 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 1, 0, 1))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 1, 0, 2))\n\n\t// regular cases\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, 0.1))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 0.9))\n\tassert.Equal(t, 5, NearestIdxForSpan(10, 0, 1, 0.5))\n}\n",
    "425513ae8a69a98a714e8b3f95e333d2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 2},\n\n\t\t// Edge cases\n\t\t{2, 0, 0, 0.5, 0},    // l == u\n\t\t{2, 0, 1, 0, 0},     // v == l\n\t\t{2, 0, 1, 1, 1},     // v == u\n\t\t{3, 0, 1, -0.5, 0},   // v \u003c l\n\t\t{3, 0, 1, 1.5, 2},   // v \u003e u\n\t\t{10, 0, 10, 5, 5},   // Integer values\n\t\t{10, -5, 5, 0, 5},  // Negative bounds\n\t\t{10, -5, 5, -2.5, 2}, // Negative v\n\n\t\t// Infinities and NaNs\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0},                // l = -Inf, u = Inf\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},                // l = -Inf, u = Inf, n odd\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},              // l = -Inf\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},                // u = Inf\n\t\t{2, math.NaN(), 0, 0, 0},                         // l = NaN\n\t\t{2, 0, math.NaN(), 0, 1},                         // u = NaN\n\t\t{2, 0, 1, math.NaN(), 0},                         // v = NaN\n\t\t{2, math.Inf(-1), math.Inf(1), math.NaN(), 0},     // l = -Inf, u = Inf, v = NaN\n\t\t{3, math.Inf(-1), math.Inf(1), math.NaN(), 1},     // l = -Inf, u = Inf, n odd, v = NaN\n\t\t{2, math.Inf(-1), 0, math.NaN(), 0},              // l = -Inf, v = NaN\n\t\t{2, 0, math.Inf(1), math.NaN(), 1},                // u = Inf, v = NaN\n\t\t{2, math.NaN(), 0, math.Inf(-1), 0},             // l = NaN, v = -Inf\n\t\t{2, 0, math.NaN(), math.Inf(-1), 1},             // u = NaN, v = -Inf\n\t\t{2, math.NaN(), 0, math.Inf(1), 0},              // l = NaN, v = Inf\n\t\t{2, 0, math.NaN(), math.Inf(1), 1},              // u = NaN, v = Inf\n\t\t{2, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // l = -Inf, u = Inf, v = -Inf\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // l = -Inf, u = Inf, n odd, v = -Inf\n\t\t{2, math.Inf(-1), math.Inf(1), math.Inf(1), 1},  // l = -Inf, u = Inf, v = Inf\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},  // l = -Inf, u = Inf, n odd, v = Inf\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) returned %d, expected %d\",\n\t\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, idx, tc.expectedIdx)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "4255a92f176f4d91698166bcd5e8c176": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slices\n\t// 2. Single element slices\n\t// 3. Multiple element slices\n\t// 4. Slices with different lengths (should panic)\n\n\t// Test case 1: Empty slices\n\tdst1 := []float64{}\n\ts1 := []float64{}\n\tMul(dst1, s1)\n\tif len(dst1) != 0 {\n\t\tt.Errorf(\"TestMul failed: Expected empty slice, got %v\", dst1)\n\t}\n\n\t// Test case 2: Single element slices\n\tdst2 := []float64{2.0}\n\ts2 := []float64{3.0}\n\tMul(dst2, s2)\n\tif len(dst2) != 1 || dst2[0] != 6.0 {\n\t\tt.Errorf(\"TestMul failed: Expected {6.0}, got %v\", dst2)\n\t}\n\n\t// Test case 3: Multiple element slices\n\tdst3 := []float64{1.0, 2.0, 3.0}\n\ts3 := []float64{4.0, 5.0, 6.0}\n\tMul(dst3, s3)\n\tif len(dst3) != 3 || dst3[0] != 4.0 || dst3[1] != 10.0 || dst3[2] != 18.0 {\n\t\tt.Errorf(\"TestMul failed: Expected {4.0, 10.0, 18.0}, got %v\", dst3)\n\t}\n\n\t// Test case 4: Slices with different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"TestMul failed: Expected panic, but got no panic\")\n\t\t}\n\t}()\n\tdst4 := []float64{1.0, 2.0}\n\ts4 := []float64{1.0, 2.0, 3.0}\n\tMul(dst4, s4)\n}",
    "427a068f7b9d98292d45ba8f0298d820": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCasePositive\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseNegative\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseMixed\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0.0, 0.0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\t// Check for length and value correctness\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) { // Special case for NaN comparison\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking with short slice\n\tt.Run(\"ShortSlicePanic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short slice\")\n\t\t\t}\n\t\t}()\n\n\t\tshortSlice := make([]float64, 1)\n\t\tSpan(shortSlice, 0.0, 1.0)\n\t})\n}\n",
    "437c902372f0d98605b3971c25a238e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is less than 2\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) }, \"Should panic when n \u003c 2\")\n\n\t// v is NaN\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, 1, math.NaN()))\n\n\t// l is NaN, u is not NaN\n\tassert.Equal(t, 2, NearestIdxForSpan(3, math.NaN(), 1, 0.5))\n\n\t// u is NaN\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, math.NaN(), 0.5))\n\n\t// Both l and u are Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(1), math.Inf(1), 0.5))\n\tassert.Equal(t, 1, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(4, math.Inf(-1), math.Inf(1), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(1), math.Inf(-1), 0.5))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), math.Inf(1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(1), math.Inf(-1), math.Inf(1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(4, math.Inf(-1), math.Inf(1), math.Inf(1)))\n\n\t// l is Inf\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(1), 1, math.Inf(1)))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, math.Inf(1), 1, 0.5))\n\n\t// u is Inf\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, math.Inf(1), math.Inf(1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, math.Inf(1), 0.5))\n\n\t// v is Inf\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, 1, math.Inf(-1)))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 1, 0, math.Inf(-1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, 1, math.Inf(1)))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 1, 0, math.Inf(1)))\n\n\t// v is outside (l, u)\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, 1, -1))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, 1, 2))\n\n\t// v is outside (u, l)\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 1, 0, -1))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 1, 0, 2))\n\n\t// Regular cases\n\tassert.Equal(t, 0, NearestIdxForSpan(3, 0, 1, 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(3, 0, 1, 0.5))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, 1, 1))\n\tassert.Equal(t, 1, NearestIdxForSpan(4, 0, 1, 0.4))\n\tassert.Equal(t, 2, NearestIdxForSpan(4, 0, 1, 0.6))\n}",
    "43b37766db5973e6b66d2f8e975f0b50": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttol := 1e-15\n\ttype testCase struct {\n\t\t// Input arguments\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t\t// Expected output\n\t\texpInds []int\n\t\terr     error\n\t}\n\ttestCases := []testCase{\n\t\t// Empty slice\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       -1,\n\t\t\texpInds: []int{},\n\t\t\terr:     nil,\n\t\t},\n\t\t// Request zero elements.\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{-1, 1, 2, -2},\n\t\t\tk:       0,\n\t\t\texpInds: []int{},\n\t\t\terr:     nil,\n\t\t},\n\t\t// Request all elements.\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{-1, 1, 2, -2},\n\t\t\tk:       -1,\n\t\t\texpInds: []int{1, 2},\n\t\t\terr:     nil,\n\t\t},\n\t\t// Request more elements than exist\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{-1, 1, 2, -2},\n\t\t\tk:       3,\n\t\t\texpInds: nil,\n\t\t\terr:     errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Request specific number of elements\n\t\t{\n\t\t\tinds:    nil,\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{-1, 1, 2, -2},\n\t\t\tk:       2,\n\t\t\texpInds: []int{1, 2},\n\t\t\terr:     nil,\n\t\t},\n\t}\n\t// Loop through each case.\n\tfor ic, c := range testCases {\n\t\t// Run the function.\n\t\tinds := make([]int, len(c.inds))\n\t\tcopy(inds, c.inds)\n\t\tgotInds, err := Find(inds, c.f, c.s, c.k)\n\t\t// Check for errors\n\t\tif c.err != nil \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"Case %d: expected error, got nil (s=%v, k=%v)\",\n\t\t\t\tic, c.s, c.k)\n\t\t\tcontinue\n\t\t} else if c.err == nil \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"Case %d: unexpected error: %v\", ic, err)\n\t\t\tcontinue\n\t\t} else if c.err != nil \u0026\u0026 err != nil {\n\t\t\tif c.err.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"Case %d: unexpected error string: got %s, want %s\",\n\t\t\t\t\tic, err.Error(), c.err.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Check the output\n\t\tif len(gotInds) != len(c.expInds) {\n\t\t\tt.Errorf(\"Case %d: length of inds wrong: got %d want %d\",\n\t\t\t\tic, len(gotInds), len(c.expInds))\n\t\t\tcontinue\n\t\t}\n\t\tfor i, got := range gotInds {\n\t\t\twant := c.expInds[i]\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"Case %d: element %d of inds wrong: got %v want %v\",\n\t\t\t\t\tic, i, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "43da2b9b629e14fe67c3831d7c5be202": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: -0.5, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1.5, i: 1},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: -0.5, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1.5, i: 0},\n\n\t\t{n: 3, l: 0, u: 2, v: -1, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: -0.5, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: 0, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: 0.5, i: 0},\n\t\t{n: 3, l: 0, u: 2, v: 1, i: 1},\n\t\t{n: 3, l: 0, u: 2, v: 1.5, i: 2},\n\t\t{n: 3, l: 0, u: 2, v: 2, i: 2},\n\t\t{n: 3, l: 0, u: 2, v: 2.5, i: 2},\n\n\t\t{n: 3, l: 2, u: 0, v: -1, i: 2},\n\t\t{n: 3, l: 2, u: 0, v: -0.5, i: 2},\n\t\t{n: 3, l: 2, u: 0, v: 0, i: 2},\n\t\t{n: 3, l: 2, u: 0, v: 0.5, i: 1},\n\t\t{n: 3, l: 2, u: 0, v: 1, i: 0},\n\t\t{n: 3, l: 2, u: 0, v: 1.5, i: 0},\n\t\t{n: 3, l: 2, u: 0, v: 2, i: 0},\n\t\t{n: 3, l: 2, u: 0, v: 2.5, i: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got index %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, got, test.i)\n\t\t}\n\t}\n\n\t// Test a bunch of random values\n\trnd := testlapack.NewRand()\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tn := rnd.Intn(100) + 2\n\t\tl := rnd.NormFloat64()\n\t\tu := rnd.NormFloat64()\n\t\tv := rnd.NormFloat64()\n\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\twant := bruteForceNearestIdxForSpan(n, l, u, v)\n\t\tif got != want {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got index %d, want %d\", n, l, u, v, got, want)\n\t\t}\n\t}\n\n}\n\nfunc bruteForceNearestIdxForSpan(n int, l, u, v float64) int {\n\ts := make([]float64, n)\n\tSpan(s, l, u)\n\treturn NearestIdx(s, v)\n}\n\nfunc TestNearestIdxForSpanSpecial(t *testing.T) {\n\t// NaN returns 0\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t}{\n\t\t{n: 2, l: 0, u: 1},\n\t\t{n: 2, l: 1, u: 0},\n\t\t{n: 2, l: 0, u: math.NaN()},\n\t\t{n: 2, l: math.NaN(), u: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, math.NaN())\n\t\tif got != 0 {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = NaN: got index %d, want 0\",\n\t\t\t\ttest.n, test.l, test.u, got)\n\t\t}\n\t}\n\n\t// Test cases with infinity\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 2},\n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(1), v: 0, i: 0},\n\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 4, l: 0, u: math.Inf(1), v: math.Inf(1), i: 3},\n\n\t\t{n: 2, l: math.Inf(1), u: 0, v: math.Inf(-1), i: 1},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: math.Inf(-1), i: 2},\n\t\t{n: 4, l: math.Inf(1), u: 0, v: math.Inf(-1), i: 3},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got index %d, want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, got, test.i)\n\t\t}\n\t}\n\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"Did not panic with invalid slice length\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "448e96e64dc8a814b9196333c8e74a69": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases with different n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{2, 0, 1, -0.5, 0},\n\t\t{2, 0, 1, 1.5, 1},\n\t\t{2, 1, 0, 0.5, 1},\n\t\t{2, 1, 0, -0.5, 0},\n\t\t{2, 1, 0, 1.5, 0},\n\n\t\t// n = 3\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 1},\n\t\t{3, 1, 0, 0.3, 1},\n\t\t{3, 1, 0, 0.7, 0},\n\n\t\t// n = 4\n\t\t{4, 0, 1, 0.2, 0},\n\t\t{4, 0, 1, 0.4, 1},\n\t\t{4, 0, 1, 0.6, 2},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{4, 1, 0, 0.2, 3},\n\t\t{4, 1, 0, 0.4, 2},\n\t\t{4, 1, 0, 0.6, 1},\n\t\t{4, 1, 0, 0.8, 0},\n\n\t\t// Special cases for Inf and NaN.\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{3, math.NaN(), math.Inf(1), 0, 2},\n\t\t{3, math.Inf(-1), math.NaN(), 0, 0},\n\t\t{4, math.Inf(-1), math.Inf(1), math.Inf(1), 3},\n\t\t{4, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tassert.Equal(t, tc.want, got, \"n=%d, l=%v, u=%v, v=%v\", tc.n, tc.l, tc.u, tc.v)\n\t\t})\n\t}\n}",
    "44b252eb7d64662d0890dd69335bcff7": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tk        int\n\t\tinput    []float64\n\t\tf        func(float64) bool\n\t\texpected []int\n\t\terr      error\n\t}\n\ttestCases := []testCase{\n\t\t// Find first 3 even numbers.\n\t\t{\n\t\t\tk:        3,\n\t\t\tinput:    []float64{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\tf:        func(v float64) bool { return int(v)%2 == 0 },\n\t\t\texpected: []int{1, 3, 5},\n\t\t\terr:      nil,\n\t\t},\n\t\t// Find all even numbers.\n\t\t{\n\t\t\tk:        -1,\n\t\t\tinput:    []float64{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\tf:        func(v float64) bool { return int(v)%2 == 0 },\n\t\t\texpected: []int{1, 3, 5, 7},\n\t\t\terr:      nil,\n\t\t},\n\t\t// Find first 3 numbers greater than 5, not enough.\n\t\t{\n\t\t\tk:        3,\n\t\t\tinput:    []float64{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\tf:        func(v float64) bool { return v \u003e 5 },\n\t\t\texpected: []int{5, 6, 7, 8},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Find first 0 elements.\n\t\t{\n\t\t\tk:        0,\n\t\t\tinput:    []float64{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\tf:        func(v float64) bool { return int(v)%2 == 0 },\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\tinds := make([]int, 0, len(tc.expected))\n\t\tgot, err := Find(inds, tc.f, tc.input, tc.k)\n\t\tif (err != nil \u0026\u0026 tc.err == nil) || (err == nil \u0026\u0026 tc.err != nil) || (err != nil \u0026\u0026 tc.err != nil \u0026\u0026 err.Error() != tc.err.Error()) {\n\t\t\tt.Errorf(\"Case %d failed: input %v, expected error %v, got %v\", i, tc.input, tc.err, err)\n\t\t}\n\t\tif len(got) != len(tc.expected) {\n\t\t\tt.Errorf(\"Case %d failed: input %v, expected %v, got %v\", i, tc.input, tc.expected, got)\n\t\t}\n\t\tfor j := 0; j \u003c len(got); j++ {\n\t\t\tif got[j] != tc.expected[j] {\n\t\t\t\tt.Errorf(\"Case %d failed: input %v, expected %v, got %v\", i, tc.input, tc.expected, got)\n\t\t\t}\n\t\t}\n\n\t}\n}",
    "4511cbb301b7d8bfcf0b0dedbc359aa4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    2.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{2.0, 5.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) returned slice of length %v, want %v\", tc.dst, tc.l, tc.u, len(got), len(tc.want))\n\t\t\t}\n\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-6 {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanNaNInf(t *testing.T) {\n\t// Test cases for NaN and Inf inputs\n\tnan := math.NaN()\n\tinf := math.Inf(1)\n\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    nan,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{nan, nan, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    nan,\n\t\t\twant: []float64{0.0, nan, nan},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    inf,\n\t\t\tu:    inf,\n\t\t\twant: []float64{inf, inf, inf, inf},\n\t\t},\n\t\t{\n\t\t\tname: \"LeftInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    inf,\n\t\t\tu:    0,\n\t\t\twant: []float64{inf, inf, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"RightInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    inf,\n\t\t\twant: []float64{0.0, inf, inf},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) returned slice of length %v, want %v\", tc.dst, tc.l, tc.u, len(got), len(tc.want))\n\t\t\t}\n\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif math.IsNaN(got[i]) != math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\t// Test that Span panics when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\n\tSpan(make([]float64, 1), 0, 1)\n}",
    "453441fed479c6b931c95d8e6a2dc624": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// Basic cases.\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\n\t\t// Cases with NaN.\n\t\t{2, math.NaN(), 1, 0.5, 1},\n\t\t{2, 0, math.NaN(), 0.5, 0},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf.\n\t\t{2, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0.5, 1},\n\t\t{2, math.Inf(-1), math.Inf(1), 0.5, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), 0, 0.5, 1},\n\n\t\t// Cases with v outside (l, u).\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 2, 1},\n\n\t\t// Cases with l \u003e u.\n\t\t{2, 1, 0, 0.5, 1},\n\t\t{3, 1, 0, 0.5, 1},\n\t\t{4, 1, 0, 0.5, 2},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tassert.Equal(t, tc.want, got)\n\t\t})\n\t}\n}",
    "45a30c5828885a89ba83eb56d93bcb68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is less than 2\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) })\n\n\t// v is NaN\n\tassert.Equal(t, NearestIdxForSpan(2, 0, 1, math.NaN()), 0)\n\n\t// l is NaN and u is not NaN\n\tassert.Equal(t, NearestIdxForSpan(2, math.NaN(), 1, 0.5), 1)\n\n\t// u is NaN\n\tassert.Equal(t, NearestIdxForSpan(2, 0, math.NaN(), 0.5), 0)\n\n\t// l and u are both Inf and equal\n\tassert.Equal(t, NearestIdxForSpan(2, math.Inf(1), math.Inf(1), 0.5), 0)\n\n\t// l and u are both Inf and not equal, n is odd, v is not Inf\n\tassert.Equal(t, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0.5), 1)\n\n\t// l and u are both Inf and not equal, n is odd, v is Inf and has same sign as l\n\tassert.Equal(t, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), math.Inf(-1)), 0)\n\n\t// l and u are both Inf and not equal, n is odd, v is Inf and has different sign from l\n\tassert.Equal(t, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), math.Inf(1)), 2)\n\n\t// l and u are both Inf and not equal, n is even, v is Inf and has same sign as l\n\tassert.Equal(t, NearestIdxForSpan(4, math.Inf(-1), math.Inf(1), math.Inf(-1)), 0)\n\n\t// l and u are both Inf and not equal, n is even, v is Inf and has different sign from l\n\tassert.Equal(t, NearestIdxForSpan(4, math.Inf(-1), math.Inf(1), math.Inf(1)), 2)\n\n\t// l is Inf, v equals l\n\tassert.Equal(t, NearestIdxForSpan(2, math.Inf(-1), 0, math.Inf(-1)), 0)\n\n\t// l is Inf, v does not equal l\n\tassert.Equal(t, NearestIdxForSpan(2, math.Inf(-1), 0, 0.5), 1)\n\n\t// u is Inf, v equals u\n\tassert.Equal(t, NearestIdxForSpan(2, 0, math.Inf(1), math.Inf(1)), 1)\n\n\t// u is Inf, v does not equal u\n\tassert.Equal(t, NearestIdxForSpan(2, 0, math.Inf(1), 0.5), 0)\n\n\t// v is -Inf, l \u003c= u\n\tassert.Equal(t, NearestIdxForSpan(2, 0, 1, math.Inf(-1)), 0)\n\n\t// v is -Inf, l \u003e u\n\tassert.Equal(t, NearestIdxForSpan(2, 1, 0, math.Inf(-1)), 1)\n\n\t// v is +Inf, u \u003c= l\n\tassert.Equal(t, NearestIdxForSpan(2, 1, 0, math.Inf(1)), 0)\n\n\t// v is +Inf, u \u003e l\n\tassert.Equal(t, NearestIdxForSpan(2, 0, 1, math.Inf(1)), 1)\n\n\t// l \u003c u, v \u003c= l\n\tassert.Equal(t, NearestIdxForSpan(2, 0, 1, -1), 0)\n\n\t// l \u003c u, v \u003e= u\n\tassert.Equal(t, NearestIdxForSpan(2, 0, 1, 2), 1)\n\n\t// l \u003e u, v \u003e= l\n\tassert.Equal(t, NearestIdxForSpan(2, 1, 0, 2), 0)\n\n\t// l \u003e u, v \u003c= u\n\tassert.Equal(t, NearestIdxForSpan(2, 1, 0, -1), 1)\n\n\t// regular cases\n\tassert.Equal(t, NearestIdxForSpan(10, 0, 1, 0.25), 2)\n\tassert.Equal(t, NearestIdxForSpan(10, 0, 1, 0.75), 7)\n\tassert.Equal(t, NearestIdxForSpan(10, 1, 0, 0.25), 7)\n\tassert.Equal(t, NearestIdxForSpan(10, 1, 0, 0.75), 2)\n}\n",
    "4627622097568676db1c4bb86f0f6c45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: (n, l, u, v, expectedIndex)\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 1},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{100, 0, 1, 0.33, 33},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\n\t\t// Cases with NaN, Inf\n\t\t{5, 0, 10, math.NaN(), 0},\n\t\t{5, math.NaN(), 10, 5, 4},\n\t\t{5, 0, math.NaN(), 5, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{5, 0, 10, math.Inf(-1), 0},\n\t\t{5, 0, 10, math.Inf(1), 4},\n\t\t{5, 10, 0, math.Inf(-1), 4},\n\t\t{5, 10, 0, math.Inf(1), 0},\n\n\t\t// Cases with v outside (l, u)\n\t\t{5, 0, 10, -1, 0},\n\t\t{5, 0, 10, 11, 4},\n\t\t{5, 10, 0, -1, 4},\n\t\t{5, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v, expected index %d, but got %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, actualIdx)\n\t\t}\n\t}\n}\n",
    "4779c1536b5e5170e27ec9a3d10c39ae": "",
    "47f60ea89af4f421e1d95c0dab96a75e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx\n\ttestCases := []struct {\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{1, 2, 3, 4, 4}, 3},\n\t\t{[]float64{math.NaN(), 2, 3, 4, 5}, 0},\n\t\t{[]float64{1, math.NaN(), 3, 4, 5}, 0},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, 0},\n\t\t{[]float64{1, 2, 3, math.NaN(), 5}, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 0},\n\t\t{[]float64{1, math.NaN(), math.NaN(), 4, 5}, 0},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Run MaxIdx and compare the output with the expected value\n\t\tgot := MaxIdx(tc.input)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: MaxIdx(%v) = %d, want %d\", i, tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "485f3f9430a5c1ee9fe363f2c8c5ca6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{s: []float64{1, 2, 3, 4}, wantIdx: 0},\n\t\t{s: []float64{4, 3, 2, 1}, wantIdx: 3},\n\t\t{s: []float64{1, 4, 2, 3}, wantIdx: 0},\n\t\t{s: []float64{1, 2, 1, 0}, wantIdx: 3},\n\t\t{s: []float64{math.NaN(), 2, 3, 4}, wantIdx: 1},\n\t\t{s: []float64{1, math.NaN(), 3, 4}, wantIdx: 0},\n\t\t{s: []float64{4, 3, 2, math.NaN()}, wantIdx: 0},\n\t\t{wantPanic: true},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != c.wantPanic {\n\t\t\t\t\tt.Errorf(\"Got panic=%v, want panic=%v\", gotPanic, c.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MinIdx(c.s)\n\t\t\tif gotIdx != c.wantIdx {\n\t\t\t\tt.Errorf(\"Got Idx: %v, want Idx: %v\", gotIdx, c.wantIdx)\n\t\t\t}\n\t\t})\n\n\t}\n\n}",
    "4902acfcc99189c581fc8a8766675600": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the vector\n\t// l: lower bound\n\t// u: upper bound\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Simple cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\n\t\t// Non-uniform spans\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "498646d911c3405408999849c323ca03": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttol := 1e-14\n\ts := []float64{1, 2, 3, 4, 5}\n\tif math.Abs(Norm(s, 1)-15) \u003e tol {\n\t\tt.Errorf(\"Sum of absolute values incorrect\")\n\t}\n\tif math.Abs(Norm(s, 2)-math.Sqrt(55)) \u003e tol {\n\t\tt.Errorf(\"2-norm incorrect\")\n\t}\n\tif math.Abs(Norm(s, 3)-math.Pow(225, 0.3333333333333333)) \u003e tol {\n\t\tt.Errorf(\"3-norm incorrect\")\n\t}\n\tif math.Abs(Norm(s, 4)-math.Pow(979, 0.25)) \u003e tol {\n\t\tt.Errorf(\"4-norm incorrect\")\n\t}\n\tif math.Abs(Norm(s, math.Inf(1))-5) \u003e tol {\n\t\tt.Errorf(\"Inf-norm incorrect\")\n\t}\n}\n",
    "49ba2faa968d0b16296a65774ac0301a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, want\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t// Non-uniform span\n\t\t{10, 1, 11, 6, 5},\n\t\t// Fractional values\n\t\t{10, 0, 1, 0.5, 5},\n\t\t// Negative span\n\t\t{10, -10, 0, -5, 5},\n\t\t// Span with NaN\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t// Span with Inf\n\t\t{10, math.Inf(1), 10, 5, 9},\n\t\t{10, 0, math.Inf(1), 5, 0},\n\t\t{10, math.Inf(-1), 0, -5, 0},\n\t\t{10, 0, math.Inf(-1), 5, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t// v is NaN or Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "49f1f6060a6fe1ef71ebca94b2d03f19": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n \u003c 2 should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n\tt.Log(\"Testing special cases for NaN.\")\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.NaN(), 1, 0.5))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.NaN(), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.NaN(), math.NaN(), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, math.NaN()))\n\n\tt.Log(\"Testing cases for Inf.\")\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.Inf(1), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), 1, 1.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 1.5))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.Inf(-1), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(1), 1, 1.5))\n\n\tt.Log(\"Testing standard cases.\")\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, -1))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, 0.1))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 0.9))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 1))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 2))\n\n\tt.Log(\"Testing standard cases, reversed bounds.\")\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 1, 0, -1))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 1, 0, 0))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 1, 0, 0.1))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 1, 0, 0.9))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 1, 0, 1))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 1, 0, 2))\n}\n",
    "4a76c915a614c1a32e928870371d7c11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.9, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.4, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.6, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 0.9, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.9, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.4, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.6, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 0.9, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 10, l: 0, u: 1, v: 0.22, want: 2},\n\t\t{n: 10, l: 0, u: 1, v: 0.25, want: 2},\n\t\t{n: 10, l: 0, u: 1, v: 0.28, want: 3},\n\n\t\t{n: 10, l: 1, u: 0, v: 0.72, want: 7},\n\t\t{n: 10, l: 1, u: 0, v: 0.75, want: 7},\n\t\t{n: 10, l: 1, u: 0, v: 0.78, want: 8},\n\n\t\t// Cases with infinite bounds.\n\t\t{n: 2, l: 0, u: math.Inf(1), v: -1, want: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 1, want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), want: 1},\n\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: -math.Inf(1), want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: -1, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 1, want: 1},\n\n\t\t{n: 3, l: 0, u: math.Inf(1), v: -1, want: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 1, want: 1},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1), want: 2},\n\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: -math.Inf(1), want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: -1, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, want: 2},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 1, want: 2},\n\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: -1, want: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: 1, want: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), want: 0},\n\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: -1, want: 1,\n\t\t},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0, want: 1,\n\t\t},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: 1, want: 1,\n\t\t},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1),\n\t\t\twant: 1,\n\t\t},\n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -1, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 1, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -1, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: 1, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1),\n\t\t\twant: 1,\n\t\t},\n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: -math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 1},\n\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: -math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 2},\n\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: -math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 3},\n\n\t\t{n: 5, l: math.Inf(-1), u: math.Inf(1), v: -math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{n: 5, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 2},\n\t\t{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 4},\n\n\t\t{n: 101, l: math.Inf(-1), u: math.Inf(1), v: -math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{n: 101, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1),\n\t\t\twant: 100,\n\t\t},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif have != test.want {\n\t\t\tt.Errorf(\"Case %d: n=%d, l=%v, u=%v, v=%v\\n\",\n\t\t\t\ti, test.n, test.l, test.u, test.v)\n\t\t\tt.Errorf(\"\\thave %v\\n\", have)\n\t\t\tt.Errorf(\"\\twant %v\\n\", test.want)\n\t\t}\n\t}\n}",
    "4b1a23c141eedc527eec4c3fbbbf89e3": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\texpected := []float64{-3, -3, -3}\n\tSubTo(dst, s, t)\n\tassert.Equal(t, expected, dst)\n}",
    "4ba005c9cdfe22faa8fc506e95a25089": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of elements\n\t// l: lower bound\n\t// u: upper bound\n\t// v: value to find nearest to\n\t// want: expected index\n\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 1, 0.5, 2},\n\t\t{5, 0, 1, -1, 0},\n\t\t{5, 0, 1, 1.1, 4},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 0, 0, 0},\n\t\t{2, 1, 1, 1, 0},\n\n\t\t// Infinities\n\t\t{5, 0, math.Inf(1), 1, 1},\n\t\t{5, 0, math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), 0, -1, 4},\n\t\t{5, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3},\n\n\t\t// NaNs\n\t\t{5, 0, 1, math.NaN(), 0},\n\t\t{5, math.NaN(), 1, 0, 4},\n\t\t{5, 0, math.NaN(), 0, 0},\n\n\t\t// Reversed bounds\n\t\t{5, 1, -1, 0.5, 2},\n\t\t{5, 1, -1, 2, 0},\n\t\t{5, 1, -1, -2, 4},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d for n=%d, l=%v, u=%v, v=%v\", i+1, got, tc.want, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "4c6cdb436525f21ceeedad76790926b9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\ts3 := []float64{1, 2}\n\ts4 := []float64{3, 4}\n\n\t// Test case 1: L = 2 (Euclidean distance)\n\texpected1 := 8.0\n\tresult1 := Distance(s1, s2, 2)\n\tif result1 != expected1 {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s1, s2, result1, expected1)\n\t}\n\n\t// Test case 2: L = 1 (Manhattan distance)\n\texpected2 := 16.0\n\tresult2 := Distance(s1, s2, 1)\n\tif result2 != expected2 {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, expected %v\", s1, s2, result2, expected2)\n\t}\n\n\t// Test case 3: L = math.Inf(1) (Chebyshev distance)\n\texpected3 := 4.0\n\tresult3 := Distance(s1, s2, math.Inf(1))\n\tif result3 != expected3 {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, expected %v\", s1, s2, result3, expected3)\n\t}\n\n\t// Test case 4: L = 3\n\texpected4 := math.Pow(math.Pow(4, 3)+math.Pow(4, 3)+math.Pow(4, 3)+math.Pow(4, 3), 1.0/3.0)\n\tresult4 := Distance(s1, s2, 3)\n\tif result4 != expected4 {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, expected %v\", s1, s2, result4, expected4)\n\t}\n\n\t// Test case 5: Empty slices\n\texpected5 := 0.0\n\tresult5 := Distance([]float64{}, []float64{}, 2)\n\tif result5 != expected5 {\n\t\tt.Errorf(\"Distance([]float64{}, []float64{}, 2) = %v, expected %v\", result5, expected5)\n\t}\n\n\t// Test case 6: Different length slices (should panic)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic with different length slices\")\n\t\t}\n\t}()\n\tDistance(s3, s1, 2)\n}\n",
    "4cbcd075e4543798c309fb6ee26e85d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// expected: the expected index\n\n\ttestCases := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t// Simple cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t\t{10, 0, math.NaN(), 0, 0},\n\t\t{10, math.NaN(), 10, 10, 9},\n\n\t\t// Odd vs even length with infinite bounds\n\t\t{9, math.Inf(-1), math.Inf(1), 0, 4},  // odd\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5}, // even\n\n\t\t// v outside (l, u) and (u, l)\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%v, u=%v, v=%v\", i, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}\n",
    "4e1af0d7b8ed5d716b99fd19e75c5557": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\ts          []float64\n\t\twant       []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:       \"Equal length vectors\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\ts:          []float64{4, 5, 6},\n\t\t\twant:       []float64{5, 7, 9},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Zero length vectors\",\n\t\t\tdst:        []float64{},\n\t\t\ts:          []float64{},\n\t\t\twant:       []float64{},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Different length vectors\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\ts:          []float64{4, 5},\n\t\t\twant:       nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif test.shouldPanic \u0026\u0026 r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t\tif !test.shouldPanic \u0026\u0026 r != nil {\n\t\t\t\t\tt.Errorf(\"The code paniced when it should not\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tAdd(test.dst, test.s)\n\n\t\t\tif !test.shouldPanic {\n\t\t\t\tfor i := range test.dst {\n\t\t\t\t\tif test.dst[i] != test.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Different values at index %v. Want: %v, got: %v\", i, test.want, test.dst)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t})\n\t}\n\n}",
    "4eb979ccf40b8e4948c951fe71f3192c": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\twant := []float64{4.0 / 1.0, 5.0 / 2.0, 6.0 / 3.0}\n\n\tgot := MulTo(dst, s, t)\n\n\tassert.Equal(t, want, got)\n}",
    "4ee2b8620a8d952f91ac91175e990d11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of points in the span\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// expected: the expected index\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{5, 0, 1, 0.5, 2},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Tie goes to the lower index\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\n\t\t// Cases with non-uniform spans\n\t\t{5, -10, 10, 0, 2},\n\t\t{5, -10, 10, -5, 1},\n\t\t{5, -10, 10, 5, 3},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d for n=%d, l=%f, u=%f, v=%f\", i, tc.expected, actual, tc.n, tc.l, tc.u, tc.v)\n\t\t}\n\t}\n}",
    "50a644966ebeb9b5f9f075ffe29701a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test that Span panics if len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span should have panicked for len(dst) \u003c 2\")\n\t\t}\n\t}()\n\t_ = Span(make([]float64, 1), 0, 1)\n\n\t// Test basic usage of Span\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span failed: expected %v, got %v\", expected, dst)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test Span with negative bounds\n\tSpan(dst, -1, 1)\n\texpected = []float64{-1.0, -0.5, 0.0, 0.5, 1.0}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span failed: expected %v, got %v\", expected, dst)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test special cases for Inf and NaN\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\t\"NaN low\",\n\t\t\tmake([]float64, 3),\n\t\t\tmath.NaN(), 1,\n\t\t\t[]float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\t\"NaN high\",\n\t\t\tmake([]float64, 3),\n\t\t\t0, math.NaN(),\n\t\t\t[]float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\t\"Inf low\",\n\t\t\tmake([]float64, 3),\n\t\t\tmath.Inf(1), 1,\n\t\t\t[]float64{math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\t\"Inf high\",\n\t\t\tmake([]float64, 3),\n\t\t\t0, math.Inf(1),\n\t\t\t[]float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\t\"Inf both same\",\n\t\t\tmake([]float64, 3),\n\t\t\tmath.Inf(1), math.Inf(1),\n\t\t\t[]float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\t\"Inf both different\",\n\t\t\tmake([]float64, 3),\n\t\t\tmath.Inf(-1), math.Inf(1),\n\t\t\t[]float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\t\"Inf both different even\",\n\t\t\tmake([]float64, 4),\n\t\t\tmath.Inf(-1), math.Inf(1),\n\t\t\t[]float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tSpan(test.dst, test.l, test.u)\n\t\t\tfor i := range test.dst {\n\t\t\t\tif !equalSpecial(test.dst[i], test.expected[i]) {\n\t\t\t\t\tt.Errorf(\"Span %s failed: expected %v, got %v\", test.name, test.expected, test.dst)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSpecial(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\tif math.IsInf(a, 0) \u0026\u0026 math.IsInf(b, 0) \u0026\u0026 math.Signbit(a) == math.Signbit(b) {\n\t\treturn true\n\t}\n\treturn a == b\n}",
    "50bf89e11cdfc6a5f67944e93b69ded7": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tinds := make([]int, 10)\n\n\t// Test for k = -1 (all elements)\n\tf := func(v float64) bool { return v \u003e 0 }\n\tinds, err := Find(inds, f, s, -1)\n\tif err != nil {\n\t\tt.Errorf(\"TestFind: error returned for k = -1, err = %v\", err)\n\t}\n\tif len(inds) != 10 {\n\t\tt.Errorf(\"TestFind: incorrect number of indices returned for k = -1, want 10, got %v\", len(inds))\n\t}\n\n\t// Test for k = 0 (no elements)\n\tf = func(v float64) bool { return v \u003e 10 }\n\tinds, err = Find(inds, f, s, 0)\n\tif err != nil {\n\t\tt.Errorf(\"TestFind: error returned for k = 0, err = %v\", err)\n\t}\n\tif len(inds) != 0 {\n\t\tt.Errorf(\"TestFind: incorrect number of indices returned for k = 0, want 0, got %v\", len(inds))\n\t}\n\n\t// Test for k \u003e 0 (first k elements)\n\tf = func(v float64) bool { return v \u003e 5 }\n\tinds, err = Find(inds, f, s, 3)\n\tif err != nil {\n\t\tt.Errorf(\"TestFind: error returned for k \u003e 0, err = %v\", err)\n\t}\n\tif len(inds) != 3 {\n\t\tt.Errorf(\"TestFind: incorrect number of indices returned for k \u003e 0, want 3, got %v\", len(inds))\n\t}\n\tfor i := 0; i \u003c 3; i++ {\n\t\tif inds[i] != i+6 {\n\t\t\tt.Errorf(\"TestFind: incorrect index returned for k \u003e 0, want %v, got %v\", i+6, inds[i])\n\t\t}\n\t}\n\n\t// Test for k \u003e 0 (insufficient elements)\n\tf = func(v float64) bool { return v \u003e 5 }\n\tinds, err = Find(inds, f, s, 10)\n\tif err == nil {\n\t\tt.Errorf(\"TestFind: no error returned for k \u003e 0 and insufficient elements\")\n\t}\n\tif len(inds) != 5 {\n\t\tt.Errorf(\"TestFind: incorrect number of indices returned for k \u003e 0 and insufficient elements, want 5, got %v\", len(inds))\n\t}\n\n\t// Test with nil inds\n\tinds = nil\n\tf = func(v float64) bool { return v \u003e 5 }\n\tinds, err = Find(inds, f, s, 3)\n\tif err != nil {\n\t\tt.Errorf(\"TestFind: error returned for nil inds, err = %v\", err)\n\t}\n\tif len(inds) != 3 {\n\t\tt.Errorf(\"TestFind: incorrect number of indices returned for nil inds, want 3, got %v\", len(inds))\n\t}\n}\n",
    "5100393d9c20179d1f466df07560df26": "package floats\n\nimport \"testing\"\n\nfunc TestAddScaled(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\talpha float64\n\t\ts     []float64\n\t\twant  []float64\n\t}{\n\t\t{\n\t\t\tname:  \"Basic case\",\n\t\t\tdst:   []float64{1, 2, 3},\n\t\t\talpha: 2.0,\n\t\t\ts:     []float64{4, 5, 6},\n\t\t\twant:  []float64{9, 12, 15},\n\t\t},\n\t\t{\n\t\t\tname:  \"Zero alpha\",\n\t\t\tdst:   []float64{1, 2, 3},\n\t\t\talpha: 0.0,\n\t\t\ts:     []float64{4, 5, 6},\n\t\t\twant:  []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:  \"Negative alpha\",\n\t\t\tdst:   []float64{1, 2, 3},\n\t\t\talpha: -1.0,\n\t\t\ts:     []float64{4, 5, 6},\n\t\t\twant:  []float64{-3, -3, -3},\n\t\t},\n\t}\n\n\t// Run test cases\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tAddScaled(tc.dst, tc.alpha, tc.s)\n\t\t\tif !Equal(tc.dst, tc.want) {\n\t\t\t\tt.Errorf(\"AddScaled(%v, %v, %v) = %v, want %v\", tc.dst, tc.alpha, tc.s, tc.dst, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic on length mismatch\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddScaled did not panic on length mismatch\")\n\t\t}\n\t}()\n\tAddScaled([]float64{1, 2}, 2.0, []float64{1, 2, 3})\n}",
    "513e0f7a072d293d0d8efdd905153883": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\tt           []float64\n\t\texpected    []float64\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Subtracting slices of equal length\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\texpected: []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname:        \"Subtracting slices of different lengths\",\n\t\t\tdst:         make([]float64, 2),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5},\n\t\t\texpectPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Subtracting with empty slices\",\n\t\t\tdst:         []float64{},\n\t\t\ts:           []float64{},\n\t\t\tt:           []float64{},\n\t\t\texpected:    []float64{},\n\t\t},\n\t\t{\n\t\t\tname:        \"Subtracting into smaller destination\",\n\t\t\tdst:         make([]float64, 2),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5, 6},\n\t\t\texpectPanic: true,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.expectPanic {\n\t\t\t\tassert.Panics(t, func() { SubTo(test.dst, test.s, test.t) })\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, test.expected, SubTo(test.dst, test.s, test.t))\n\t\t\t}\n\t\t})\n\t}\n}",
    "51de97e964a1fffb9b422eb59da5400d": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDiv(t *testing.T) {\n\tdst := []float64{1, 2, 3, 4, 5}\n\ts := []float64{2, 2, 3, 4, 1}\n\texpected := []float64{0.5, 1, 1, 1, 5}\n\tDiv(dst, s)\n\tassert.Equal(t, expected, dst)\n\n\tassert.Panics(t, func() { Div([]float64{1, 2, 3}, []float64{1, 2}) })\n}\n",
    "51e62d3003c1cef2b289488bb49642bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Out of bounds low\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Out of bounds high\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds infinite, same sign\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds infinite, different sign, odd n\",\n\t\t\tn:    11,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds infinite, different sign, even n\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinite lower bound\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinite upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Descending span\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tassert.Equal(t, tt.want, got)\n\t\t})\n\t}\n\n\t// Test that it panics when n \u003c 2\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 10, 5) })\n}\n",
    "51e6755e7f508768bca93b584325caa1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{2, 0, 1, 0.1, 0},\n\t\t{2, 0, 1, 0.9, 1},\n\t\t{2, 1, 0, 0.5, 1},\n\t\t{2, 1, 0, 0.1, 0},\n\t\t{2, 1, 0, 0.9, 1},\n\n\t\t// n = 3\n\t\t{3, 0, 1, 0.33, 0},\n\t\t{3, 0, 1, 0.66, 1},\n\t\t{3, 1, 0, 0.33, 1},\n\t\t{3, 1, 0, 0.66, 0},\n\n\t\t// n = 4\n\t\t{4, 0, 1, 0.25, 0},\n\t\t{4, 0, 1, 0.75, 2},\n\t\t{4, 1, 0, 0.25, 2},\n\t\t{4, 1, 0, 0.75, 0},\n\n\t\t// Special cases\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.NaN(), 1, 0.5, 8},\n\t\t{10, 0, math.NaN(), 0.5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 1, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), -1, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "51f37ea8b340d88b86dd6365594f823f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\t// Test cases: empty slice, slice with infinity, regular slices\n\tt.Run(\"Empty slice should panic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tLogSumExp([]float64{})\n\t})\n\n\tt.Run(\"Slice with infinity should return infinity\", func(t *testing.T) {\n\t\tgot := LogSumExp([]float64{1.0, math.Inf(1)})\n\t\tif !math.IsInf(got, 1) {\n\t\t\tt.Errorf(\"LogSumExp([]float64{1.0, math.Inf(1)}) = %v, want Inf\", got)\n\t\t}\n\n\t\tgot = LogSumExp([]float64{1.0, math.Inf(-1)})\n\t\tif !math.IsInf(got, -1) {\n\t\t\tt.Errorf(\"LogSumExp([]float64{1.0, math.Inf(-1)}) = %v, want -Inf\", got)\n\t\t}\n\t})\n\n\tt.Run(\"Regular slices should return correct logsumexp\", func(t *testing.T) {\n\t\tgot := LogSumExp([]float64{1.0, 2.0, 3.0})\n\t\twant := math.Log(math.Exp(1.0) + math.Exp(2.0) + math.Exp(3.0))\n\t\tif !EqualApprox([]float64{got}, []float64{want}, 1e-15) {\n\t\t\tt.Errorf(\"LogSumExp([]float64{1.0, 2.0, 3.0}) = %v, want %v\", got, want)\n\t\t}\n\n\t\tgot = LogSumExp([]float64{-1.0, -2.0, -3.0})\n\t\twant = math.Log(math.Exp(-1.0) + math.Exp(-2.0) + math.Exp(-3.0))\n\t\tif !EqualApprox([]float64{got}, []float64{want}, 1e-15) {\n\t\t\tt.Errorf(\"LogSumExp([]float64{-1.0, -2.0, -3.0}) = %v, want %v\", got, want)\n\t\t}\n\t})\n}\n",
    "535e683dd7462e2c87fae6b37215e513": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\td float64\n\t}{\n\t\t{[]float64{2, 4, 6, 8}, []float64{1, 3, 5, 7}, 1, 4,},\n\t\t{[]float64{2, 4, 6, 8}, []float64{1, 3, 5, 7}, 2, math.Sqrt(4),},\n\t\t{[]float64{2, 4, 6, 8}, []float64{1, 3, 5, 7}, math.Inf(1), 1,},\n\t\t{[]float64{2, 4, 6, 8}, []float64{2, 4, 6, 8}, 2, 0,},\n\t} {\n\t\tgot := Distance(c.s, c.t, c.L)\n\t\tif got != c.d {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", c.s, c.t, c.L, got, c.d)\n\t\t}\n\t}\n}\n",
    "54cf5f7fc12931717650aaf61a9e1990": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// n=2\n\tcheckNearestIdxForSpan(t, 2, 0, 1, 0.1, 0, tol)\n\tcheckNearestIdxForSpan(t, 2, 0, 1, 0.9, 1, tol)\n\tcheckNearestIdxForSpan(t, 2, 0, 1, -math.Inf(1), 0, tol)\n\tcheckNearestIdxForSpan(t, 2, 0, 1, math.Inf(1), 1, tol)\n\tcheckNearestIdxForSpan(t, 2, 0, 1, math.NaN(), 0, tol)\n\n\t// n=3\n\tcheckNearestIdxForSpan(t, 3, 0, 1, 0.1, 0, tol)\n\tcheckNearestIdxForSpan(t, 3, 0, 1, 0.4, 1, tol)\n\tcheckNearestIdxForSpan(t, 3, 0, 1, 0.9, 2, tol)\n\tcheckNearestIdxForSpan(t, 3, 0, 1, -math.Inf(1), 0, tol)\n\tcheckNearestIdxForSpan(t, 3, 0, 1, math.Inf(1), 2, tol)\n\tcheckNearestIdxForSpan(t, 3, 0, 1, math.NaN(), 0, tol)\n\n\t// n=4\n\tcheckNearestIdxForSpan(t, 4, 0, 1, 0.1, 0, tol)\n\tcheckNearestIdxForSpan(t, 4, 0, 1, 0.4, 1, tol)\n\tcheckNearestIdxForSpan(t, 4, 0, 1, 0.6, 2, tol)\n\tcheckNearestIdxForSpan(t, 4, 0, 1, 0.9, 3, tol)\n\tcheckNearestIdxForSpan(t, 4, 0, 1, -math.Inf(1), 0, tol)\n\tcheckNearestIdxForSpan(t, 4, 0, 1, math.Inf(1), 3, tol)\n\tcheckNearestIdxForSpan(t, 4, 0, 1, math.NaN(), 0, tol)\n\n}\nfunc checkNearestIdxForSpan(t *testing.T, n int, l, u, v float64, want int, tol float64) {\n\thave := NearestIdxForSpan(n, l, u, v)\n\tif have != want {\n\t\tt.Errorf(\"NearestIdxForSpan(%v,%v,%v,%v) = %v, want %v\", n, l, u, v, have, want)\n\t}\n}\n",
    "5510c4a37a65894d6414bbbb693794cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Cases with NaN\n\t\t{2, math.NaN(), 1, 0.5, 0},\n\t\t{2, 0, math.NaN(), 0.5, 0},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf\n\t\t{2, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0.5, 1},\n\t\t{2, math.Inf(-1), math.Inf(1), 0.5, 1},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// Cases with v outside (l, u)\n\t\t{2, 0, 1, -0.5, 0},\n\t\t{2, 0, 1, 1.5, 1},\n\t\t{2, 1, 0, -0.5, 1},\n\t\t{2, 1, 0, 1.5, 0},\n\n\t\t// Cases with equal l and u\n\t\t{2, 0, 0, 0.5, 0},\n\t\t{3, 1, 1, 0.5, 0},\n\n\t\t// Fuzz test cases\n\t\t{10, 0.2, 0.8, 0.3, 2},\n\t\t{10, -0.8, -0.2, -0.7, 1},\n\t\t{100, -100, 100, 50, 75},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactualIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actualIdx != tc.expectedIdx {\n\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v got index %d, expected %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, actualIdx, tc.expectedIdx)\n\t\t}\n\t}\n}\n",
    "553492048d9a895e0c7a6480f8a52aa9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 2, []float64{-1, 0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 3, []float64{-1, 0, 1, 2, 3}},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Test case %d: Span(%v, %v, %v) = %v, want %v\", i, tc.dst, tc.l, tc.u, got, tc.want)\n\t\t}\n\t}\n\t//test cases when l or u is NaN\n\tnanCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t}\n\tfor i, tc := range nanCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Test case %d: Span(%v, %v, %v) = %v, want %v\", i, tc.dst, tc.l, tc.u, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases when l or u is Inf\n\tinfCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), 1, []float64{math.Inf(1), 1}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(-1), []float64{0, math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t}\n\tfor i, tc := range infCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Test case %d: Span(%v, %v, %v) = %v, want %v\", i, tc.dst, tc.l, tc.u, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 1)\n}\n",
    "557c377cf77cfee5862a9c9ac824624d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with different lengths and values.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10, 1e-10}, 5e-10},\n\t\t{[]float64{1e10, 1e10, 1e10, 1e10, 1e10}, 5e10},\n\t\t{[]float64{-1, 1, -1e-10, 1e-10}, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within the expected tolerance.\n\t\tif !Float64Equal(actual, tc.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n// Float64Equal compares two float64 values for equality within a small tolerance.\nfunc Float64Equal(a, b float64) bool {\n\ttolerance := 1e-10\n\treturn math.Abs(a-b) \u003c tolerance\n}",
    "566741d6f8a87aed21ab7e8ff5149d73": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 1},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 0, 1, 0, 1},\n\t\t{2, 0, 1, 1, 1},\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.i {\n\t\t\t\tt.Errorf(\"For n = %v, l = %v, u = %v, and v = %v\\nexpected index %v, got %v\", tc.n, tc.l, tc.u, tc.v, tc.i, got)\n\t\t\t}\n\t\t})\n\t}\n}",
    "585b7ac09a3b8d7ae48ddfa3fb2ed341": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with three elements\n\t// - Slice with many elements\n\t// - Slice with NaN values\n\t// - Slice with Inf values\n\t// - Slice with mixed NaN and Inf values\n\n\t// Test case 1: Empty slice\n\tdst := make([]float64, 0)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 2: Slice with one element\n\tdst = make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n\n\t// Test case 3: Slice with two elements\n\tdst = make([]float64, 2)\n\tSpan(dst, 0, 1)\n\tif dst[0] != 0 || dst[1] != 1 {\n\t\tt.Errorf(\"Span() = %v, want [0 1]\", dst)\n\t}\n\n\t// Test case 4: Slice with three elements\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, 1)\n\tif dst[0] != 0 || dst[1] != 0.5 || dst[2] != 1 {\n\t\tt.Errorf(\"Span() = %v, want [0 0.5 1]\", dst)\n\t}\n\n\t// Test case 5: Slice with many elements\n\tdst = make([]float64, 10)\n\tSpan(dst, 0, 1)\n\texpected := []float64{0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9}\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Span() = %v, want %v\", dst, expected)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 6: Slice with NaN values\n\tdst = make([]float64, 3)\n\tSpan(dst, math.NaN(), 1)\n\tif !math.IsNaN(dst[0]) || !math.IsNaN(dst[1]) || dst[2] != 1 {\n\t\tt.Errorf(\"Span() = %v, want [NaN NaN 1]\", dst)\n\t}\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 || !math.IsNaN(dst[1]) || !math.IsNaN(dst[2]) {\n\t\tt.Errorf(\"Span() = %v, want [0 NaN NaN]\", dst)\n\t}\n\n\t// Test case 7: Slice with Inf values\n\tdst = make([]float64, 3)\n\tSpan(dst, math.Inf(1), 1)\n\tif !math.IsInf(dst[0], 1) || !math.IsInf(dst[1], 1) || dst[2] == 1 {\n\t\tt.Errorf(\"Span() = %v, want [Inf Inf 1]\", dst)\n\t}\n\tdst = make([]float64, 3)\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 || math.IsInf(dst[1], 1) || math.IsInf(dst[2], 1) {\n\t\tt.Errorf(\"Span() = %v, want [0 Inf Inf]\", dst)\n\t}\n\tdst = make([]float64, 3)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tif !math.IsInf(dst[0], 1) || !math.IsInf(dst[2], -1) || dst[1] != 0 {\n\t\tt.Errorf(\"Span() = %v, want [Inf 0 -Inf]\", dst)\n\t}\n\n\t// Test case 8: Slice with mixed NaN and Inf values\n\tdst = make([]float64, 3)\n\tSpan(dst, math.NaN(), math.Inf(1))\n\tif !math.IsNaN(dst[0]) || !math.IsNaN(dst[1]) || math.IsInf(dst[2], 1) {\n\t\tt.Errorf(\"Span() = %v, want [NaN NaN Inf]\", dst)\n\t}\n}\n",
    "58c241954b2664727c41d7721efab838": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tdst := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\texpected := []float64{5, 7, 9}\n\n\tAdd(dst, s)\n\tassert.Equal(t, expected, dst)\n}\n\nfunc TestAddPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\n\tdst := []float64{1, 2, 3}\n\ts := []float64{4, 5}\n\tAdd(dst, s)\n}",
    "596038e104a8cfd0669b4e0ae9d834d2": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Define test cases.\n\ttestCases := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname:    \"EmptySlice\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       1,\n\t\t\twant:    []int{},\n\t\t\twantErr: errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:    \"ZeroElementsRequested\",\n\t\t\tinds:    []int{1, 2, 3},\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{1, 2, 3, 4},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllElementsSatisfy\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(v float64) bool { return v \u003e 0 },\n\t\t\ts:       []float64{1, 2, 3, 4},\n\t\t\tk:       -1,\n\t\t\twant:    []int{0, 1, 2, 3},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"SomeElementsSatisfy\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(v float64) bool { return v \u003e 2 },\n\t\t\ts:       []float64{1, 2, 3, 4},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"KLessThanFound\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(v float64) bool { return v \u003e 2 },\n\t\t\ts:       []float64{1, 2, 3, 4},\n\t\t\tk:       1,\n\t\t\twant:    []int{2},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname:    \"KGreaterThanFound\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(v float64) bool { return v \u003e 2 },\n\t\t\ts:       []float64{1, 2, 3, 4},\n\t\t\tk:       3,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\t// Run test cases.\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Call Find.\n\t\t\tgot, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\t// Check error.\n\t\t\tif (err != nil \u0026\u0026 tc.wantErr == nil) || (err == nil \u0026\u0026 tc.wantErr != nil) {\n\t\t\t\tt.Fatalf(\"got error = %v, want error = %v\", err, tc.wantErr)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 err.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Fatalf(\"got error = %v, want error = %v\", err, tc.wantErr)\n\t\t\t}\n\n\t\t\t// Check result.\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"got inds = %v, want inds = %v\", got, tc.want)\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Fatalf(\"got inds = %v, want inds = %v\", got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "59cfb0df3d116931d8ef233f5c4d4ba1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tfor i, n := range []int{0, 1} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif err := recover(); err == nil {\n\t\t\t\t\tt.Errorf(\"Test %d: Expected panic with dst length %d\", i, n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdst := make([]float64, n)\n\t\t\tSpan(dst, 0, 1)\n\t\t}()\n\t}\n\n\t// Simple cases.\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\twant []float64\n\t}{\n\t\t{2, 0, 1, []float64{0, 1}},\n\t\t{3, 0, 1, []float64{0, 0.5, 1}},\n\t\t{4, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{5, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{3, -1, 5, []float64{-1, 2, 5}},\n\t} {\n\t\tdst := make([]float64, tc.n)\n\t\tgot := Span(dst, tc.l, tc.u)\n\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Test %d: Got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n\n\t// Special cases.\n\tinf := math.Inf(1)\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\twant []float64\n\t}{\n\t\t{4, math.NaN(), 0, []float64{math.NaN(), math.NaN(), math.NaN(), 0}},\n\t\t{4, 0, math.NaN(), []float64{0, math.NaN(), math.NaN(), math.NaN()}},\n\t\t{5, inf, inf, []float64{inf, inf, inf, inf, inf}},\n\t\t{6, inf, inf, []float64{inf, inf, inf, inf, inf, inf}},\n\t\t{5, inf, 0, []float64{inf, inf, 0, 0, 0}},\n\t\t{6, inf, 0, []float64{inf, inf, 0, 0, 0, 0}},\n\t\t{5, 0, inf, []float64{0, 0, 0, inf, inf}},\n\t\t{6, 0, inf, []float64{0, 0, 0, inf, inf, inf}},\n\t\t{5, inf, -inf, []float64{inf, inf, 0, -inf, -inf}},\n\t\t{6, inf, -inf, []float64{inf, inf, inf, -inf, -inf, -inf}},\n\t} {\n\t\tdst := make([]float64, tc.n)\n\t\tgot := Span(dst, tc.l, tc.u)\n\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Test %d: Got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "59e9807e410b3b1e42476d1626350de1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Regular span\n\tdst := make([]float64, 5)\n\tl := 0.0\n\tu := 1.0\n\texpected := []float64{0.0, 0.25, 0.5, 0.75, 1.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Test case 1 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 2: Span with NaN lower bound\n\tdst = make([]float64, 5)\n\tl = math.NaN()\n\tu = 1.0\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Test case 2 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 3: Span with NaN upper bound\n\tdst = make([]float64, 5)\n\tl = 0.0\n\tu = math.NaN()\n\texpected = []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"Test case 3 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 4: Span with infinite lower and upper bounds\n\tdst = make([]float64, 6)\n\tl = math.Inf(1)\n\tu = math.Inf(1)\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Test case 4 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 5: Span with infinite lower bound\n\tdst = make([]float64, 5)\n\tl = math.Inf(1)\n\tu = 1.0\n\texpected = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1.0}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Test case 5 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 6: Span with infinite upper bound\n\tdst = make([]float64, 5)\n\tl = 0.0\n\tu = math.Inf(1)\n\texpected = []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsInf(dst[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\tt.Errorf(\"Test case 6 failed: Expected %v, got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 7: Span with length less than 2\n\tdst = make([]float64, 1)\n\tl = 0.0\n\tu = 1.0\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case 7 failed: Expected panic, but got none\")\n\t\t}\n\t}()\n\tSpan(dst, l, u)\n}\n",
    "5a067b714f12586ffcf7e6ed3a76e094": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 0},\n\t\t{[]float64{5, 4, 3, 2, 1}, 4},\n\t\t{[]float64{1, 5, 3, 2, 4}, 0},\n\t\t{[]float64{1, math.NaN(), 3, 2, 4}, 0},\n\t\t{[]float64{math.NaN(), 1, 3, 2, 4}, 1},\n\t}\n\n\tfor i, tc := range tests {\n\t\tgot := MinIdx(tc.input)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: input %v - got %d, want %d\", i, tc.input, got, tc.want)\n\t\t}\n\t}\n}",
    "5aa15949cd7c6551c734080cf1d8b245": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - v is less than the first element\n\t// - v is greater than the last element\n\t// - v is NaN\n\t// - v is within the slice\n\t// - v is equal to an element in the slice\n\n\t// Empty slice\n\t{\n\t\ts := []float64{}\n\t\tv := 1.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tWithin(s, v)\n\t}\n\n\t// Slice with one element\n\t{\n\t\ts := []float64{1.0}\n\t\tv := 1.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tWithin(s, v)\n\t}\n\t// Unsorted slice\n\t{\n\t\ts := []float64{1.0, 0.0}\n\t\tv := 1.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tWithin(s, v)\n\t}\n\t// v is less than the first element\n\t{\n\t\ts := []float64{1.0, 2.0}\n\t\tv := 0.0\n\t\texpected := -1\n\t\tans := Within(s, v)\n\t\tif ans != expected {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, ans)\n\t\t}\n\t}\n\n\t// v is greater than the last element\n\t{\n\t\ts := []float64{1.0, 2.0}\n\t\tv := 3.0\n\t\texpected := -1\n\t\tans := Within(s, v)\n\t\tif ans != expected {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, ans)\n\t\t}\n\t}\n\n\t// v is NaN\n\t{\n\t\ts := []float64{1.0, 2.0}\n\t\tv := math.NaN()\n\t\texpected := -1\n\t\tans := Within(s, v)\n\t\tif ans != expected {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, ans)\n\t\t}\n\t}\n\n\t// v is within the slice\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tv := 1.5\n\t\texpected := 0\n\t\tans := Within(s, v)\n\t\tif ans != expected {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, ans)\n\t\t}\n\t}\n\n\t// v is equal to an element in the slice\n\t{\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tv := 2.0\n\t\texpected := 1\n\t\tans := Within(s, v)\n\t\tif ans != expected {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expected, ans)\n\t\t}\n\t}\n}\n",
    "5cab14684e3236374aff22310a463d29": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\twantIdx  int\n\t\twantPanic bool\n\t}{\n\t\t{nil, 0, true},\n\t\t{[]float64{1}, 0, false},\n\t\t{[]float64{1, 2, 3, 4, 5}, 4, false},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0, false},\n\t\t{[]float64{1, 5, 4, 3, 2}, 1, false},\n\t\t{[]float64{1, 4, 5, 3, 2}, 2, false},\n\t\t{[]float64{1, 2, 3, 5, 4}, 3, false},\n\t\t{[]float64{1, math.NaN(), 3}, 2, false},\n\t\t{[]float64{1, 3, math.NaN()}, 1, false},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != c.wantPanic {\n\t\t\t\t\tt.Errorf(\"Got panic=%v, want panic=%v\", gotPanic, c.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgotIdx := MaxIdx(c.s)\n\t\t\tif gotIdx != c.wantIdx {\n\t\t\t\tt.Errorf(\"Got max index %v, want %v\", gotIdx, c.wantIdx)\n\t\t\t}\n\n\t\t})\n\t}\n\n}",
    "5cfd5efc057e14d6f915e2f0e3a7a4e1": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !Equal(s1, s2) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be true\", s1, s2)\n\t}\n\n\tif Equal(s1, s3) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s3)\n\t}\n\n\tif Equal(s1, s4) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s4)\n\t}\n}\n",
    "5db0ca7cc9e199b358e4086356bd249f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{0, 0, 0, 0}, 1, 0},\n\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{0, 0, 0, 0}, 2, 0},\n\n\t\t// L = 3\n\t\t{[]float64{1, 2, 3, 4}, 3, 4.641588833612778},\n\t\t{[]float64{-1, -2, -3, -4}, 3, 4.641588833612778},\n\t\t{[]float64{0, 0, 0, 0}, 3, 0},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over test cases\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "5e5b494cf15f876e881c448b70eb2381": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tt.Parallel()\n\t// Test cases\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\ts           []float64\n\t\tt           []float64\n\t\texpectedDst []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:        \"Equal length vectors\",\n\t\t\tdst:         make([]float64, 3),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5, 6},\n\t\t\texpectedDst: []float64{-3, -3, -3},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Zero length vectors\",\n\t\t\tdst:         []float64{},\n\t\t\ts:           []float64{},\n\t\t\tt:           []float64{},\n\t\t\texpectedDst: []float64{},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"Dst shorter than s and t\",\n\t\t\tdst:         make([]float64, 2),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5, 6},\n\t\t\texpectedDst: nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"s shorter than dst and t\",\n\t\t\tdst:         make([]float64, 3),\n\t\t\ts:           []float64{1, 2},\n\t\t\tt:           []float64{4, 5, 6},\n\t\t\texpectedDst: nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"t shorter than dst and s\",\n\t\t\tdst:         make([]float64, 3),\n\t\t\ts:           []float64{1, 2, 3},\n\t\t\tt:           []float64{4, 5},\n\t\t\texpectedDst: nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.shouldPanic {\n\t\t\t\tassert.Panics(t, func() { SubTo(test.dst, test.s, test.t) })\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, test.expectedDst, SubTo(test.dst, test.s, test.t))\n\t\t\t}\n\t\t})\n\t}\n}",
    "5ec0328f90a34d616e3b204f7b27312c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-14\n\t// n = 2\n\tif NearestIdxForSpan(2, 0, 1, -1) != 0 {\n\t\tt.Errorf(\"Expected 0, got %d\", NearestIdxForSpan(2, 0, 1, -1))\n\t}\n\tif NearestIdxForSpan(2, 0, 1, 0.5) != 0 {\n\t\tt.Errorf(\"Expected 0, got %d\", NearestIdxForSpan(2, 0, 1, 0.5))\n\t}\n\tif NearestIdxForSpan(2, 0, 1, 2) != 1 {\n\t\tt.Errorf(\"Expected 1, got %d\", NearestIdxForSpan(2, 0, 1, 2))\n\t}\n\n\t// n = 3\n\tif NearestIdxForSpan(3, 0, 1, -0.5) != 0 {\n\t\tt.Errorf(\"Expected 0, got %d\", NearestIdxForSpan(3, 0, 1, -0.5))\n\t}\n\tif NearestIdxForSpan(3, 0, 1, 0.5) != 1 {\n\t\tt.Errorf(\"Expected 1, got %d\", NearestIdxForSpan(3, 0, 1, 0.5))\n\t}\n\tif NearestIdxForSpan(3, 0, 1, 1.5) != 2 {\n\t\tt.Errorf(\"Expected 2, got %d\", NearestIdxForSpan(3, 0, 1, 1.5))\n\t}\n\n\t// Test cases for v outside (l, u)\n\tif NearestIdxForSpan(3, 0, 1, -1) != 0 {\n\t\tt.Errorf(\"Expected 0, got %d\", NearestIdxForSpan(3, 0, 1, -1))\n\t}\n\tif NearestIdxForSpan(3, 0, 1, 2) != 2 {\n\t\tt.Errorf(\"Expected 2, got %d\", NearestIdxForSpan(3, 0, 1, 2))\n\t}\n\n\t// Test cases for v outside (u, l)\n\tif NearestIdxForSpan(3, 1, 0, 2) != 0 {\n\t\tt.Errorf(\"Expected 0, got %d\", NearestIdxForSpan(3, 1, 0, 2))\n\t}\n\tif NearestIdxForSpan(3, 1, 0, -1) != 2 {\n\t\tt.Errorf(\"Expected 2, got %d\", NearestIdxForSpan(3, 1, 0, -1))\n\t}\n\n\t// Test cases for Inf and NaN\n\tif NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0) != 1 {\n\t\tt.Errorf(\"Expected 1, got %d\", NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0))\n\t}\n\tif NearestIdxForSpan(3, 0, math.NaN(), 0) != 2 {\n\t\tt.Errorf(\"Expected 2, got %d\", NearestIdxForSpan(3, 0, math.NaN(), 0))\n\t}\n\tif NearestIdxForSpan(3, math.NaN(), 0, 0) != 0 {\n\t\tt.Errorf(\"Expected 0, got %d\", NearestIdxForSpan(3, math.NaN(), 0, 0))\n\t}\n\n\t// Test cases for halfway points\n\tn := 10\n\tfor i := 0; i \u003c n; i++ {\n\t\tv := -1 + 2*float64(i)/float64(n-1)\n\t\tidx := NearestIdxForSpan(n, -1, 1, v)\n\t\tif math.Abs(v-(-1+2*float64(idx)/float64(n-1))) \u003e tol {\n\t\t\tt.Errorf(\"For v = %v, expected index %d, got %d\", v, i, idx)\n\t\t}\n\t}\n}\n",
    "61372161edf3c9defd238b1135cd48bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l = u\n\t// - l = NaN\n\t// - u = NaN\n\t// - l = Inf\n\t// - u = Inf\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 4)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 0) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 1) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u = NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, Inf, 1) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, 0, Inf) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l = Inf, u = Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range want {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, Inf, Inf) = %v, want %v\", dst, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "619b5b88adc14dd5e12b4896a2e60292": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\ts:    []float64{},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"one\",\n\t\t\ts:    []float64{1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"two\",\n\t\t\ts:    []float64{1, 2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"three\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"first\",\n\t\t\ts:    []float64{3, 2, 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate\",\n\t\t\ts:    []float64{1, 2, 3, 3},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1, math.NaN(), 3},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"allNaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tc := c\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif c.want != -1 {\n\t\t\t\t\t\tt.Errorf(\"MaxIdx(%v) panicked, want %v\", c.s, c.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := MaxIdx(c.s)\n\t\t\tif c.want == -1 {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want panic\", c.s, got)\n\t\t\t} else if got != c.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", c.s, got, c.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63eb0a38dfc2724cfeb1f978ccfde92a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), math.Inf(-1), 5, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, 5, 5, 5, 0},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d - NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, test.n, test.l, test.u, test.v, got, test.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\n\tNearestIdxForSpan(1, 0, 10, 5)\n\n}",
    "63fa0b8a84228ec317cfed7688363a0a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n\n\t// Test some valid cases.\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{make([]float64, 2), 0, 1, []float64{0, 1}},\n\t\t{make([]float64, 3), 0, 1, []float64{0, 0.5, 1}},\n\t\t{make([]float64, 4), 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{make([]float64, 3), 1, 3, []float64{1, 2, 3}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tfor j := range got {\n\t\t\tif got[j] != c.ans[j] {\n\t\t\t\tt.Errorf(\"Test %d: Element %d mismatch. Expected %v, got %v\", i, j, c.ans, got)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases with Inf.\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{make([]float64, 2), math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 2), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(1)}},\n\t\t{make([]float64, 3), math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 3), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{make([]float64, 4), math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 4), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, 0, math.Inf(1)}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tfor j := range got {\n\t\t\tif got[j] != c.ans[j] {\n\t\t\t\tt.Errorf(\"Test %d: Element %d mismatch. Expected %v, got %v\", i, j, c.ans, got)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "6413829de65ffe830657a47656e35ce0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 0.5, 0}, // Can't guarantee exact halfway\n\n\t\t// Infinities\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(f\"TestCase %d\", func(t *testing.T) {\n\t\t\tgotIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif gotIdx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v, expected index %d, got %d\",\n\t\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, gotIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "656d8243e7ab61dd1b5d5d4c0a1c2a51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are very large\n\t// - l and u are very small\n\t// - l and u are Inf\n\t// - l and u are NaN\n\t// - l and u are a mixture of the above\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsOnShortDst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short dst\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular\n\tt.Run(\"RegularSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span failed, expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very large\n\tt.Run(\"LargeSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1e10, 1e10+1)\n\t\texpected := []float64{1e10, 1e10 + 0.25, 1e10 + 0.5, 1e10 + 0.75, 1e10 + 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span failed, expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are very small\n\tt.Run(\"SmallSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1e-10, 1e-10+1e-11)\n\t\texpected := []float64{1e-10, 1e-10 + 2.5e-12, 1e-10 + 5e-12, 1e-10 + 7.5e-12, 1e-10 + 1e-11}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span failed, expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are Inf\n\tt.Run(\"InfSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed, expected Inf, got %v\", dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are NaN\n\tt.Run(\"NaNSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span failed, expected NaN, got %v\", dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are a mixture of the above\n\tt.Run(\"MixedSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span failed, expected %v, got %v\", expected, dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "65a07e02fcce872028436f8a915909a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"EmptySlice\", args{[]float64{}, 0}, -1},\n\t\t{\"NaNValue\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"PositiveInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"NegativeInfinityValue\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"SingleElementSlice\", args{[]float64{5}, 3}, 0},\n\t\t{\"TwoElementSlice\", args{[]float64{1, 5}, 3}, 1},\n\t\t{\"MultipleElementSlice\", args{[]float64{1, 3, 5, 7, 9}, 6}, 3},\n\t\t{\"DuplicateValues\", args{[]float64{1, 5, 2, 5, 3}, 5}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil \u0026\u0026 tt.want != -1 {\n\t\t\t\t\tt.Errorf(\"NearestIdx() panicked: %v, want %v\", r, tt.want)\n\t\t\t\t}\n\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "65fd8ad4512dfef4102fe3bfb9270a4f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic.\n\t\t},\n\t\t{\n\t\t\tname: \"InfL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfSameSign\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfDifferentSign\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.want == nil {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) did not panic, want panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif tc.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v,%v,%v) returned slice of length %v, want %v\", tc.dst, tc.l, tc.u, len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range tc.want {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v)[%v] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "6614f0f640bed3219f6edca88d44dd37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn       int\n\t\tl, u, v float64\n\t\twant    int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Cases with NaN\n\t\t{2, math.NaN(), 1, 0.5, 0},\n\t\t{2, 0, math.NaN(), 0.5, 0},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf\n\t\t{2, math.Inf(1), 0, 0.5, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\n\t\t// Edge cases\n\t\t{2, 0, 0, 0, 0},\n\t\t{2, 1, 1, 1, 0},\n\t\t{3, 0, 1, 0, 0},\n\t\t{3, 0, 1, 1, 2},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "662f2e407358b89be4281a5a18880939": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\tfor _, test := range []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"test same slice\",\n\t\t\ts:    s,\n\t\t\tt:    s,\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices, L = 2\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    2,\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices, L = 1\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    1,\n\t\t\twant: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices, L = Inf(1)\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"test different slices, L = 3\",\n\t\t\ts:    s,\n\t\t\tt:    t,\n\t\t\tL:    3,\n\t\t\twant: f64.Pow(96, 1/3.0),\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := Distance(test.s, test.t, test.L)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t\t}\n\t\t})\n\n\t}\n\tpanics := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t}{\n\t\t{\n\t\t\tname: \"test different lengths\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t},\n\t}\n\n\tfor _, test := range panics {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// Execute the code that should panic\n\t\t\tDistance(test.s, test.t, test.L)\n\t\t})\n\t}\n\n}\n",
    "66d292c1ce226e5c8864cc13fe05bc21": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, -1},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), 0, -5, 9},\n\t\t{10, math.NaN(), 0, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\t\t{10, 0, 10, math.NaN(), 0},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\n\t\t// Odd and even n with Inf bounds\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3},\n\t\t{5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{6, math.Inf(-1), math.Inf(1), math.Inf(1), 5},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Test case %d failed: expected index %d, got %d for n=%d, l=%v, u=%v, v=%v\",\n\t\t\t\t\ti, tc.expectedIdx, idx, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "67dd6295b47259e6fb279f0555c34da2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases:\n\t// - Empty input\n\t// - Single slice\n\t// - Multiple slices with equal lengths\n\t// - Multiple slices with unequal lengths\n\n\t// Empty input\n\tif !EqualLengths() {\n\t\tt.Error(\"EqualLengths() with empty input should return true\")\n\t}\n\n\t// Single slice\n\ts1 := []float64{1, 2, 3}\n\tif !EqualLengths(s1) {\n\t\tt.Error(\"EqualLengths() with single slice should return true\")\n\t}\n\n\t// Multiple slices with equal lengths\n\ts2 := []float64{4, 5, 6}\n\ts3 := []float64{7, 8, 9}\n\tif !EqualLengths(s1, s2, s3) {\n\t\tt.Error(\"EqualLengths() with multiple slices of equal length should return true\")\n\t}\n\n\t// Multiple slices with unequal lengths\n\ts4 := []float64{10, 11}\n\tif EqualLengths(s1, s2, s4) {\n\t\tt.Error(\"EqualLengths() with multiple slices of unequal length should return false\")\n\t}\n\tif EqualLengths(s1, s4) {\n\t\tt.Error(\"EqualLengths() with multiple slices of unequal length should return false\")\n\t}\n}",
    "68474e5a72e61670a6cb46b5ac1305bf": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty\", args{[]float64{}}, 1},\n\t\t{\"one\", args{[]float64{2}}, 1},\n\t\t{\"many\", args{[]float64{2, 3, 4}}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "68899a430ddf4f6f239e756b66bbbffb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\t// Test cases for Same function\n\ttestCases := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, math.NaN()}, true},\n\t\t{[]float64{1, 2, math.NaN()}, []float64{1, 2, 3}, false},\n\t\t{[]float64{}, []float64{}, true},\n\t\t{nil, nil, true},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := Same(tc.s, tc.t)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "68e0afb435fbddde65eef21993523abe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{0, 1, 2}, -1, -1},\n\t\t{[]float64{0, 1, 2}, 0, 0},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{0, 1, 2}, 2, -1},\n\t\t{[]float64{0, 1, 2}, 3, -1},\n\t\t{[]float64{-1, 0, 1}, -2, -1},\n\t\t{[]float64{-1, 0, 1}, -1, 0},\n\t\t{[]float64{-1, 0, 1}, -0.5, 0},\n\t\t{[]float64{-1, 0, 1}, 0, 1},\n\t\t{[]float64{-1, 0, 1}, 0.5, 1},\n\t\t{[]float64{-1, 0, 1}, 1, -1},\n\t\t{[]float64{-1, 0, 1}, 2, -1},\n\t} {\n\t\ti := Within(c.s, c.v)\n\t\tif i != c.i {\n\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", c.s, c.v, i, c.i)\n\t\t}\n\t}\n\tfor _, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t}{\n\t\t{[]float64{0, 1}, math.NaN()},\n\t\t{[]float64{0, math.NaN()}, 0},\n\t\t{[]float64{math.NaN(), 0}, 0},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic\", c.s, c.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tWithin(c.s, c.v)\n\t\t}()\n\t}\n}\n",
    "690866bf0f92f2e1f2a6c438c10bc8eb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various scenarios.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\n\t\t// Cases with NaN\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\n\t\t// Cases with Inf\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 10, 9},\n\t\t{10, 0, math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), 0, 5, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(-1), 5, 0},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor _, tc := range testCases {\n\t\t// Run the function and check the result.\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n = %v, l = %v, u = %v, and v = %v, expected %v but got %v\", tc.n, tc.l, tc.u, tc.v, tc.expected, actual)\n\t}\n\n\t// Test panicking with n \u003c 2.\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 10, 5) }, \"The code did not panic with n \u003c 2\")\n}",
    "6930d616072f2ca90b31519426117788": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.4519143959375933},\n\t\t{[]float64{100, 100, 100}, 103.61972238569823},\n\t\t{[]float64{-100, -100, -100}, -96.38027761430177},\n\t\t{[]float64{1, 1e10, 1e-10}, 1e10},\n\t\t{[]float64{-1e10, -1, -1e-10}, -1},\n\t} {\n\t\tactual := LogSumExp(test.s)\n\t\tif math.Abs(actual-test.expected) \u003e tol {\n\t\t\tt.Errorf(\"Test %d: Expected %v, but got %v\", i, test.expected, actual)\n\t\t}\n\t}\n}",
    "69897caeb65fe72f7aa78c474973b3a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n less than 2 should panic\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) })\n\n\t// NaN tests\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, math.NaN()))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.NaN(), 1, 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.NaN(), 0.5))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.NaN(), 1, math.NaN()))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.NaN(), math.NaN()))\n\n\t// Inf tests\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 0.5))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(1), math.Inf(-1), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, math.Inf(1), math.Inf(1)))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(1), 0, math.Inf(1)))\n\n\t// v outside (l, u) tests\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, -1))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 2))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 1, 0, -1))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 1, 0, 2))\n\n\t// regular cases\n\tassert.Equal(t, 0, NearestIdxForSpan(10, 0, 1, 0))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, 0, 1, 1))\n\tassert.Equal(t, 5, NearestIdxForSpan(10, 0, 1, 0.5))\n\tassert.Equal(t, 2, NearestIdxForSpan(10, 0, 1, 0.2))\n\tassert.Equal(t, 7, NearestIdxForSpan(10, 0, 1, 0.7))\n}",
    "6aede9c09c69006b852dd6e16ffad905": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - Slice with negative bounds\n\t// - Slice with infinite bounds\n\t// - Slice with NaN bounds\n\n\t// Test case 1: Empty slice\n\t{\n\t\tvar dst []float64\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with slice with one element\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with negative bounds\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, -1, 1)\n\t\texpected := []float64{-1, -0.5, 0, 0.5, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: Slice with infinite bounds\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, 0) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 7: Slice with NaN bounds\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "6af629ddd937cab703589d0bb7a8abe6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: -0.1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 0}, // Exactly halfway, should truncate\n\t\t{n: 2, l: 0, u: 1, v: 0.6, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1.1, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: -0.1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.6, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1.1, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: -0.1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, want: 1}, // Exactly halfway, should truncate\n\t\t{n: 3, l: 0, u: 1, v: 0.6, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1.1, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: -0.1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.6, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1.1, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\n\t\t{n: 2, l: 0, u: 0, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 0, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: 0, v: 1, want: 0},\n\t\t{n: 3, l: 0, u: 0, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 0, v: 0, want: 0},\n\t\t{n: 3, l: 0, u: 0, v: 1, want: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: math.Inf(-1), want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1), want: 2},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: 0, want: 0},\n\n\t\t{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1), want: 0},\n\t\t{n: 2, l: math.Inf(1), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: math.Inf(-1), want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, want: 0},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: math.Inf(1), want: 0},\n\t\t{n: 3, l: math.Inf(1), u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: math.Inf(-1), want: 2},\n\t\t{n: 3, l: 0, u: math.Inf(-1), v: 0, want: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), want: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), want: 0},\n\n\t\t{n: 2, l: math.NaN(), u: 0, v: math.NaN(), want: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: math.NaN(), want: 0},\n\t\t{n: 3, l: math.NaN(), u: 0, v: math.NaN(), want: 0},\n\t\t{n: 3, l: 0, u: math.NaN(), v: math.NaN(), want: 0},\n\n\t\t{n: 2, l: math.NaN(), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, want: 0},\n\t\t{n: 3, l: math.NaN(), u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 0, u: math.NaN(), v: 0, want: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 1},\n\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 2},\n\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), want: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0, want: 1},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 3},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d- NearestIdxForSpan(%d,%v,%v,%v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\ttest.Panic(t, \"NearestIdxForSpan\", func() {\n\t\tNearestIdxForSpan(1, 0, 1, 0.5)\n\t})\n}",
    "6bfc7b9f97ba65b7653d66b1e69f0b80": "package floats\n\nimport \"testing\"\n\nfunc TestEqualFunc(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\n\tif !EqualFunc(s1, s2, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be true\", s1, s2)\n\t}\n\n\tif EqualFunc(s1, s3, func(a, b float64) bool { return a == b }) {\n\t\tt.Errorf(\"Expected EqualFunc(%v, %v, func(a, b float64) bool { return a == b }) to be false\", s1, s3)\n\t}\n}",
    "6c7c9566e0529939e343a754e38af8a8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with two elements\n\t// 4. Slice with odd number of elements\n\t// 5. Slice with even number of elements\n\t// 6. l \u003e u\n\t// 7. l = u\n\t// 8. l = NaN\n\t// 9. u = NaN\n\t// 10. l = Inf, u = Inf\n\t// 11. l = Inf, u = finite\n\t// 12. l = finite, u = Inf\n\n\t// Test case 1: Empty slice\n\t{\n\t\ts := []float64{}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(s, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\ts := []float64{0}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic with slice with one element\")\n\t\t\t}\n\t\t}()\n\t\tSpan(s, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\ts := []float64{0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with odd number of elements\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with even number of elements\n\t{\n\t\ts := []float64{0, 0, 0, 0, 0, 0}\n\t\tSpan(s, 0, 1)\n\t\twant := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: l \u003e u\n\t{\n\t\ts := []float64{0, 0, 0}\n\t\tSpan(s, 1, 0)\n\t\twant := []float64{1, 0.5, 0}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 7: l = u\n\t{\n\t\ts := []float64{0, 0, 0}\n\t\tSpan(s, 1, 1)\n\t\twant := []float64{1, 1, 1}\n\t\tfor i := range s {\n\t\t\tif s[i] != want[i] {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 8: l = NaN\n\t{\n\t\ts := []float64{0, 0, 0}\n\t\tSpan(s, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), 1}\n\t\tfor i := range s {\n\t\t\tif math.IsNaN(s[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 9: u = NaN\n\t{\n\t\ts := []float64{0, 0, 0}\n\t\tSpan(s, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN()}\n\t\tfor i := range s {\n\t\t\tif math.IsNaN(s[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 10: l = Inf, u = Inf\n\t{\n\t\ts := []float64{0, 0, 0, 0}\n\t\tSpan(s, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range s {\n\t\t\tif math.IsInf(s[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 11: l = Inf, u = finite\n\t{\n\t\ts := []float64{0, 0, 0}\n\t\tSpan(s, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range s {\n\t\t\tif math.IsInf(s[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 12: l = finite, u = Inf\n\t{\n\t\ts := []float64{0, 0, 0}\n\t\tSpan(s, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1)}\n\t\tfor i := range s {\n\t\t\tif math.IsInf(s[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"s[%d] = %f, want %f\", i, s[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "6d06d0759e4be25c7b630ad5ceb5bc13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// NaNs\n\t\t{2, math.NaN(), 1, 1, 0},\n\t\t{2, 1, math.NaN(), 1, 1},\n\t\t{2, 0, 1, math.NaN(), 0},\n\t\t// infinities\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), math.Inf(1), 1, 1},\n\t\t{100, math.Inf(-1), math.Inf(1), 0, 49},\n\t\t{101, math.Inf(-1), math.Inf(1), 0, 50},\n\t\t{100, math.Inf(-1), math.Inf(1), 1, 0},\n\t\t{100, math.Inf(-1), math.Inf(1), -1, 99},\n\t\t{101, math.Inf(-1), math.Inf(1), 1, 0},\n\t\t{101, math.Inf(-1), math.Inf(1), -1, 100},\n\t\t{2, 1, math.Inf(1), 2, 1},\n\t\t{2, math.Inf(-1), 1, 0, 0},\n\t\t{2, 1, 1, 1, 0},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 10, 9},\n\t\t{10, 0, 10, 5, 5},\n\t\t// regression\n\t\t{10, -10, -1, -9.545454545454545, 1},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d mismatch. Got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n\tpanics := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 1, 0.5},\n\t\t{0, 0, 1, 0.5},\n\t\t{-1, 0, 1, 0.5},\n\t}\n\tfor i, tc := range panics {\n\t\ttest.Panics(t, \"short span\", func() {\n\t\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t}, \"case %d did not panic\", i)\n\t}\n\n}",
    "6d21515f8125323eb177cf800f931b07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 1, -1, []float64{1, 1.0 / 3.0, -1.0 / 3.0, -1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, -1, []float64{1, 0.5, 0, -0.5, -1}},\n\t\t// Test cases for NaN and Inf.\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 1, math.NaN(), []float64{1, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, 1, math.NaN(), []float64{1, math.NaN(), math.NaN()}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, 1, math.Inf(1), []float64{1, math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1}},\n\t}\n\tfor i, test := range tests {\n\t\tSpan(test.dst, test.l, test.u)\n\t\tfor j := 0; j \u003c len(test.dst); j++ {\n\t\t\tif !same(test.dst[j], test.want[j]) {\n\t\t\t\tt.Errorf(\"Test %d: At element %d: got %v, want %v\", i, j, test.dst, test.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst epsilon = 1e-15\n\nfunc same(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c epsilon\n}\n",
    "6deba74db0b90460246258ff700fb465": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t}\n\tfor i, tt := range tests {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !Equal(got, tt.want) {\n\t\t\tt.Errorf(\"Case %d: Input: dst = %v, l = %v, u = %v\\ngot  %v\\nwant %v\", i, tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n\n\t// Test cases when l is NaN\n\ttestsNaNl := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t}\n\tfor i, tt := range testsNaNl {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t// Check if the elements except the last one are NaN\n\t\tfor j := 0; j \u003c len(got)-1; j++ {\n\t\t\tif !math.IsNaN(got[j]) {\n\t\t\t\tt.Errorf(\"CaseNaNl %d: Expected NaN at index %d, got %v\", i, j, got[j])\n\t\t\t}\n\t\t}\n\t\tif got[len(got)-1] != tt.u {\n\t\t\tt.Errorf(\"CaseNaNl %d: Input: dst = %v, l = %v, u = %v\\ngot  %v\\nwant last element to be %v\", i, tt.dst, tt.l, tt.u, got, tt.u)\n\t\t}\n\t}\n\t// Test cases when u is NaN\n\ttestsNaNu := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, math.NaN(), []float64{0, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t}\n\tfor i, tt := range testsNaNu {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t// Check if the elements except the first one are NaN\n\t\tfor j := 1; j \u003c len(got); j++ {\n\t\t\tif !math.IsNaN(got[j]) {\n\t\t\t\tt.Errorf(\"CaseNaNu %d: Expected NaN at index %d, got %v\", i, j, got[j])\n\t\t\t}\n\t\t}\n\t\tif got[0] != tt.l {\n\t\t\tt.Errorf(\"CaseNaNu %d: Input: dst = %v, l = %v, u = %v\\ngot  %v\\nwant first element to be %v\", i, tt.dst, tt.l, tt.u, got, tt.l)\n\t\t}\n\t}\n\t// Test cases when both l and u are Inf\n\ttestsInf := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t}\n\tfor i, tt := range testsInf {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !Equal(got, tt.want) {\n\t\t\tt.Errorf(\"CaseInf %d: Input: dst = %v, l = %v, u = %v\\ngot  %v\\nwant %v\", i, tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n\t// Test cases when l is Inf\n\ttestsInfinitel := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), 1, []float64{math.Inf(1), 1}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 1, []float64{math.Inf(1), math.Inf(1), 1}},\n\t}\n\tfor i, tt := range testsInfinitel {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !Equal(got, tt.want) {\n\t\t\tt.Errorf(\"CaseInfinitel %d: Input: dst = %v, l = %v, u = %v\\ngot  %v\\nwant %v\", i, tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n\t// Test cases when u is Inf\n\ttestsInfiniteu := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1)}},\n\t}\n\tfor i, tt := range testsInfiniteu {\n\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\tif !Equal(got, tt.want) {\n\t\t\tt.Errorf(\"CaseInfiniteu %d: Input: dst = %v, l = %v, u = %v\\ngot  %v\\nwant %v\", i, tt.dst, tt.l, tt.u, got, tt.want)\n\t\t}\n\t}\n}\n",
    "6f60e11c27d167cc98a6c777b2ed309f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.25, 0},\n\t\t{2, 0, 1, 0.75, 1},\n\t\t{2, 1, 0, 0.25, 1},\n\t\t{2, 1, 0, 0.75, 0},\n\n\t\t// n = 3\n\t\t{3, 0, 2, -1, 0},\n\t\t{3, 0, 2, 0, 0},\n\t\t{3, 0, 2, 0.5, 0},\n\t\t{3, 0, 2, 1, 1},\n\t\t{3, 0, 2, 1.5, 1},\n\t\t{3, 0, 2, 2, 2},\n\t\t{3, 0, 2, 3, 2},\n\n\t\t{3, 2, 0, -1, 2},\n\t\t{3, 2, 0, 0, 2},\n\t\t{3, 2, 0, 0.5, 2},\n\t\t{3, 2, 0, 1, 1},\n\t\t{3, 2, 0, 1.5, 1},\n\t\t{3, 2, 0, 2, 0},\n\t\t{3, 2, 0, 3, 0},\n\n\t\t// n = 4\n\t\t{4, 0, 3, -1, 0},\n\t\t{4, 0, 3, 0, 0},\n\t\t{4, 0, 3, 0.5, 0},\n\t\t{4, 0, 3, 1, 1},\n\t\t{4, 0, 3, 1.5, 1},\n\t\t{4, 0, 3, 2, 2},\n\t\t{4, 0, 3, 2.5, 2},\n\t\t{4, 0, 3, 3, 3},\n\t\t{4, 0, 3, 4, 3},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test %d: unexpected index returned for n = %d, l = %v, u = %v, v = %v. Want %v, got %v.\", i, tc.n, tc.l, tc.u, tc.v, tc.want, got)\n\t\t}\n\t}\n}\nfunc TestNearestIdxForSpanNaNs(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, math.NaN(), 0, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 1},\n\t\t{3, math.NaN(), 0, 0, 0},\n\t\t{3, 0, math.NaN(), 0, 2},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test %d: unexpected index returned for n = %d, l = %v, u = %v, v = %v. Want %v, got %v.\", i, tc.n, tc.l, tc.u, tc.v, tc.want, got)\n\t\t}\n\t}\n\t// Test that we return the zeroth index if everything is a NaN.\n\tfor i := 2; i \u003c 10; i++ {\n\t\tgot := NearestIdxForSpan(i, math.NaN(), math.NaN(), math.NaN())\n\t\tif got != 0 {\n\t\t\tt.Errorf(\"Test %d: unexpected index returned for NearestIdxForSpan(%d, NaN, NaN, NaN). Want 0, got %v\", i, i, got)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanInfs(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{2, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 1},\n\n\t\t{2, math.Inf(1), 0, math.Inf(1), 1},\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, 0, math.Inf(-1), math.Inf(-1), 0},\n\n\t\t{3, math.Inf(1), 0, math.Inf(1), 2},\n\t\t{3, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{3, 0, math.Inf(1), math.Inf(1), 2},\n\t\t{3, 0, math.Inf(-1), math.Inf(-1), 0},\n\n\t\t{2, math.Inf(1), 0, math.Inf(-1), 0},\n\t\t{2, 0, math.Inf(1), math.Inf(-1), 0},\n\t\t{3, math.Inf(1), 0, math.Inf(-1), 0},\n\t\t{3, 0, math.Inf(1), math.Inf(-1), 0},\n\n\t\t{11, math.Inf(1), math.Inf(-1), 10, 0},\n\t\t{11, math.Inf(-1), math.Inf(1), 10, 10},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test %d: unexpected index returned for n = %d, l = %v, u = %v, v = %v. Want %v, got %v.\", i, tc.n, tc.l, tc.u, tc.v, tc.want, got)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{0, 0, 1, 0.25},\n\t\t{1, 0, 1, 0.25},\n\t} {\n\t\ttest.Panic(t, func() { NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v) }, \"Test %d: did not panic with n = %d\", i, tc.n)\n\t}\n}",
    "6f8f0cf089b9296b93c93e650fdcf0f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single Element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive Values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1, -2, -3, -4, -5},\n\t\t\t\tv: -2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed Values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1, 2, -3, 4, -5},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive Infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif len(tt.args.s) == 0 {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "705779804a0d6e416d989d33e5d71d2c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// This test tests against the actual implementation using Span\n\t// to make sure the results are correct.\n\tfor _, n := range []int{2, 3, 4, 5, 10, 20, 100} {\n\t\tfor _, lower := range []float64{-5, -1, -0.1, 0, 0.1, 1, 5} {\n\t\t\tfor _, upper := range []float64{-5, -1, -0.1, 0, 0.1, 1, 5} {\n\t\t\t\ts := make([]float64, n)\n\t\t\t\tSpan(s, lower, upper)\n\t\t\t\tfor _, v := range []float64{-10, -1, -0.1, 0, 0.1, 1, 10} {\n\t\t\t\t\twant := NearestIdx(s, v)\n\t\t\t\t\tgot := NearestIdxForSpan(n, lower, upper, v)\n\t\t\t\t\tif want != got {\n\t\t\t\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: want %v, got %v\", n, lower, upper, v, want, got)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Test the NaN cases\n\tfor _, n := range []int{2, 3, 4, 5, 10, 20, 100} {\n\t\tfor i := 0; i \u003c n; i++ {\n\t\t\ts := make([]float64, n)\n\t\t\tSpan(s, 0, 1)\n\t\t\ts[i] = math.NaN()\n\t\t\tv := 0.5\n\t\t\tgot := NearestIdxForSpan(n, 0, 1, v)\n\t\t\tif got != i {\n\t\t\t\tt.Errorf(\"Did not return NaN index. Returned %v, expected %v\", got, i)\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc TestNearestIdxForSpanSpecial(t *testing.T) {\n\t// Test cases that would cause a panic from zero-length Span\n\tnan := math.NaN()\n\tinf := math.Inf(1)\n\n\tfor _, test := range []struct {\n\t\tn   int\n\t\tl   float64\n\t\tu   float64\n\t\tv   float64\n\t\tans int\n\t}{\n\t\t{10, nan, 0, 0.1, 0},\n\t\t{10, 0, nan, 0.1, 9},\n\t\t{10, nan, nan, 0.1, 0},\n\t\t{10, inf, inf, 0.1, 0},\n\t\t{11, inf, inf, 0.1, 5},\n\t\t{11, -inf, -inf, 0.1, 6},\n\t\t{10, inf, inf, inf, 0},\n\t\t{10, inf, inf, -inf, 9},\n\t\t{10, -inf, -inf, inf, 9},\n\t\t{10, -inf, -inf, -inf, 0},\n\t\t{10, inf, 0, 0.1, 8},\n\t\t{10, -inf, 0, 0.1, 9},\n\t\t{10, 0, inf, 0.1, 0},\n\t\t{10, 0, -inf, 0.1, 9},\n\t\t{10, 1, 0, -inf, 9},\n\t\t{10, 0, 1, -inf, 0},\n\t\t{10, 0, 1, inf, 9},\n\t\t{10, 1, 0, inf, 0},\n\t\t{10, 0, 1, 0.1, 0},\n\t\t{10, 1, 0, 0.1, 9},\n\t\t{10, 1, 1, 1, 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.ans {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: want %v, got %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, test.ans, got)\n\t\t}\n\t}\n}\n\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\tfor _, size := range []int{10, 100, 1000, 10000} {\n\t\tb.Run(testlapack.Itoa(size), func(b *testing.B) {\n\t\t\ts := make([]float64, size)\n\t\t\tSpan(s, 0, 1)\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\tNearestIdxForSpan(size, 0, 1, 0.5)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "70ef5cf162ccbbbeaffa61109d9d5327": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 10, 2.5, 2},\n\t\t{10, -5, 5, 0, 5},\n\n\t\t// Edge cases\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 5, 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "719fbaed10eb9f84af07d905fd6dc8b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with positive numbers\n\t// 4. Slice with negative numbers\n\t// 5. Slice with mixed positive and negative numbers\n\t// 6. Slice with numbers that might cause large error with naive summation\n\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{-1.0, -2.0, -3.0}, -6.0},\n\t\t{[]float64{-1.0, 2.0, -3.0, 4.0}, 2.0},\n\t\t{[]float64{1e10, 1.0, -1e10}, 1.0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "72080191d1a0f6a037ea1ba79b729034": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ts1 := []float64{1, 2, 3}\n\ts2 := []float64{4, 5, 6}\n\texpected := 32.0\n\n\tactual := Dot(s1, s2)\n\n\tif actual != expected {\n\t\tt.Errorf(\"Dot() = %v, want %v\", actual, expected)\n\t}\n}",
    "731ef9c1650a0835b8d91c3e5645ea3d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various scenarios\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, 0, 2, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"DecimalBounds\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1.5,\n\t\t\tu:    2.5,\n\t\t\twant: []float64{1.5, 2.0, 2.5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-1, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    3,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 3},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{-1, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfSameSign\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfDifferentSign\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !EqualWithinTol(got[i], tc.want[i], 1e-14) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short dst slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\n// EqualWithinTol checks if two float64 values are equal within a given tolerance.\nfunc EqualWithinTol(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c= tol\n}",
    "7342be149dca4d93bbc1c7058fc4b165": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ts1 := []float64{1, 2, math.NaN()}\n\ts2 := []float64{1, 2, math.NaN()}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2}\n\n\tif !Same(s1, s2) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be true\", s1, s2)\n\t}\n\n\tif Same(s1, s3) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s1, s3)\n\t}\n\n\tif Same(s1, s4) {\n\t\tt.Errorf(\"Expected Same(%v, %v) to be false\", s1, s4)\n\t}\n}\n",
    "735adf687a18e301fe773c3aa12dfa6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t//   - n \u003c 2\n\t//   - v is NaN\n\t//   - l or u is NaN\n\t//   - l and u are Inf\n\t//   - l or u is Inf\n\t//   - v is Inf\n\t//   - v outside (l, u)\n\t//   - v inside (l, u)\n\t//   - v on the edge of (l, u)\n\t//   - l \u003e u\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, 0, 1, 0) did not panic\", n)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t}\n\n\t// v is NaN\n\tassertNearestIdxForSpan(t, 2, 0, 1, math.NaN(), 0)\n\n\t// l or u is NaN\n\tassertNearestIdxForSpan(t, 2, math.NaN(), 1, 0.5, 1)\n\tassertNearestIdxForSpan(t, 2, 0, math.NaN(), 0.5, 0)\n\n\t// l and u are Inf\n\tassertNearestIdxForSpan(t, 2, math.Inf(1), math.Inf(1), 0, 0)\n\tassertNearestIdxForSpan(t, 3, math.Inf(1), math.Inf(1), 0, 0)\n\tassertNearestIdxForSpan(t, 2, math.Inf(-1), math.Inf(-1), 0, 0)\n\tassertNearestIdxForSpan(t, 3, math.Inf(-1), math.Inf(-1), 0, 0)\n\tassertNearestIdxForSpan(t, 2, math.Inf(1), math.Inf(-1), 0, 0)\n\tassertNearestIdxForSpan(t, 3, math.Inf(1), math.Inf(-1), 0, 1)\n\tassertNearestIdxForSpan(t, 4, math.Inf(1), math.Inf(-1), 0, 1)\n\n\t// l or u is Inf\n\tassertNearestIdxForSpan(t, 2, math.Inf(1), 0, 1, 1)\n\tassertNearestIdxForSpan(t, 2, 0, math.Inf(1), 0, 0)\n\tassertNearestIdxForSpan(t, 2, math.Inf(-1), 0, 0, 0)\n\tassertNearestIdxForSpan(t, 2, 0, math.Inf(-1), 1, 1)\n\n\t// v is Inf\n\tassertNearestIdxForSpan(t, 2, 0, 1, math.Inf(-1), 0)\n\tassertNearestIdxForSpan(t, 2, 0, 1, math.Inf(1), 1)\n\tassertNearestIdxForSpan(t, 2, 1, 0, math.Inf(-1), 1)\n\tassertNearestIdxForSpan(t, 2, 1, 0, math.Inf(1), 0)\n\n\t// v outside (l, u)\n\tassertNearestIdxForSpan(t, 10, 0, 1, -1, 0)\n\tassertNearestIdxForSpan(t, 10, 0, 1, 2, 9)\n\n\t// v inside (l, u)\n\tassertNearestIdxForSpan(t, 10, 0, 1, 0.1, 1)\n\tassertNearestIdxForSpan(t, 10, 0, 1, 0.9, 8)\n\n\t// v on the edge of (l, u)\n\tassertNearestIdxForSpan(t, 10, 0, 1, 0, 0)\n\tassertNearestIdxForSpan(t, 10, 0, 1, 1, 9)\n\n\t// l \u003e u\n\tassertNearestIdxForSpan(t, 10, 1, 0, -1, 9)\n\tassertNearestIdxForSpan(t, 10, 1, 0, 2, 0)\n\tassertNearestIdxForSpan(t, 10, 1, 0, 0.1, 9)\n\tassertNearestIdxForSpan(t, 10, 1, 0, 0.9, 0)\n\tassertNearestIdxForSpan(t, 10, 1, 0, 0, 9)\n\tassertNearestIdxForSpan(t, 10, 1, 0, 1, 0)\n}\n\nfunc assertNearestIdxForSpan(t *testing.T, n int, l, u, v float64, expected int) {\n\tactual := NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n}",
    "742c3a0e60b52275548045f9937128ed": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\t// Test case 1: Basic ascending sort\n\tdst1 := []float64{3, 1, 4, 1, 5}\n\tinds1 := make([]int, len(dst1))\n\texpectedDst1 := []float64{1, 1, 3, 4, 5}\n\texpectedInds1 := []int{1, 3, 0, 2, 4}\n\tArgsortStable(dst1, inds1)\n\tif !Equal(dst1, expectedDst1) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 1 failed: dst mismatch. Expected: %v, Got: %v\", expectedDst1, dst1)\n\t}\n\tif !Equal(inds1, expectedInds1) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 1 failed: inds mismatch. Expected: %v, Got: %v\", expectedInds1, inds1)\n\t}\n\n\t// Test case 2: Descending sort\n\tdst2 := []float64{5, 4, 3, 2, 1}\n\tinds2 := make([]int, len(dst2))\n\texpectedDst2 := []float64{1, 2, 3, 4, 5}\n\texpectedInds2 := []int{4, 3, 2, 1, 0}\n\tArgsortStable(dst2, inds2)\n\tif !Equal(dst2, expectedDst2) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 2 failed: dst mismatch. Expected: %v, Got: %v\", expectedDst2, dst2)\n\t}\n\tif !Equal(inds2, expectedInds2) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 2 failed: inds mismatch. Expected: %v, Got: %v\", expectedInds2, inds2)\n\t}\n\n\t// Test case 3: Duplicate values\n\tdst3 := []float64{2, 1, 3, 1, 2}\n\tinds3 := make([]int, len(dst3))\n\texpectedDst3 := []float64{1, 1, 2, 2, 3}\n\texpectedInds3 := []int{1, 3, 0, 4, 2}\n\tArgsortStable(dst3, inds3)\n\tif !Equal(dst3, expectedDst3) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 3 failed: dst mismatch. Expected: %v, Got: %v\", expectedDst3, dst3)\n\t}\n\tif !Equal(inds3, expectedInds3) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 3 failed: inds mismatch. Expected: %v, Got: %v\", expectedInds3, inds3)\n\t}\n\n\t// Test case 4: Already sorted\n\tdst4 := []float64{1, 2, 3, 4, 5}\n\tinds4 := make([]int, len(dst4))\n\texpectedDst4 := []float64{1, 2, 3, 4, 5}\n\texpectedInds4 := []int{0, 1, 2, 3, 4}\n\tArgsortStable(dst4, inds4)\n\tif !Equal(dst4, expectedDst4) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 4 failed: dst mismatch. Expected: %v, Got: %v\", expectedDst4, dst4)\n\t}\n\tif !Equal(inds4, expectedInds4) {\n\t\tt.Errorf(\"TestArgsortStable - Test case 4 failed: inds mismatch. Expected: %v, Got: %v\", expectedInds4, inds4)\n\t}\n}",
    "74b6c2682cd0091c2b1d38011061c6ec": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ts := make([]float64, 20)\n\tu := make([]float64, 20)\n\tv := make([]float64, 20)\n\tdst := make([]float64, 20)\n\tfor i := range s {\n\t\ts[i] = rand.Float64()\n\t\tu[i] = rand.Float64()\n\t\tv[i] = s[i] + u[i]\n\t}\n\tAddTo(dst, s, u)\n\tfor i := range dst {\n\t\tif dst[i] != v[i] {\n\t\t\tt.Errorf(\"floats.Add to mismatch at index %v, got %v expected %v\", i, dst[i], v[i])\n\t\t}\n\n\t}\n\t// Tests for panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\ts1 := make([]float64, 10)\n\ts2 := make([]float64, 20)\n\tAddTo(dst, s1, s2)\n}\n",
    "7531e22078872885620137b8f10e36fa": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\texpected := []float64{5, 7, 9}\n\tAddTo(dst, s, t)\n\tassert.Equal(t, expected, dst)\n}",
    "75568582d0db1dd3b3d9aaadf9b871d7": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ttype testCase struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}\n\ttestCases := []testCase{\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 0.0, 0},\n\t\t{[]float64{0, 1}, 1.0, -1},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1.0, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{-1, 0, 1}, -0.5, 0},\n\t\t{[]float64{-1, 0, 1}, -1.0, -1},\n\t\t{[]float64{-1, 0, 1}, 1, 1},\n\t}\n\tfor i, tc := range testCases {\n\t\tvar err error\n\t\tif tc.s, err = AddConst(0.5, tc.s); err != nil {\n\t\t\tt.Errorf(\"Test case %d: Failed to add constant to slice: %v\", i, err)\n\t\t}\n\t\ttc.v += 0.5\n\t\tidx := Within(tc.s, tc.v)\n\t\tif idx != tc.expected {\n\t\t\tt.Errorf(\"Test case %d: Expected idx %v, got %v\", i, tc.expected, idx)\n\t\t}\n\t}\n\ttestCasesShort := []testCase{\n\t\t{[]float64{0, 1}, math.NaN(), -1},\n\t\t{[]float64{0, 1}, math.Inf(1), -1},\n\t\t{[]float64{0, 1}, math.Inf(-1), -1},\n\t}\n\tfor i, tc := range testCasesShort {\n\t\tvar err error\n\t\tif tc.s, err = AddConst(0.5, tc.s); err != nil {\n\t\t\tt.Errorf(\"Test case %d: Failed to add constant to slice: %v\", i, err)\n\t\t}\n\t\tidx := Within(tc.s, tc.v)\n\t\tif idx != tc.expected {\n\t\t\tt.Errorf(\"Test case %d: Expected idx %v, got %v\", i, tc.expected, idx)\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{0}, 0.5)\n}\n",
    "764003bc0b16664630dab25d0a7361f9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 2, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 5}, 0, math.Pow(1, 1.0/0)},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 5}, 1, 1},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 5}, 2, 1},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 5}, 3, 1},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 5}, math.Inf(1), 1},\n\t\t{[]float64{-1, -2, -3, -4}, []float64{-1, -2, -3, -5}, 2, 1},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !testlapack.Same(got, test.want) {\n\t\t\tt.Errorf(\"Case %v: mismatch. Want %v, got %v\", i, test.want, got)\n\t\t}\n\t}\n\n\tn := 10\n\ts := make([]float64, n)\n\tt := make([]float64, n)\n\t// Explicitly set values to avoid NaN.\n\tfor i := range s {\n\t\ts[i] = float64(i + 1)\n\t\tt[i] = float64(i)\n\t}\n\tfor i := 0; i \u003c 4; i++ {\n\t\tL := float64(i)\n\t\tgot := Distance(s, t, L)\n\t\tvar want float64\n\t\tfor j := 0; j \u003c n; j++ {\n\t\t\twant += math.Pow(math.Abs(s[j]-t[j]), L)\n\t\t}\n\t\twant = math.Pow(want, 1/L)\n\t\tif !testlapack.Same(got, want) {\n\t\t\tt.Errorf(\"Case %v: mismatch. Want %v, got %v\", i, want, got)\n\t\t}\n\t}\n}",
    "7775eae90044d2b83c4ba237a18e6524": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{1, 2, 3, 4, 5, 1.1, 1.2, 1.3, 1.4, 1.5}\n\ttype testCase struct {\n\t\tV    float64\n\t\tWant int\n\t}\n\ttestCases := []testCase{\n\t\t{V: 1.15, Want: 6},\n\t\t{V: 1.6, Want: 9},\n\t\t{V: -10, Want: 0},\n\t\t{V: 10, Want: 4},\n\t\t{V: math.NaN(), Want: 0},\n\t\t{V: math.Inf(1), Want: 4},\n\t\t{V: math.Inf(-1), Want: 0},\n\t}\n\tfor i, tc := range testCases {\n\t\thave := NearestIdx(s, tc.V)\n\t\tif have != tc.Want {\n\t\t\tt.Errorf(\"Test case %d: input array %v, v = %v\\nWant %d, have %d\\n\",\n\t\t\t\ti, s, tc.V, tc.Want, have)\n\t\t}\n\t}\n\t// Test case where multiple indices would work. Should return\n\t// lowest index.\n\ts = []float64{1, 2, 3, 4, 5, 5, 5, 4, 3, 2, 1}\n\ttestCases = []testCase{\n\t\t{V: 1.15, Want: 0},\n\t\t{V: 1.6, Want: 1},\n\t\t{V: -10, Want: 0},\n\t\t{V: 10, Want: 4},\n\t}\n\tfor i, tc := range testCases {\n\t\thave := NearestIdx(s, tc.V)\n\t\tif have != tc.Want {\n\t\t\tt.Errorf(\"Test case %d: input array %v, v = %v\\nWant %d, have %d\\n\",\n\t\t\t\ti, s, tc.V, tc.Want, have)\n\t\t}\n\t}\n}\n",
    "77b93326ee7c291bfa127d16988aa7d8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking behavior.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\ttestSpanHelper([]float64{}, 0.0, 1.0, t)\n}\n\nfunc TestSpanShort(t *testing.T) {\n\tdst := make([]float64, 2)\n\tSpan(dst, 0.0, 1.0)\n\tif dst[0] != 0.0 || dst[1] != 1.0 {\n\t\tt.Errorf(\"Span failed for short dst\")\n\t}\n}\nfunc TestSpanEasy(t *testing.T) {\n\tdst := make([]float64, 3)\n\tSpan(dst, 0.0, 2.0)\n\tif dst[0] != 0.0 || dst[1] != 1.0 || dst[2] != 2.0 {\n\t\tt.Errorf(\"Span failed for dst length 3\")\n\t}\n}\n\nfunc TestSpanLonger(t *testing.T) {\n\tN := 10\n\tdst := make([]float64, N)\n\tSpan(dst, 0.0, 1.0)\n\tfor i := 0; i \u003c N; i++ {\n\t\ttruth := float64(i) / float64(N-1)\n\t\tif dst[i] != truth {\n\t\t\tt.Errorf(\"Span failed at element %d\", i)\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tN := 10\n\tdst := make([]float64, N)\n\tSpan(dst, math.Inf(1), 0)\n\tfor i := 0; i \u003c N-1; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Span failed with Inf at element %d\", i)\n\t\t}\n\t}\n\tif dst[N-1] != 0 {\n\t\tt.Errorf(\"Span failed with Inf at element %d\", N-1)\n\t}\n}\n\nfunc TestSpanNegInf(t *testing.T) {\n\tN := 10\n\tdst := make([]float64, N)\n\tSpan(dst, 0, math.Inf(-1))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Span failed with -Inf at element 0\")\n\t}\n\tfor i := 1; i \u003c N; i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Span failed with -Inf at element %d\", i)\n\t\t}\n\t}\n}\n\nfunc TestSpanNaNs(t *testing.T) {\n\tN := 10\n\tdst := make([]float64, N)\n\tSpan(dst, math.NaN(), 0)\n\tfor i := 0; i \u003c N-1; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span failed with NaN at element %d\", i)\n\t\t}\n\t}\n\tif dst[N-1] != 0 {\n\t\tt.Errorf(\"Span failed with NaN at element %d\", N-1)\n\t}\n\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Span failed with NaN at element %d\", 0)\n\t}\n\tfor i := 1; i \u003c N; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span failed with NaN at element %d\", i)\n\t\t}\n\t}\n\n\tSpan(dst, math.NaN(), math.NaN())\n\tfor i := 0; i \u003c N; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span failed with NaN at element %d\", i)\n\t\t}\n\t}\n}\n\nfunc testSpanHelper(dst []float64, l, u float64, t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, l, u)\n}\n",
    "79104be89c9c1a79798d2bc6dce60d34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"LargeSlice\",\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    2.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{2.0, 2.3333333333333335, 2.666666666666667, 3.0, 3.3333333333333335, 3.666666666666667, 4.0, 4.333333333333333, 4.666666666666667, 5.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-10 {\n\t\t\t\t\tt.Errorf(\"Span(%v, %.2f, %.2f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for Inf and NaN.\n\tinfTestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfEven\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfDiff\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range infTestCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif math.IsNaN(got[i]) \u0026\u0026 !math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %.2f, %.2f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, %.2f, %.2f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking with short dst.\n\tt.Run(\"ShortDst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Span did not panic with dst of len \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}",
    "79ba96a414ec58600a22cf4d6a65c7d9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: length of the hypothetical vector\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\n\t\t// Cases with NaN and Inf\n\t\t{10, 0, 10, math.NaN(), 0},\n\t\t{10, math.NaN(), 10, 5, 10},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), 1, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 10, 0, math.Inf(1), 0},\n\t\t{10, 10, 0, math.Inf(-1), 9},\n\n\t\t// Cases with reversed bounds\n\t\t{10, 10, 0, 5, 4},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, -1, 9},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "79f3aca3977491f8d5f9776daa658477": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.5, 0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSame\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseDifferent\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseLSame\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseUSame\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !EqualWithinAbsOrRel(got[i], tc.want[i], 1e-15, 1e-15) {\n\t\t\t\t\tt.Errorf(\"Got %v, want %v\", got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t})\n\t}\n\n\tt.Run(\"PanicCase\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with invalid input\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\n\t})\n\n}\n\nfunc EqualWithinAbsOrRel(x, y, absTol, relTol float64) bool {\n\tif math.IsNaN(x) \u0026\u0026 math.IsNaN(y) {\n\t\treturn true\n\t}\n\tdiff := math.Abs(x - y)\n\treturn diff \u003c= absTol || diff \u003c= relTol*math.Max(math.Abs(x), math.Abs(y))\n}",
    "7ae0b412168e3741e885695e100e10dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-14\n\n\tdst := make([]float64, 5)\n\tans := []float64{0, 0.25, 0.5, 0.75, 1}\n\tSpan(dst, 0, 1)\n\tfor i := range dst {\n\t\tif math.Abs(dst[i]-ans[i]) \u003e tol {\n\t\t\tt.Errorf(\"Expected %v, got %v\", ans, dst)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tdst = make([]float64, 10)\n\tSpan(dst, -1, 3)\n\tsum := 0.0\n\tfor _, val := range dst {\n\t\tsum += val\n\t}\n\tif math.Abs(sum-5.0) \u003e tol {\n\t\tt.Errorf(\"Expected sum to be 5.0, got %v\", sum)\n\t}\n\n\t// Test cases for Inf and NaN\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(1), 1)\n\tfor i := range dst {\n\t\tif i \u003c len(dst)-1 \u0026\u0026 !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf at index %d, got %v\", i, dst[i])\n\t\t} else if i == len(dst)-1 \u0026\u0026 dst[i] != 1 {\n\t\t\tt.Errorf(\"Expected 1 at last index, got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tSpan(dst, -1, math.NaN())\n\tif dst[0] != -1 {\n\t\tt.Errorf(\"Expected -1 at first index, got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, dst[i])\n\t\t}\n\t}\n}",
    "7ba6c1a9d9cfc826feb1c6cc29a7d1d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.0, 1e-10, 1.0, -1e-10}, 2},\n\t\t{[]float64{math.MaxFloat64, 1, 1, 1}, math.MaxFloat64},\n\t}\n\n\t// Iterate through the test cases.\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within acceptable tolerance.\n\t\tif !almostEqual(actual, tc.expected) {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n\n// almostEqual checks if two float64 values are almost equal within a small tolerance.\nfunc almostEqual(a, b float64) bool {\n\ttolerance := 1e-14\n\treturn math.Abs(a-b) \u003c tolerance\n}\n",
    "7be2cfa5773f77e57f0b52a902a37906": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, -5, 5, -2.5, 2},\n\t\t{10, -5, 5, 2.5, 7},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, 0, 0, 0, 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for v outside of (l, u)\n\ttestCasesOutside := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, 2, 0},\n\t\t{10, 1, 0, -1, 9},\n\t}\n\tfor i, tc := range testCasesOutside {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\t// Test cases for NaN and Inf\n\ttestCasesInf := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, math.Inf(1), 1, 0},\n\t\t{10, math.Inf(-1), 0, 1, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.NaN(), 0, 1, 0},\n\t\t{10, 0, math.NaN(), 1, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t}\n\tfor i, tc := range testCasesInf {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case for panic when n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}",
    "7ce7e0ff5d5a26e4ace3cfba39e5cd75": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErrStr string\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"k=0\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErrStr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:      \"k=1\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         1,\n\t\t\twantInds:  []int{0},\n\t\t\twantErrStr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:      \"k=2\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantErrStr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:      \"k=-1\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErrStr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:      \"error: k too large\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return f \u003e 10 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{},\n\t\t\twantErrStr: \"floats: insufficient elements found\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\tif tc.wantErrStr != \"\" {\n\t\t\t\tif gotErr == nil {\n\t\t\t\t\tt.Errorf(\"Find() error = nil, wantErr %v\", tc.wantErrStr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif gotErr.Error() != tc.wantErrStr {\n\t\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", gotErr, tc.wantErrStr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif gotErr != nil {\n\t\t\t\t\tt.Errorf(\"Find() error = %v, wantErr nil\", gotErr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find() gotInds = %v, want %v\", gotInds, tc.wantInds)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := range tc.wantInds {\n\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Errorf(\"Find() gotInds = %v, want %v\", gotInds, tc.wantInds)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t})\n\t}\n\n}\n",
    "7dbdc50dd0c7ca092a6eb33c2b115cb4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\tt.Parallel()\n\tfor _, test := range []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single slice\",\n\t\t\tslices:   [][]float64{{1, 2, 3}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"equal lengths\",\n\t\t\tslices:   [][]float64{{1, 2}, {3, 4}, {5, 6}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unequal lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero length and non-zero length\",\n\t\t\tslices:   [][]float64{{}, {1, 2, 3}},\n\t\t\texpected: false,\n\t\t},\n\t} {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tactual := EqualLengths(test.slices...)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", test.slices, actual, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dee733e37d1cd403fa43e560561b44b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tfor i, c := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 3, []float64{0, 1, 2, 3}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0}, 1, -1, []float64{1, 0, -1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 2, []float64{-1, 0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, -1, -2, []float64{-1, -1.3333333333333333, -1.6666666666666667, -2}},\n\t} {\n\t\tgot := Span(c.dst, c.l, c.u)\n\t\tif !EqualApprox(got, c.ans, 1e-15) {\n\t\t\tt.Errorf(\"Case %v: unexpected result. Want %v, got %v\", i, c.ans, got)\n\t\t}\n\t}\n\n\t// Special cases for Inf and NaN.\n\tinf := math.Inf(1)\n\tnan := math.NaN()\n\n\t// All same value if both bounds are the same infinity.\n\tfor _, c := range []struct {\n\t\tl, u float64\n\t}{\n\t\t{-inf, -inf},\n\t\t{inf, inf},\n\t} {\n\t\tdst := make([]float64, 4)\n\t\tgot := Span(dst, c.l, c.u)\n\t\tfor j := range dst {\n\t\t\tif got[j] != c.l {\n\t\t\t\tt.Errorf(\"Expected dst[%d] = %v, got %v\", j, c.l, got[j])\n\t\t\t}\n\t\t}\n\t}\n\n\t// NaN cases\n\tfor _, c := range []struct {\n\t\tl, u float64\n\t\tans []float64\n\t}{\n\t\t{nan, 0.0, []float64{nan, nan, 0.0}},\n\t\t{0.0, nan, []float64{0.0, nan, nan}},\n\t\t{nan, nan, []float64{nan, nan, nan}},\n\t\t{nan, inf, []float64{nan, nan, inf}},\n\t\t{-inf, nan, []float64{-inf, nan, nan}},\n\t} {\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, c.l, c.u)\n\t\tfor j := range dst {\n\t\t\tif j == len(dst)-1 {\n\t\t\t\tif got[j] != c.ans[j] {\n\t\t\t\t\tt.Errorf(\"Expected dst[%d] = %v, got %v\", j, c.l, got[j])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !math.IsNaN(got[j]) {\n\t\t\t\t\tt.Errorf(\"Expected dst[%d] = NaN, got %v\", j, got[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "7e067ec2eec8c0ce92a797561684a201": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is the length of the hypothetical vector\n\t// l is the lower bound of the vector\n\t// u is the upper bound of the vector\n\t// v is the value to search for\n\n\t// Test cases for various combinations of n, l, u, and v\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\t\t{2, -1, 1, 0, 1},\n\t\t{2, -1, 1, -10, 0},\n\t\t{2, -1, 1, 10, 1},\n\n\t\t// n = 3\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{3, 1, 0, 0.3, 0},\n\t\t{3, 1, 0, 0.7, 1},\n\n\t\t// n = 4\n\t\t{4, 0, 1, 0.2, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{4, 1, 0, 0.2, 0},\n\t\t{4, 1, 0, 0.5, 1},\n\t\t{4, 1, 0, 0.8, 2},\n\n\t\t// Special cases for Inf and NaN\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{4, math.Inf(1), math.Inf(-1), 0, 2},\n\t\t{4, 0, math.Inf(1), 100, 3},\n\t\t{4, math.Inf(-1), 0, -100, 0},\n\t\t{4, math.NaN(), 0, 0, 0},\n\t\t{4, 0, math.NaN(), 0, 3},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "7e0e584ee99bb04f534bf4a061567134": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttol := 1e-15\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantError error\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"Nil inds, k = 0\",\n\t\t\tinds:      nil,\n\t\t\tf:         func(v float64) bool { return true },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"Non-nil inds, k = 0\",\n\t\t\tinds:      make([]int, 10),\n\t\t\tf:         func(v float64) bool { return true },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k \u003c 0, finds all\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(v float64) bool { return true },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{0, 1, 2, 3},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k \u003c 0, finds none\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(v float64) bool { return false },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k \u003e 0, finds all\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(v float64) bool { return v \u003e 0.5 \u0026\u0026 v \u003c 4.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         4,\n\t\t\twantInds:  []int{0, 1, 2, 3},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k \u003e 0, finds some\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(v float64) bool { return v \u003e 1.5 \u0026\u0026 v \u003c 3.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 2},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"k \u003e 0, finds one\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(v float64) bool { return v \u003e 1.5 \u0026\u0026 v \u003c 2.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1},\n\t\t\twantError: errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:      \"k \u003e 0, finds none\",\n\t\t\tinds:      make([]int, 0),\n\t\t\tf:         func(v float64) bool { return v \u003e 5.5 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{},\n\t\t\twantError: errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotError := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\tif gotError != nil \u0026\u0026 tc.wantError == nil {\n\t\t\t\tt.Fatalf(\"Got unexpected error: %v, want: nil\", gotError)\n\t\t\t}\n\t\t\tif gotError == nil \u0026\u0026 tc.wantError != nil {\n\t\t\t\tt.Fatalf(\"Got no error, want: %v\", tc.wantError)\n\t\t\t}\n\t\t\tif gotError != nil \u0026\u0026 tc.wantError != nil {\n\t\t\t\tif gotError.Error() != tc.wantError.Error() {\n\t\t\t\t\tt.Fatalf(\"Got error: %v, want: %v\", gotError, tc.wantError)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\tt.Fatalf(\"Got %d inds, want %d\", len(gotInds), len(tc.wantInds))\n\t\t\t}\n\n\t\t\tfor i := range tc.wantInds {\n\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Errorf(\"Ind %d: Got %v, want %v\", i, gotInds[i], tc.wantInds[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7e338ea1edf5d53d16546d7262adfbf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},                                  // v in the middle\n\t\t{10, 0, 10, -1, 0},                                 // v less than l\n\t\t{10, 0, 10, 11, 9},                                 // v greater than u\n\t\t{10, 0, 10, 2.5, 2},                                // v closer to lower index\n\t\t{10, 0, 10, 7.5, 7},                                // v closer to higher index\n\t\t{10, -5, 5, 0, 5},                                 // negative l and positive u\n\t\t{10, -5, -1, -3, 5},                                // negative l and u\n\t\t{10, 1, 5, 3, 5},                                  // v exactly halfway\n\t\t{9, 1, 5, 3, 4},                                   // odd n, v exactly halfway\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 0},            // l = -Inf, u = Inf, v = 0\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},  // l = -Inf, u = Inf, v = Inf\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0}, // l = -Inf, u = Inf, v = -Inf\n\t\t{10, 0, math.Inf(1), 5, 5},                       // l = 0, u = Inf\n\t\t{10, math.Inf(-1), 0, -5, 5},                      // l = -Inf, u = 0\n\t\t{10, math.NaN(), 5, 0, 9},                        // l = NaN\n\t\t{10, 5, math.NaN(), 0, 0},                        // u = NaN\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d\", i+1, tc.expected, actual)\n\t\t}\n\t}\n\n\t// Test cases for panics\n\tpanicCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 10, 5}, // n \u003c 2\n\t}\n\n\tfor i, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Test case %d failed: expected panic, but got none\", i+1)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "7f25d22513ef6e04b64a192ed3cfc5b0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    2,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, same sign\",\n\t\t\tn:    2,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, odd n, finite v\",\n\t\t\tn:    3,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, odd n, infinite v, same sign as lower\",\n\t\t\tn:    3,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, odd n, infinite v, same sign as upper\",\n\t\t\tn:    3,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, even n, v same sign as lower\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"both bounds infinite, different sign, even n, v same sign as upper\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound, finite upper bound, v equals lower\",\n\t\t\tn:    2,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite lower bound, finite upper bound, v different from lower\",\n\t\t\tn:    2,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0,\n\t\t\tv:    0,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"finite lower bound, infinite upper bound, v equals upper\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"finite lower bound, infinite upper bound, v different from upper\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, ascending\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, descending\",\n\t\t\tn:    2,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, ascending\",\n\t\t\tn:    2,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, descending\",\n\t\t\tn:    2,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ascending, below\",\n\t\t\tn:    4,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    -1.1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ascending, above\",\n\t\t\tn:    4,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    1.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"descending, below\",\n\t\t\tn:    4,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    -1.1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"descending, above\",\n\t\t\tn:    4,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    1.1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ascending, inside, lower\",\n\t\t\tn:    4,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    -0.9,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ascending, inside, upper\",\n\t\t\tn:    4,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    0.9,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"random1\",\n\t\t\tn:    5,\n\t\t\tl:    -2.3,\n\t\t\tu:    3.5,\n\t\t\tv:    1.1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"random2\",\n\t\t\tn:    5,\n\t\t\tl:    3.5,\n\t\t\tu:    -2.3,\n\t\t\tv:    1.1,\n\t\t\twant: 2,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"unexpected index: got: %d want: %d\", got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t}{\n\t\t{\n\t\t\tname: \"zero length\",\n\t\t\tn:    0,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t\t{\n\t\t\tname: \"unit length\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan did not panic with short slice\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t})\n\t}\n}\n\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\tfor _, bench := range []struct {\n\t\tname string\n\t\tn    int\n\t}{\n\t\t{\n\t\t\tname: \"small\",\n\t\t\tn:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"medium\",\n\t\t\tn:    1000,\n\t\t},\n\t\t{\n\t\t\tname: \"large\",\n\t\t\tn:    100000,\n\t\t},\n\t} {\n\t\tb.Run(bench.name, func(b *testing.B) {\n\t\t\tsrc := make([]float64, bench.n)\n\t\t\ttest.BenchSpan(b, src)\n\t\t\tl := src[0]\n\t\t\tu := src[len(src)-1]\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\tNearestIdxForSpan(bench.n, l, u, src[i%bench.n])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7f3a126a386b9ed26bfb0769fd5122a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice (should panic)\n\t// 2. Slice with one element\n\t// 3. Slice with multiple elements, max at the beginning\n\t// 4. Slice with multiple elements, max at the end\n\t// 5. Slice with multiple elements, max in the middle\n\t// 6. Slice with multiple max values, first occurrence should be returned\n\t// 7. Slice with NaN values\n\n\t// Test case 1: Empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with an empty slice\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n\n\t// Test case 2: Slice with one element\n\ts1 := []float64{5.0}\n\texpected1 := 0\n\tresult1 := MaxIdx(s1)\n\tif result1 != expected1 {\n\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s1, result1, expected1)\n\t}\n\n\t// Test case 3: Slice with multiple elements, max at the beginning\n\ts2 := []float64{5.0, 2.0, 1.0, 4.0}\n\texpected2 := 0\n\tresult2 := MaxIdx(s2)\n\tif result2 != expected2 {\n\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s2, result2, expected2)\n\t}\n\n\t// Test case 4: Slice with multiple elements, max at the end\n\ts3 := []float64{1.0, 2.0, 4.0, 5.0}\n\texpected3 := 3\n\tresult3 := MaxIdx(s3)\n\tif result3 != expected3 {\n\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s3, result3, expected3)\n\t}\n\n\t// Test case 5: Slice with multiple elements, max in the middle\n\ts4 := []float64{1.0, 4.0, 5.0, 2.0}\n\texpected4 := 2\n\tresult4 := MaxIdx(s4)\n\tif result4 != expected4 {\n\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s4, result4, expected4)\n\t}\n\n\t// Test case 6: Slice with multiple max values, first occurrence returned\n\ts5 := []float64{5.0, 2.0, 5.0, 1.0}\n\texpected5 := 0\n\tresult5 := MaxIdx(s5)\n\tif result5 != expected5 {\n\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s5, result5, expected5)\n\t}\n\n\t// Test case 7: Slice with NaN values\n\ts6 := []float64{math.NaN(), 2.0, 5.0, math.NaN(), 1.0}\n\texpected6 := 2\n\tresult6 := MaxIdx(s6)\n\tif result6 != expected6 {\n\t\tt.Errorf(\"MaxIdx(%v) = %v, expected %v\", s6, result6, expected6)\n\t}\n}",
    "7f6810e613aee48e70477e69512564f4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases.\n\ttcs := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Empty case\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Single slice\",\n\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tslices: [][]float64{{1, 2}, {3, 4}, {5, 6}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal lengths\",\n\t\t\tslices: [][]float64{{1, 2}, {3, 4, 5}, {6}},\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\t// Run test cases.\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f69ce5884584bab680bef849c1ae2aa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"SmallSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCasePositive\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseNegative\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseMixed\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleInfL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleInfU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Got %v, want %v\", got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Span did not panic with short slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\n// Helper function to compare floats for equality within a tolerance.\nconst epsilon = 1e-10\n\nfunc closeEnough(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c epsilon || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}",
    "806936f5d9d784f8306b0ac2a5943872": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases for EqualLengths function.\n\ttype testCase struct {\n\t\tinput    [][]float64\n\t\texpected bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{[][]float64{}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5}}, false},\n\t\t{[][]float64{{1}, {2}, {3}}, true},\n\t\t{[][]float64{{1}, {2, 3}, {4}}, false},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := EqualLengths(tc.input...)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: input=%v, expected=%v, actual=%v\", i, tc.input, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "809daefdfb910db4c42b0f1b1277fcbe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    2.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{2.0, 5.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.Abs(got[i]-tc.want[i]) \u003e 1e-10 {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t}\n\n\t\t\t}\n\t\t})\n\n\t}\n\n\t// Test cases for NaN and Inf.\n\tt.Run(\"NaN cases\", func(t *testing.T) {\n\t\tnanCases := []struct {\n\t\t\tname string\n\t\t\tdst  []float64\n\t\t\tl    float64\n\t\t\tu    float64\n\t\t\twant []float64\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"NaN for l\",\n\t\t\t\tdst:  make([]float64, 3),\n\t\t\t\tl:    math.NaN(),\n\t\t\t\tu:    1.0,\n\t\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"NaN for u\",\n\t\t\t\tdst:  make([]float64, 3),\n\t\t\t\tl:    0.0,\n\t\t\t\tu:    math.NaN(),\n\t\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range nanCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tfor i := range got {\n\t\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\t\tif !math.IsNaN(got[i]) \u0026\u0026 !math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif math.IsNaN(got[i]) != math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\t// Test case for panic when len(dst) \u003c 2\n\tt.Run(\"PanicsOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on a short slice\")\n\t\t\t}\n\t\t}()\n\n\t\tshortSlice := make([]float64, 1)\n\t\tSpan(shortSlice, 0.0, 1.0)\n\t})\n}\n",
    "80ffe1ef1dc80434c8321ba0d2fb1c7c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - l is not NaN, u is NaN\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - l is not Inf, u is Inf\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"one element\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"two elements\", func(t *testing.T) {\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"odd number of elements\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"even number of elements\", func(t *testing.T) {\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l \u003e u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l == u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is NaN, u is not\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is not NaN, u is NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l and u are Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is Inf, u is not\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"l is not Inf, u is Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "8164f904edbace0e687a6eb1a01a3af5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{2, 3, 1}, []float64{5, 6, 7}, 2, math.Sqrt(38)},\n\t\t{[]float64{2, 3, 1}, []float64{5, 6, 7}, 1, 12},\n\t\t{[]float64{2, 3, 1}, []float64{5, 6, 7}, math.Inf(1), 6},\n\t\t{[]float64{2, 3, 1}, []float64{2, 3, 1}, 2, 0},\n\t\t{[]float64{2, 3, 1}, []float64{2, 3, 1}, 1, 0},\n\t\t{[]float64{2, 3, 1}, []float64{2, 3, 1}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 3, math.Pow(96, 1.0/3)},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n}",
    "820e22f4df79d99e681e83421197f3ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{0, 0, 0, 0}, 1, 0},\n\t\t{[]float64{0, 0, 0, 0}, 2, 0},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(1), 0},\n\t\t{[]float64{}, 1, -1},\n\t\t{[]float64{}, 2, -1},\n\t\t{[]float64{}, math.Inf(1), -1},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the L-norm using the Norm function\n\t\tgot := Norm(tc.s, tc.L)\n\n\t\t// Check if the calculated L-norm matches the expected value\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: Norm(%v, %v) = %v, want %v\", i, tc.s, tc.L, got, tc.want)\n\t\t}\n\t}\n}",
    "8237b765f07159af3926d27949397523": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 2, []float64{0, 1, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 3, []float64{0, 1, 2, 3}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0}, -10, -5, []float64{-10, -7.5, -5}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 2.2, 6.8, []float64{2.2, 3.4, 4.6, 5.8, 6.8}},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t// Check if the lengths match\n\t\tif len(got) != len(tc.want) {\n\t\t\tt.Errorf(\"Test case %d: length mismatch, got %d, want %d\", i, len(got), len(tc.want))\n\t\t}\n\n\t\t// Check if the values match\n\t\tfor j := range got {\n\t\t\tif math.Abs(got[j]-tc.want[j]) \u003e 1e-6 {\n\t\t\t\tt.Errorf(\"Test case %d: element %d mismatch, got %v, want %v\", i, j, got, tc.want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf\n\tnanCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 1, math.NaN(), []float64{1, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0}, 1, math.NaN(), []float64{1, math.NaN(), math.NaN()}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0}, 1, math.Inf(1), []float64{1, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, 1, math.Inf(1), []float64{1, 1, math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1, 1}},\n\t}\n\n\tfor i, tc := range nanCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t// Check if the lengths match\n\t\tif len(got) != len(tc.want) {\n\t\t\tt.Errorf(\"Test case %d: length mismatch, got %d, want %d\", i, len(got), len(tc.want))\n\t\t}\n\n\t\t// Check if the values match\n\t\tfor j := range got {\n\t\t\tif math.IsNaN(tc.want[j]) {\n\t\t\t\tif !math.IsNaN(got[j]) {\n\t\t\t\t\tt.Errorf(\"Test case %d: element %d mismatch, got %v, want %v\", i, j, got[j], tc.want[j])\n\t\t\t\t}\n\t\t\t} else if got[j] != tc.want[j] {\n\t\t\t\tt.Errorf(\"Test case %d: element %d mismatch, got %v, want %v\", i, j, got[j], tc.want[j])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case for panic when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 1)\n}",
    "82cfd02b37e335e4d6d30fe85596f5fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\n\t\t// L = 2\n\t\t{[]float64{1, 1, 1, 1}, 2, 2},\n\t\t{[]float64{-1, -1, -1, -1}, 2, 2},\n\t\t{[]float64{3, 4}, 2, 5},\n\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\n\t\t// L = 3\n\t\t{[]float64{1, 1, 1, 1}, 3, math.Pow(4, 1.0/3.0)},\n\n\t\t// Empty slice\n\t\t{[]float64{}, 2, 0},\n\t}\n\n\t// Test each case\n\tfor i, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif !floats.EqualApprox(actual, tc.expected, 1e-15) {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}",
    "8316756719bd266dc16a02ec38ac71fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is the length of the hypothetical vector.\n\tn := 10\n\n\t// Test cases consist of a lower and upper bound, a value to search for,\n\t// and the expected index.\n\ttestCases := []struct {\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t// Simple cases.\n\t\t{0, 10, 5, 5},\n\t\t{0, 10, -1, 0},\n\t\t{0, 10, 11, 9},\n\n\t\t// Cases with bounds reversed.\n\t\t{10, 0, 5, 5},\n\t\t{10, 0, 11, 0},\n\t\t{10, 0, -1, 9},\n\n\t\t// Cases with infinities.\n\t\t{0, math.Inf(1), 5, 5},\n\t\t{math.Inf(-1), 0, -5, 5},\n\t\t{math.Inf(-1), math.Inf(1), 0, 5},\n\n\t\t// Cases with NaNs.\n\t\t{0, math.NaN(), 5, 0},\n\t\t{math.NaN(), 10, 5, 0},\n\t\t{math.NaN(), math.NaN(), 5, 0},\n\t\t{0, 10, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\t// Run the test and check the result.\n\t\tactual := NearestIdxForSpan(n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"Test case %d failed: expected %d, got %d\", i, tc.expected, actual)\n\t}\n\n\t// Test panicking with n \u003c 2.\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 10, 5) }, \"Did not panic with n \u003c 2\")\n\tassert.Panics(t, func() { NearestIdxForSpan(0, 0, 10, 5) }, \"Did not panic with n \u003c 2\")\n}\n",
    "833b21a0075c577fde94c189898f66a9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort_Swap(t *testing.T) {\n\t// Example input data\n\tdata := []float64{3.0, 1.0, 4.0, 2.0}\n\tinds := []int{0, 1, 2, 3}\n\n\t// Create an argsort instance\n\ta := Argsort(data, inds)\n\n\t// Swap elements at index 1 and 2\n\ta.Swap(1, 2)\n\n\t// Check if the swap was successful\n\tif a.s[1] != 4.0 || a.s[2] != 1.0 {\n\t\tt.Errorf(\"Swap() failed to swap elements correctly. Expected: [3 4 1 2], Got: %v\", a.s)\n\t}\n\n\t// Check if the indices were updated correctly\n\tif a.inds[1] != 2 || a.inds[2] != 1 {\n\t\tt.Errorf(\"Swap() failed to update indices correctly. Expected: [0 2 1 3], Got: %v\", a.inds)\n\t}\n}",
    "84cba209de73be9fc8a65c3115cd478d": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Define test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"k=0\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003c0\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(f float64) bool { return f \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        -1,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0, all elements found\",\n\t\t\tinds:     []int{1},\n\t\t\tf:        func(f float64) bool { return f \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        4,\n\t\t\texpected: []int{0, 1, 2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0, some elements found\",\n\t\t\tinds:     make([]int, 10),\n\t\t\tf:        func(f float64) bool { return f \u003e 2 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"k\u003e0, insufficient elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(f float64) bool { return f \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4},\n\t\t\tk:        2,\n\t\t\texpected: nil,\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\t// Run test cases\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Call Find function\n\t\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\t// Check error\n\t\t\tif err != nil \u0026\u0026 tc.err == nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t} else if err == nil \u0026\u0026 tc.err != nil {\n\t\t\t\tt.Errorf(\"expected error but got nil\")\n\t\t\t} else if err != nil \u0026\u0026 tc.err != nil \u0026\u0026 err.Error() != tc.err.Error() {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tc.err, err)\n\t\t\t}\n\n\t\t\t// Check result\n\t\t\tif len(inds) != len(tc.expected) {\n\t\t\t\tt.Errorf(\"expected inds length %d, got %d\", len(tc.expected), len(inds))\n\t\t\t}\n\t\t\tfor i := range inds {\n\t\t\t\tif inds[i] != tc.expected[i] {\n\t\t\t\t\tt.Errorf(\"expected inds[%d]=%d, got %d\", i, tc.expected[i], inds[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cf1db0881ba9374d11a631125e887c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2 (panics)\n\t// - math.IsNaN(v) (returns 0)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u) (returns n - 1)\n\t// - math.IsNaN(u) (returns 0)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\t//     - l == u (returns 0)\n\t//     - n%2 == 1 \u0026\u0026 !math.IsInf(v, 0) (returns n / 2)\n\t//     - n%2 == 1 \u0026\u0026 math.IsInf(v, 0) \u0026\u0026 math.Copysign(1, v) == math.Copysign(1, l) (returns 0)\n\t//     - n%2 == 1 \u0026\u0026 math.IsInf(v, 0) \u0026\u0026 math.Copysign(1, v) != math.Copysign(1, l) (returns n/2 + 1)\n\t//     - n%2 == 0 \u0026\u0026 math.Copysign(1, v) == math.Copysign(1, l) (returns 0)\n\t//     - n%2 == 0 \u0026\u0026 math.Copysign(1, v) != math.Copysign(1, l) (returns n / 2)\n\t// - math.IsInf(l, 0) (returns n - 1 if v == l else 0)\n\t// - math.IsInf(u, 0) (returns 0 if v == u else n - 1)\n\t// - math.IsInf(v, -1) (returns 0 if l \u003c= u else n - 1)\n\t// - math.IsInf(v, 1) (returns 0 if u \u003c= l else n - 1)\n\t// - l \u003c u\n\t//     - v \u003c= l (returns 0)\n\t//     - v \u003e= u (returns n - 1)\n\t//     - l \u003c v \u003c u (returns int((float64(n)-1)/(u-l)*(v-l) + 0.5))\n\t// - l \u003e u\n\t//     - v \u003e= l (returns 0)\n\t//     - v \u003c= u (returns n - 1)\n\t//     - u \u003c v \u003c l (returns int((float64(n)-1)/(u-l)*(v-l) + 0.5))\n\t// - l == u (returns 0)\n\n\t// n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n\n\t// math.IsNaN(v)\n\tn := 10\n\tl := 0.0\n\tu := 1.0\n\tv := math.NaN()\n\texpected := 0\n\tactual := NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\tn = 10\n\tl = math.NaN()\n\tu = 1.0\n\tv = 0.5\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsNaN(u)\n\tn = 10\n\tl = 0.0\n\tu = math.NaN()\n\tv = 0.5\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\tn = 10\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = 0.0\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 11\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = 0.0\n\texpected = n / 2\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 11\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = math.Inf(0)\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 11\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = math.Inf(-1)\n\texpected = n/2 + 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = math.Inf(0)\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = math.Inf(0)\n\tu = math.Inf(0)\n\tv = math.Inf(-1)\n\texpected = n / 2\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsInf(l, 0)\n\tn = 10\n\tl = math.Inf(0)\n\tu = 1.0\n\tv = math.Inf(0)\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = math.Inf(0)\n\tu = 1.0\n\tv = 0.0\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsInf(u, 0)\n\tn = 10\n\tl = 0.0\n\tu = math.Inf(0)\n\tv = math.Inf(0)\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 0.0\n\tu = math.Inf(0)\n\tv = 0.0\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsInf(v, -1)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(-1)\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = math.Inf(-1)\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// math.IsInf(v, 1)\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = math.Inf(1)\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = math.Inf(1)\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// l \u003c u\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = -0.5\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = 1.5\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 0.0\n\tu = 1.0\n\tv = 0.5\n\texpected = int((float64(n)-1)/(u-l)*(v-l) + 0.5)\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// l \u003e u\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = 1.5\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = -0.5\n\texpected = n - 1\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\tn = 10\n\tl = 1.0\n\tu = 0.0\n\tv = 0.5\n\texpected = int((float64(n)-1)/(u-l)*(v-l) + 0.5)\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n\n\t// l == u\n\tn = 10\n\tl = 0.0\n\tu = 0.0\n\tv = 0.5\n\texpected = 0\n\tactual = NearestIdxForSpan(n, l, u, v)\n\tif actual != expected {\n\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, expected %v\", n, l, u, v, actual, expected)\n\t}\n}\n",
    "84fc49945a232770c24f21a053cee5a1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := [][5]int{\n\t\t{2, 0, 1, 0.0, 0},\n\t\t{2, 0, 1, 1.0, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.75, 7},\n\t\t{10, -1, 1, 0.0, 5},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0.5, 7},\n\t\t{11, -1, 1, 0.0, 5},\n\t\t{11, -1, 1, -0.5, 3},\n\t\t{11, -1, 1, 0.5, 8},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tn, l, u, v := tc[0], float64(tc[1]), float64(tc[2]), float64(tc[3])\n\t\texpected := tc[4]\n\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, expected)\n\t\t}\n\t}\n\n\t// Test cases for Inf and NaN\n\tinfTestCases := [][5]int{\n\t\t{2, 0, math.Inf(1), 0.0, 0},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, math.Inf(-1), 0, 0.0, 1},\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{2, math.Inf(-1), math.Inf(1), 0.0, 0},\n\t\t{2, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{2, math.Inf(-1), math.Inf(1), math.Inf(1), 1},\n\t}\n\tfor _, tc := range infTestCases {\n\t\tn, l, u, v := tc[0], float64(tc[1]), float64(tc[2]), float64(tc[3])\n\t\texpected := tc[4]\n\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, expected)\n\t\t}\n\t}\n}\n",
    "8660c16f640958be268b424125fc3fec": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Single element slice\n\t// - Multiple element slice\n\t// - L = 1\n\t// - L = 2\n\t// - L = infinity\n\t// - L = other positive value\n\n\t// Empty slice\n\ts := []float64{}\n\tif Norm(s, 1) != 0 {\n\t\tt.Errorf(\"Norm of empty slice should be 0\")\n\t}\n\n\t// Single element slice\n\ts = []float64{1}\n\tif Norm(s, 1) != 1 {\n\t\tt.Errorf(\"Norm of [1] should be 1\")\n\t}\n\n\t// Multiple element slice\n\ts = []float64{1, 2, 3}\n\tif Norm(s, 1) != 6 {\n\t\tt.Errorf(\"Norm of [1, 2, 3] with L=1 should be 6\")\n\t}\n\n\t// L = 2\n\tif Norm(s, 2) != math.Sqrt(14) {\n\t\tt.Errorf(\"Norm of [1, 2, 3] with L=2 should be sqrt(14)\")\n\t}\n\n\t// L = infinity\n\tif Norm(s, math.Inf(1)) != 3 {\n\t\tt.Errorf(\"Norm of [1, 2, 3] with L=infinity should be 3\")\n\t}\n\n\t// L = other positive value\n\tif Norm(s, 3) != math.Pow(36, 1.0/3.0) {\n\t\tt.Errorf(\"Norm of [1, 2, 3] with L=3 should be (36)^(1/3)\")\n\t}\n\n}\n",
    "876a136b2371b18a843f206bffeb3c2a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// First test the panics\n\t// shortSpan\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n\tfor _, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.25, want: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, want: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.75, want: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, want: 2},\n\t\t{n: 10, l: -1, u: 1, v: -2, want: 0},\n\t\t{n: 10, l: -1, u: 1, v: -1, want: 0},\n\t\t{n: 10, l: -1, u: 1, v: 0, want: 5},\n\t\t{n: 10, l: -1, u: 1, v: 1, want: 9},\n\t\t{n: 10, l: -1, u: 1, v: 2, want: 9},\n\t\t// reversed\n\t\t{n: 2, l: 1, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, want: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.25, want: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, want: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.75, want: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, want: 0},\n\t\t{n: 10, l: 1, u: -1, v: -2, want: 9},\n\t\t{n: 10, l: 1, u: -1, v: -1, want: 9},\n\t\t{n: 10, l: 1, u: -1, v: 0, want: 5},\n\t\t{n: 10, l: 1, u: -1, v: 1, want: 0},\n\t\t{n: 10, l: 1, u: -1, v: 2, want: 0},\n\t\t// nasty cases\n\t\t{n: 2, l: 0, u: 0, v: 0, want: 0},\n\t\t{n: 2, l: 1, u: 1, v: 0, want: 0},\n\t\t{n: 3, l: 0, u: 0, v: 0, want: 0},\n\t\t{n: 3, l: 1, u: 1, v: 0, want: 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v,%v,%v,%v) = %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, have, test.want)\n\t\t}\n\t}\n\n\t// Test NaN cases\n\tfor _, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 0, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: 0, want: 1},\n\t\t{n: 2, l: math.NaN(), u: 0, v: math.NaN(), want: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), v: math.NaN(), want: 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v,%v,%v,%v) = %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, have, test.want)\n\t\t}\n\t}\n\t// Test Inf cases\n\tfor _, test := range []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t//              v=-inf    v=0     v=+inf\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0.0, want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 1},\n\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), want: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0.0, want: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), want: 0},\n\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), want: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0.0, want: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), want: 2},\n\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), want: 2},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0.0, want: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), want: 0},\n\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), want: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: 0, want: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(1), want: 1},\n\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: math.Inf(-1), want: 1},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: 0, want: 0},\n\t\t{n: 2, l: 0, u: math.Inf(-1), v: math.Inf(1), want: 0},\n\t} {\n\t\thave := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v,%v,%v,%v) = %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, have, test.want)\n\t\t}\n\t}\n\t// generate random test cases\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tn := i + 2\n\t\tl := 2*rng.Float64() - 1\n\t\tu := 2*rng.Float64() - 1\n\t\tv := 2*rng.Float64() - 1\n\t\t// perturb v by a small amount to test for off-by-one errors\n\t\tvp := v * (1 + (2*rng.Float64()-1)*tol)\n\t\twant := NearestIdxForSpan(n, l, u, v)\n\t\thave := NearestIdxForSpan(n, l, u, vp)\n\t\tif want != have {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v,%v,%v,%v) = %v, want %v\",\n\t\t\t\tn, l, u, vp, have, want)\n\t\t}\n\t}\n}\n",
    "88a0193ded84b9e893d23ff426b1843c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{2, 3, 4}, []float64{2, 3, 4}, 2, 0},\n\t\t{[]float64{2, 3, 4}, []float64{3, 2, 5}, 1, 4},\n\t\t{[]float64{2, 3, 4}, []float64{3, 2, 5}, 2, math.Sqrt(6)},\n\t\t{[]float64{2, 3, 4}, []float64{3, 2, 5}, 3, math.Pow(1+1+1, 1.0/3)},\n\t\t{[]float64{2, 3, 4, 10}, []float64{3, 2, 5, -10}, math.Inf(1), 20},\n\t\t{[]float64{}, []float64{}, 2, -1},\n\t\t{[]float64{1, 2}, []float64{1, 1}, 0, 1},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"For s = %v, t = %v and L = %v, got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\tpanics := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}{\n\t\t{[]float64{2, 3}, []float64{2, 3, 4}, 2},\n\t\t{[]float64{2, 3, 4}, []float64{2, 3}, 2},\n\t}\n\tfor _, test := range panics {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic for s = %v, and t = %v\", test.s, test.t)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tDistance(test.s, test.t, test.L)\n\t\t}()\n\t}\n}",
    "8900aa68771056c6d140df5d1c575cfa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tdst := make([]float64, 5)\n\n\t// Basic case\n\tSpan(dst, 0, 10)\n\tassert.Equal(t, []float64{0, 2.5, 5, 7.5, 10}, dst)\n\n\t// Length less than 2\n\tassert.Panics(t, func() { Span(make([]float64, 1), 0, 10) })\n\n\t// NaN cases\n\tSpan(dst, math.NaN(), 10)\n\tassert.True(t, math.IsNaN(dst[0]))\n\tassert.True(t, math.IsNaN(dst[1]))\n\tassert.True(t, math.IsNaN(dst[2]))\n\tassert.True(t, math.IsNaN(dst[3]))\n\tassert.Equal(t, float64(10), dst[4])\n\n\tSpan(dst, 0, math.NaN())\n\tassert.Equal(t, float64(0), dst[0])\n\tassert.True(t, math.IsNaN(dst[1]))\n\tassert.True(t, math.IsNaN(dst[2]))\n\tassert.True(t, math.IsNaN(dst[3]))\n\tassert.True(t, math.IsNaN(dst[4]))\n\n\t// Inf cases\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tassert.Equal(t, math.Inf(1), dst[0])\n\tassert.Equal(t, math.Inf(1), dst[1])\n\tassert.Equal(t, float64(0), dst[2])\n\tassert.Equal(t, math.Inf(-1), dst[3])\n\tassert.Equal(t, math.Inf(-1), dst[4])\n\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tassert.Equal(t, math.Inf(1), dst[0])\n\tassert.Equal(t, math.Inf(1), dst[1])\n\tassert.Equal(t, math.Inf(1), dst[2])\n\tassert.Equal(t, math.Inf(1), dst[3])\n\tassert.Equal(t, math.Inf(1), dst[4])\n\n\tSpan(dst, math.Inf(1), 10)\n\tassert.Equal(t, math.Inf(1), dst[0])\n\tassert.Equal(t, math.Inf(1), dst[1])\n\tassert.Equal(t, math.Inf(1), dst[2])\n\tassert.Equal(t, math.Inf(1), dst[3])\n\tassert.Equal(t, float64(10), dst[4])\n\n\tSpan(dst, 0, math.Inf(-1))\n\tassert.Equal(t, float64(0), dst[0])\n\tassert.Equal(t, math.Inf(-1), dst[1])\n\tassert.Equal(t, math.Inf(-1), dst[2])\n\tassert.Equal(t, math.Inf(-1), dst[3])\n\tassert.Equal(t, math.Inf(-1), dst[4])\n}\n",
    "8957cbfb628c000e6a23a0af86dc0e6d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"golang.org/x/exp/slices\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts, t []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(27, 1.0/3.0)},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t} {\n\t\tgot := Distance(c.s, c.t, c.L)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", c.s, c.t, c.L, got, c.want)\n\t\t}\n\t}\n\t// test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{1, 2}, 2)\n}",
    "8a268a807febdd1589044723d42783f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// n, l, u, v, want\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.25, 0},\n\t\t{4, 0, 1, 0.75, 3},\n\t\t{3, 0, 1, -0.5, 0},\n\t\t{3, 0, 1, 1.5, 2},\n\t\t{5, -1, 1, -0.5, 1},\n\t\t{5, -1, 1, 0.5, 3},\n\t\t{10, -5, 5, -4, 1},\n\t\t{10, -5, 5, 4, 8},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, test.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanTests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, math.NaN(), 0, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 1},\n\t\t{2, math.NaN(), math.NaN(), 0, 0},\n\t\t{3, math.Inf(-1), 0, 0, 0},\n\t\t{3, 0, math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 1},\n\t}\n\tfor i, test := range nanTests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, test.want)\n\t\t}\n\t}\n}",
    "8d7bf8dcb492c4994dab8bf626b97ed0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l or u is NaN\n\t// - l or u is Inf\n\t// - l == u\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsIfLenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular\n\tt.Run(\"Regular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif got[i] != expected[i] {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"lIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"uIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.NaN()\n\t\texpected := []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsNaN(got[i]) != math.IsNaN(expected[i]) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is +Inf\n\tt.Run(\"lIsPosInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// u is +Inf\n\tt.Run(\"uIsPosInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(1)\n\t\texpected := []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is -Inf\n\tt.Run(\"lIsNegInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(-1)\n\t\tu := 5.0\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 5.0}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], -1) != math.IsInf(expected[i], -1) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// u is -Inf\n\tt.Run(\"uIsNegInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(-1)\n\t\texpected := []float64{1.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], -1) != math.IsInf(expected[i], -1) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both +Inf\n\tt.Run(\"lAndUPosInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], 1) != math.IsInf(expected[i], 1) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both -Inf\n\tt.Run(\"lAndUNegInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(-1)\n\t\tu := math.Inf(-1)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], -1) != math.IsInf(expected[i], -1) {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are both Inf but have different signs\n\tt.Run(\"lAndUInfDiffSign\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(-1)\n\t\tu := math.Inf(1)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif math.IsInf(got[i], 0) != math.IsInf(expected[i], 0) || got[i] != expected[i] {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l == u\n\tt.Run(\"lEqualsU\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 1.0\n\t\texpected := []float64{1.0, 1.0, 1.0, 1.0, 1.0}\n\t\tgot := Span(dst, l, u)\n\t\tfor i := range expected {\n\t\t\tif got[i] != expected[i] {\n\t\t\t\tt.Errorf(\"For i = %v, expected %v, got %v\", i, expected[i], got[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "8db84bf8b529bb0fc69aa47c2d3ac7c6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1}, // Tie goes to lower index.\n\t\t{[]float64{1, math.NaN(), 3}, 2, 2},\n\t\t{[]float64{1, 2, math.NaN()}, math.NaN(), 0},\n\t\t{[]float64{testlapack.Inf(-1), 1, 2, 3, testlapack.Inf(1)}, math.Inf(1), 4},\n\t\t{[]float64{testlapack.Inf(-1), 1, 2, 3, testlapack.Inf(1)}, math.Inf(-1), 0},\n\t} {\n\t\tj := NearestIdx(test.s, test.v)\n\t\tif j != test.i {\n\t\t\tt.Errorf(\"Test %v: Index mismatch. Want %v, got %v\", i, test.i, j)\n\t\t}\n\t}\n}",
    "8f9e9416d8c0aaecb379aacadcf67c50": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\tfor i, c := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.75, 7},\n\t\t{10, 0, 1, -0.1, 0},\n\t\t{10, 0, 1, 1.1, 9},\n\t\t{10, 1, 0, 0.25, 7},\n\t\t{10, 1, 0, 0.5, 5},\n\t\t{10, 1, 0, 0.75, 2},\n\t\t{10, 1, 0, -0.1, 9},\n\t\t{10, 1, 0, 1.1, 0},\n\n\t\t// Cases with infs.\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, math.Inf(-1), 0, -100, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 9},\n\n\t\t// Cases with NaNs.\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.NaN(), 1, 0.5, 0},\n\t\t{10, 0, math.NaN(), 0.5, 9},\n\t\t{10, math.NaN(), math.NaN(), 0.5, 0},\n\t} {\n\t\thave := NearestIdxForSpan(c.n, c.l, c.u, c.v)\n\t\tif have != c.want {\n\t\t\tt.Errorf(\"Test %d failed: different indices returned. Want %v, have %v\", i, c.want, have)\n\t\t}\n\t}\n}",
    "9012a9920bb033f073d1054b802c5912": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases for Find.\n\tvar testCases = []struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t}{\n\t\t{\n\t\t\tname:      \"EmptySlice\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"AllElementsFoundKNegative\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{0, 1, 2, 3, 4},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"SomeElementsFoundKNegative\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{2, 3, 6, 7},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"NoElementsFoundKNegative\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 10 },\n\t\t\ts:         []float64{1, 2, 3, 4, 1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"AllElementsFoundKZero\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"SomeElementsFoundKPositive\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{2, 3},\n\t\t\twantErr:   nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"InsufficientElementsFound\",\n\t\t\tinds:      []int{},\n\t\t\tf:         func(v float64) bool { return v \u003e 2 },\n\t\t\ts:         []float64{1, 2, 3, 4, 1, 2, 3, 4},\n\t\t\tk:         5,\n\t\t\twantInds:  []int{2, 3, 6, 7},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned unexpected error: %v\", tc.inds, tc.f, tc.s, tc.k, gotErr)\n\t\t\t} else if gotErr == nil \u0026\u0026 tc.wantErr != nil {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) did not return expected error: %v\", tc.inds, tc.f, tc.s, tc.k, tc.wantErr)\n\t\t\t} else if gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned wrong error: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotErr, tc.wantErr)\n\t\t\t}\n\n\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned slice with wrong length: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, gotInds, tc.wantInds)\n\t\t\t} else {\n\t\t\t\tfor i := range gotInds {\n\t\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned slice with wrong element at position %v: got %v, want %v\", tc.inds, tc.f, tc.s, tc.k, i, gotInds[i], tc.wantInds[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "90eda1a8282de7144480b0cef156e607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, testCase := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1,2,3,4,5}, 4},\n\t\t{[]float64{1,2,3,4,5,5}, 4},\n\t\t{[]float64{5,4,3,2,1}, 0},\n\t\t{[]float64{math.NaN(), 4, 3, 2, 1}, 1},\n\t\t{[]float64{1, 4, math.NaN(), 2, 1}, 1},\n\t\t{[]float64{1, 4, 3, 2, math.NaN()}, 1},\n\t} {\n\t\tgot := MaxIdx(testCase.s)\n\t\tif got != testCase.want {\n\t\t\tt.Errorf(\"Test case %v: MaxIdx(%v) == %v, want %v\", i, testCase.s, got, testCase.want)\n\t\t}\n\t}\n}",
    "9303356005fcdaa7752836a212c96a6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different values of L and input slices.\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// L = 1 (Manhattan norm)\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 15},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 1, 15},\n\t\t{[]float64{1, -2, 3, -4, 5}, 1, 15},\n\t\t// L = 2 (Euclidean norm)\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{-1, -2, -3}, 2, math.Sqrt(14)},\n\t\t// L = Inf (Infinity norm, maximum absolute value)\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 5},\n\t\t{[]float64{-1, -2, -3, -4, -5}, math.Inf(1), 5},\n\t\t{[]float64{1, -2, 3, -4, 5}, math.Inf(1), 5},\n\t\t// Edge cases\n\t\t{[]float64{}, 2, 0}, // Empty slice\n\t\t{nil, 2, 0},         // Nil slice\n\t}\n\n\t// Iterate over the test cases and compare the results with the expected values.\n\tfor _, tc := range testCases {\n\t\t// Calculate the norm using the function being tested.\n\t\tactual := Norm(tc.s, tc.L)\n\t\t// Compare the actual result with the expected value.\n\t\tif math.Abs(actual - tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}",
    "930bfa10b6dc4b7a361ff5e9c117915b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - Slice with a single element\n\t// - Slice with all elements equal\n\t// - Slice with positive and negative elements\n\t// - Slice with very large and very small elements\n\n\t// Test case 1: Empty slice (should panic)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp([]float64{}) did not panic\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n\n\t// Test case 2: Slice with a single element\n\tgot := LogSumExp([]float64{1.0})\n\twant := 1.0\n\tif got != want {\n\t\tt.Errorf(\"LogSumExp([]float64{1.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 3: Slice with all elements equal\n\tgot = LogSumExp([]float64{2.0, 2.0, 2.0})\n\twant = math.Log(3) + 2.0\n\tif got != want {\n\t\tt.Errorf(\"LogSumExp([]float64{2.0, 2.0, 2.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 4: Slice with positive and negative elements\n\tgot = LogSumExp([]float64{1.0, -1.0, 2.0})\n\twant = math.Log(math.Exp(1.0) + math.Exp(-1.0) + math.Exp(2.0))\n\tif math.Abs(got-want) \u003e 1e-15 {\n\t\tt.Errorf(\"LogSumExp([]float64{1.0, -1.0, 2.0}) = %v, want %v\", got, want)\n\t}\n\n\t// Test case 5: Slice with very large and very small elements\n\tgot = LogSumExp([]float64{1000.0, -1000.0, 2.0})\n\twant = 1000.0\n\tif math.Abs(got-want) \u003e 1e-10 {\n\t\tt.Errorf(\"LogSumExp([]float64{1000.0, -1000.0, 2.0}) = %v, want %v\", got, want)\n\t}\n}",
    "93bb65f0c24933e8c6e5822ca34a87d6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\"empty\", args{[]float64{}}, []float64{}},\n\t\t{\"one element\", args{[]float64{1}}, []float64{1}},\n\t\t{\"two elements\", args{[]float64{1, 2}}, []float64{2, 1}},\n\t\t{\"many elements\", args{[]float64{1, 2, 3, 4, 5}}, []float64{5, 4, 3, 2, 1}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tReverse(tt.args.s)\n\t\t\tif !reflect.DeepEqual(tt.args.s, tt.want) {\n\t\t\t\tt.Errorf(\"Reverse() = %v, want %v\", tt.args.s, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "95db695f7002f97cfcc763d5f131bde2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// n: number of points in the span\n\t// l: lower bound of the span\n\t// u: upper bound of the span\n\t// v: value to find the nearest index for\n\t// want: the expected index\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{5, 0, 4, 2.2, 2},\n\t\t{10, 0, 1, 0.5, 5},\n\n\t\t// Edge cases\n\t\t{5, 0, 4, -1, 0},\n\t\t{5, 0, 4, 5, 4},\n\t\t{5, 0, 4, 0, 0},\n\t\t{5, 0, 4, 4, 4},\n\n\t\t// Cases with NaN and Inf\n\t\t{5, 0, 4, math.NaN(), 0},\n\t\t{5, 0, math.Inf(1), math.Inf(1), 4},\n\t\t{5, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{6, math.Inf(-1), math.Inf(1), 0, 3},\n\n\t\t// Cases with l \u003e u\n\t\t{5, 4, 0, 2.2, 2},\n\t\t{5, 4, 0, 5, 0},\n\t\t{5, 4, 0, -1, 4},\n\n\t\t// Cases with equal bounds\n\t\t{5, 2, 2, 2, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: for n=%d, l=%v, u=%v, v=%v, got %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "971cdb9966ab10f3b6a66f22cf666530": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\ts5 := []float64{1.0001, 2, 3, 4}\n\n\tif !EqualApprox(s1, s2, 1e-10) {\n\t\tt.Errorf(\"Expected true, got false\")\n\t}\n\n\tif EqualApprox(s1, s3, 1e-10) {\n\t\tt.Errorf(\"Expected false, got true\")\n\t}\n\n\tif EqualApprox(s1, s4, 1e-10) {\n\t\tt.Errorf(\"Expected false, got true\")\n\t}\n\n\tif !EqualApprox(s1, s5, 1e-3) {\n\t\tt.Errorf(\"Expected true, got false\")\n\t}\n\n\tif EqualApprox(s1, s5, 1e-5) {\n\t\tt.Errorf(\"Expected false, got true\")\n\t}\n}\n",
    "97f6a508a005bcc949f1573f054387f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: {n, l, u, v, expected index}\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},         // Exactly in the middle\n\t\t{2, 0, 1, 0.1, 0},         // Closer to the lower bound\n\t\t{2, 0, 1, 0.9, 1},         // Closer to the upper bound\n\t\t{3, 0, 1, 0.33, 1},        // Near one-third\n\t\t{3, 0, 1, 0.66, 2},        // Near two-thirds\n\t\t{10, 0, 1, 0.25, 2},       // Between elements\n\t\t{10, 0, 1, -0.1, 0},       // Below lower bound\n\t\t{10, 0, 1, 1.1, 9},        // Above upper bound\n\t\t{10, 1, 0, 0.5, 7},        // Reverse span\n\t\t{10, -1, 1, 0, 5},        // Span crossing zero\n\t\t{2, math.Inf(1), 0, 0, 1}, // Infinite span, positive infinity to 0\n\t\t{2, 0, math.Inf(1), 0, 0}, // Infinite span, 0 to positive infinity\n\t\t{2, math.NaN(), 0, 0, 0},  // NaN bound\n\t\t{2, 0, math.NaN(), 0, 1},  // NaN bound\n\t\t{2, 0, 1, math.NaN(), 0},  // NaN value\n\t\t{10, 0, 0, 0.5, 0},        // Zero-length span\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d: n=%d, l=%v, u=%v, v=%v\", i, tc.n, tc.l, tc.u, tc.v), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "98455f52f62b2e50bb908d3d0ed0a1ec": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty\", args{[]float64{}}, 1},\n\t\t{\"one\", args{[]float64{2}}, 2},\n\t\t{\"many\", args{[]float64{2, 3, 4}}, 24},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9968eecfdf30082706212c97588e7293": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 5.451914395411216,\n\t\t},\n\t\t{[]float64{100, 100, 100}, 103.60542101597728,\n\t\t},\n\t\t{[]float64{-100, -100, -100}, -96.39457898402272,\n\t\t},\n\t\t{[]float64{1e-10, 1e-10, 1e-10}, -23.02585092993046,\n\t\t},\n\t\t{[]float64{-1e-10, -1e-10, -1e-10}, -23.02585092994046,\n\t\t},\n\t\t{[]float64{1, 1e10, 1e-10}, 1e10,\n\t\t},\n\t\t{[]float64{math.Inf(1), 1, 2, 3}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), 1, 2, 3}, 3},\n\t} {\n\t\tactual := LogSumExp(test.s)\n\t\tif !EqualWithinAbsOrRel(actual, test.expected, tol, tol) {\n\t\t\tt.Errorf(\"Test %d: Expected %v, but got %v\", i, test.expected, actual)\n\t\t}\n\t}\n}",
    "99d6db2036d4ac3edc0116983f0e560d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, f64.Sqrt(27)},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 1, 0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 3, 0},\n\t\t{[]float64{-1, -2, -3, -4}, []float64{1, 2, 3, 4}, 3, math.Pow(128, 1.0/3.0)},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif math.Abs(got-test.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: Got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, 2},\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, 1},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, math.Inf(1)},\n\t\t{[]float64{1, 2}, []float64{1, 2, 3}, 3},\n\t} {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: The code did not panic\", test.s, test.t, test.L)\n\t\t\t}\n\t\t}()\n\t\tDistance(test.s, test.t, test.L)\n\t}\n}",
    "9a496ba17ec527d8f006609f6f843ff6": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testfloats\"\n)\n\nfunc TestDiv(t *testing.T) {\n\tfor i := range testfloats.DivTests {\n\t\tn := len(testfloats.DivTests[i].Dst)\n\t\tdst := make([]float64, n)\n\t\tcopy(dst, testfloats.DivTests[i].Dst)\n\t\tDiv(dst, testfloats.DivTests[i].S)\n\t\tif !testfloats.EqualApprox(dst, testfloats.DivTests[i].Want, 1e-14) {\n\t\t\tt.Errorf(\"Case %d: Got %v, want %v\", i, dst, testfloats.DivTests[i].Want)\n\t\t}\n\t}\n\n\t// Test panics\n\tfor i := range testfloats.PanicTests {\n\t\tt.Run(testfloats.PanicTests[i].Name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tDiv(testfloats.PanicTests[i].Dst, testfloats.PanicTests[i].S)\n\t\t})\n\t}\n}",
    "9a6f496faafe107e1f1f8261c46d7bf1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases for NearestIdx.\n\ttype testCase struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}\n\n\ttestCases := []testCase{\n\t\t// Basic cases.\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 0, 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, 6, 4},\n\n\t\t// Cases with multiple nearest values.\n\t\t{[]float64{1, 2, 2, 4, 5}, 2.5, 1},\n\n\t\t// Cases with NaN and Inf values.\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, 2.5, 1},\n\t\t{[]float64{1, 2, math.NaN(), 4, 5}, math.NaN(), 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(-1), 0},\n\t}\n\n\t// Run the test cases.\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdx(tc.s, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n\n\t// Test for panic when s is empty.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with an empty slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0)\n}",
    "9a98ff29fee4e9f72e766486242fbc11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"DecimalBounds\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1.5,\n\t\t\tu:    2.5,\n\t\t\twant: []float64{1.5, 2.0, 2.5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    2.5,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 2.5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1.5,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{1.5, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    2.5,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 2.5},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    1.5,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{1.5, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfSameSign\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfDifferentSign\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, got %v\", i, got[i])\n\t\t\t\t\t}\n\t\t\t\t} else if !math.IsInf(tc.want[i], 0) \u0026\u0026 !math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\tt.Errorf(\"For index %d, expected %v, got %v\", i, tc.want[i], got[i])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif math.IsInf(got[i], 0) {\n\t\t\t\t\t\tif math.Signbit(got[i]) != math.Signbit(tc.want[i]) {\n\t\t\t\t\t\t\tt.Errorf(\"Expected sign of Inf at index %d to be %v, got %v\", i, math.Signbit(tc.want[i]), math.Signbit(got[i]))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tt.Run(\"PanicsOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with a slice of length less than 2.\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "9ab1d4dcd4e6e4dd07be351879e21a61": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.75, 3},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0, 5},\n\t\t{10, -1, 1, 0.5, 7},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for special values (Inf, NaN).\n\tspecialCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, math.Inf(1), 0, 0, 1},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, math.NaN(), 0, 0, 1},\n\t\t{2, 0, math.NaN(), 0, 0},\n\t\t{2, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 1},\n\t}\n\n\tfor _, tc := range specialCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "9b77ccabddafb9d8dc5b4b9224996375": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\t// Test case 1\n\tdst1 := make([]float64, 5)\n\ty1 := []float64{1, 2, 3, 4, 5}\n\talpha1 := 2.0\n\ts1 := []float64{6, 7, 8, 9, 10}\n\tAddScaledTo(dst1, y1, alpha1, s1)\n\tassert.Equal(t, []float64{13, 16, 19, 22, 25}, dst1, \"Test case 1 failed\")\n\n\t// Test case 2\n\tdst2 := []float64{0, 0, 0}\n\ty2 := []float64{1, 2, 3}\n\talpha2 := -1.0\n\ts2 := []float64{1, 2, 3}\n\tAddScaledTo(dst2, y2, alpha2, s2)\n\tassert.Equal(t, []float64{0, 0, 0}, dst2, \"Test case 2 failed\")\n\n\t// Test case 3: empty slices\n\tdst3 := make([]float64, 0)\n\ty3 := make([]float64, 0)\n\ts3 := make([]float64, 0)\n\tAddScaledTo(dst3, y3, alpha1, s3)\n\tassert.Equal(t, []float64{}, dst3, \"Test case 3 failed\")\n}",
    "9c55932632ea7107edec31327f638aa7": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{[]float64{}, 0.0}, -1},\n\t\t{\"single\", args{[]float64{1.0}, 0.0}, -1},\n\t\t{\"below\", args{[]float64{1.0, 2.0}, 0.0}, -0},\n\t\t{\"above\", args{[]float64{1.0, 2.0}, 3.0}, -0},\n\t\t{\"first\", args{[]float64{1.0, 2.0}, 1.0}, 0},\n\t\t{\"second\", args{[]float64{1.0, 2.0}, 1.5}, 0},\n\t\t{\"last\", args{[]float64{1.0, 2.0, 3.0}, 2.5}, 1},\n\t\t{\"nan\", args{[]float64{1.0, 2.0, 3.0}, math.NaN()}, -0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tt.want == -1 \u0026\u0026 recover() == nil {\n\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t}\n\t\t\t\tif tt.want \u003e= 0 \u0026\u0026 recover() != nil {\n\t\t\t\t\tt.Errorf(\"Within() panicked\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9cb0d360d85ad376bf2194447eafd178": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\"empty\", args{[]float64{}}, false},\n\t\t{\"noNaN\", args{[]float64{1, 2, 3}}, false},\n\t\t{\"oneNaN\", args{[]float64{1, math.NaN(), 3}}, true},\n\t\t{\"allNaN\", args{[]float64{math.NaN(), math.NaN()}}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d291a0a7219e71f1248386c72c4ebdd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for various L-norms\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},                                // L1 norm\n\t\t{[]float64{1, -2, 3, -4}, 2, math.Sqrt(30)},                    // L2 norm\n\t\t{[]float64{1, 2, 3, 4}, 3, math.Pow(100, 1.0/3.0)},               // L3 norm\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},                       // L-infinity norm\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},                      // L-infinity norm with negative values\n\t\t{[]float64{1.0, 2.5, 3.75, 4.99}, 2, 6.537243539533177}, // L2 norm with decimals\n\t}\n\n\t// Iterate through test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the norm using the function\n\t\tactual := Norm(tc.s, tc.L)\n\n\t\t// Check if the result matches the expected value\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-6 {\n\t\t\tt.Errorf(\"Test case %d failed: Expected norm for s=%v, L=%v to be %v, but got %v\", i+1, tc.s, tc.L, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "9d4ab18a2d3be262fae27fe7439bf295": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases:\n\t// - k = 0\n\t// - k \u003c 0\n\t// - k \u003e 0 and sufficient elements found\n\t// - k \u003e 0 and insufficient elements found\n\t// - empty input slice\n\t// - nil input slice\n\t// - various data types\n\n\t// k = 0\n\tinds := make([]int, 10)\n\tresult, err := Find(inds, func(f float64) bool { return f \u003e 5 }, []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\tif len(result) != 0 {\n\t\tt.Errorf(\"Expected empty slice, got: %v\", result)\n\t}\n\n\t// k \u003c 0\n\tinds = make([]int, 10)\n\tresult, err = Find(inds, func(f float64) bool { return f \u003e 5 }, []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, -1)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\tif len(result) != 5 {\n\t\tt.Errorf(\"Expected 5 elements, got: %v\", result)\n\t}\n\n\t// k \u003e 0 and sufficient elements found\n\tinds = make([]int, 10)\n\tresult, err = Find(inds, func(f float64) bool { return f \u003e 5 }, []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 3)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t}\n\tif len(result) != 3 {\n\t\tt.Errorf(\"Expected 3 elements, got: %v\", result)\n\t}\n\n\t// k \u003e 0 and insufficient elements found\n\tinds = make([]int, 10)\n\tresult, err = Find(inds, func(f float64) bool { return f \u003e 5 }, []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 6)\n\tif !errors.Is(err, errors.New(\"floats: insufficient elements found\")) {\n\t\tt.Errorf(\"Expected error 'floats: insufficient elements found', got: %v\", err)\n\t}\n\tif len(result) != 5 {\n\t\tt.Errorf(\"Expected 5 elements, got: %v\", result)\n\t}\n\n\t// empty input slice\n\tinds = make([]int, 0)\n\tresult, err = Find(inds, func(f float64) bool { return f \u003e 5 }, []float64{}, 3)\n\tif !errors.Is(err, errors.New(\"floats: insufficient elements found\")) {\n\t\tt.Errorf(\"Expected error 'floats: insufficient elements found', got: %v\", err)\n\t}\n\tif len(result) != 0 {\n\t\tt.Errorf(\"Expected empty slice, got: %v\", result)\n\t}\n\n\t// nil input slice\n\tresult, err = Find(nil, func(f float64) bool { return f \u003e 5 }, nil, 3)\n\tif !errors.Is(err, errors.New(\"floats: insufficient elements found\")) {\n\t\tt.Errorf(\"Expected error 'floats: insufficient elements found', got: %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil slice, got: %v\", result)\n\t}\n}",
    "9e6b0f9dd9f49f75a5ba370e3a417163": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\ts3 := []float64{1, 2}\n\ts4 := []float64{}\n\n\t// Test cases for L = 2 (Euclidean distance)\n\tgot := Distance(s1, s2, 2)\n\twant := 8.0\n\tif got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = 1 (Manhattan distance)\n\tgot = Distance(s1, s2, 1)\n\twant = 16.0\n\tif got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = math.Inf(1) (Chebyshev distance)\n\tgot = Distance(s1, s2, math.Inf(1))\n\twant = 4.0\n\tif got != want {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for other values of L\n\tgot = Distance(s1, s2, 3)\n\twant = math.Pow(96, 1.0/3.0)\n\tif got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for empty slices\n\tgot = Distance(s4, s4, 2)\n\twant = 0.0\n\tif got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s4, s4, got, want)\n\t}\n\n\t// Test cases for slices with different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance(%v, %v, 2) did not panic\", s1, s3)\n\t\t}\n\t}()\n\tDistance(s1, s3, 2)\n}\n",
    "a016dbc2f0d6caf11e2cb0a3b863ab48": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant int\n\t}{\n\t\t{n: 2, l: 0, u: 2, v: -1, want: 0},\n\t\t{n: 2, l: 0, u: 2, v: 0, want: 0},\n\t\t{n: 2, l: 0, u: 2, v: 0.1, want: 0},\n\t\t{n: 2, l: 0, u: 2, v: 1, want: 0},\n\t\t{n: 2, l: 0, u: 2, v: 1.9, want: 1},\n\t\t{n: 2, l: 0, u: 2, v: 2, want: 1},\n\t\t{n: 2, l: 0, u: 2, v: 3, want: 1},\n\n\t\t{n: 3, l: 0, u: 2, v: -1, want: 0},\n\t\t{n: 3, l: 0, u: 2, v: 0, want: 0},\n\t\t{n: 3, l: 0, u: 2, v: 0.1, want: 0},\n\t\t{n: 3, l: 0, u: 2, v: 1, want: 1},\n\t\t{n: 3, l: 0, u: 2, v: 1.9, want: 2},\n\t\t{n: 3, l: 0, u: 2, v: 2, want: 2},\n\t\t{n: 3, l: 0, u: 2, v: 3, want: 2},\n\n\t\t{n: 2, l: 2, u: 0, v: -1, want: 1},\n\t\t{n: 2, l: 2, u: 0, v: 0, want: 1},\n\t\t{n: 2, l: 2, u: 0, v: 0.1, want: 1},\n\t\t{n: 2, l: 2, u: 0, v: 1, want: 1},\n\t\t{n: 2, l: 2, u: 0, v: 1.9, want: 0},\n\t\t{n: 2, l: 2, u: 0, v: 2, want: 0},\n\t\t{n: 2, l: 2, u: 0, v: 3, want: 0},\n\n\t\t{n: 3, l: 2, u: 0, v: -1, want: 2},\n\t\t{n: 3, l: 2, u: 0, v: 0, want: 2},\n\t\t{n: 3, l: 2, u: 0, v: 0.1, want: 2},\n\t\t{n: 3, l: 2, u: 0, v: 1, want: 1},\n\t\t{n: 3, l: 2, u: 0, v: 1.9, want: 0},\n\t\t{n: 3, l: 2, u: 0, v: 2, want: 0},\n\t\t{n: 3, l: 2, u: 0, v: 3, want: 0},\n\n\t\t{n: 100, l: -1, u: 1, v: -1.1, want: 0},\n\t\t{n: 100, l: -1, u: 1, v: -1, want: 0},\n\t\t{n: 100, l: -1, u: 1, v: 0, want: 49},\n\t\t{n: 100, l: -1, u: 1, v: 1, want: 99},\n\t\t{n: 100, l: -1, u: 1, v: 1.1, want: 99},\n\n\t\t{n: 10, l: -10, u: -10, v: 0, want: 0},\n\t} {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Case %d mismatch. Want %v, got %v.\", i, test.want, got)\n\t\t}\n\t}\n\n\t// Test the equivalence to Nearest(Span()).\n\trnd := testlapack.NewRand()\n\tfor i := 0; i \u003c 100; i++ {\n\t\tn := rnd.Intn(100) + 2\n\t\tl := rnd.NormFloat64()\n\t\tu := rnd.NormFloat64()\n\t\ts := make([]float64, n)\n\t\tSpan(s, l, u)\n\t\tfor j := 0; j \u003c 50; j++ {\n\t\t\tv := rnd.NormFloat64()\n\t\t\twant := NearestIdx(s, v)\n\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"Case %d:%d mismatch. Want %v, got %v.\", i, j, want, got)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panics.\n\tfor _, n := range []int{0, 1, -1} {\n\t\tpanics(t, \"n \u003c 2 did not panic\", func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t}\n}\n\nfunc panics(t *testing.T, msg string, fn func()) {\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(msg)\n\t\t}\n\t}()\n\tfn()\n}",
    "a27f6a53f7ef837c6a2016083242e078": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n}\n\nfunc TestSpan_Simple(t *testing.T) {\n\ttol := 1e-14\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, 1)\n\texpect := []float64{0, 0.25, 0.5, 0.75, 1}\n\tfor i := range dst {\n\t\tif math.Abs(dst[i]-expect[i]) \u003e tol {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expect, dst)\n\t\t\tbreak\n\t\t}\n\t}\n}\nfunc TestSpan_Inf(t *testing.T) {\n\ttol := 1e-14\n\tdst := make([]float64, 5)\n\tSpan(dst, math.Inf(1), 1)\n\texpect := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\tfor i := range dst {\n\t\tif math.Abs(dst[i]-expect[i]) \u003e tol {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expect, dst)\n\t\t\tbreak\n\t\t}\n\t}\n\tSpan(dst, 0, math.Inf(1))\n\texpect = []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tfor i := range dst {\n\t\tif math.Abs(dst[i]-expect[i]) \u003e tol {\n\t\t\tt.Errorf(\"Expected %v, got %v\", expect, dst)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t// For this case, we just test to make sure the boundaries\n\t// are correct.\n\tif dst[0] != math.Inf(-1) {\n\t\tt.Errorf(\"Expected %v, got %v\", math.Inf(-1), dst[0])\n\t}\n\tif dst[len(dst)-1] != math.Inf(1) {\n\t\tt.Errorf(\"Expected %v, got %v\", math.Inf(1), dst[len(dst)-1])\n\t}\n\n}\nfunc TestSpan_NaN(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, math.NaN(), 1)\n\tfor i := range dst[:len(dst)-1] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 1 {\n\t\tt.Errorf(\"Expected %v, got %v\", 1, dst[len(dst)-1])\n\t}\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected %v, got %v\", 0, dst[0])\n\t}\n\tfor i := range dst[1:] {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t}\n\t}\n}\n",
    "a2bf07ba250a0365f9ac0b0f63d41c94": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\tt1 := []float64{5, 6, 7, 8}\n\ts2 := []float64{1, -2, 3, -4}\n\tt2 := []float64{-5, 6, -7, 8}\n\ts3 := []float64{1, 2}\n\tt3 := []float64{2, 1}\n\ts4 := []float64{1, 1, 1, 1}\n\tt4 := []float64{2, 2, 2, 2}\n\n\ttol := 1e-14\n\n\tif !panics(func() { Distance(s1, []float64{1}, 2) }) {\n\t\tt.Errorf(\"Did not panic with unequal lengths\")\n\t}\n\tif !panics(func() { Distance([]float64{1}, s1, 2) }) {\n\t\tt.Errorf(\"Did not panic with unequal lengths\")\n\t}\n\n\tif math.Abs(Distance(s1, t1, 1)-16) \u003e tol {\n\t\tt.Errorf(\"L1 distance computed incorrectly\")\n\t}\n\tif math.Abs(Distance(s2, t2, 1)-22) \u003e tol {\n\t\tt.Errorf(\"L1 distance computed incorrectly\")\n\t}\n\tif math.Abs(Distance(s1, t1, 2)-8) \u003e tol {\n\t\tt.Errorf(\"L2 distance computed incorrectly\")\n\t}\n\tif math.Abs(Distance(s2, t2, 2)-math.Pow(218, 0.5)) \u003e tol {\n\t\tt.Errorf(\"L2 distance computed incorrectly\")\n\t}\n\tif math.Abs(Distance(s3, t3, math.Inf(1))-1) \u003e tol {\n\t\tt.Errorf(\"L-inf distance computed incorrectly\")\n\t}\n\tif math.Abs(Distance(s1, t1, math.Inf(1))-4) \u003e tol {\n\t\tt.Errorf(\"L-inf distance computed incorrectly\")\n\t}\n\tif math.Abs(Distance(s4, t4, 0.5)-4) \u003e tol {\n\t\tt.Errorf(\"L0.5 distance computed incorrectly\")\n\t}\n\n}\n\nfunc panics(f func()) (b bool) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tb = true\n\t\t}\n\t}()\n\tf()\n\treturn\n}",
    "a3fe2ed40acd3b91aacc802c7c7b7333": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twantIdx  int\n\t\twantDist float64\n\t}{\n\t\t{[]float64{10, 20, 30, 40, 50}, 25, 1, 5},\n\t\t{[]float64{10, 20, 30, 40, 50}, 100, 4, 50},\n\t\t{[]float64{10, 20, 30, 40, 50}, -100, 0, 110},\n\t\t{[]float64{10, 20, 30, 40, 50}, 20, 1, 0},\n\t\t{[]float64{10, 20, 30, 40, 50}, math.NaN(), 0, math.NaN()},\n\t\t{[]float64{10, 20, 30, 40, 50}, math.Inf(1), 4, math.Inf(1)},\n\t\t{[]float64{10, 20, 30, 40, 50}, math.Inf(-1), 0, math.Inf(1)},\n\t} {\n\t\thaveIdx := NearestIdx(test.s, test.v)\n\t\thaveDist := test.s[haveIdx] - test.v\n\t\tif haveIdx != test.wantIdx || math.Abs(haveDist-test.wantDist) \u003e tol {\n\t\t\tt.Errorf(\"Test %d failed: for s = %v and v = %v, got index %d (value %v), want index %d (value %v)\",\n\t\t\t\ti, test.s, test.v, haveIdx, test.s[haveIdx], test.wantIdx, test.s[test.wantIdx])\n\t\t}\n\t}\n}",
    "a41f57f74af72aeefcd635aa831db8f0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{[]float64{}, 0}, -1},\n\t\t{\"one\", args{[]float64{1}, 0}, -1},\n\t\t{\"two\", args{[]float64{1, 2}, 1.5}, 0},\n\t\t{\"ltAll\", args{[]float64{1, 2, 3}, 0.5}, -1},\n\t\t{\"gtAll\", args{[]float64{1, 2, 3}, 3.5}, -1},\n\t\t{\"eqMin\", args{[]float64{1, 2, 3}, 1}, 0},\n\t\t{\"eqMax\", args{[]float64{1, 2, 3}, 3}, -1},\n\t\t{\"NaN\", args{[]float64{1, 2, 3}, math.NaN()}, -1},\n\t\t{\"many\", args{[]float64{-3, -2, -1, 0, 1, 2, 3}, 1.5}, 4},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want != -1 {\n\t\t\t\t\t\tt.Errorf(\"Within() panicked for valid input\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a47dd1cdc3dc83bbdb439193cd64f607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n is the length of the hypothetical vector\n\t// l is the lower bound of the hypothetical vector\n\t// u is the upper bound of the hypothetical vector\n\t// v is the value to find the nearest index for\n\n\t// Test cases with n = 10, l = 0, u = 10\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 0, 10, math.NaN(), 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases with n = 5, l = -5, u = 5\n\ttestCases = []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{5, -5, 5, 0, 2},\n\t\t{5, -5, 5, -6, 0},\n\t\t{5, -5, 5, 6, 4},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "a497dd8b46bc2c813c600319f2b295de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-12\n\ts := []float64{1, 2, 3, 4, 5, 6}\n\t// Test cases for values within the slice\n\tfor i := 0; i \u003c len(s)-1; i++ {\n\t\tv := (s[i] + s[i+1]) / 2\n\t\twant := i\n\t\thave := Within(s, v)\n\t\tif have != want {\n\t\t\tt.Errorf(\"Within(s, %v) = %v, want %v\", v, have, want)\n\t\t}\n\t}\n\t// Test cases for edge cases\n\ttestCases := []struct {\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{0.5, -1},\n\t\t{1, 0},\n\t\t{1.1, 0},\n\t\t{5.9, 4},\n\t\t{6, -1},\n\t\t{6.5, -1},\n\t\t{math.NaN(), -1},\n\t}\n\tfor _, tc := range testCases {\n\t\thave := Within(s, tc.v)\n\t\tif have != tc.want {\n\t\t\tt.Errorf(\"Within(s, %v) = %v, want %v\", tc.v, have, tc.want)\n\t\t}\n\t}\n}",
    "a4b60974e46bfdf6e006c7d82aaa379c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test case where n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n\t// Test cases where v is NaN\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.NaN(), 1, 0.5, 9},\n\t\t{10, 0, math.NaN(), 0.5, 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases where l and u are both Inf\n\ttestCases = []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{11, math.Inf(1), math.Inf(1), 0.5, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), 0.5, 5},\n\t\t{11, math.Inf(1), math.Inf(-1), 0.5, 5},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{10, math.Inf(1), math.Inf(-1), math.Inf(-1), 9},\n\t\t{11, math.Inf(1), math.Inf(-1), math.Inf(-1), 10},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases where l or u is Inf\n\ttestCases = []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, math.Inf(1), 0, 0.5, 9},\n\t\t{10, math.Inf(1), 0, math.Inf(1), 0},\n\t\t{10, 0, math.Inf(1), 0.5, 0},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{10, 1, 10, math.Inf(-1), 0},\n\t\t{10, 10, 1, math.Inf(-1), 9},\n\t\t{10, 1, 10, math.Inf(1), 9},\n\t\t{10, 10, 1, math.Inf(1), 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases where v is outside (l, u) or (u, l)\n\ttestCases = []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 1, 0, 2, 0},\n\t\t{10, 1, 0, -1, 9},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases where v is inside (l, u) or (u, l)\n\ttestCases = []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 1, 0, 0.5, 4},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases from the original test function\n\ttestCases = []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 10, 9},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, 4.9, 4},\n\t\t{10, 0, 10, 5.1, 5},\n\t\t{11, 0, 10, -1, 0},\n\t\t{11, 0, 10, 10, 10},\n\t\t{11, 0, 10, 5, 5},\n\t\t{11, 0, 10, 4.9, 5},\n\t\t{11, 0, 10, 5.1, 6},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 10, 0},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, 4.9, 6},\n\t\t{10, 10, 0, 5.1, 5},\n\t\t{11, 10, 0, -1, 10},\n\t\t{11, 10, 0, 10, 0},\n\t\t{11, 10, 0, 5, 5},\n\t\t{11, 10, 0, 4.9, 5},\n\t\t{11, 10, 0, 5.1, 6},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "a4d1d307540cd4a4d2ac0b2fb9d31721": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases: empty slice, L=1, L=2, L=inf, L=other\n\ttests := []struct {\n\t\ts []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{1, 2, 3}, 1, 6},\n\t\t{[]float64{1, 2, 3}, 2, math.Sqrt(14)},\n\t\t{[]float64{1, 2, 3, 4, -5}, math.Inf(1), 5},\n\t\t{[]float64{1, 2, 3, 4}, 3, math.Pow(100, 1.0/3.0)},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := Norm(test.s, test.L)\n\t\tif math.Abs(got - test.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Test %d: got %.16f, want %.16f\", i, got, test.want)\n\t\t}\n\t}\n}\n",
    "a521218401b9b8dba09f0819080b73d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, math.Sqrt(27)},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, math.Pow(30, 1.0/3)},\n\t}{\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbs(got, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n}",
    "a54d54664865f2c31b2989b19aa1f707": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (panics)\n\t// - Slice with one element (panics)\n\t// - Slice with two elements\n\t// - Slice with odd number of elements\n\t// - Slice with even number of elements\n\t// - l \u003e u\n\t// - l == u\n\t// - l and u are NaN\n\t// - l is NaN, u is not\n\t// - u is NaN, l is not\n\t// - l and u are Inf\n\t// - l is Inf, u is not\n\t// - u is Inf, l is not\n\n\t// Empty slice\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tif dst[i] != expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "a5e41a7195939f58c03fbd26820a8ba7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"Empty slice\", args{[]float64{}, 0}, 0},\n\t\t{\"Single element slice\", args{[]float64{1}, 0}, 0},\n\t\t{\"Two element slice, v is closer to the first\", args{[]float64{1, 2}, 0}, 0},\n\t\t{\"Two element slice, v is closer to the second\", args{[]float64{1, 2}, 1.5}, 1},\n\t\t{\"Multiple element slice\", args{[]float64{1, 2, 3, 4, 5}, 3.2}, 2},\n\t\t{\"Multiple element slice, v is negative\", args{[]float64{1, 2, 3, 4, 5}, -1}, 0},\n\t\t{\"Multiple element slice, v is larger than all elements\", args{[]float64{1, 2, 3, 4, 5}, 6}, 4},\n\t\t{\"Multiple element slice, v is NaN\", args{[]float64{1, 2, 3, 4, 5}, math.NaN()}, 0},\n\t\t{\"Multiple element slice, one element is NaN\", args{[]float64{1, 2, math.NaN(), 4, 5}, 3}, 1},\n\t\t{\"Multiple element slice, v is Inf(1)\", args{[]float64{1, 2, 3, 4, 5}, math.Inf(1)}, 4},\n\t\t{\"Multiple element slice, v is Inf(-1)\", args{[]float64{1, 2, 3, 4, 5}, math.Inf(-1)}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"Empty slice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a69b30c54f2b14f26c3f18c8767573b0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor i, c := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\te float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 2, 0},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, 1, 0},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, 2, 3.7416573867739413},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, 1, 6},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, math.Inf(1), 3},\n\t\t{[]float64{-1, -2, -3}, []float64{1, 2, 3}, 2, 7.483314773547883},\n\t\t{[]float64{-1, -2, -3}, []float64{1, 2, 3}, 1, 12},\n\t\t{[]float64{-1, -2, -3}, []float64{1, 2, 3}, math.Inf(1), 6},\n\t} {\n\t\tvar got float64\n\t\tif c.L == 2 {\n\t\t\tgot = Distance(c.s, c.t, 2)\n\t\t} else {\n\t\t\tgot = Distance(c.s, c.t, c.L)\n\t\t}\n\t\tif !panics(func() { Distance(c.s, c.t, c.L) }) {\n\t\t\tt.Errorf(\"Did not panic for case %d\", i)\n\t\t}\n\t\tif math.Abs(got-c.e) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Failed on case %d: Expected %v, got %v\", i, c.e, got)\n\t\t}\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\ts := make([]float64, 10)\n\tt := make([]float64, 5)\n\tfor i := range s {\n\t\ts[i] = rand.Float64()\n\t}\n\tfor i := range t {\n\t\tt[i] = rand.Float64()\n\t}\n\tif !panics(func() { Distance(s, t, 2) }) {\n\t\tt.Errorf(\"Did not panic for different length slices\")\n\t}\n}\n\nfunc panics(f func()) (b bool) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tb = true\n\t\t}\n\t}()\n\tf()\n\treturn\n}\n",
    "a7d15f2cc559aa317134a3b5cf5abf3b": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestSub(t *testing.T) {\n\tfor i := 0; i \u003c 10; i++ {\n\t\tn := rand.Intn(100) + 1\n\t\tdst := make([]float64, n)\n\t\ts := make([]float64, n)\n\t\tfor j := 0; j \u003c n; j++ {\n\t\t\tdst[j] = rand.Float64()\n\t\t\ts[j] = rand.Float64()\n\t\t}\n\t\t// Copy dst to compare after the function call.\n\t\texpect := make([]float64, n)\n\t\tcopy(expect, dst)\n\t\tSub(dst, s)\n\t\tfor j := 0; j \u003c n; j++ {\n\t\t\tif dst[j] != expect[j]-s[j] {\n\t\t\t\tt.Errorf(\"Sub(%v, %v) = %v, want %v\", expect, s, dst, expect)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// Test panics for mismatched lengths.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tSub([]float64{1, 2, 3}, []float64{1, 2})\n}",
    "a9d4441a857e403200ecd0cceab9906d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases: slice length, lower bound, upper bound, expected slice\n\ttestCases := []struct {\n\t\tlenDst int\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t}{\n\t\t{2, 0, 1, []float64{0, 1}},                                // Simple case\n\t\t{5, 0, 10, []float64{0, 2.5, 5, 7.5, 10}},                 // More elements\n\t\t{3, -5, 5, []float64{-5, 0, 5}},                           // Negative bounds\n\t\t{4, 1, 1, []float64{1, 1, 1, 1}},                           // Equal bounds\n\t\t{3, math.Inf(-1), math.Inf(1), []float64{0, 0, 0}},        // Both bounds Inf\n\t\t{3, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1)}}, // Upper bound Inf\n\t\t{3, math.Inf(-1), 0, []float64{math.Inf(-1), math.Inf(-1), 0}}, // Lower bound Inf\n\t\t{3, math.NaN(), 0, []float64{math.NaN(), math.NaN(), 0}},       // Lower bound NaN\n\t\t{3, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},       // Upper bound NaN\n\t}\n\n\tfor i, tc := range testCases {\n\t\tdst := make([]float64, tc.lenDst)\n\t\tgot := Span(dst, tc.l, tc.u)\n\n\t\t// Check if the returned slice is the same as the input slice\n\t\tif got != dst {\n\t\t\tt.Errorf(\"Test case %d: returned slice is not the same as the input slice\", i+1)\n\t\t}\n\n\t\t// Check if the generated slice has the correct values\n\t\tfor j := range tc.want {\n\t\t\tif tc.want[j] == math.NaN() {\n\t\t\t\tif !math.IsNaN(got[j]) {\n\t\t\t\t\tt.Errorf(\"Test case %d: element %d should be NaN, got %v\", i+1, j, got[j])\n\t\t\t\t}\n\t\t\t} else if got[j] != tc.want[j] {\n\t\t\t\tt.Errorf(\"Test case %d: element %d mismatch: want %v, got %v\", i+1, j, tc.want[j], got[j])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case: panics when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n}",
    "aaf32cd17c4604ddafa4458bb47ea3c4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that a length 1 span panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n\n\t// Test a few simple cases.\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t} {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tif !Equal(got, test.want) {\n\t\t\tt.Errorf(\"Test %d - Span(dst, %v, %v) = %v, want %v\", i, test.l, test.u, got, test.want)\n\t\t}\n\t}\n\n\t// Test that Span handles infinities correctly.\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), math.Inf(-1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(-1), []float64{math.Inf(1), 0, math.Inf(-1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t} {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tif !Equal(got, test.want) {\n\t\t\tt.Errorf(\"Test %d - Span(dst, %v, %v) = %v, want %v\", i, test.l, test.u, got, test.want)\n\t\t}\n\t}\n\n\t// Test that Span handles NaNs correctly\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, math.NaN(), 0, []float64{math.NaN(), 0}},\n\t\t{[]float64{0, 0}, 0, math.NaN(), []float64{0, math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 0, []float64{math.NaN(), math.NaN(), 0}},\n\t\t{[]float64{0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t} {\n\t\tgot := Span(test.dst, test.l, test.u)\n\t\tnanCountGot, nanCountWant := 0, 0\n\t\tfor j := range got {\n\t\t\tif math.IsNaN(got[j]) {\n\t\t\t\tnanCountGot++\n\t\t\t}\n\t\t}\n\t\tfor j := range test.want {\n\t\t\tif math.IsNaN(test.want[j]) {\n\t\t\t\tnanCountWant++\n\t\t\t}\n\t\t}\n\t\tif nanCountGot != nanCountWant {\n\t\t\tt.Errorf(\"Test %d - Span(dst, %v, %v) = %v - has wrong number of NaNs\", i, test.l, test.u, got)\n\t\t}\n\t}\n}\n",
    "ab7dc606c0b084ab5d94a2ed91fc6c4b": "package floats\n\nimport \"testing\"\n\nfunc TestDivTo(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{1, 2, 3, 4}\n\tdst := make([]float64, len(s))\n\n\twant := []float64{1, 1, 1, 1}\n\n\tDivTo(dst, s, t)\n\tfor i := range dst {\n\t\tif dst[i] != want[i] {\n\t\t\tt.Errorf(\"Got %v, want %v\", dst, want)\n\t\t\tbreak\n\t\t}\n\t}\n}",
    "abb812288b8de738509d66c3ec95412e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\tv   float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.8, 2},\n\t\t{[]float64{1, 2, 3, 4, 5}, 10, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, -10, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 2.2, 1},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, math.NaN(), 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(-1), 0},\n\t} {\n\t\thave := NearestIdx(test.s, test.v)\n\t\tif test.want != have {\n\t\t\tt.Errorf(\"Case %d: Expected %v, got %v\", i, test.want, have)\n\t\t}\n\t}\n}",
    "adc5acf237e9d9e0b0eaa3cab7609c7a": "package floats\n\nimport \"testing\"\n\nfunc Test_argsort_Swap(t *testing.T) {\n\ttype fields struct {\n\t\ts    []float64\n\t\tinds []int\n\t}\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\targs   args\n\t}{\n\t\t{\n\t\t\tname: \"TestSwap_Case1\",\n\t\t\tfields: fields{\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tinds: []int{0, 1, 2, 3, 4},\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\ti: 1,\n\t\t\t\tj: 3,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSwap_Case2\",\n\t\t\tfields: fields{\n\t\t\t\ts:    []float64{5, 4, 3, 2, 1},\n\t\t\t\tinds: []int{4, 3, 2, 1, 0},\n\t\t\t},\n\t\t\targs: args{\n\t\t\t\ti: 0,\n\t\t\t\tj: 4,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ta := argsort{\n\t\t\t\ts:    tt.fields.s,\n\t\t\t\tinds: tt.fields.inds,\n\t\t\t}\n\t\t\ta.Swap(tt.args.i, tt.args.j)\n\t\t\tif a.inds[tt.args.i] != tt.args.j || a.inds[tt.args.j] != tt.args.i {\n\t\t\t\tt.Errorf(\"Swap() failed, want %v, got %v\", tt.args.j, a.inds[tt.args.i])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "af54b607219a486ffb62bfa2478b3568": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\tt.Parallel()\n\tfor i, tc := range []struct {\n\t\ta        [][]float64\n\t\texpected bool\n\t}{\n\t\t{[][]float64{}, true},\n\t\t{[][]float64{{}}, true},\n\t\t{[][]float64{{1}, {2}}, true},\n\t\t{[][]float64{{1, 2}, {2, 3}}, true},\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}}, true},\n\t\t{[][]float64{{1}, {2}, {3}}, true},\n\t\t{[][]float64{{1}, {}, {3}}, false},\n\t\t{[][]float64{{1, 2}, {3}}, false},\n\t\t{[][]float64{{1}, {2, 3}}, false},\n\t\t{[][]float64{{1, 2, 3}, {4, 5}}, false},\n\t\t{[][]float64{{1, 2}, {3, 4, 5}}, false},\n\t} {\n\t\tactual := EqualLengths(tc.a...)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Case %d fail, expected %v got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n}",
    "af91ec866fc2f872635e8cfdd90e66fa": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !Equal(s1, s2) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be true\", s1, s2)\n\t}\n\n\tif Equal(s1, s3) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s3)\n\t}\n\n\tif Equal(s1, s4) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s4)\n\t}\n}\n",
    "afb6691cc094d2b363d8525e14a19ac8": "",
    "afc5e1b592f391571a48959e2f9e490f": "package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"empty\", args{func(v float64) bool { return v \u003e 0 }, []float64{}}, 0},\n\t\t{\"all\", args{func(v float64) bool { return v \u003e 0 }, []float64{1, 2, 3}}, 3},\n\t\t{\"some\", args{func(v float64) bool { return v \u003e 1 }, []float64{1, 2, 3}}, 2},\n\t\t{\"none\", args{func(v float64) bool { return v \u003e 4 }, []float64{1, 2, 3}}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b023a706762e4bc46743e63893e9d4ca": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\texpected := []float64{4, 10, 18}\n\n\t// Test that the function returns the expected result\n\tassert.Equal(t, expected, MulTo(dst, s, t))\n\t\n\t// Test that the function panics when the lengths of the input slices do not match\n\tassert.Panics(t, func() { MulTo(dst, s, []float64{1, 2}) })\n\tassert.Panics(t, func() { MulTo(dst, []float64{1, 2}, t) })\n\tassert.Panics(t, func() { MulTo([]float64{1,2}, s, t) })\n}\n",
    "b057253b10925d31efe70b9b96fdeb78": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, -1, -1},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 0, -1},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 0.5, 0},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 1, 0},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 1.5, 1},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 2.5, 2},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 3.5, 3},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 4.5, 4},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 5, -1},\n\t\t{[]float64{0, 1, 2, 3, 4, 5}, 6, -1},\n\t\t{[]float64{0, 1, 2, math.NaN(), 4, 5}, 1.5, 1},\n\t\t{[]float64{0, 1, 2, math.NaN(), 4, 5}, math.NaN(), -1},\n\t} {\n\t\tif act := Within(test.s, test.v); act != test.expected {\n\t\t\tt.Errorf(\"Test %d: Expected %v but got %v\", i, test.expected, act)\n\t\t}\n\t}\n\n\t// test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1}, 0)\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{2, 1}, 0)\n}\n",
    "b0f9a3504d61dd97d7d30c129c71d603": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\tv   float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 0.0, 0},\n\t\t{[]float64{0, 1}, 1.0, -1},\n\t\t{[]float64{0, 1}, -1.0, -1},\n\t\t{[]float64{1, 2, 3, 4}, 0.5, -1},\n\t\t{[]float64{1, 2, 3, 4}, 1.5, 0},\n\t\t{[]float64{1, 2, 3, 4}, 3.5, 2},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, -0.75, 0},\n\t\t{[]float64{-1, -0.5, 0, 0.5, 1}, 0.0, 1},\n\t} {\n\t\thave := Within(test.s, test.v)\n\t\tif have != test.want {\n\t\t\tt.Errorf(\"Case %d: input array %v, val %v: Expected %v, got %v\", i, test.s, test.v, test.want, have)\n\t\t}\n\t}\n\t// NaN cases\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tv float64\n\t}{\n\t\t{[]float64{0, 1}, math.NaN()},\n\t\t{[]float64{-100, 0, 100}, math.NaN()},\n\t} {\n\t\thave := Within(test.s, test.v)\n\t\tif have != -1 {\n\t\t\tt.Errorf(\"Case %d: For input array %v and val %v: Expected -1, got %v\", i, test.s, test.v, have)\n\t\t}\n\t}\n\t// Panics\n\tfor i, test := range [][]float64{\n\t\t{0},\n\t\t{},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Case %d: input array %v: Expected panic, got none\", i, test)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tWithin(test, 0)\n\t\t}()\n\t}\n\tfor i, test := range [][]float64{\n\t\t{1, 0},\n\t\t{0, 0, 1, 2, 1},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Case %d: input array %v: Expected panic, got none\", i, test)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tWithin(test, 0)\n\t\t}()\n\t}\n\n}\n",
    "b1237c007a154e7551e96e4abef395ac": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}, 0.0}, 0},\n\t\t{\"NaN Value\", args{[]float64{1.0, 2.0, 3.0}, math.NaN()}, 0},\n\t\t{\"Positive Infinity Value\", args{[]float64{1.0, 2.0, 3.0}, math.Inf(1)}, 2},\n\t\t{\"Negative Infinity Value\", args{[]float64{1.0, 2.0, 3.0}, math.Inf(-1)}, 0},\n\t\t{\"Nearest Value\", args{[]float64{1.0, 2.0, 3.0}, 2.1}, 1},\n\t\t{\"Nearest Value, Multiple Occurrences\", args{[]float64{1.0, 2.0, 2.0, 3.0}, 2.1}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name != \"Empty Slice\" {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() panicked for non-empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b171a68a65a0482c47261417a55b4971": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.7, 3},\n\t\t{10, -1, 1, -0.9, 1},\n\t\t{10, -1, 1, 0.9, 9},\n\t\t{10, 1, -1, -0.9, 9},\n\t\t{10, 1, -1, 0.9, 1},\n\t\t{2, 0, 0, 1, 0},\n\t\t{3, 0, 0, 1, 0},\n\t\t{2, 1, 1, 1, 1},\n\t\t{3, 1, 1, 1, 1},\n\t\t{10, -math.Inf(1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(1), -math.Inf(1), 0, 5},\n\t\t{11, -math.Inf(1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(1), -math.Inf(1), 0, 5},\n\t\t{9, -math.Inf(1), math.Inf(1), 0, 4},\n\t\t{9, math.Inf(1), -math.Inf(1), 0, 4},\n\t\t{10, -math.Inf(1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), -math.Inf(1), math.Inf(1), 0},\n\t\t{10, -math.Inf(1), math.Inf(1), -math.Inf(1), 0},\n\t\t{10, math.Inf(1), -math.Inf(1), -math.Inf(1), 9},\n\t\t{10, math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t{10, -math.Inf(1), -math.Inf(1), -math.Inf(1), 1},\n\t\t{10, 0, math.Inf(1), math.NaN(), 0},\n\t\t{10, math.NaN(), 0, math.NaN(), 0},\n\t\t{10, math.NaN(), math.Inf(1), math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "b19603c719cd669e4b4e7417b1673a44": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\tfor _, c := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{0, 1, 2}, -1, -1},\n\t\t{[]float64{0, 1, 2}, 0, 0},\n\t\t{[]float64{0, 1, 2}, 0.5, 0},\n\t\t{[]float64{0, 1, 2}, 1, 1},\n\t\t{[]float64{0, 1, 2}, 1.5, 1},\n\t\t{[]float64{0, 1, 2}, 2, -1},\n\t\t{[]float64{0, 1, 2}, 3, -1},\n\t\t{[]float64{-1, 0, 1}, -2, -1},\n\t\t{[]float64{-1, 0, 1}, -1, 0},\n\t\t{[]float64{-1, 0, 1}, -0.5, 0},\n\t\t{[]float64{-1, 0, 1}, 0, 1},\n\t\t{[]float64{-1, 0, 1}, 0.5, 1},\n\t\t{[]float64{-1, 0, 1}, 1, -1},\n\t\t{[]float64{-1, 0, 1}, 2, -1},\n\t} {\n\t\t// Test cases when v is NaN\n\t\tif math.IsNaN(c.v) {\n\t\t\tgot := Within(c.s, c.v)\n\t\t\tif got != c.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", c.s, c.v, got, c.expected)\n\t\t\t}\n\t\t} else {\n\t\t\tgot := Within(c.s, c.v)\n\t\t\tif got != c.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", c.s, c.v, got, c.expected)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases when len(s) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{0}, 0)\n\n\t// Test cases when s is not sorted\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tWithin([]float64{1, 0}, 0)\n}\n",
    "b1c211d15e5b97db52c1164cf02ab259": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},                // v exactly in between l and u\n\t\t{3, 0, 1, 0.3, 1},                // v closer to l\n\t\t{3, 0, 1, 0.7, 2},                // v closer to u\n\t\t{10, 0, 1, 0.25, 2},               // v falls on a point\n\t\t{10, 0, 1, -1, 0},               // v less than l\n\t\t{10, 0, 1, 1.5, 9},               // v greater than u\n\t\t{10, -1, 1, -0.5, 5},              // negative span\n\t\t{10, -1, 1, 0, 5},               // v at zero in negative span\n\t\t{10, math.Inf(-1), 0, -1, 9},      // l = -Inf\n\t\t{10, 0, math.Inf(1), 1, 0},       // u = Inf\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5}, // l = -Inf, u = Inf\n\t\t{10, 0, 1, math.NaN(), 0},         // v = NaN\n\t\t{10, math.NaN(), 1, 0.5, 9},       // l = NaN\n\t\t{10, 0, math.NaN(), 0.5, 0},       // u = NaN\n\t\t{10, math.NaN(), math.NaN(), 0, 0}, // l = NaN, u = NaN\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics\n\tpanicCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 1, 0.5}, // n \u003c 2\n\t}\n\n\tfor i, tc := range panicCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) did not panic\", i, tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}\n",
    "b213bf54d996e0039fda47719746bfab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases: empty slice, single element, multiple elements.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{}, 0.0},\n\t\t{[]float64{1.0}, 1.0},\n\t\t{[]float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{[]float64{1e-16, 1.0, 1e-16}, 1.0}, // Test for improved accuracy\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "b24730c325c23f8e9cf5a440666a54cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSlice\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLeft\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNRight\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LeftInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"RightInf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !closeEnough(got[i], tc.want[i], 1e-14) {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) mismatch at index %v: got %v, want %v\\n\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t})\n\t}\n\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n\n}\n\nfunc closeEnough(a, b, tol float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c tol\n}\n",
    "b247c18384f0d8daf42cbf9e1815e8cd": "package floats\n\nimport \"testing\"\n\nfunc TestSumCompensated(t *testing.T) {\n\t// TODO: Add test cases.\n}",
    "b274b8c757536346f03da55ed0a60c98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various valid inputs\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 0.5, 0}, // Ties should go to lower index\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 2, 1},\n\n\t\t// n = 3\n\t\t{3, 0, 2, -1, 0},\n\t\t{3, 0, 2, 0, 0},\n\t\t{3, 0, 2, 1, 1},\n\t\t{3, 0, 2, 2, 2},\n\t\t{3, 0, 2, 3, 2},\n\n\t\t// n = 4\n\t\t{4, 0, 3, -1, 0},\n\t\t{4, 0, 3, 0, 0},\n\t\t{4, 0, 3, 1, 1},\n\t\t{4, 0, 3, 2, 2},\n\t\t{4, 0, 3, 3, 3},\n\t\t{4, 0, 3, 4, 3},\n\n\t\t// Other cases\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, -5, 0},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, 5, 9},\n\t\t{10, -5, 5, 6, 9},\n\t\t{5, 10, 0, -1, 4},\n\t\t{5, 10, 0, 0, 4},\n\t\t{5, 10, 0, 5, 2},\n\t\t{5, 10, 0, 10, 0},\n\t\t{5, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanNaNInf(t *testing.T) {\n\t// Test cases for NaN and Inf\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{10, math.NaN(), 5, 1, 9},\n\t\t{10, 5, math.NaN(), 1, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 1},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), 10, 9},\n\t\t{10, math.Inf(-1), 0, 10, 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 10, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 10, 0},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\t// Test case that should panic (n \u003c 2)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "b2b41c0984a6fc130569c29ce9ac8aed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking for invalid input length.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n\n}\n\nfunc TestSpanValidInput(t *testing.T) {\n\t// Test cases for valid input lengths.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 3\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    2,\n\t\t\twant: []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 4\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0,\n\t\t\tu:    3,\n\t\t\twant: []float64{0, 1, 2, 3},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanNaNInput(t *testing.T) {\n\t// Test cases when NaN is given as input for l and/or u.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaN for l\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN for u\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif math.IsNaN(got[i]) != math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanInfInput(t *testing.T) {\n\t// Test cases when Inf is given as input for l and/or u.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Inf for l\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    3,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 3},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf for u\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf for l and u, equal\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf for l and u, different signs\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsInf(got[i], 0) != math.IsInf(tc.want[i], 0) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b39b4e92d68ff04931e1f9c49dce0d52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\t// Test L = 1\n\texpected := 16.0\n\tactual := Distance(s, t, 1)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test L = 2\n\texpected = math.Sqrt(64)\n\tactual = Distance(s, t, 2)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test L = infinity\n\texpected = 4.0\n\tactual = Distance(s, t, math.Inf(1))\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test other L\n\texpected = math.Pow(math.Pow(4, 3)+math.Pow(4, 3)+math.Pow(4, 3)+math.Pow(4, 3), 1.0/3.0)\n\tactual = Distance(s, t, 3)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test empty slices\n\ts = []float64{}\n\tt = []float64{}\n\texpected = 0.0\n\tactual = Distance(s, t, 2)\n\tif actual != expected {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, expected %v\", s, t, actual, expected)\n\t}\n\n\t// Test panic on different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic with different length slices\")\n\t\t}\n\t}()\n\ts = []float64{1, 2, 3}\n\tt = []float64{1, 2}\n\tDistance(s, t, 2)\n}\n",
    "b40f3129f28d9f1eeaeb9805d894b2d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts := []float64{1, 2, 3, 4}\n\tt := []float64{5, 6, 7, 8}\n\n\ttests := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{s, t, 0, math.NaN()},\n\t\t{s, t, 1, 16,},\n\t\t{s, t, 2, f64.Distance(s, t),},\n\t\t{s, t, 3, math.Pow(96, 1./3),},\n\t\t{s, t, math.Inf(1), 4},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(test.want, got, 1e-14, 1e-14) \u0026\u0026 !(math.IsNaN(test.want) \u0026\u0026 math.IsNaN(got)) {\n\t\t\tt.Errorf(\"Case %d mismatch. Want %v, got %v\\n\", i, test.want, got)\n\t\t}\n\t}\n\n\t// panic conditions\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"Did not panic with mismatched lengths\")\n\t\t}\n\t}()\n\tDistance(s, []float64{1, 2, 3}, 2)\n}",
    "b453eeefaf291a83ffcb9e4516aac460": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// Regular cases\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 1, 1},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, 9, 9},\n\t\t{10, 0, 10, 10, 9},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Special cases for Inf and NaN\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 4},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\n\t\t{9, math.Inf(-1), math.Inf(1), 5, 4},\n\t\t{9, math.Inf(-1), math.Inf(1), math.Inf(1), 8},\n\t\t{9, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\n\t\t{10, math.Inf(-1), 10, 5, 9},\n\t\t{10, 0, math.Inf(1), 5, 0},\n\t\t{10, math.Inf(1), 0, 5, 9},\n\t\t{10, 0, math.Inf(-1), 5, 0},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t\t{10, 10, 0, math.Inf(-1), 8},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 10, 0, math.Inf(1), 9},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Case %d - NearestIdxForSpan mismatch. Got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n\n\t// Test panics\n\ttest.CheckPanic(t, \"NearestIdxForSpan with n \u003c 2\", func() {\n\t\tNearestIdxForSpan(1, 0, 1, 0)\n\t})\n}\n",
    "b4b092207079221ea52e0eecea53fb6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 2, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 2, 8},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 1, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 1, 16},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, math.Inf(1), 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, 3, 0},\n\t\t{[]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}, 3, math.Pow(128, 1.0/3.0)},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !f64.EqualWithinAbsOrRel(got, test.want, 1e-14, 1e-14) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 2)\n}",
    "b517facd54cabc2f4032e18bd4d107cd": "package floats\n\nimport \"testing\"\n\nfunc TestMul(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tdst      []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 4, 9}},\n\t\t{[]float64{1, -2, 3}, []float64{1, 2, 3}, []float64{1, -4, 9}},\n\t} {\n\t\tMul(test.dst, test.s)\n\t\tfor j := range test.dst {\n\t\t\tif !panics(func() { Mul(test.dst, test.s) }) {\n\t\t\t\tt.Errorf(\"Mul did not panic with unequal lengths\")\n\t\t\t}\n\t\t\tif test.dst[j] != test.expected[j] {\n\t\t\t\tt.Errorf(\"Test %d: Expected %v but got %v\", i, test.expected, test.dst)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc panics(f func()) (b bool) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tb = true\n\t\t}\n\t}()\n\tf()\n\treturn\n}",
    "b62580acc0fe992fad3b01981ef69e94": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\twant []float64\n\t}{\n\t\t{nil, nil, nil},\n\t\t{[]float64{1,2,3}, []float64{4,5,6}, []float64{5,7,9}},\n\t\t{[]float64{1,-2,3}, []float64{-4,5,-6}, []float64{-3,3,-3}},\n\t} {\n\t\t// allocate dst with the correct size\n\t\tdst := make([]float64, len(test.s))\n\t\tfor j := range dst {\n\t\t\tdst[j] = 0.0\n\t\t}\n\t\t// test the function\n\t\tgot := AddTo(dst, test.s, test.t)\n\t\t// ensure the lengths are correct\n\t\tif len(got) != len(test.want) {\n\t\t\tt.Errorf(\"Test %v: slice lengths mismatch, got %v want %v\", i, len(got), len(test.want))\n\t\t}\n\t\t// ensure the values are correct\n\t\tfor j := range got {\n\t\t\tif got[j] != test.want[j] {\n\t\t\t\tt.Errorf(\"Test %v: element %v mismatch, got %v want %v\", i, j, got[j], test.want[j])\n\t\t\t}\n\t\t}\n\t}\n}",
    "b62c0496f8758e4bda8819180b790391": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum/floats/floats64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 4, 6}\n\ts3 := []float64{0, 0}\n\ts4 := []float64{100, 100}\n\ts5 := []float64{-2, -6, -1, -4}\n\n\t// case for two non-empty slices with L = 2\n\tans := Distance(s1, s2, 2)\n\tif math.Abs(ans-3) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected 3, got %f\", ans)\n\t}\n\n\t// case for two non-empty slices with L = 1\n\tans = Distance(s1, s2, 1)\n\tif math.Abs(ans-5) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected 5, got %f\", ans)\n\t}\n\n\t// case for two non-empty slices with L = 3\n\tans = Distance(s1, s2, 3)\n\tif math.Abs(ans-math.Pow(29, 1.0/3.0)) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected %f, got %f\", math.Pow(29, 1.0/3.0), ans)\n\t}\n\n\t// case for two non-empty slices with L = Inf\n\tans = Distance(s1, s2, math.Inf(1))\n\tif math.Abs(ans-2) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected 2, got %f\", ans)\n\t}\n\n\t// case for two empty slices\n\tans = Distance(nil, nil, 2)\n\tif math.Abs(ans-0) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected 0, got %f\", ans)\n\t}\n\n\t// cases for both slices containing same values\n\tans = Distance(s3, s3, 2)\n\tif math.Abs(ans-0) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected 0, got %f\", ans)\n\t}\n\tans = Distance(s4, s4, 2)\n\tif math.Abs(ans-0) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected 0, got %f\", ans)\n\t}\n\n\t// cases for both slices containing completely opposite values\n\tans = Distance(s3, s4, 2)\n\tif math.Abs(ans-math.Sqrt(20000)) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected %f, got %f\", math.Sqrt(20000), ans)\n\t}\n\n\t// test case for s1 and s5 where values in s5 are negative of s1\n\tans = Distance(s1, s5, 2)\n\texpectedDistance := floats64.Distance(s1, s5, 2)\n\tif math.Abs(ans-expectedDistance) \u003e 1e-14 {\n\t\tt.Errorf(\"Expected %v, got %v\", expectedDistance, ans)\n\t}\n}\n",
    "b7f2edbdc613f82d19b5b99c215ff5f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that panicking behavior\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\t// Intentionally cause a panic\n\tSpan(make([]float64, 1), 0, 1)\n}\nfunc TestSpanFinite(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, 4)\n\tfor i := range dst {\n\t\tif dst[i] != float64(i) {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", float64(i), i, dst[i])\n\t\t}\n\t}\n\n\tSpan(dst, -1, 3)\n\ttruth := []float64{-1, -0.5, 0, 0.5, 1}\n\tfor i := range dst {\n\t\tif dst[i] != truth[i] {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", truth[i], i, dst[i])\n\t\t}\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, math.Inf(1))\n\ttruth := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\tfor i := range dst {\n\t\tif dst[i] != truth[i] {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", truth[i], i, dst[i])\n\t\t}\n\t}\n\n\tSpan(dst, math.Inf(-1), 4)\n\ttruth = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 4}\n\tfor i := range dst {\n\t\tif dst[i] != truth[i] {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", truth[i], i, dst[i])\n\t\t}\n\t}\n\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\ttruth = []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\tfor i := range dst {\n\t\tif dst[i] != truth[i] {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", truth[i], i, dst[i])\n\t\t}\n\t}\n\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := range dst {\n\t\tif dst[i] != math.Inf(1) {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", math.Inf(1), i, dst[i])\n\t\t}\n\t}\n\n}\nfunc TestSpanNaN(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, 0, math.NaN())\n\ttruth := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tfor i := range dst {\n\t\tif dst[i] != truth[i] {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", truth[i], i, dst[i])\n\t\t}\n\t}\n\n\tSpan(dst, math.NaN(), 4)\n\ttruth = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4}\n\tfor i := range dst {\n\t\tif dst[i] != truth[i] {\n\t\t\tt.Errorf(\"Expected %v at position %v, but got %v\", truth[i], i, dst[i])\n\t\t}\n\t}\n}\n",
    "b89f9f1089868798b9e02bcd5e68794b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tfor i, n := range []int{0, 1} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Test %d: did not panic with len(dst)=%d\", i, n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tSpan(make([]float64, n), 0, 1)\n\t\t}()\n\t}\n\n\t// dst = []float64{0, 0}\n\t// Span(dst, 0, 1) = []float64{0, 1}\n\t{\n\t\tdst := make([]float64, 2)\n\t\tgot := Span(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, 0, 1) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n\n\t// dst = []float64{0, 0, 0}\n\t// Span(dst, 0, 2) = []float64{0, 1, 2}\n\t{\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, 0, 2)\n\t\twant := []float64{0, 1, 2}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, 0, 2) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n\n\t// dst = make([]float64, 4)\n\t// Span(dst, -1, 1) = []float64{-1, -1/3, 1/3, 1}\n\t{\n\t\tdst := make([]float64, 4)\n\t\tgot := Span(dst, -1, 1)\n\t\twant := []float64{-1, -1.0 / 3, 1.0 / 3, 1}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, -1, 1) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n\n\t// Test cases for non-finite values.\n\t// dst = make([]float64, 3)\n\t// Span(dst, math.NaN(), 0) = []float64{NaN, NaN, 0}\n\t{\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, math.NaN(), 0)\n\t\twant := []float64{math.NaN(), math.NaN(), 0}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] \u0026\u0026 !(math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(want[i])) {\n\t\t\t\tt.Errorf(\"Span(dst, NaN, 0) returned dst[%d] = %v, want %v\", i, got[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// dst = make([]float64, 3)\n\t// Span(dst, 0, math.NaN()) = []float64{0, NaN, NaN}\n\t{\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, 0, math.NaN())\n\t\twant := []float64{0, math.NaN(), math.NaN()}\n\t\tfor i := range want {\n\t\t\tif got[i] != want[i] \u0026\u0026 !(math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(want[i])) {\n\t\t\t\tt.Errorf(\"Span(dst, 0, NaN) returned dst[%d] = %v, want %v\", i, got[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// dst = make([]float64, 3)\n\t// Span(dst, math.Inf(1), math.Inf(-1)) = []float64{+Inf, 0, -Inf}\n\t{\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, math.Inf(1), math.Inf(-1))\n\t\twant := []float64{math.Inf(1), 0, math.Inf(-1)}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, math.Inf(1), math.Inf(-1)) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n\n\t// dst = make([]float64, 4)\n\t// Span(dst, math.Inf(1), math.Inf(-1)) = []float64{+Inf, +Inf, -Inf, -Inf}\n\t{\n\t\tdst := make([]float64, 4)\n\t\tgot := Span(dst, math.Inf(1), math.Inf(-1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, math.Inf(1), math.Inf(-1)) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n\n\t// dst = make([]float64, 3)\n\t// Span(dst, math.Inf(1), 0) = []float64{+Inf, +Inf, 0}\n\t{\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, math.Inf(1), 0)\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, math.Inf(1), 0) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n\n\t// dst = make([]float64, 3)\n\t// Span(dst, 0, math.Inf(1)) = []float64{0, +Inf, +Inf}\n\t{\n\t\tdst := make([]float64, 3)\n\t\tgot := Span(dst, 0, math.Inf(1))\n\t\twant := []float64{0, math.Inf(1), math.Inf(1)}\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(dst, 0, math.Inf(1)) returned dst = %v, want %v\", got, want)\n\t\t}\n\t}\n}\n",
    "b8a05ba3a712e311a1d2e9009147f26b": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\t// Test cases:\n\t// edge cases: empty slice, slice with NaN\n\t// normal cases: value in the middle, value at the edge\n\t// special cases: value less than the first element, value greater than the last element, value is NaN\n\ttype testCase struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := Within(tc.s, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n}",
    "b90b25d30caac34e602553815fe2c041": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.0, 0.1, 0.01, 0.001, 0.0001}, 1.1111},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{-1, -2, -3, -4, -5}, -15},\n\t\t{[]float64{1, -1, 1, -1}, 0},\n\t\t{[]float64{}, 0},\n\t}\n\n\t// Iterate through test cases.\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result matches the expected value.\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v): expected %v, got %v\", tc.input, tc.expected, actual)\n\t\t}\n\t}\n}\n",
    "ba6c5492461668b1361d8b51e520bf52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various input lengths and ranges.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 3\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    0,\n\t\t\tu:    2,\n\t\t\twant: []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 5\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Length 10\",\n\t\t\tdst:  make([]float64, 10),\n\t\t\tl:    1,\n\t\t\tu:    10,\n\t\t\twant: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf values\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-1, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds Inf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound Inf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound Inf\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-1, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif i == len(got)-1 {\n\t\t\t\t\tif math.IsNaN(got[i]) != math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"NaN mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when dst length is less than 2\n\tt.Run(\"Panics for short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "bd09c4b3139e4799017cb559fa235589": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify panicking with short dst.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 1)\n\tt.Errorf(\"Span did not panic with short dst\")\n}\nfunc TestSpanInternal(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{[]float64{0, 0}, -10, 10, []float64{-10, 10}},\n\t\t{[]float64{0, 0, 0}, -10, 10, []float64{-10, 0, 10}},\n\t\t{[]float64{0, 0, 0, 0}, -10, 10, []float64{-10, -5, 0, 10}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -10, 10, []float64{-10, -5, 0, 5, 10}},\n\t\t{[]float64{0, 0}, -10, 5, []float64{-10, 5}},\n\t\t{[]float64{0, 0, 0}, -10, 5, []float64{-10, -2.5, 5}},\n\t\t{[]float64{0, 0, 0, 0}, -10, 5, []float64{-10, -3.75, -1.25, 5}},\n\t\t{[]float64{0, 0}, 1, math.Inf(1), []float64{1, math.Inf(1)}},\n\t\t{[]float64{0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1}},\n\t\t{[]float64{0, 0, 0}, 1, math.Inf(1), []float64{1, 1, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 1, math.Inf(1), []float64{1, 1, 1, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), 1, []float64{math.Inf(-1), 1, 1, 1}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 1, []float64{1, 1, 1, 1, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.NaN(), 1, []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, math.NaN(), []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()}},\n\t} {\n\t\tSpan(test.dst, test.l, test.u)\n\t\tfor j := range test.dst {\n\t\t\tif !EqualWithinAbsOrRel(test.dst[j], test.want[j], tol, tol) {\n\t\t\t\tt.Errorf(\"Test %d, subtest %d: got %v, want %v\", i, j, test.dst, test.want)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t}\n}\n",
    "bd0baf941d695935d5dc6dc476aff106": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, -1, 1, 0, 1},\n\t\t{5, -1, 1, -0.5, 1},\n\t\t{10, 0, 100, 50, 5},\n\t\t{10, 0, 100, -1, 0},  // v \u003c l\n\t\t{10, 0, 100, 101, 9}, // v \u003e u\n\t\t{2, 0, 0, 0, 0},      // l == u\n\t\t{2, 1, 0, 0.5, 0},     // l \u003e u\n\t\t{3, 1, 0, 0.5, 1},     // l \u003e u, n odd\n\t\t{100, -100, 100, math.NaN(), 0}, // NaN handling\n\t\t{100, math.NaN(), 100, 50, 99}, // NaN handling\n\t\t{100, -100, math.NaN(), 50, 0}, // NaN handling\n\t\t{100, math.Inf(-1), math.Inf(1), 0, 50}, // Inf handling\n\t\t{100, math.Inf(-1), math.Inf(1), 1, 51}, // Inf handling\n\t\t{100, 1, 10, math.Inf(-1), 0}, // Inf handling\n\t\t{100, 1, 10, math.Inf(1), 99}, // Inf handling\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\n\t\t// Calculate the expected value using Span for comparison\n\t\t// (only if no NaNs or Infs are involved).\n\t\tif !math.IsNaN(tc.l) \u0026\u0026 !math.IsNaN(tc.u) \u0026\u0026 !math.IsInf(tc.l, 0) \u0026\u0026 !math.IsInf(tc.u, 0) \u0026\u0026\n\t\t\t!math.IsNaN(tc.v) \u0026\u0026 !math.IsInf(tc.v, 0) {\n\t\t\ts := Span(make([]float64, tc.n), tc.l, tc.u)\n\t\t\twant := NearestIdx(s, tc.v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, want)\n\t\t\t}\n\t\t}\n\n\t\t// Check against the hardcoded expected value.\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases that caused panics before.\n\t// These should now be handled gracefully.\n\t//t.Logf(\"NearestIdxForSpan(2, 0, 0, 0) = %v\", NearestIdxForSpan(2, 0, 0, 0))\n\t//t.Logf(\"NearestIdxForSpan(2, 1, 0, 0.5) = %v\", NearestIdxForSpan(2, 1, 0, 0.5))\n\t//t.Logf(\"NearestIdxForSpan(3, 1, 0, 0.5) = %v\", NearestIdxForSpan(3, 1, 0, 0.5))\n\n\t// Test panic case for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}",
    "bdbac0eb9fce9bd1874ee7d0e7ca5d5a": "package floats\n\nimport \"testing\"\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\talpha      float64\n\t\ts         []float64\n\t\twant       []float64\n\t\tshouldPanic bool\n\t}{\n\t\t{\n\t\t\tname:       \"BasicTest\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\talpha:      2.0,\n\t\t\ts:         []float64{4, 5, 6},\n\t\t\twant:       []float64{9, 12, 15},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"ZeroAlpha\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\talpha:      0.0,\n\t\t\ts:         []float64{4, 5, 6},\n\t\t\twant:       []float64{1, 2, 3},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"NegativeAlpha\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\talpha:      -1.0,\n\t\t\ts:         []float64{4, 5, 6},\n\t\t\twant:       []float64{-3, -3, -3},\n\t\t\tshouldPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"DifferentLengths\",\n\t\t\tdst:        []float64{1, 2, 3},\n\t\t\talpha:      2.0,\n\t\t\ts:         []float64{4, 5},\n\t\t\twant:       nil,\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.shouldPanic \u0026\u0026 r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t\tif !tt.shouldPanic \u0026\u0026 r != nil {\n\t\t\t\t\tt.Errorf(\"The code panicked when it should not have\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAddScaled(tt.dst, tt.alpha, tt.s)\n\t\t\tfor i := range tt.dst {\n\t\t\t\tif tt.dst[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"got %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "bf076eed918d7c3223f67e7e25518cf2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ts1 := []float64{1, 2, 3, math.NaN()}\n\ts2 := []float64{1, 2, 3, math.NaN()}\n\ts3 := []float64{1, 2, 3, 4}\n\ts4 := []float64{1, 2, 3}\n\n\tif !Same(s1, s2) {\n\t\tt.Error(\"Expected Same to return true for slices with same elements\")\n\t}\n\n\tif Same(s1, s3) {\n\t\tt.Error(\"Expected Same to return false for slices with different elements\")\n\t}\n\n\tif Same(s1, s4) {\n\t\tt.Error(\"Expected Same to return false for slices with different lengths\")\n\t}\n}\n",
    "bfda35f3c18a5baeca503393dbab6526": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slice\n\t// 2. Slice with one element\n\t// 3. Slice with two elements\n\t// 4. Slice with odd number of elements\n\t// 5. Slice with even number of elements\n\t// 6. l \u003e u\n\t// 7. l = u\n\t// 8. l and u are NaN\n\t// 9. l is NaN, u is not\n\t// 10. u is NaN, l is not\n\t// 11. l and u are Inf\n\t// 12. l is Inf, u is not\n\t// 13. u is Inf, l is not\n\n\t// Test case 1: Empty slice\n\t{\n\t\tvar dst []float64\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 2: Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Test case 3: Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 4: Slice with odd number of elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 5: Slice with even number of elements\n\t{\n\t\tdst := make([]float64, 6)\n\t\tSpan(dst, 0, 1)\n\t\texpected := []float64{0, 0.2, 0.4, 0.6, 0.8, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 6: l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 7: l = u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\texpected := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 8: l and u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), math.NaN())\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsNaN(v) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 9: l is NaN, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsNaN(dst[i]) \u0026\u0026 math.IsNaN(expected[i])) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 10: u is NaN, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif !(math.IsNaN(dst[i]) \u0026\u0026 math.IsNaN(expected[i])) \u0026\u0026 dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 11: l and u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor _, v := range dst {\n\t\t\tif !math.IsInf(v, 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case 12: l is Inf, u is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1, got %v\", dst[len(dst)-1])\n\t\t}\n\t}\n\n\t// Test case 13: u is Inf, l is not\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i+1], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf, got %v\", dst[i+1])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "c0ec03dca8cd07a84c9284fb4860376c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{5, -5, 5, 0, 2},\n\t\t{5, -5, 5, -6, 0},\n\t\t{5, -5, 5, 6, 4},\n\t\t{11, 0, 10, 5.5, 5},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, -1, 0, -0.5, 5},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n=%v, l=%v, u=%v, v=%v, expected %v, but got %v\", tc.n, tc.l, tc.u, tc.v, tc.expected, actual)\n\t}\n\n\t// Test cases for NaN and Inf\n\tnanCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{10, 0, math.NaN(), 5, 0},\n\t\t{10, math.NaN(), 0, 5, 9},\n\t\t{10, math.NaN(), math.NaN(), 5, 0},\n\t\t{10, math.Inf(1), math.Inf(1), 5, -1},\n\t\t{10, math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t{10, math.Inf(-1), math.Inf(-1), 5, -1},\n\t\t{10, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{10, math.Inf(1), 5, math.Inf(1), 9},\n\t\t{10, math.Inf(-1), 5, math.Inf(-1), 0},\n\t\t{10, 5, math.Inf(1), math.Inf(1), 9},\n\t\t{10, 5, math.Inf(-1), math.Inf(-1), 0},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\t}\n\tfor _, tc := range nanCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n=%v, l=%v, u=%v, v=%v, expected %v, but got %v\", tc.n, tc.l, tc.u, tc.v, tc.expected, actual)\n\t}\n\n\t// Test cases when l == u\n\tluEqualCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\texpected int\n\t}{\n\t\t{10, 5, 5, 5, 0},\n\t\t{10, 5, 5, 4, 0},\n\t\t{10, 5, 5, 6, 0},\n\t}\n\tfor _, tc := range luEqualCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.expected, actual, \"For n=%v, l=%v, u=%v, v=%v, expected %v, but got %v\", tc.n, tc.l, tc.u, tc.v, tc.expected, actual)\n\t}\n}\n",
    "c0edc28b0bb8ad039cd83dc2899be0c1": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\t// Test cases:\n\t// 1. Empty slices\n\t// 2. Slices of length 1\n\t// 3. Slices of length \u003e 1\n\t// 4. Slices with different lengths (should panic)\n\t// 5. Slices with different dst length (should panic)\n\n\t// Test case 1: Empty slices\n\ts1 := []float64{}\n\tt1 := []float64{}\n\tdst1 := make([]float64, 0)\n\tMulTo(dst1, s1, t1)\n\tif len(dst1) != 0 {\n\t\tt.Errorf(\"MulTo() failed for empty slices, expected empty slice but got %v\", dst1)\n\t}\n\n\t// Test case 2: Slices of length 1\n\ts2 := []float64{2.0}\n\tt2 := []float64{3.0}\n\tdst2 := make([]float64, 1)\n\tMulTo(dst2, s2, t2)\n\tif len(dst2) != 1 || dst2[0] != 6.0 {\n\t\tt.Errorf(\"MulTo() failed for slices with length 1, expected {6.0} but got %v\", dst2)\n\t}\n\n\t// Test case 3: Slices of length \u003e 1\n\ts3 := []float64{1.0, 2.0, 3.0}\n\tt3 := []float64{4.0, 5.0, 6.0}\n\tdst3 := make([]float64, 3)\n\tMulTo(dst3, s3, t3)\n\texpected3 := []float64{4.0, 10.0, 18.0}\n\tfor i := range dst3 {\n\t\tif dst3[i] != expected3[i] {\n\t\t\tt.Errorf(\"MulTo() failed for slices with length \u003e 1, expected %v but got %v\", expected3, dst3)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 4: Slices with different lengths (should panic)\n\ts4 := []float64{1.0, 2.0, 3.0}\n\tt4 := []float64{4.0, 5.0}\n\tdst4 := make([]float64, 3)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MulTo() did not panic for slices with different lengths\")\n\t\t}\n\t}()\n\tMulTo(dst4, s4, t4)\n\n\t// Test case 5: Slices with different dst length (should panic)\n\ts5 := []float64{1.0, 2.0, 3.0}\n\tt5 := []float64{4.0, 5.0, 6.0}\n\tdst5 := make([]float64, 2)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MulTo() did not panic for slices with different dst length\")\n\t\t}\n\t}()\n\tMulTo(dst5, s5, t5)\n}",
    "c219c9759b2b913ab17a36a30c8a5282": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    [][]float64\n\t\texpected bool\n\t}{\n\t\t{nil, true},                           // No slices\n\t\t{[][]float64{{1, 2, 3}}, true},         // Single slice\n\t\t{[][]float64{{1, 2}, {3, 4}}, true},    // Equal lengths\n\t\t{[][]float64{{1, 2, 3}, {4, 5}}, false}, // Unequal lengths\n\t\t{[][]float64{{}, {}}, true},           // Empty slices, equal lengths\n\t\t{[][]float64{{1}, {}, {2}}, false},     // Mixed lengths\n\t}\n\n\t// Run test cases\n\tfor i, tc := range testCases {\n\t\tactual := EqualLengths(tc.input...)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: input=%v, expected=%v, actual=%v\",\n\t\t\t\ti, tc.input, tc.expected, actual)\n\t\t}\n\t}\n}",
    "c245931e3d9384bd8814b85c1d7c28c5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - NaN values in slice\n\t// - NaN value as target\n\t// - Infinite values in slice and as target\n\t// - Normal cases with single and multiple nearest values\n\t// - Negative values\n\t// - Zero values\n\n\tt.Run(\"EmptySlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tNearestIdx([]float64{}, 0)\n\t})\n\n\tt.Run(\"NaNValuesInSlice\", func(t *testing.T) {\n\t\ts := []float64{1, 2, math.NaN(), 4, 5}\n\t\tv := 3.0\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 1 {\n\t\t\tt.Errorf(\"Expected index 1, but got %v\", ind)\n\t\t}\n\t})\n\n\tt.Run(\"NaNTarget\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tv := math.NaN()\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 0 {\n\t\t\tt.Errorf(\"Expected index 0, but got %v\", ind)\n\t\t}\n\t})\n\n\tt.Run(\"InfiniteValues\", func(t *testing.T) {\n\t\ts := []float64{1, 2, math.Inf(1), 4, math.Inf(-1)}\n\t\tv := math.Inf(1)\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 2 {\n\t\t\tt.Errorf(\"Expected index 2, but got %v\", ind)\n\t\t}\n\t})\n\n\tt.Run(\"NormalCaseSingleNearest\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tv := 2.2\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 1 {\n\t\t\tt.Errorf(\"Expected index 1, but got %v\", ind)\n\t\t}\n\t})\n\n\tt.Run(\"NormalCaseMultipleNearest\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3, 4, 5}\n\t\tv := 2.5\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 1 {\n\t\t\tt.Errorf(\"Expected index 1, but got %v\", ind)\n\t\t}\n\t})\n\n\tt.Run(\"NegativeValues\", func(t *testing.T) {\n\t\ts := []float64{-5, -4, -3, -2, -1}\n\t\tv := -2.2\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 3 {\n\t\t\tt.Errorf(\"Expected index 3, but got %v\", ind)\n\t\t}\n\t})\n\n\tt.Run(\"ZeroValues\", func(t *testing.T) {\n\t\ts := []float64{-2, -1, 0, 1, 2}\n\t\tv := 0.3\n\t\tind := NearestIdx(s, v)\n\t\tif ind != 2 {\n\t\t\tt.Errorf(\"Expected index 2, but got %v\", ind)\n\t\t}\n\t})\n}",
    "c319c9163393d0f1a232cc36990f80f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various input values.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"InfL\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfU\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNTestL\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNTestU\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -3,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-3, math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tc.name == \"ZeroLength\" {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif len(got) != len(tc.want) {\n\t\t\t\t\tt.Errorf(\"Got %v, want %v\", got, tc.want)\n\t\t\t\t}\n\n\t\t\t\tfor i := range got {\n\t\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\t\tt.Errorf(\"Got %v, want %v\", got, tc.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\t\tt.Errorf(\"Got %v, want %v\", got, tc.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// Call the function being tested.\n\t\t\t_ = Span(tc.dst, tc.l, tc.u)\n\t\t})\n\t}\n}\n",
    "c36fad062905512cad6644b00bea6fb9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn          int\n\t\tl, u, v    float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 1},\n\t\t{4, 0, 1, 0.25, 0},\n\t\t{4, 0, 1, 0.75, 2},\n\n\t\t// Cases with NaN and Inf\n\t\t{2, math.NaN(), 1, 0.5, 0},\n\t\t{2, 0, math.NaN(), 0.5, 1},\n\t\t{2, math.Inf(1), 1, 0.5, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), 1, 0.5, 1},\n\t\t{2, 0, math.Inf(-1), 0.5, 0},\n\n\t\t// v outside (l, u)\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 1, 0, -1, 2},\n\t\t{3, 1, 0, 2, 0},\n\n\t\t// Special cases for halfway points\n\t\t{3, 0, 1, 0.5, 0},\n\t\t{4, 0, 1, 0.5, 1},\n\n\t\t// Cases with large n\n\t\t{1000, 0, 1, 0.25, 249},\n\t\t{1000, 0, 1, 0.75, 749},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Case %d failed: n=%d, l=%v, u=%v, v=%v. Expected index %d, but got %d\",\n\t\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "c424d8a35f7c8b05e45733b34ada50f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - math.IsNaN(v)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0)\n\t//   - l == u\n\t//   - n%2 == 1\n\t//     - !math.IsInf(v, 0)\n\t//     - math.Copysign(1, v) == math.Copysign(1, l)\n\t//   - n%2 == 0\n\t//     - math.Copysign(1, v) == math.Copysign(1, l)\n\t// - math.IsInf(l, 0)\n\t//   - v == l\n\t// - math.IsInf(u, 0)\n\t//   - v == u\n\t// - math.IsInf(v, -1)\n\t//   - l \u003c= u\n\t// - math.IsInf(v, 1)\n\t//   - u \u003c= l\n\t// - l \u003c u\n\t//   - v \u003c= l\n\t//   - v \u003e= u\n\t// - l \u003e u\n\t//   - v \u003e= l\n\t//   - v \u003c= u\n\t// - general cases\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{1, 0, 1, 0, 0}, // Panics, but should be caught by testing framework\n\t\t{2, 0, 1, math.NaN(), 0},\n\t\t{2, math.NaN(), 1, 0, 1},\n\t\t{2, 0, math.NaN(), 0, 0},\n\t\t{2, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(-1), 2},\n\t\t{2, math.Inf(1), math.Inf(-1), math.Inf(1), 0},\n\t\t{2, math.Inf(1), math.Inf(-1), math.Inf(-1), 1},\n\t\t{2, math.Inf(1), 0, math.Inf(1), 0},\n\t\t{2, math.Inf(1), 0, 0, 1},\n\t\t{2, 0, math.Inf(1), 0, 0},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, 0, 1, math.Inf(-1), 0},\n\t\t{2, 1, 0, math.Inf(-1), 1},\n\t\t{2, 0, 1, math.Inf(1), 1},\n\t\t{2, 1, 0, math.Inf(1), 0},\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 2, 1},\n\t\t{2, 1, 0, 2, 0},\n\t\t{2, 1, 0, -1, 1},\n\t\t{10, 0, 1, 0.5, 5},\n\t\t{10, 0, 1, 0.25, 2},\n\t\t{10, 0, 1, 0.75, 7},\n\t\t{10, -1, 1, 0, 4},\n\t\t{10, -1, 1, -0.5, 2},\n\t\t{10, -1, 1, 0.5, 7},\n\t}\n\tfor i, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.n \u003e= 2 {\n\t\t\t\t\t\tt.Errorf(\"Test %d: panicking with n \u003e= 2\", i)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"Test %d: got %v, want %v\", i, got, test.want)\n\t\t\t}\n\t\t}()\n\t}\n}",
    "c4347345bb3b757aabbc440dd959adf5": "package floats\n\nimport \"math\"\nimport \"testing\"\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases: slice with different lengths and values.\n\ttestCases := []struct {\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1, 2, 3, 4}, 4},\n\t\t{[]float64{4, 3, 2, 1, 0}, 0},\n\t\t{[]float64{1, 1, 1, 1, 1}, 0},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{1, 2, 3, 4, math.NaN()}, 3},\n\t\t{[]float64{math.NaN(), 1, 2, 3, 4}, 1},\n\t\t{[]float64{1, math.NaN(), 2, 3, 4}, 0},\n\t}\n\n\t// Iterate over the test cases and check the results.\n\tfor i, tc := range testCases {\n\t\tgot := MaxIdx(tc.s)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d failed: MaxIdx(%v) = %d, want %d\", i, tc.s, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case: empty slice.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Test case failed: MaxIdx([]float64{}) did not panic\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}\n",
    "c44e095c6325fd9ca41dd7c3957a9234": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases.\n\ttype testCase struct {\n\t\ts1     []float64\n\t\ts2     []float64\n\t\ts3     []float64\n\t\texpect bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{[]float64{}, []float64{}, []float64{}, true},\n\t\t{[]float64{1, 2}, []float64{2, 3}, []float64{4, 5}, true},\n\t\t{[]float64{1}, []float64{2, 3}, []float64{4, 5}, false},\n\t\t{[]float64{1, 2, 3}, []float64{2, 3}, []float64{4, 5}, false},\n\t\t{[]float64{1, 2}, []float64{2, 3}, []float64{4, 5, 6}, false},\n\t}\n\n\t// Run test cases.\n\tfor i, tc := range testCases {\n\t\tgot := EqualLengths(tc.s1, tc.s2, tc.s3)\n\t\tif got != tc.expect {\n\t\t\tt.Errorf(\"Test case %d failed: EqualLengths(%v, %v, %v) = %v, want %v\", i, tc.s1, tc.s2, tc.s3, got, tc.expect)\n\t\t}\n\t}\n}",
    "c50cc8843b4580e570dbf84f66a3386f": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tInds   []int\n\t\tF      func(float64) bool\n\t\tS      []float64\n\t\tK      int\n\t\tWant   []int\n\t\tWantOK bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v \u003e 0 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      2,\n\t\t\tWant:   []int{0, 1},\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   make([]int, 10),\n\t\t\tF:      func(v float64) bool { return v \u003e 0 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      2,\n\t\t\tWant:   []int{0, 1},\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v \u003e 0 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      -1,\n\t\t\tWant:   []int{0, 1, 2, 3},\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   make([]int, 10),\n\t\t\tF:      func(v float64) bool { return v \u003e 0 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      -1,\n\t\t\tWant:   []int{0, 1, 2, 3},\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v \u003e 1 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      2,\n\t\t\tWant:   []int{1, 2},\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v \u003e 10 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      2,\n\t\t\tWant:   nil,\n\t\t\tWantOK: false,\n\t\t},\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v \u003e 10 },\n\t\t\tS:      []float64{1, 2, 3, 4},\n\t\t\tK:      -1,\n\t\t\tWant:   nil,\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v == 1 },\n\t\t\tS:      []float64{1, 2, 3, 4, 1},\n\t\t\tK:      -1,\n\t\t\tWant:   []int{0, 4},\n\t\t\tWantOK: true,\n\t\t},\n\t\t{\n\t\t\tInds:   nil,\n\t\t\tF:      func(v float64) bool { return v == 1 },\n\t\t\tS:      []float64{1, 2, 3, 4, 1},\n\t\t\tK:      0,\n\t\t\tWant:   nil,\n\t\t\tWantOK: true,\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot, err := Find(tc.Inds, tc.F, tc.S, tc.K)\n\t\tif tc.WantOK \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"Test %d - Unexpected error: %v\", i, err)\n\t\t}\n\t\tif !tc.WantOK \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"Test %d - Expected error but got nil\", i)\n\t\t}\n\t\tif !Equal(got, tc.Want) {\n\t\t\tt.Errorf(\"Test %d -  Mismatch - Want: %v, Got: %v\", i, tc.Want, got)\n\t\t}\n\t}\n}",
    "c5390b0747a0390f595f5a93fd3be797": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular values\n\t// - l and/or u is NaN\n\t// - l and u are both +Inf\n\t// - l and u are both -Inf\n\t// - l is +Inf\n\t// - u is +Inf\n\t// - l is -Inf\n\t// - u is -Inf\n\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar dst []float64\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\twant := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 4) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaNCases\", func(t *testing.T) {\n\t\tt.Run(\"lNaN\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, math.NaN(), 4)\n\t\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, NaN, 4) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"uNaN\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, 0, math.NaN())\n\t\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"InfCases\", func(t *testing.T) {\n\t\tt.Run(\"BothPosInf\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, +Inf, +Inf) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"BothNegInf\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\t\t\twant := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsInf(dst[i], -1) != math.IsInf(want[i], -1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, -Inf, -Inf) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"LPosInf\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, math.Inf(1), 4)\n\t\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, +Inf, 4) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"UPosInf\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, 0, math.Inf(1))\n\t\t\twant := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, +Inf) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"LNegInf\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, math.Inf(-1), 4)\n\t\t\twant := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 4}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsInf(dst[i], -1) != math.IsInf(want[i], -1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, -Inf, 4) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"UNegInf\", func(t *testing.T) {\n\t\t\tdst := make([]float64, 5)\n\t\t\tSpan(dst, 0, math.Inf(-1))\n\t\t\twant := []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\t\tfor i := range dst {\n\t\t\t\tif math.IsInf(dst[i], -1) != math.IsInf(want[i], -1) {\n\t\t\t\t\tt.Errorf(\"Span(%v, 0, -Inf) = %v, want %v\", dst, dst, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n}\n",
    "c63de35547795507c7e26f34c81f2123": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSub(t *testing.T) {\n\tdst := []float64{1, 2, 3, 4}\n\ts := []float64{1, 1, 2, 2}\n\n\t// Calculate the expected result\n\texpected := []float64{0, 1, 1, 2}\n\n\t// Call the function being tested\n\tSub(dst, s)\n\n\t// Assert the result\n\tassert.Equal(t, expected, dst, \"Slices should be equal after subtraction\")\n}\n",
    "c66f332326724bc488067fc1ae2dee45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\t// Test cases:\n\t// - dst length \u003c 2\n\t// - l or u is negative\n\t// - l or u is zero\n\t// - valid input\n\n\t// dst length \u003c 2\n\tt.Run(\"TestPanicsOnDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tLogSpan(dst, 0.0, 1.0)\n\t})\n\n\t// l or u is negative\n\tt.Run(\"TestNegativeInput\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tLogSpan(dst, -1.0, 1.0)\n\t\tfor _, val := range dst {\n\t\t\tif !math.IsNaN(val) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", val)\n\t\t\t}\n\t\t}\n\t})\n\n\t// l or u is zero\n\tt.Run(\"TestZeroInput\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tLogSpan(dst, 0.0, 1.0)\n\t\tfor _, val := range dst {\n\t\t\tif val != 0.0 {\n\t\t\t\tt.Errorf(\"Expected 0.0, got %v\", val)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Valid input\n\tt.Run(\"TestValidInput\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\texpected := []float64{1.0, math.E, math.E * math.E, math.E * math.E * math.E}\n\t\tLogSpan(dst, 0.0, 3.0)\n\t\tfor i := range dst {\n\t\t\tif math.Abs(dst[i]-expected[i]) \u003e 1e-15 {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected[i], dst[i])\n\t\t\t}\n\t\t}\n\t})\n}",
    "c67238fc1cdc7f32abd6e8a9759afd8f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that length less than 2 panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when the slice had length 1\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 10)\n\n\t// Verify that length 2 works.\n\tdst = make([]float64, 2)\n\tSpan(dst, 0, 10)\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected dst[0] = 0, but got %v\", dst[0])\n\t}\n\tif dst[1] != 10 {\n\t\tt.Errorf(\"Expected dst[1] = 10, but got %v\", dst[1])\n\t}\n\n\t// Test a range.\n\tdst = make([]float64, 11)\n\tSpan(dst, 0, 10)\n\tfor i := range dst {\n\t\texpected := float64(i)\n\t\tif x := dst[i]; x != expected {\n\t\t\tt.Errorf(\"At i = %v, expected %v, but got %v\", i, expected, x)\n\t\t}\n\t}\n\n\t// Test NaN cases\n\tdst = make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, math.NaN(), 0)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN but got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"Expected 0 but got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, 0, math.NaN())\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected 0 but got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Expected NaN but got %v\", dst[i])\n\t\t}\n\t}\n\n\t// Test Inf cases\n\tdst = make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, math.Inf(1), 0)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf but got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"Expected 0 but got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, 0, math.Inf(1))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected 0 but got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf but got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, math.Inf(-1), 0)\n\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Expected -Inf but got %v\", dst[i])\n\t\t}\n\t}\n\tif dst[len(dst)-1] != 0 {\n\t\tt.Errorf(\"Expected 0 but got %v\", dst[len(dst)-1])\n\t}\n\n\tdst = make([]float64, 5)\n\tfor i := range dst {\n\t\tdst[i] = float64(i)\n\t}\n\tSpan(dst, 0, math.Inf(-1))\n\tif dst[0] != 0 {\n\t\tt.Errorf(\"Expected 0 but got %v\", dst[0])\n\t}\n\tfor i := 1; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Expected -Inf but got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 11)\n\tSpan(dst, math.Inf(1), math.Inf(1))\n\tfor i := range dst {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf but got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 11)\n\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\tfor i := range dst {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Expected -Inf but got %v\", dst[i])\n\t\t}\n\t}\n\n\tdst = make([]float64, 11)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := 0; i \u003c len(dst)/2; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf but got %v\", dst[i])\n\t\t}\n\t}\n\tfor i := len(dst)/2 + 1; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Expected -Inf but got %v\", dst[i])\n\t\t}\n\t}\n\tif len(dst)%2 == 1 {\n\t\tif dst[len(dst)/2] != 0 {\n\t\t\tt.Errorf(\"Expected 0 but got %v\", dst[len(dst)/2])\n\t\t}\n\t}\n\n\tdst = make([]float64, 10)\n\tSpan(dst, math.Inf(1), math.Inf(-1))\n\tfor i := 0; i \u003c len(dst)/2; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Expected +Inf but got %v\", dst[i])\n\t\t}\n\t}\n\tfor i := len(dst)/2; i \u003c len(dst); i++ {\n\t\tif !math.IsInf(dst[i], -1) {\n\t\t\tt.Errorf(\"Expected -Inf but got %v\", dst[i])\n\t\t}\n\t}\n\tif len(dst)%2 == 1 {\n\t\tif dst[len(dst)/2] != 0 {\n\t\t\tt.Errorf(\"Expected 0 but got %v\", dst[len(dst)/2])\n\t\t}\n\t}\n\n}\n",
    "c68f0eeab1152e158103052b21dc3f6f": "package floats\n\nimport \"testing\"\n\nfunc TestMul(t *testing.T) {\n\tdst := make([]float64, 3)\n\ts := []float64{1, 2, 3}\n\twant := []float64{1, 2, 3}\n\n\tMul(dst, s)\n\tfor i := range want {\n\t\tif dst[i] != want[i] {\n\t\t\tt.Errorf(\"Mul error: got %v for dst[%v], want %v\", dst[i], i, want[i])\n\t\t}\n\t}\n\t//test if dst[i] = s[i]*dst[i]\n\tMul(dst, s)\n\tfor i := range want {\n\t\tif dst[i] != want[i]*s[i] {\n\t\t\tt.Errorf(\"Mul error: got %v for dst[%v], want %v\", dst[i], i, want[i]*s[i])\n\t\t}\n\t}\n\n\t// Test panicking with unequal lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tMul(dst, []float64{1, 2, 3, 4})\n}",
    "c6e905e1ad53e35ccd01273d9f1d7878": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{10, 0, 10, 3.14, 3},\n\t\t{10, 0, 10, 3.1415926, 3},\n\t\t{10, 10, 0, 3.14, 7},\n\t\t{10, 10, 0, 3.1415926, 7},\n\t\t{5, -10, 10, -12, 0},\n\t\t{5, -10, 10, 12, 4},\n\t\t{5, -10, 10, -math.Inf(1), 0},\n\t\t{5, -10, 10, math.Inf(1), 4},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 1},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for NaN inputs\n\tnanTestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{5, math.NaN(), 10, 5, 0},\n\t\t{5, 0, math.NaN(), 5, 4},\n\t\t{5, 0, 10, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range nanTestCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test case for panicking when n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "c70bd4226e4382659ab756194d226ddb": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{-1, -0.1, 0, 1, 1.1, 2}\n\tfor i, v := range s {\n\t\tif i \u003c len(s)-1 {\n\t\t\tif j := Within(s, v+tol); j != i {\n\t\t\t\tt.Errorf(\"Expected Within(s, %v) = %v, but got %v\", v, i, j)\n\t\t\t}\n\t\t} else {\n\t\t\tif j := Within(s, v); j != -1 {\n\t\t\t\tt.Errorf(\"Expected Within(s, %v) = -1, but got %v\", v, j)\n\t\t\t}\n\t\t}\n\t}\n\tif j := Within(s, -1-tol); j != -1 {\n\t\tt.Errorf(\"Expected Within(s, -1-tol) = -1, but got %v\", j)\n\t}\n\tif j := Within(s, 2+tol); j != -1 {\n\t\tt.Errorf(\"Expected Within(s, 2+tol) = -1, but got %v\", j)\n\t}\n\tif j := Within(s, math.NaN()); j != -1 {\n\t\tt.Errorf(\"Expected Within(s, NaN) = -1, but got %v\", j)\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when the slice is not sorted\")\n\t\t}\n\t}()\n\tWithin([]float64{1, 0}, 0.5)\n}\n",
    "c84004bbf3a69183c622f48e660f5b13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/f64\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor _, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\ts: []float64{1, 2, 3, 4},\n\t\t\tt: []float64{1, 2, 3, 4},\n\t\t\tL: 2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts: []float64{1, 2, 3, 4},\n\t\t\tt: []float64{2, 3, 4, 5},\n\t\t\tL: 1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\ts: []float64{1, 2, 3, 4},\n\t\t\tt: []float64{2, 3, 4, 5},\n\t\t\tL: 2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\ts: []float64{1, 2, 3, 4},\n\t\t\tt: []float64{2, 3, 4, 5},\n\t\t\tL: math.Inf(1),\n\t\t\twant: 1,\n\t\t},\n\t}{\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Case s = %v, t = %v, L = %v: got %v, want %v\", test.s, test.t, test.L, got, test.want)\n\t\t}\n\t}\n\n\t// Test that it panics\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 2)\n}",
    "c9072aa3fc2774f4553a579a976d9871": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666666, -0.3333333333333333, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    2.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-2.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInfinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    2.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-2.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\t// Check if the lengths of got and want are equal.\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Fatalf(\"Length mismatch: got %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\n\t\t\t// Check if got and want are equal element-wise with NaN handling.\n\t\t\tfor i := range got {\n\t\t\t\tif !(got[i] == tc.want[i] || (math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tc.want[i]))) {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking when len(dst) \u003c 2.\n\tt.Run(\"PanicsOnDstLessThanTwo\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 1.0)\n\t})\n}\n",
    "c9a488ed3661683813cdc9acf0983fe4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l is Inf, u is regular\n\t// - l is regular, u is Inf\n\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"RegularValues\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\texpected := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaNCases\", func(t *testing.T) {\n\t\t// l is NaN\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 4)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 4 {\n\t\t\tt.Errorf(\"Expected 4, got %v\", dst[len(dst)-1])\n\t\t}\n\t\t// u is NaN\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"InfCases\", func(t *testing.T) {\n\t\t// both Inf\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", expected, dst)\n\t\t\t}\n\t\t}\n\t\t// only l is Inf\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 4)\n\t\tfor i := 0; i \u003c len(dst)-1; i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 4 {\n\t\t\tt.Errorf(\"Expected 4, got %v\", dst[len(dst)-1])\n\t\t}\n\t\t// only u is Inf\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0, got %v\", dst[0])\n\t\t}\n\t\tfor i := 1; i \u003c len(dst); i++ {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected Inf, got %v\", dst[i])\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "ca0939efcf7f3a8da4f08dbb68580e05": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\t// Define test cases\n\ttestCases := []struct {\n\t\ts []float64\n\t\tt []float64\n\t\twant bool\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, true},              // Identical slices\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 4}, false},             // Different values\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, false},                // Different lengths\n\t\t{[]float64{1, math.NaN(), 3}, []float64{1, math.NaN(), 3}, true}, // NaN handling\n\t}\n\n\t// Iterate over test cases\n\tfor _, tc := range testCases {\n\t\t// Call Same function\n\t\tgot := Same(tc.s, tc.t)\n\n\t\t// Check if result matches expected value\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tc.s, tc.t, got, tc.want)\n\t\t}\n\t}\n}\n",
    "ca5c8d4320f117c218de35798e287ba6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various spans and values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{5, 1, 5, 3, 2},\n\t\t{5, 5, 1, 3, 2},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for edge cases and special values.\n\ttestCasesEdge := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 0, 0, 0},\n\t\t{3, 0, 0, 0, 0},\n\t\t{2, 1, 1, 0, 0},\n\t\t{3, 1, 1, 0, 0},\n\t\t{2, 0, 1, math.NaN(), 0},\n\t\t{3, 0, 1, math.NaN(), 0},\n\t\t{2, math.NaN(), 0, 0, 1},\n\t\t{3, math.NaN(), 0, 0, 2},\n\t\t{2, 0, math.NaN(), 0, 0},\n\t\t{3, 0, math.NaN(), 0, 0},\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{4, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{2, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{4, math.Inf(1), math.Inf(-1), 0, 2},\n\t\t{2, 0, 1, math.Inf(-1), 0},\n\t\t{2, 1, 0, math.Inf(-1), 1},\n\t\t{2, 0, 1, math.Inf(1), 1},\n\t\t{2, 1, 0, math.Inf(1), 0},\n\t}\n\tfor _, tc := range testCasesEdge {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases for panics.\n\ttestCasesPanic := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}{\n\t\t{1, 0, 10, 5},\n\t\t{0, 0, 10, 5},\n\t\t{-1, 0, 10, 5},\n\t}\n\tfor _, tc := range testCasesPanic {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tc.n, tc.l, tc.u, tc.v)\n\t\t\t}\n\t\t}()\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t}\n}",
    "cad7b02fd7a43024f9e31aaa000ba4d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: {n, l, u, v, want}\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases.\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 0, 1, 2, 1},\n\n\t\t// Generic cases.\n\t\t{5, 0, 1, -1, 0},\n\t\t{5, 0, 1, 0.1, 0},\n\t\t{5, 0, 1, 0.3, 1},\n\t\t{5, 0, 1, 0.6, 3},\n\t\t{5, 0, 1, 0.9, 4},\n\t\t{5, 0, 1, 1, 4},\n\t\t{5, 0, 1, 2, 4},\n\n\t\t// Reversed bounds.\n\t\t{5, 1, 0, -1, 4},\n\t\t{5, 1, 0, 0.1, 4},\n\t\t{5, 1, 0, 0.3, 3},\n\t\t{5, 1, 0, 0.6, 1},\n\t\t{5, 1, 0, 0.9, 0},\n\t\t{5, 1, 0, 1, 0},\n\t\t{5, 1, 0, 2, 0},\n\n\t\t// Special cases for Inf and NaN.\n\t\t{5, math.NaN(), 1, 0, 0},\n\t\t{5, 0, math.NaN(), 0, 0},\n\t\t{5, math.Inf(-1), 1, 0, 0},\n\t\t{5, 0, math.Inf(1), 0, 4},\n\t\t{5, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{5, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{5, math.Inf(-1), math.Inf(1), 0, 2},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"case %d: got %d, want %d\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "cb2f4ecce6f8ce30d05a1cb5dedc4149": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, -1, -1},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 2, -1},\n\t\t{[]float64{-1, 0, 1}, -2, -1},\n\t\t{[]float64{-1, 0, 1}, -1 - tol, -1},\n\t\t{[]float64{-1, 0, 1}, -1, 0},\n\t\t{[]float64{-1, 0, 1}, -0.5, 0},\n\t\t{[]float64{-1, 0, 1}, 0, 1},\n\t\t{[]float64{-1, 0, 1}, 0.5, 1},\n\t\t{[]float64{-1, 0, 1}, 1, -1},\n\t\t{[]float64{-1, 0, 1}, 1 + tol, -1},\n\t\t{[]float64{-1, 0, 1}, 2, -1},\n\t} {\n\t\tgot := Within(c.s, c.v)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Test %d: Within(%v,%v) = %v, want %v\", i, c.s, c.v, got, c.want)\n\t\t}\n\t}\n\n\t// NaN should always return -1\n\tfor i, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{[]float64{0, 1}, math.NaN(), -1},\n\t\t{[]float64{-1, 0, 1}, math.NaN(), -1},\n\t} {\n\t\tgot := Within(c.s, c.v)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Test %d: Within(%v,%v) = %v, want %v\", i, c.s, c.v, got, c.want)\n\t\t}\n\t}\n\n\t// Panics\n\tfor i, c := range [][]float64{{}, {0}} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Test %d: Within(%v) did not panic\", i, c)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tWithin(c, 0)\n\t\t}()\n\t}\n\tfor i, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t}{\n\t\t{[]float64{1, 0}, 0},\n\t\t{[]float64{0, 1, -1}, 0.5},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"Test %d: Within(%v,%v) did not panic\", i, c.s, c.v)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tWithin(c.s, c.v)\n\t\t}()\n\t}\n}",
    "cb50929c3d31ad17a3f460bf88000ad7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1, -1, 1e-10, -1e-10}, 0},\n\t\t{[]float64{math.MaxFloat64, 1, 1, 1}, math.MaxFloat64},\n\t}\n\n\t// Iterate over the test cases.\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated.\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result matches the expected value.\n\t\tif !equalWithinTolerance(actual, tc.expected, 1e-14) {\n\t\t\tt.Errorf(\"For input %#v, expected %v, but got %v\", tc.input, tc.expected, actual)\n\t\t}\n\t}\n}\n\n// Helper function to compare floats with a tolerance.\nfunc equalWithinTolerance(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c= tol\n}",
    "cb535218c3f70cf84aad141358af65fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/rand\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{0, 0, 0},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\ts:    []float64{-1, -2, -3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(56),\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{0, 0, 0},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{-1, -2, -3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 12,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{0, 0, 0},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\ts:    []float64{-1, -2, -3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 6,\n\t\t},\n\t} {\n\t\tgot := Distance(test.s, test.t, test.L)\n\t\tif !panics(func() { Distance(test.s, []float64{}, test.L) }) {\n\t\t\tt.Errorf(\"Did not panic with unequal lengths\")\n\t\t}\n\t\tif math.Abs(got-test.want) \u003e 1e-14 {\n\t\t\tt.Errorf(\"Distance mismatch case %d: got %v want %v\", i, got, test.want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDistanceL2(b *testing.B) {\n\ts := rand.NormFloat64n(b.N, 100, 1)\n\tt := rand.NormFloat64n(b.N, 100, 1)\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tDistance(s, t, 2)\n\t}\n}\n\nfunc BenchmarkDistanceL1(b *testing.B) {\n\ts := rand.NormFloat64n(b.N, 100, 1)\n\tt := rand.NormFloat64n(b.N, 100, 1)\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tDistance(s, t, 1)\n\t}\n}\n\nfunc BenchmarkDistanceLinf(b *testing.B) {\n\ts := rand.NormFloat64n(b.N, 100, 1)\n\tt := rand.NormFloat64n(b.N, 100, 1)\n\tb.ResetTimer()\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tDistance(s, t, math.Inf(1))\n\t}\n}",
    "cba9f4ddaeffe47ca5b276cb857f5a91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slice contents\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{1, 2, 3, 4}, 2, 5.477225575051661},\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 2, 5.477225575051661},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t{[]float64{}, 1, 0},\n\t\t{[]float64{}, 2, 0},\n\t\t{[]float64{}, math.Inf(1), 0},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the norm using the Norm function\n\t\tactual := Norm(tc.s, tc.L)\n\n\t\t// Check if the calculated norm is within the acceptable tolerance\n\t\tif !close(actual, tc.expected, 1e-14) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, want %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}\n\nfunc close(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol\n}",
    "cbb8d4e698be7f05734f9a6261da1335": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various lengths and ranges.\n\ttestCases := []struct {\n\t\tdstLen int\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t}{\n\t\t{2, 0, 1, []float64{0, 1}},\n\t\t{3, 0, 1, []float64{0, 0.5, 1}},\n\t\t{4, -1, 1, []float64{-1, -0.3333333333333333, 0.3333333333333333, 1}},\n\t\t{5, 10, 20, []float64{10, 12.5, 15, 17.5, 20}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdst := make([]float64, tc.dstLen)\n\t\tgot := Span(dst, tc.l, tc.u)\n\n\t\t// Check if the returned slice is the same as the input slice.\n\t\tif got != dst {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) returned a different slice\", dst, tc.l, tc.u)\n\t\t}\n\n\t\t// Check if the generated values are correct.\n\t\tfor i, wantVal := range tc.want {\n\t\t\tif !closeEnough(got[i], wantVal, 1e-9) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", dst, tc.l, tc.u, i, got[i], wantVal)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanCases := []struct {\n\t\tdstLen int\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t}{\n\t\t{3, math.NaN(), 1, []float64{math.NaN(), math.NaN(), 1}},\n\t\t{3, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t\t{4, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{5, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}},\n\t\t{4, math.Inf(1), 10, []float64{math.Inf(1), math.Inf(1), math.Inf(1), 10}},\n\t\t{4, -10, math.Inf(-1), []float64{-10, math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tdst := make([]float64, tc.dstLen)\n\t\tgot := Span(dst, tc.l, tc.u)\n\n\t\t// Check if the returned slice is the same as the input slice.\n\t\tif got != dst {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) returned a different slice\", dst, tc.l, tc.u)\n\t\t}\n\n\t\t// Check if the generated values are correct.\n\t\tfor i, wantVal := range tc.want {\n\t\t\tif !isClose(got[i], wantVal) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", dst, tc.l, tc.u, i, got[i], wantVal)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\n// Helper function to compare floats for approximate equality.\nfunc closeEnough(a, b, tol float64) bool {\n\treturn math.Abs(a-b) \u003c tol || (math.IsNaN(a) \u0026\u0026 math.IsNaN(b))\n}\n\n// Helper function to compare floats for equality, including NaN and Inf.\nfunc isClose(a, b float64) bool {\n\tif math.IsNaN(a) {\n\t\treturn math.IsNaN(b)\n\t} else if math.IsInf(a, 0) {\n\t\treturn math.IsInf(b, 0) \u0026\u0026 math.Signbit(a) == math.Signbit(b)\n\t} else {\n\t\treturn math.Abs(a-b) \u003c 1e-9\n\t}\n}",
    "cd1af6b4b2cac1a9911a1fa1e5f63565": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, 0, 10, 0, 0},\n\t\t{10, 0, 10, 10, 9},\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t\t{10, 10, 0, 0, 9},\n\t\t{10, 10, 0, 10, 0},\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\t\t{3, 0, 2, 1, 1},\n\t\t{3, 2, 0, 1, 1},\n\t\t{10, -math.Inf(1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(1), -math.Inf(1), 0, 5},\n\t\t{10, -math.Inf(1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(1), -math.Inf(1), math.Inf(1), 0},\n\t\t{10, -math.Inf(1), math.Inf(1), -math.Inf(1), 0},\n\t\t{10, math.Inf(1), -math.Inf(1), -math.Inf(1), 9},\n\t\t{10, 0, math.Inf(1), 100, 9},\n\t\t{10, -math.Inf(1), 0, -100, 0},\n\t\t{10, 0, 10, math.NaN(), 1},\n\t\t{10, math.NaN(), 10, 5, 9},\n\t\t{10, 0, math.NaN(), 5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %d, got %d\", i+1, tc.expected, got)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for n \u003c 2, but got none\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n",
    "cd2551357bf5a4761b1d93b27199cd8e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results.\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1e-10, 1e10, 1e-10}, 1e10},\n\t\t{[]float64{1, -1, 1e-10}, 1e-10},\n\t\t{[]float64{}, 0},\n\t}\n\n\t// Iterate over the test cases and compare results.\n\tfor _, tc := range testCases {\n\t\tactual := SumCompensated(tc.input)\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-10 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}",
    "cd59b1cd0bb3ec2ddb479fb44184b611": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{2, 3, 4, 5}\n\ts3 := []float64{3, 4, 5, 6}\n\ts4 := []float64{-1, 0, -1, 0}\n\n\tassert.Panics(t, func() { Distance(s1, []float64{1, 2, 3}, 1) })\n\n\tassert.Equal(t, 0.0, Distance([]float64{}, []float64{}, 1))\n\tassert.Equal(t, 0.0, Distance(s1, s1, 1))\n\n\tassert.Equal(t, 4.0, Distance(s1, s2, 1))\n\tassert.Equal(t, 8.0, Distance(s1, s3, 1))\n\n\tassert.Equal(t, 4.0, Distance(s1, s2, math.Inf(1)))\n\tassert.Equal(t, 5.0, Distance(s1, s4, math.Inf(1)))\n\n\tassert.InDelta(t, 2.0, Distance(s1, s2, 2), 1e-15)\n\tassert.InDelta(t, 4.0, Distance(s1, s3, 2), 1e-15)\n}\n",
    "cdbdf12b54f31cf75f3fe8b5f104b1b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for Span function\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.5, 0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBoundaries2\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundaries\",\n\t\t\tdst:  make([]float64, 6),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundary\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoundary2\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !EqualWithinAbsOrRel(got[i], tc.want[i], 1e-15, 1e-15) {\n\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 1.0)\n}\n",
    "cec8ccef0f30afa2aa52c89fdd1aaf3a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttol := 1e-14\n\ts1 := []float64{1, 2, 3, 4, 5}\n\ts2 := []float64{-1, -2, -3, -4, -5}\n\ts3 := []float64{1, -2, 3, -4, 5}\n\ts4 := []float64{}\n\tif math.Abs(Norm(s1, 1)-15) \u003e tol {\n\t\tt.Errorf(\"Failed for s1, L = 1\")\n\t}\n\tif math.Abs(Norm(s1, 2)-math.Sqrt(55)) \u003e tol {\n\t\tt.Errorf(\"Failed for s1, L = 2\")\n\t}\n\tif math.Abs(Norm(s1, math.Inf(1))-5) \u003e tol {\n\t\tt.Errorf(\"Failed for s1, L = Inf\")\n\t}\n\tif math.Abs(Norm(s2, 1)-15) \u003e tol {\n\t\tt.Errorf(\"Failed for s2, L = 1\")\n\t}\n\tif math.Abs(Norm(s2, 2)-math.Sqrt(55)) \u003e tol {\n\t\tt.Errorf(\"Failed for s2, L = 2\")\n\t}\n\tif math.Abs(Norm(s2, math.Inf(1))-5) \u003e tol {\n\t\tt.Errorf(\"Failed for s2, L = Inf\")\n\t}\n\tif math.Abs(Norm(s3, 1)-15) \u003e tol {\n\t\tt.Errorf(\"Failed for s3, L = 1\")\n\t}\n\tif math.Abs(Norm(s3, 2)-math.Sqrt(55)) \u003e tol {\n\t\tt.Errorf(\"Failed for s3, L = 2\")\n\t}\n\tif math.Abs(Norm(s3, math.Inf(1))-5) \u003e tol {\n\t\tt.Errorf(\"Failed for s3, L = Inf\")\n\t}\n\tif Norm(s4, 1) != 0 {\n\t\tt.Errorf(\"Failed for []float64{}, L = 1\")\n\t}\n\tif Norm(s4, 2) != 0 {\n\t\tt.Errorf(\"Failed for []float64{}, L = 2\")\n\t}\n\tif Norm(s4, math.Inf(1)) != 0 {\n\t\tt.Errorf(\"Failed for []float64{}, L = Inf\")\n\t}\n}\n",
    "ced77cd244892a4bc6b7d487dd1b6d4a": "package floats\n\nimport \"testing\"\n\nfunc TestScaleTo(t *testing.T) {\n\t// Test cases.\n\tvar testCases = []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tc    float64\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test empty slices\",\n\t\t\tdst:  []float64{},\n\t\t\tc:    2.0,\n\t\t\ts:    []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Test scaling by 0\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tc:    0,\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Test scaling by positive constant\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tc:    2.0,\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: []float64{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tname: \"Test scaling by negative constant\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tc:    -1.5,\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: []float64{-1.5, -3, -4.5},\n\t\t},\n\t}\n\n\t// Run the test cases.\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := ScaleTo(tc.dst, tc.c, tc.s)\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) = %v, want %v\", tc.dst, tc.c, tc.s, got, tc.want)\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) = %v, want %v\", tc.dst, tc.c, tc.s, got, tc.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "cee9aea2c702fc18ba210f59a68d56ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various valid inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TwoElementSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    2.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{2.0, 5.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-15) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test cases for NaN and Inf.\n\tnanCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-2.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    3.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-2.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range nanCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(got[i]) \u0026\u0026 !math.IsNaN(tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t} else if !math.IsNaN(got[i]) \u0026\u0026 math.IsNaN(tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v)[%d] = %v, want %v\", tc.dst, tc.l, tc.u, i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panicking with less than two elements.\n\tt.Run(\"PanicsOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with a slice of length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n",
    "cf3d2ac834f186c8f0097e850e7bbbbe": "package floats\n\nimport \"testing\"\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2, 3},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn a == b\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2, 4},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn a == b\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn a == b\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "cfbb4651815b01c03980fee9bcea668b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    100,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds, same sign\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds, different sign\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds, different sign, odd n\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds, different sign, matching v\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound, matching v\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound, matching v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, increasing\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, decreasing\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"-Inf v, increasing\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"-Inf v, decreasing\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"offset increasing\",\n\t\t\tn:    10,\n\t\t\tl:    100,\n\t\t\tu:    110,\n\t\t\tv:    105,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"offset decreasing\",\n\t\t\tn:    10,\n\t\t\tl:    110,\n\t\t\tu:    100,\n\t\t\tv:    105,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"extreme increasing\",\n\t\t\tn:    10,\n\t\t\tl:    -1e307,\n\t\t\tu:    1e307,\n\t\t\tv:    0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"extreme decreasing\",\n\t\t\tn:    10,\n\t\t\tl:    1e307,\n\t\t\tu:    -1e307,\n\t\t\tv:    0,\n\t\t\twant: 4,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d,%v,%v,%v): got=%d want=%d\", test.n, test.l, test.u, test.v, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t}{\n\t\t{\n\t\t\tname: \"n=0\",\n\t\t\tn:    0,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t},\n\t\t{\n\t\t\tname: \"n=1\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttest.DidPanic(t, func() { NearestIdxForSpan(test.n, test.l, test.u, test.v) })\n\t\t})\n\t}\n}\n",
    "cfc03b5acebd84a7b4d5789bde286391": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantInds2 []int\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"k \u003c 0, find all even numbers\",\n\t\t\tinds:      nil,\n\t\t\tf:         func(f float64) bool { return int(f)%2 == 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 3, 5},\n\t\t\twantErr:   nil,\n\t\t\twantInds2: []int{},\n\t\t},\n\t\t{\n\t\t\tname:      \"k = 0, find no elements\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return int(f)%2 == 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantInds2: []int{1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:      \"k = 2, find first 2 even numbers\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return int(f)%2 == 0 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1, 3},\n\t\t\twantErr:   nil,\n\t\t\twantInds2: []int{1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:      \"k = 10, insufficient elements\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(f float64) bool { return int(f) \u003e 10 },\n\t\t\ts:         []float64{1, 2, 3, 4, 5, 6},\n\t\t\tk:         10,\n\t\t\twantInds:  nil,\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantInds2: []int{1, 2, 3, 4},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif !errorEqual(gotErr, tc.wantErr) {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", gotErr, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !intSliceEqual(gotInds, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find() gotInds = %v, wantInds %v\", gotInds, tc.wantInds)\n\t\t\t}\n\t\t\tif !intSliceEqual(tc.inds, tc.wantInds2) {\n\t\t\t\tt.Errorf(\"Find() inds = %v, wantInds2 %v\", tc.inds, tc.wantInds2)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// errorEqual compares two errors for equality.\nfunc errorEqual(e1, e2 error) bool {\n\tif e1 == nil \u0026\u0026 e2 == nil {\n\t\treturn true\n\t}\n\tif e1 == nil || e2 == nil {\n\t\treturn false\n\t}\n\treturn e1.Error() == e2.Error()\n}\n\n// intSliceEqual compares two int slices for equality.\nfunc intSliceEqual(s1, s2 []int) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "d00820bb1a4bd89672dcb2c82326bc12": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\t// Test cases for Mul function\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{2, 3, 4},\n\t\t\twant: []float64{2, 6, 12},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero slice\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\tdst:  []float64{-1, -2, 3},\n\t\t\ts:    []float64{2, -3, -4},\n\t\t\twant: []float64{-2, 6, -12},\n\t\t},\n\t}\n\n\t// Iterate over test cases and run Mul function\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tMul(tc.dst, tc.s)\n\t\t\tfor i := range tc.dst {\n\t\t\t\tif tc.dst[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Mul(%v, %v) = %v, want %v\", tc.dst, tc.s, tc.dst, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test case for panic when slice lengths don't match\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Mul() did not panic when slice lengths don't match\")\n\t\t}\n\t}()\n\tMul([]float64{1, 2}, []float64{1, 2, 3})\n}\n",
    "d03fbbedb07ba59353ee3aa2469554c4": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\ts        []float64\n\t\tf        func(float64) bool\n\t\tk        int\n\t\twantInds []int\n\t\twantErr  error\n\t}\n\ttestCases := []testCase{\n\t\t// Empty slice cases\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        0,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        2,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\ts:        []float64{},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        -1,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Positive k, sufficient elements\n\t\t{\n\t\t\ts:        []float64{0, 1, 2, -1, 4},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        2,\n\t\t\twantInds: []int{1, 2},\n\t\t\twantErr:  nil,\n\t\t},\n\t\t// Positive k, insufficient elements\n\t\t{\n\t\t\ts:        []float64{0, 1, 2, -1, 4},\n\t\t\tf:        func(v float64) bool { return v \u003e 2 },\n\t\t\tk:        2,\n\t\t\twantInds: []int{4},\n\t\t\twantErr:  errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Negative k, returns all elements\n\t\t{\n\t\t\ts:        []float64{0, 1, 2, -1, 4},\n\t\t\tf:        func(v float64) bool { return v \u003e 0 },\n\t\t\tk:        -1,\n\t\t\twantInds: []int{1, 2, 4},\n\t\t\twantErr:  nil,\n\t\t},\n\t}\n\tfor i, tc := range testCases {\n\t\t// Test with nil inds\n\t\tinds, err := Find(nil, tc.f, tc.s, tc.k)\n\t\tif err != nil {\n\t\t\tif tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Case %d - unexpected error: %v\", i, err)\n\t\t\t} else if tc.wantErr.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"Case %d - incorrect error: Want %v, got %v\", i, tc.wantErr, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif !Equal(inds, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Case %d - incorrect indices: Want %v, got %v\", i, tc.wantInds, inds)\n\t\t\t}\n\t\t}\n\t\t// Test with non-nil inds\n\t\tinds = make([]int, 0)\n\t\tinds, err = Find(inds, tc.f, tc.s, tc.k)\n\t\tif err != nil {\n\t\t\tif tc.wantErr == nil {\n\t\t\t\tt.Errorf(\"Case %d - unexpected error: %v\", i, err)\n\t\t\t} else if tc.wantErr.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"Case %d - incorrect error: Want %v, got %v\", i, tc.wantErr, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif !Equal(inds, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Case %d - incorrect indices: Want %v, got %v\", i, tc.wantInds, inds)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "d0618cf3772a1cbdb3f414697491934f": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname       string\n\t\tinds       []int\n\t\tf          func(float64) bool\n\t\ts          []float64\n\t\tk          int\n\t\twantInds   []int\n\t\twantErr    error\n\t\twantIndsOK bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:       \"Nil inds, k = 0\",\n\t\t\tinds:       nil,\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          0,\n\t\t\twantInds:   []int{},\n\t\t\twantErr:    nil,\n\t\t\twantIndsOK: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-nil inds, k = 0\",\n\t\t\tinds:       make([]int, 10),\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          0,\n\t\t\twantInds:   []int{},\n\t\t\twantErr:    nil,\n\t\t\twantIndsOK: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"k \u003c 0, inds nil\",\n\t\t\tinds:       nil,\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          -1,\n\t\t\twantInds:   []int{0, 1, 2, 3},\n\t\t\twantErr:    nil,\n\t\t\twantIndsOK: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"k \u003c 0, inds non-nil\",\n\t\t\tinds:       make([]int, 10),\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          -1,\n\t\t\twantInds:   []int{0, 1, 2, 3},\n\t\t\twantErr:    nil,\n\t\t\twantIndsOK: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"k \u003e 0, inds nil, k found\",\n\t\t\tinds:       nil,\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          4,\n\t\t\twantInds:   []int{0, 1, 2, 3},\n\t\t\twantErr:    nil,\n\t\t\twantIndsOK: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"k \u003e 0, inds non-nil, k found\",\n\t\t\tinds:       make([]int, 10),\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          4,\n\t\t\twantInds:   []int{0, 1, 2, 3},\n\t\t\twantErr:    nil,\n\t\t\twantIndsOK: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"k \u003e 0, inds nil, k not found\",\n\t\t\tinds:       nil,\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          5,\n\t\t\twantInds:   nil,\n\t\t\twantErr:    errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsOK: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"k \u003e 0, inds non-nil, k not found\",\n\t\t\tinds:       make([]int, 10),\n\t\t\tf:          func(f float64) bool { return f \u003e 0 },\n\t\t\ts:          []float64{1, 2, 3, 4},\n\t\t\tk:          5,\n\t\t\twantInds:   nil,\n\t\t\twantErr:    errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsOK: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\n\t\t\tif tc.wantIndsOK {\n\t\t\t\tif len(gotInds) != len(tc.wantInds) {\n\t\t\t\t\tt.Fatalf(\"length of gotInds = %d, want %d\", len(gotInds), len(tc.wantInds))\n\t\t\t\t}\n\n\t\t\t\tfor i := range tc.wantInds {\n\t\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\t\tt.Errorf(\"gotInds[%d] = %d, want %d\", i, gotInds[i], tc.wantInds[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif gotErr != tc.wantErr {\n\t\t\t\tt.Errorf(\"got error %v, want %v\", gotErr, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n\n}\n",
    "d1ae84045c77da5ac561a7f186238cb5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttol := 1e-15\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn         int\n\t\tl, u, v float64\n\t\twant      int\n\t}{\n\t\t// Simple cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{2, 1, 0, 0, 1},\n\t\t{2, 1, 0, 1, 0},\n\n\t\t// Cases with NaN and Inf\n\t\t{2, math.NaN(), 1, 0.5, 0},\n\t\t{2, 0, math.NaN(), 0.5, 1},\n\t\t{2, math.Inf(1), 0, 0.5, 1},\n\t\t{2, 0, math.Inf(1), 0.5, 0},\n\t\t{2, math.Inf(-1), 0, 0.5, 1},\n\t\t{2, 0, math.Inf(-1), 0.5, 0},\n\t\t{2, math.Inf(1), math.Inf(1), 0.5, 0},\n\t\t{3, math.Inf(1), math.Inf(1), 0.5, 1},\n\n\t\t// Cases with large n\n\t\t{1000, 0, 1, 0.5, 500},\n\t\t{1001, 0, 1, 0.5, 500},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\n\t\t// Test equivalence with Nearest\n\t\tspan := Span(make([]float64, tc.n), tc.l, tc.u)\n\t\twant := NearestIdx(span, tc.v)\n\t\tif got != want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, but Nearest(%v, %v) = %v\", i, tc.n, tc.l, tc.u, tc.v, got, span, tc.v, want)\n\t\t}\n\t}\n}\n",
    "d1e51f3ebef2601345a50316d8222b28": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\tt.Parallel()\n\tfor i := 0; i \u003c 10; i++ {\n\t\tfor j := -5; j \u003c= 5; j++ {\n\t\t\ts := make([]float64, i)\n\t\t\tfor k := range s {\n\t\t\t\ts[k] = float64(j)\n\t\t\t}\n\t\t\tgot := LogSumExp(s)\n\t\t\twant := math.Log(float64(i)) + float64(j)\n\t\t\tif !EqualApprox([]float64{got}, []float64{want}, 1e-15) {\n\t\t\t\tt.Errorf(\"Case len(s)=%d, all values = %f: got %v, want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test case with infinity\n\tsInf := []float64{math.Inf(1)}\n\tgotInf := LogSumExp(sInf)\n\tif !math.IsInf(gotInf, 1) {\n\t\tt.Errorf(\"Case s=[+Inf]: got %v, want +Inf\", gotInf)\n\t}\n\n\t// Test case with NaN\n\tsNaN := []float64{math.NaN()}\n\tgotNaN := LogSumExp(sNaN)\n\tif !math.IsNaN(gotNaN) {\n\t\tt.Errorf(\"Case s=[NaN]: got %v, want NaN\", gotNaN)\n\t}\n\n\t// Test empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with an empty slice\")\n\t\t}\n\t}()\n\n\tLogSumExp([]float64{})\n}",
    "d21d94f17836ef34ef6e24fe8f5c1794": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    [][]float64\n\t\texpected bool\n\t}{\n\t\t{[][]float64{}, true},                                                                  // Empty input\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}}, true},                                               // Equal lengths\n\t\t{[][]float64{{1, 2}, {3, 4, 5}}, false},                                              // Unequal lengths\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},                                  // Multiple slices, equal lengths\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}}, false},                                     // Multiple slices, unequal lengths\n\t\t{[][]float64{{1}, {2}, {3}}, true},                                                   // Single element slices, equal lengths\n\t\t{[][]float64{{1}, {2, 3}}, false},                                                  // Single element slices, unequal lengths\n\t\t{[][]float64{{1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}}, false},                         // Varying lengths\n\t\t{[][]float64{{1.1, 2.2, 3.3}, {4.4, 5.5, 6.6}}, true},                                 // Float values, equal lengths\n\t\t{[][]float64{{1.1, 2.2}, {3.3, 4.4, 5.5, 6.6}}, false},                                // Float values, unequal lengths\n\t}\n\n\t// Iterate through test cases\n\tfor i, tc := range testCases {\n\t\t// Execute the function\n\t\tactual := EqualLengths(tc.input...)\n\n\t\t// Check if the result matches the expected value\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: Expected %v, got %v\", i+1, tc.expected, actual)\n\t\t}\n\t}\n}",
    "d2d4683e15ed6c7820e9cc788de1ae6c": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tinds      []int\n\t\tf         func(float64) bool\n\t\ts         []float64\n\t\tk         int\n\t\twantInds  []int\n\t\twantErr   error\n\t\twantIndsN int\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"k=0\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(x float64) bool { return x \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         0,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"k=2, nFound=2\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(x float64) bool { return x \u003e 0 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{0, 1},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 2,\n\t\t},\n\t\t{\n\t\t\tname:      \"k=2, nFound=1\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(x float64) bool { return x \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{1},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsN: 1,\n\t\t},\n\t\t{\n\t\t\tname:      \"k=2, nFound=0\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(x float64) bool { return x \u003e 4 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         2,\n\t\t\twantInds:  []int{},\n\t\t\twantErr:   errors.New(\"floats: insufficient elements found\"),\n\t\t\twantIndsN: 0,\n\t\t},\n\t\t{\n\t\t\tname:      \"k=-1\",\n\t\t\tinds:      []int{1, 2, 3, 4},\n\t\t\tf:         func(x float64) bool { return x \u003e 1 },\n\t\t\ts:         []float64{1, 2, 3, 4},\n\t\t\tk:         -1,\n\t\t\twantInds:  []int{1, 2, 3},\n\t\t\twantErr:   nil,\n\t\t\twantIndsN: 3,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, gotErr := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (gotErr != nil \u0026\u0026 tc.wantErr == nil) || (gotErr == nil \u0026\u0026 tc.wantErr != nil) {\n\t\t\t\tt.Fatalf(\"gotErr = %v, wantErr = %v\", gotErr, tc.wantErr)\n\t\t\t}\n\t\t\tif gotErr != nil \u0026\u0026 tc.wantErr != nil \u0026\u0026 gotErr.Error() != tc.wantErr.Error() {\n\t\t\t\tt.Fatalf(\"gotErr = %v, wantErr = %v\", gotErr, tc.wantErr)\n\t\t\t}\n\t\t\tif len(gotInds) != tc.wantIndsN {\n\t\t\t\tt.Fatalf(\"length of inds = %v, want %v\", len(gotInds), tc.wantIndsN)\n\t\t\t}\n\t\t\tfor i := 0; i \u003c len(gotInds); i++ {\n\t\t\t\tif gotInds[i] != tc.wantInds[i] {\n\t\t\t\t\tt.Fatalf(\"inds[%v] = %v, want %v\", i, gotInds[i], tc.wantInds[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d3f731fcec5e030b686db890c77b0152": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice (should panic)\n\t// - NaN value\n\t// - +Inf value\n\t// - -Inf value\n\t// - Single element slice\n\t// - Multiple element slice with unique values\n\t// - Multiple element slice with duplicate values\n\n\t// Empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic with empty slice\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 0)\n\n\t// NaN value\n\ts1 := []float64{1, 2, 3, math.NaN()}\n\texpected1 := 3\n\tactual1 := NearestIdx(s1, math.NaN())\n\tif actual1 != expected1 {\n\t\tt.Errorf(\"NearestIdx failed for NaN value. Expected: %v, Actual: %v\\n\", expected1, actual1)\n\t}\n\n\t// +Inf value\n\ts2 := []float64{1, 2, 3, 4}\n\texpected2 := 3\n\tactual2 := NearestIdx(s2, math.Inf(1))\n\tif actual2 != expected2 {\n\t\tt.Errorf(\"NearestIdx failed for +Inf value. Expected: %v, Actual: %v\\n\", expected2, actual2)\n\t}\n\n\t// -Inf value\n\ts3 := []float64{1, 2, 3, 4}\n\texpected3 := 0\n\tactual3 := NearestIdx(s3, math.Inf(-1))\n\tif actual3 != expected3 {\n\t\tt.Errorf(\"NearestIdx failed for -Inf value. Expected: %v, Actual: %v\\n\", expected3, actual3)\n\t}\n\n\t// Single element slice\n\ts4 := []float64{5}\n\texpected4 := 0\n\tactual4 := NearestIdx(s4, 3)\n\tif actual4 != expected4 {\n\t\tt.Errorf(\"NearestIdx failed for single element slice. Expected: %v, Actual: %v\\n\", expected4, actual4)\n\t}\n\n\t// Multiple element slice with unique values\n\ts5 := []float64{1, 3, 5, 7, 9}\n\texpected5 := 2\n\tactual5 := NearestIdx(s5, 4)\n\tif actual5 != expected5 {\n\t\tt.Errorf(\"NearestIdx failed for multiple element slice with unique values. Expected: %v, Actual: %v\\n\", expected5, actual5)\n\t}\n\n\t// Multiple element slice with duplicate values\n\ts6 := []float64{1, 3, 5, 5, 7, 9}\n\texpected6 := 2\n\tactual6 := NearestIdx(s6, 6)\n\tif actual6 != expected6 {\n\t\tt.Errorf(\"NearestIdx failed for multiple element slice with duplicate values. Expected: %v, Actual: %v\\n\", expected6, actual6)\n\t}\n}",
    "d472e2d93552a6c0dda8754ae8121fc6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttol := 1e-14\n\tfor i, test := range []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\tans []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{[]float64{0, 0}, -1, 1, []float64{-1, 1}},\n\t\t{[]float64{0, 0, 0}, -1, 1, []float64{-1, 0, 1}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -1.0 / 3.0, 1.0 / 3.0, 1}},\n\t\t{[]float64{0, 0}, 1, 0, []float64{1, 0}},\n\t\t{[]float64{0, 0, 0}, 1, 0, []float64{1, 0.5, 0}},\n\t\t{[]float64{0, 0, 0, 0}, 1, 0, []float64{1, 2.0 / 3.0, 1.0 / 3.0, 0}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 0, []float64{1, 0.75, 0.5, 0.25, 0}},\n\n\t\t{make([]float64, 10), -math.Inf(1), math.Inf(1), []float64{-math.Inf(1), -math.Inf(1), -math.Inf(1), -math.Inf(1), -math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{make([]float64, 9), -math.Inf(1), math.Inf(1), []float64{-math.Inf(1), -math.Inf(1), -math.Inf(1), -math.Inf(1), 0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t} {\n\t\tSpan(test.dst, test.l, test.u)\n\t\tfor j := range test.dst {\n\t\t\tif !EqualWithinAbsOrRel(test.dst[j], test.ans[j], tol, tol) {\n\t\t\t\tt.Errorf(\"Test %d, subtest %d:  Expected %v, but got %v.\\n\", i, j, test.ans, test.dst)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpanNaNs(t *testing.T) {\n\ts := make([]float64, 4)\n\tSpan(s, 0, math.NaN())\n\tif !math.IsNaN(s[0]) || !math.IsNaN(s[1]) || !math.IsNaN(s[2]) || !math.IsNaN(s[3]) {\n\t\tt.Errorf(\"Expected NaNs, got %v\", s)\n\t}\n\n\tSpan(s, math.NaN(), 0)\n\tif math.IsNaN(s[0]) || !math.IsNaN(s[1]) || !math.IsNaN(s[2]) || !math.IsNaN(s[3]) {\n\t\tt.Errorf(\"Expected only first element to not be NaN, got %v\", s)\n\t}\n}",
    "d54d5f470d5f7010a1f68fb43aacbcd4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t// - n \u003c 2\n\t// - math.IsNaN(v)\n\t// - math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(u, 0) \u0026\u0026 l == u\n\t// - math.IsInf(u, 0) \u0026\u0026 n%2 == 1 \u0026\u0026 !math.IsInf(v, 0)\n\t// - math.IsInf(u, 0) \u0026\u0026 n%2 == 1 \u0026\u0026 math.IsInf(v, 0) \u0026\u0026 math.Copysign(1, v) == math.Copysign(1, l)\n\t// - math.IsInf(u, 0) \u0026\u0026 n%2 == 1 \u0026\u0026 math.IsInf(v, 0) \u0026\u0026 math.Copysign(1, v) != math.Copysign(1, l)\n\t// - math.IsInf(u, 0) \u0026\u0026 n%2 == 0 \u0026\u0026 math.Copysign(1, v) == math.Copysign(1, l)\n\t// - math.IsInf(u, 0) \u0026\u0026 n%2 == 0 \u0026\u0026 math.Copysign(1, v) != math.Copysign(1, l)\n\t// - math.IsInf(l, 0) \u0026\u0026 v == l\n\t// - math.IsInf(l, 0) \u0026\u0026 v != l\n\t// - math.IsInf(u, 0) \u0026\u0026 v == u\n\t// - math.IsInf(u, 0) \u0026\u0026 v != u\n\t// - math.IsInf(v, -1) \u0026\u0026 l \u003c= u\n\t// - math.IsInf(v, -1) \u0026\u0026 l \u003e u\n\t// - math.IsInf(v, 1) \u0026\u0026 u \u003c= l\n\t// - math.IsInf(v, 1) \u0026\u0026 u \u003e l\n\t// - l \u003c u \u0026\u0026 v \u003c= l\n\t// - l \u003c u \u0026\u0026 v \u003e= u\n\t// - l \u003e u \u0026\u0026 v \u003e= l\n\t// - l \u003e u \u0026\u0026 v \u003c= u\n\t// - l == u\n\t// - general case\n\n\t// n \u003c 2\n\tfor n := 0; n \u003c 2; n++ {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, 0, 1, 0) did not panic\", n)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tNearestIdxForSpan(n, 0, 1, 0)\n\t\t}()\n\t}\n\n\t// math.IsNaN(v)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 0, 1, math.NaN())\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, 1, NaN) = 0, got %v\", n, idx)\n\t\t}\n\t}\n\n\t// math.IsNaN(l) \u0026\u0026 !math.IsNaN(u)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, math.NaN(), 1, 0)\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, NaN, 1, 0) = %v, got %v\", n, n-1, idx)\n\t\t}\n\t}\n\n\t// math.IsNaN(u)\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 0, math.NaN(), 0)\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, NaN, 0) = 0, got %v\", n, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 l == u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{math.Inf(1), math.Inf(-1)} {\n\t\t\tidx := NearestIdxForSpan(n, l, l, 0)\n\t\t\tif idx != 0 {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, 0) = 0, got %v\", n, l, l, idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 n%2 == 1 \u0026\u0026 !math.IsInf(v, 0)\n\tfor n := 3; n \u003c 10; n += 2 {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tfor _, u := range []float64{math.Inf(1), math.Inf(-1)} {\n\t\t\t\tidx := NearestIdxForSpan(n, l, u, 0)\n\t\t\t\tif idx != n/2 {\n\t\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, 0) = %v, got %v\", n, l, u, n/2, idx)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 n%2 == 1 \u0026\u0026 math.IsInf(v, 0) \u0026\u0026 math.Copysign(1, v) == math.Copysign(1, l)\n\tfor n := 3; n \u003c 10; n += 2 {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tu := math.Copysign(math.Inf(1), float64(l))\n\t\t\tv := math.Copysign(math.Inf(1), float64(l))\n\t\t\tidx := NearestIdxForSpan(n, l, u, v)\n\t\t\tif idx != 0 {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, %v) = 0, got %v\", n, l, u, v, idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 n%2 == 1 \u0026\u0026 math.IsInf(v, 0) \u0026\u0026 math.Copysign(1, v) != math.Copysign(1, l)\n\tfor n := 3; n \u003c 10; n += 2 {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tu := math.Copysign(math.Inf(1), float64(l))\n\t\t\tv := -math.Copysign(math.Inf(1), float64(l))\n\t\t\tidx := NearestIdxForSpan(n, l, u, v)\n\t\t\tif idx != n/2+1 {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, %v) = %v, got %v\", n, l, u, v, n/2+1, idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 n%2 == 0 \u0026\u0026 math.Copysign(1, v) == math.Copysign(1, l)\n\tfor n := 2; n \u003c 10; n += 2 {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tu := math.Copysign(math.Inf(1), float64(l))\n\t\t\tv := math.Copysign(math.Inf(1), float64(l))\n\t\t\tidx := NearestIdxForSpan(n, l, u, v)\n\t\t\tif idx != 0 {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, %v) = 0, got %v\", n, l, u, v, idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 n%2 == 0 \u0026\u0026 math.Copysign(1, v) != math.Copysign(1, l)\n\tfor n := 2; n \u003c 10; n += 2 {\n\t\tfor _, l := range []float64{-1, 1} {\n\t\t\tu := math.Copysign(math.Inf(1), float64(l))\n\t\t\tv := -math.Copysign(math.Inf(1), float64(l))\n\t\t\tidx := NearestIdxForSpan(n, l, u, v)\n\t\t\tif idx != n/2 {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, %v) = %v, got %v\", n, l, u, v, n/2, idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 v == l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tl := math.Inf(-1)\n\t\tidx := NearestIdxForSpan(n, l, 1, l)\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, 1, %v) = 0, got %v\", n, l, l, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(l, 0) \u0026\u0026 v != l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tl := math.Inf(-1)\n\t\tidx := NearestIdxForSpan(n, l, 1, 0)\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, 1, 0) = %v, got %v\", n, l, n-1, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 v == u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tu := math.Inf(1)\n\t\tidx := NearestIdxForSpan(n, 0, u, u)\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, %v, %v) = %v, got %v\", n, u, u, n-1, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(u, 0) \u0026\u0026 v != u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tu := math.Inf(1)\n\t\tidx := NearestIdxForSpan(n, 0, u, 0)\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, %v, 0) = 0, got %v\", n, u, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(v, -1) \u0026\u0026 l \u003c= u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 0, 1, math.Inf(-1))\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, 1, -Inf) = 0, got %v\", n, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(v, -1) \u0026\u0026 l \u003e u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 1, 0, math.Inf(-1))\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 1, 0, -Inf) = %v, got %v\", n, n-1, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(v, 1) \u0026\u0026 u \u003c= l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 1, 0, math.Inf(1))\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 1, 0, Inf) = 0, got %v\", n, idx)\n\t\t}\n\t}\n\n\t// math.IsInf(v, 1) \u0026\u0026 u \u003e l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 0, 1, math.Inf(1))\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, 1, Inf) = %v, got %v\", n, n-1, idx)\n\t\t}\n\t}\n\n\t// l \u003c u \u0026\u0026 v \u003c= l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 0, 1, -1)\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, 1, -1) = 0, got %v\", n, idx)\n\t\t}\n\t}\n\n\t// l \u003c u \u0026\u0026 v \u003e= u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 0, 1, 2)\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 0, 1, 2) = %v, got %v\", n, n-1, idx)\n\t\t}\n\t}\n\n\t// l \u003e u \u0026\u0026 v \u003e= l\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 1, 0, 2)\n\t\tif idx != 0 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 1, 0, 2) = 0, got %v\", n, idx)\n\t\t}\n\t}\n\n\t// l \u003e u \u0026\u0026 v \u003c= u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tidx := NearestIdxForSpan(n, 1, 0, -1)\n\t\tif idx != n-1 {\n\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, 1, 0, -1) = %v, got %v\", n, n-1, idx)\n\t\t}\n\t}\n\n\t// l == u\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor _, l := range []float64{-1, 0, 1} {\n\t\t\tidx := NearestIdxForSpan(n, l, l, 0)\n\t\t\tif idx != 0 {\n\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, 0) = 0, got %v\", n, l, l, idx)\n\t\t\t}\n\t\t}\n\t}\n\n\t// general case\n\tfor n := 2; n \u003c 10; n++ {\n\t\tfor l := -10.0; l \u003c= 10.0; l += 1.0 {\n\t\t\tfor u := l; u \u003c= 10.0; u += 1.0 {\n\t\t\t\tfor v := l - 1; v \u003c= u+1; v += 0.1 {\n\t\t\t\t\tidx := NearestIdxForSpan(n, l, u, v)\n\t\t\t\t\tif idx \u003c 0 || idx \u003e= n {\n\t\t\t\t\t\tt.Errorf(\"Expected NearestIdxForSpan(%v, %v, %v, %v) in [0, %v), got %v\", n, l, u, v, n, idx)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "d54f36e019297f6ad65085cc8a881991": "package floats\n\nimport \"testing\"\n\nfunc TestEqualApprox(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3, 5}\n\ts4 := []float64{1, 2, 3}\n\n\tif !EqualApprox(s1, s2, 1e-6) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-6) to be true\", s1, s2)\n\t}\n\n\tif EqualApprox(s1, s3, 1e-6) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-6) to be false\", s1, s3)\n\t}\n\n\tif EqualApprox(s1, s4, 1e-6) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-6) to be false\", s1, s4)\n\t}\n\n}",
    "d7391925b9ae35074c2ad1cdf8cee8b0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !Equal(s1, s2) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be true\", s1, s2)\n\t}\n\n\tif Equal(s1, s3) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s3)\n\t}\n\n\tif Equal(s1, s4) {\n\t\tt.Errorf(\"Expected Equal(%v, %v) to be false\", s1, s4)\n\t}\n}",
    "d799b91a3bd21a0eb9863753a3943661": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Cases with NaN\n\t\t{3, math.NaN(), 1, 0.5, 2},\n\t\t{3, 0, math.NaN(), 0.5, 0},\n\t\t{3, 0, 1, math.NaN(), 0},\n\n\t\t// Cases with Inf\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{3, 0, math.Inf(1), math.Inf(1), 2},\n\t\t{3, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},\n\n\t\t// Cases with v outside (l, u)\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 1, 0, -1, 2},\n\t\t{3, 1, 0, 2, 0},\n\n\t\t// Cases with large n\n\t\t{1000, 0, 1, 0.25, 250},\n\t\t{1000, 0, 1, 0.75, 750},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(string(i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"Case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, expected %d\", i, tc.n, tc.l, tc.u, tc.v, idx, tc.expectedIdx)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panicking for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n",
    "d7b6ea6bd6829ec9f86229042aa6cc5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// n \u003c 2 panics.\n\t\t{1, 0, 10, 5, 0},\n\n\t\t// Cases with NaNs.\n\t\t{2, 0, 10, math.NaN(), 0},\n\t\t{2, math.NaN(), 10, 5, 1},\n\t\t{2, 0, math.NaN(), 5, 1},\n\t\t{2, math.NaN(), math.NaN(), 5, 1},\n\n\t\t// Cases with Infs.\n\t\t{2, math.Inf(-1), math.Inf(1), 5, 0},\n\t\t{2, math.Inf(1), math.Inf(-1), 5, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 5, 1},\n\t\t{3, math.Inf(1), math.Inf(-1), 5, 1},\n\t\t{2, math.Inf(-1), 10, 5, 1},\n\t\t{2, 10, math.Inf(1), 5, 0},\n\t\t{2, 10, math.Inf(-1), 5, 0},\n\t\t{2, math.Inf(1), 10, 5, 0},\n\t\t{4, math.Inf(-1), math.Inf(1), 5, 1},\n\t\t{4, math.Inf(1), math.Inf(-1), 5, 1},\n\t\t{4, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{4, math.Inf(1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{4, math.Inf(-1), math.Inf(1), math.Inf(1), 3},\n\t\t{4, math.Inf(1), math.Inf(-1), math.Inf(1), 3},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},\n\t\t{3, math.Inf(1), math.Inf(-1), math.Inf(1), 2},\n\t\t{2, 0, 0, math.Inf(1), 0},\n\n\t\t{2, -5, 5, -10, 0},\n\t\t{2, -5, 5, 10, 1},\n\t\t{2, 5, -5, -10, 1},\n\t\t{2, 5, -5, 10, 0},\n\t\t{2, -5, 5, -5, 0},\n\t\t{2, -5, 5, 5, 1},\n\t\t{2, 5, -5, 5, 0},\n\t\t{2, 5, -5, -5, 1},\n\n\t\t{2, 0, 10, 0, 0},\n\t\t{2, 0, 10, 10, 1},\n\t\t{10, 0, 10, 5, 4},\n\t} {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"unexpected result for test %d: got:%d want:%d\", i, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\tfor _, bm := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tvs   []float64\n\t}{\n\t\t{\"10_0_1\", 10, 0, 1, test.BenchValues(10000, 0, 1)},\n\t\t{\"10_1e-15_1\", 10, 1e-15, 1, test.BenchValues(10000, 1e-15, 1)},\n\t\t{\"10_-1_1\", 10, -1, 1, test.BenchValues(10000, -1, 1)},\n\t} {\n\t\tb.Run(bm.name, func(b *testing.B) {\n\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\tfor _, v := range bm.vs {\n\t\t\t\t\tNearestIdxForSpan(bm.n, bm.l, bm.u, v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d8099fc547bc3e0cba409e34e0be5d49": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l and u are NaN\n\t// - l and u are Inf\n\t// - l or u is Inf\n\n\t// len(dst) \u003c 2\n\tt.Run(\"PanicsWhenDstLessThan2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic when len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\t// l and u are regular\n\tt.Run(\"Regular\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := 5.0\n\t\texpected := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: %f, got: %f\", i, expected[i], dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is NaN\n\tt.Run(\"lIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.NaN()\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: NaN, got: %f\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Span failed at last index, expected: %f, got: %f\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is NaN\n\tt.Run(\"uIsNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.NaN()\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Span failed at first index, expected: %f, got: %f\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: NaN, got: %f\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are +Inf\n\tt.Run(\"lAnduArePlusInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := math.Inf(1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: +Inf, got: %f\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l and u are -Inf\n\tt.Run(\"lAnduAreMinusInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(-1)\n\t\tu := math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: -Inf, got: %f\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n\n\t// l is +Inf\n\tt.Run(\"lIsPlusInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := math.Inf(1)\n\t\tu := 5.0\n\t\tSpan(dst, l, u)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: +Inf, got: %f\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != u {\n\t\t\tt.Errorf(\"Span failed at last index, expected: %f, got: %f\", u, dst[len(dst)-1])\n\t\t}\n\t})\n\n\t// u is -Inf\n\tt.Run(\"uIsMinusInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl := 1.0\n\t\tu := math.Inf(-1)\n\t\tSpan(dst, l, u)\n\t\tif dst[0] != l {\n\t\t\tt.Errorf(\"Span failed at first index, expected: %f, got: %f\", l, dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i], -1) {\n\t\t\t\tt.Errorf(\"Span failed at index %d, expected: -Inf, got: %f\", i, dst[i])\n\t\t\t}\n\t\t}\n\t})\n}",
    "d91536c4291955fa1cb968ab179e0f7a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},     // v falls exactly in the middle\n\t\t{3, 0, 1, 0.3, 1},     // v falls closer to the lower third\n\t\t{4, 0, 1, 0.8, 3},     // v falls closer to the upper third\n\t\t{10, 0, 1, 0.25, 2},    // v falls exactly on a point\n\t\t{10, 0, 1, -0.1, 0},   // v is less than l\n\t\t{10, 0, 1, 1.1, 9},    // v is greater than u\n\t\t{10, 1, 0, 0.5, 7},    // l \u003e u\n\t\t{10, 1, 0, 1.1, 0},    // l \u003e u, v \u003e l\n\t\t{10, 1, 0, -0.1, 9},   // l \u003e u, v \u003c u\n\t\t{2, 0, 0, 0.5, 0},     // l == u\n\t\t{3, 0, 0, 0.5, 1},     // l == u, n % 3 == 1\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5}, // l = -Inf, u = Inf\n\t\t{10, math.Inf(-1), math.Inf(1), 1, 5}, // l = -Inf, u = Inf\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5}, // l = -Inf, u = Inf, n % 3 == 1\n\t\t{11, math.Inf(-1), math.Inf(1), 1, 5}, // l = -Inf, u = Inf, n % 3 == 1\n\t\t{10, math.NaN(), 1, 0.5, 9},           // l is NaN\n\t\t{10, 0, math.NaN(), 0.5, 0},           // u is NaN\n\t\t{10, 0, 1, math.NaN(), 0},             // v is NaN\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},  // l = v = -Inf\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},   // u = v = Inf\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n",
    "d9c055ec104c56718a9f735546ef9f34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{10, 0, 1, -1, 0},\n\t\t{10, 0, 1, 2, 9},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t\t{10, math.NaN(), 1, 0.5, 9},\n\t\t{10, 0, math.NaN(), 0.5, 0},\n\t\t{10, math.Inf(-1), math.Inf(1), 0.5, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 10, 0, 5, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), 0.5, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(1), 10},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}",
    "db0efa97eac5aa38beace3d862c72995": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: 0, u: 1, v: -1, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: -0.1, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.1, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.5, i: 0},\n\t\t{n: 2, l: 0, u: 1, v: 0.9, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 1.1, i: 1},\n\t\t{n: 2, l: 0, u: 1, v: 2, i: 1},\n\n\t\t{n: 3, l: 0, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: 0, u: 1, v: -0.1, i: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0, i: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.1, i: 0},\n\t\t{n: 3, l: 0, u: 1, v: 0.5, i: 1},\n\t\t{n: 3, l: 0, u: 1, v: 0.9, i: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: 0, u: 1, v: 1.1, i: 2},\n\t\t{n: 3, l: 0, u: 1, v: 2, i: 2},\n\n\t\t{n: 2, l: 1, u: 0, v: -1, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: -0.1, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.1, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.5, i: 1},\n\t\t{n: 2, l: 1, u: 0, v: 0.9, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 1.1, i: 0},\n\t\t{n: 2, l: 1, u: 0, v: 2, i: 0},\n\n\t\t{n: 3, l: 1, u: 0, v: -1, i: 2},\n\t\t{n: 3, l: 1, u: 0, v: -0.1, i: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0, i: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.1, i: 2},\n\t\t{n: 3, l: 1, u: 0, v: 0.5, i: 1},\n\t\t{n: 3, l: 1, u: 0, v: 0.9, i: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1, i: 0},\n\t\t{n: 3, l: 1, u: 0, v: 1.1, i: 0},\n\t\t{n: 3, l: 1, u: 0, v: 2, i: 0},\n\n\t\t// Test cases where the span covers zero.\n\t\t{n: 5, l: -1, u: 1, v: -1.25, i: 0},\n\t\t{n: 5, l: -1, u: 1, v: -0.75, i: 0},\n\t\t{n: 5, l: -1, u: 1, v: -0.25, i: 1},\n\t\t{n: 5, l: -1, u: 1, v: 0.25, i: 3},\n\t\t{n: 5, l: -1, u: 1, v: 0.75, i: 4},\n\t\t{n: 5, l: -1, u: 1, v: 1.25, i: 4},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d l=%v u=%v v=%v: got index %d want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanNaN(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: 0, u: 1, i: 0},\n\t\t{n: 2, l: 1, u: 0, i: 0},\n\t\t{n: 2, l: 0, u: math.NaN(), i: 0},\n\t\t{n: 2, l: math.NaN(), u: 0, i: 1},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, math.NaN())\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d l=%v u=%v: got index %d want %d\",\n\t\t\t\ttest.n, test.l, test.u, i, test.i)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanInf(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t// Cases where at least one bound is infinite.\n\t\t{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 3, l: math.Inf(-1), u: 0, v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\n\t\t// Cases where the value is infinite.\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(1), i: 1},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(1), i: 0},\n\t\t{n: 2, l: 0, u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: 1, u: 0, v: math.Inf(-1), i: 1},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(1), i: 2},\n\t\t{n: 3, l: 1, u: 0, v: math.Inf(1), i: 0},\n\t\t{n: 3, l: 0, u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: 1, u: 0, v: math.Inf(-1), i: 2},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n=%d l=%v u=%v v=%v: got index %d want %d\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n}\n\nfunc BenchmarkNearestIdxForSpan(b *testing.B) {\n\tfor _, bench := range []struct {\n\t\tname string\n\t\tn    int\n\t}{\n\t\t{\"small\", 4},\n\t\t{\"medium\", 1024},\n\t\t{\"large\", 1 \u003c\u003c 20},\n\t} {\n\t\tb.Run(bench.name, func(b *testing.B) {\n\t\t\tl := float64(-2)\n\t\t\tu := float64(3)\n\t\t\ts := Span(make([]float64, bench.n), l, u)\n\t\t\tv := make([]float64, len(s))\n\t\t\trnd := testlapack.NewRand()\n\t\t\tfor i := range v {\n\t\t\t\tv[i] = rnd.NormFloat64()\n\t\t\t}\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i \u003c b.N; i++ {\n\t\t\t\tfor j := range v {\n\t\t\t\t\tNearestIdxForSpan(bench.n, l, u, v[j])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "dc0c51f114dd31f4e8df118530ca14e5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn           int\n\t\tl, u, v     float64\n\t\texpectedIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.7, 3},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\n\t\t// Infinities\n\t\t{2, math.Inf(-1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{2, math.Inf(-1), 0, math.Inf(-1), 0},\n\n\t\t// NaNs\n\t\t{2, math.NaN(), 0, 0, 0},\n\t\t{2, 0, math.NaN(), 0, 1},\n\t\t{2, 0, 1, math.NaN(), 0},\n\n\t\t// Reversed bounds\n\t\t{2, 1, 0, 0.5, 0},\n\t\t{3, 1, 0, 0.7, 0},\n\t\t{3, 1, 0, 0.3, 1},\n\n\t\t// Equal bounds\n\t\t{2, 1, 1, 0, 0},\n\t\t{3, 1, 1, 1, 1},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(sf(\"Test case %d\", i), func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"For n=%v, l=%v, u=%v, v=%v, expected index %v, got %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, tc.v, tc.expectedIdx, idx)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// sf is a helper function to format strings.\nfunc sf(format string, a ...interface{}) string {\n\treturn fmt.Sprintf(format, a...)\n}",
    "dc352efe1934cd3627e87fc74681474a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\t// Test cases for MaxIdx function\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 4},\n\t\t{[]float64{5, 4, 3, 2, 1}, 0},\n\t\t{[]float64{1, 5, 3, 2, 4}, 1},\n\t\t{[]float64{-1, -2, -3, -4, -5}, 0},\n\t\t{[]float64{-5, -4, -3, -2, -1}, 4},\n\t\t{[]float64{1, 2, 3, math.NaN(), 4, 5}, 2},\n\t\t{[]float64{1, 2, math.NaN(), 3, 4, 5}, 1},\n\t}\n\n\t// Iterate over the test cases\n\tfor i, tc := range testCases {\n\t\t// Calculate the actual result\n\t\tactual := MaxIdx(tc.input)\n\n\t\t// Compare the actual result with the expected result\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v but got %v for input %v\", i+1, tc.expected, actual, tc.input)\n\t\t}\n\t}\n}",
    "dcd2c202fca790496c6f66029cca00a0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 1, []float64{0, 1}},\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 1, []float64{0, 1.0 / 3.0, 2.0 / 3.0, 1}},\n\t\t{[]float64{0, 0, 0}, 1, 3, []float64{1, 2, 3}},\n\t\t{[]float64{0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5}},\n\t\t{[]float64{0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(1)}},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\tif !Equal(got, tc.want) {\n\t\t\tt.Errorf(\"Test case %v: got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\n\tSpan(make([]float64, 1), 0, 1)\n}",
    "dcfe3ecfae6fa288d7bcd0d33508722c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-1.0, -0.6666666666666667, -0.33333333333333337, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    2.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{-2.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"BothBoundsInfinite\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    2.0,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBoundInfinite\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -2.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{-2.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"OppositeInfinities\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\n\t\t\t// Check if the lengths of slices are equal.\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Length mismatch: got %v, want %v\", len(got), len(tc.want))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check for NaN values separately, as direct comparison with NaN always results in false.\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Expected NaN at index %d, but got %v\", i, got[i])\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Value mismatch at index %d: got %v, want %v\", i, got[i], tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic when len(dst) \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic when len(dst) \u003c 2\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 1.0)\n}\n",
    "de0f41c026a90025ceeee7a8b47d9b51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, want\n\ttestCases := []struct {\n\t\tn    int\n\t\tl, u float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t// Basic cases.\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Non-uniform spans.\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, 1, 11, 6, 5},\n\n\t\t// Infinities.\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\n\t\t{10, 0, math.Inf(1), math.Inf(-1), 0},\n\t\t{10, 0, math.Inf(1), 0, 0},\n\t\t{10, 0, math.Inf(1), math.Inf(1), 9},\n\n\t\t{10, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), 0, 0, 9},\n\t\t{10, math.Inf(-1), 0, math.Inf(1), 9},\n\n\t\t// NaNs.\n\t\t{10, math.NaN(), 0, 0, 0},\n\t\t{10, 0, math.NaN(), 0, 9},\n\t\t{10, math.NaN(), math.NaN(), 0, 0},\n\t\t{10, 0, 1, math.NaN(), 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: got %v, want %v\", i, got, tc.want)\n\t\t}\n\t}\n}",
    "df7fb887ea18e4ff6789fa276836ed07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    -1.0,\n\t\t\tu:    1.0,\n\t\t\twant: []float64{-1.0, -0.3333333333333333, 0.3333333333333333, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\tdst:  make([]float64, 0),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"OneLength\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    1.0,\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBothSame\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseBothDifferent\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    0.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.want != nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v,%v,%v) panicked unexpectedly\", tc.dst, tc.l, tc.u)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif tc.want == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(got) != len(tc.want) {\n\t\t\t\tt.Errorf(\"Got length %d, want %d\", len(got), len(tc.want))\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif math.IsNaN(tc.want[i]) {\n\t\t\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\t\t\tt.Errorf(\"Got %v at index %d, want NaN\", got[i], i)\n\t\t\t\t\t}\n\t\t\t\t} else if math.IsInf(tc.want[i], 0) {\n\t\t\t\t\tif !math.IsInf(got[i], 0) {\n\t\t\t\t\t\tt.Errorf(\"Got %v at index %d, want Inf\", got[i], i)\n\t\t\t\t\t}\n\t\t\t\t} else if got[i] != tc.want[i] {\n\t\t\t\t\tt.Errorf(\"Got %v at index %d, want %v\", got[i], i, tc.want[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0511d81fad1093714fcf21a2a02a933": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty slice\", args{[]float64{}}, 1},\n\t\t{\"one element\", args{[]float64{2}}, 2},\n\t\t{\"multiple elements\", args{[]float64{2, 3, 4}}, 24},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0de08f91bb8621093aea8a6f6895828": "package floats\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\t// Test case 1: Empty slice.\n\tdst := []float64{}\n\tinds := make([]int, len(dst))\n\tArgsort(dst, inds)\n\tif len(dst) != 0 || len(inds) != 0 {\n\t\tt.Errorf(\"TestArgsort: Case 1 Failed: Expected empty slices, got dst = %v, inds = %v\", dst, inds)\n\t}\n\n\t// Test case 2: Slice with unique elements.\n\tdst = []float64{3, 1, 4, 2}\n\tinds = make([]int, len(dst))\n\tArgsort(dst, inds)\n\tif !Equal(dst, []float64{1, 2, 3, 4}) {\n\t\tt.Errorf(\"TestArgsort: Case 2 Failed: Expected dst = %v, got dst = %v\", []float64{1, 2, 3, 4}, dst)\n\t}\n\tif !EqualInt(inds, []int{1, 3, 0, 2}) {\n\t\tt.Errorf(\"TestArgsort: Case 2 Failed: Expected inds = %v, got inds = %v\", []int{1, 3, 0, 2}, inds)\n\t}\n\n\t// Test case 3: Slice with duplicate elements.\n\tdst = []float64{2, 3, 1, 4, 1}\n\tinds = make([]int, len(dst))\n\tArgsort(dst, inds)\n\tif !Equal(dst, []float64{1, 1, 2, 3, 4}) {\n\t\tt.Errorf(\"TestArgsort: Case 3 Failed: Expected dst = %v, got dst = %v\", []float64{1, 1, 2, 3, 4}, dst)\n\t}\n\tif !EqualInt(inds, []int{2, 4, 0, 1, 3}) {\n\t\tt.Errorf(\"TestArgsort: Case 3 Failed: Expected inds = %v, got inds = %v\", []int{2, 4, 0, 1, 3}, inds)\n\t}\n\n\t// Test case 4: Random slice.\n\trand.Seed(1)\n\tn := 100\n\tdst = make([]float64, n)\n\tfor i := range dst {\n\t\tdst[i] = rand.Float64()\n\t}\n\torigDst := make([]float64, len(dst))\n\tcopy(origDst, dst)\n\tinds = make([]int, len(dst))\n\tArgsort(dst, inds)\n\tfor i := 1; i \u003c n; i++ {\n\t\tif dst[i-1] \u003e dst[i] {\n\t\t\tt.Errorf(\"TestArgsort: Case 4 Failed: dst is not sorted\")\n\t\t}\n\t}\n\tfor i := range dst {\n\t\tif dst[i] != origDst[inds[i]] {\n\t\t\tt.Errorf(\"TestArgsort: Case 4 Failed: inds does not track original positions\")\n\t\t}\n\t}\n}\n\nfunc EqualInt(s1, s2 []int) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "e23f0499b54dde9b7d452678e119f319": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases: n, l, u, v, expected index\n\ttestCases := []struct {\n\t\tn         int\n\t\tl, u, v   float64\n\t\twantIdx int\n\t}{\n\t\t// Basic cases\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 1},\n\t\t{4, 0, 1, 0.8, 3},\n\n\t\t// Edge cases\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\n\t\t// Reversed bounds\n\t\t{2, 1, 0, 0.5, 0},\n\t\t{3, 1, 0, 0.7, 0},\n\t\t{4, 1, 0, 0.2, 3},\n\n\t\t// Infinite bounds\n\t\t{2, 0, math.Inf(1), 1, 0},\n\t\t{2, math.Inf(-1), 0, -1, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\n\t\t// NaN cases\n\t\t{2, 0, 1, math.NaN(), 0},\n\t\t{3, math.NaN(), 1, 0.5, 2},\n\t\t{3, 0, math.NaN(), 0.5, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tgotIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif gotIdx != tc.wantIdx {\n\t\t\tt.Errorf(\"Test case %d failed: NearestIdxForSpan(%d, %v, %v, %v) = %d, want %d\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, gotIdx, tc.wantIdx)\n\t\t}\n\t}\n}\n",
    "e25ace83e9153cf53faa9bc86e8579de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2.1,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"basic decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    1.9,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"first element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"last element\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    4.1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"at n/2 -1, n odd\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.9,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"at n/2, n odd\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"at n/2 - 1, n even\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    1.9,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"at n/2, n even\",\n\t\t\tn:    4,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value for increasing\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value for decreasing\",\n\t\t\tn:    5,\n\t\t\tl:    4,\n\t\t\tu:    0,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"unexpected index for NearestIdxForSpan(%d, %v, %v, %v): got: %d want: %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n\ttest.Panics(t, \"shortSpan\", func() {\n\t\tNearestIdxForSpan(1, 0, 1, 0)\n\t})\n}\n",
    "e36e2d6500656f6ab7d05eebfb5207f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"EmptySlice\", args{[]float64{}, 0}, 0}, // Should panic\n\t\t{\"NaNValue\", args{[]float64{1, 2, 3}, math.NaN()}, 0},\n\t\t{\"PositiveInfinity\", args{[]float64{1, 2, 3}, math.Inf(1)}, 2},\n\t\t{\"NegativeInfinity\", args{[]float64{1, 2, 3}, math.Inf(-1)}, 0},\n\t\t{\"ExactMatch\", args{[]float64{1, 2, 3}, 2}, 1},\n\t\t{\"NearestLower\", args{[]float64{1, 2, 3}, 1.5}, 1},\n\t\t{\"NearestUpper\", args{[]float64{1, 2, 3}, 2.5}, 2},\n\t\t{\"MultipleNearest\", args{[]float64{1, 2, 2, 3}, 2.5}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif tt.name == \"EmptySlice\" {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx() did not panic on empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e3d4b6f7a4af707bc819ae7f7d99fff2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\t// Test cases for different L values and slices\n\ttestCases := []struct {\n\t\ts []float64\n\t\tL float64\n\t\texpected float64\n\t}{\n\t\t// Empty slice\n\t\t{[]float64{}, 1, 0},\n\t\t// L = 1\n\t\t{[]float64{1, 2, 3, 4}, 1, 10},\n\t\t{[]float64{-1, -2, -3, -4}, 1, 10},\n\t\t{[]float64{1, -2, 3, -4}, 1, 10},\n\t\t// L = 2\n\t\t{[]float64{1, 2, 3, 4}, 2, math.Sqrt(30)},\n\t\t{[]float64{-1, -2, -3, -4}, 2, math.Sqrt(30)},\n\t\t{[]float64{1, -2, 3, -4}, 2, math.Sqrt(30)},\n\t\t// L = Inf\n\t\t{[]float64{1, 2, 3, 4}, math.Inf(1), 4},\n\t\t{[]float64{-1, -2, -3, -4}, math.Inf(1), 4},\n\t\t{[]float64{1, -2, 3, -4}, math.Inf(1), 4},\n\t\t// L = 3\n\t\t{[]float64{1, 2, 3, 4}, 3, math.Pow(100, 1.0/3.0)},\n\t}\n\n\t// Iterate over test cases and compare results\n\tfor _, tc := range testCases {\n\t\tactual := Norm(tc.s, tc.L)\n\t\tif !EqualApprox([]float64{actual}, []float64{tc.expected}, 1e-15) {\n\t\t\tt.Errorf(\"Norm(%v, %v) = %v, expected %v\", tc.s, tc.L, actual, tc.expected)\n\t\t}\n\t}\n}\n",
    "e3debfe533834eb7a925993f5da8abed": "package floats\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tfor i := 0; i \u003c 100; i++ {\n\t\tn := rand.Intn(100)\n\t\tdst := make([]float64, n)\n\t\tfor i := range dst {\n\t\t\tdst[i] = rand.Float64()\n\t\t}\n\t\tinds := make([]int, n)\n\t\tArgsort(dst, inds)\n\t\tif !isSorted(dst) {\n\t\t\tt.Errorf(\"floats.Argsort() failed to sort dst in increasing order\")\n\t\t}\n\t\tif !permutation(inds, n) {\n\t\t\tt.Errorf(\"floats.Argsort() failed to provide valid permutation\")\n\t\t}\n\t}\n}\n\nfunc isSorted(x []float64) bool {\n\tfor i := 1; i \u003c len(x); i++ {\n\t\tif x[i-1] \u003e x[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc permutation(inds []int, n int) bool {\n\tif len(inds) != n {\n\t\treturn false\n\t}\n\tseen := make([]bool, n)\n\tfor _, v := range inds {\n\t\tif v \u003c 0 || v \u003e= n {\n\t\t\treturn false\n\t\t}\n\t\tif seen[v] {\n\t\t\treturn false\n\t\t}\n\t\tseen[v] = true\n\t}\n\treturn true\n}",
    "e46741c04a2ae3e8fb5d63a0dfcf1389": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twant     int\n\t\twantPanic bool\n\t}{\n\t\t{[]float64{0, 1}, 0.5, 0, false},\n\t\t{[]float64{0, 1}, 0.0, -1, false},\n\t\t{[]float64{0, 1}, 1.0, -1, false},\n\t\t{[]float64{0, 1}, -1e-15, -1, false},\n\t\t{[]float64{0, 1}, 1 + 1e-15, -1, false},\n\t\t{[]float64{0, 1, 2}, 0.5, 0, false},\n\t\t{[]float64{0, 1, 2}, 1.5, 1, false},\n\t\t{[]float64{-1, -0.5, -0.1}, -0.6, 0, false},\n\t\t{[]float64{0, math.NaN()}, 0.5, -1, false},\n\t\t{[]float64{}, 0.5, -1, true},\n\t\t{[]float64{0}, 0.5, -1, true},\n\t\t{[]float64{1, 0}, 0.5, -1, true},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tgotPanic := r != nil\n\t\t\t\tif gotPanic != test.wantPanic {\n\t\t\t\t\tt.Errorf(\"Test %d: input = %v, v= %v - got panic = %v, want panic = %v\",\n\t\t\t\t\t\ti, test.s, test.v, gotPanic, test.wantPanic)\n\t\t\t\t}\n\t\t\t\tif gotPanic {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Within(test.s, test.v)\n\t\t\tif test.want != got {\n\t\t\t\tt.Errorf(\"Test %d: input = %v, v= %v\\ngot: %v\\nwant:%v\",\n\t\t\t\t\ti, test.s, test.v, got, test.want)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "e4b1a35bdcaef67e0246950a70f8a28b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases with different n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.5, 0},\n\t\t{2, 0, 1, -1, 0},\n\t\t{2, 0, 1, 2, 1},\n\t\t{2, 1, 0, 0.5, 1},\n\t\t{2, 1, 0, -1, 1},\n\t\t{2, 1, 0, 2, 0},\n\n\t\t// n = 3\n\t\t{3, 0, 1, 0.33, 0},\n\t\t{3, 0, 1, 0.66, 1},\n\t\t{3, 0, 1, -1, 0},\n\t\t{3, 0, 1, 2, 2},\n\t\t{3, 1, 0, 0.66, 1},\n\t\t{3, 1, 0, 0.33, 2},\n\t\t{3, 1, 0, -1, 2},\n\t\t{3, 1, 0, 2, 0},\n\n\t\t// n = 4\n\t\t{4, 0, 1, 0.25, 0},\n\t\t{4, 0, 1, 0.5, 1},\n\t\t{4, 0, 1, 0.75, 2},\n\t\t{4, 0, 1, -1, 0},\n\t\t{4, 0, 1, 2, 3},\n\t\t{4, 1, 0, 0.75, 1},\n\t\t{4, 1, 0, 0.5, 2},\n\t\t{4, 1, 0, 0.25, 3},\n\t\t{4, 1, 0, -1, 3},\n\t\t{4, 1, 0, 2, 0},\n\n\t\t// Special cases for Inf and NaN.\n\t\t{3, math.Inf(1), math.Inf(1), 0, 0},\n\t\t{3, math.Inf(-1), math.Inf(-1), 0, 0},\n\t\t{3, math.Inf(1), math.Inf(-1), 0, 1},\n\t\t{3, math.Inf(-1), math.Inf(1), 0, 1},\n\t\t{3, math.NaN(), 0, 0, 0},\n\t\t{3, 0, math.NaN(), 0, 2},\n\t\t{3, math.Inf(1), 0, math.Inf(1), 2},\n\t\t{3, 0, math.Inf(1), math.Inf(1), 2},\n\t\t{3, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{3, 0, math.Inf(-1), math.Inf(-1), 0},\n\t}\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tassert.Equal(t, tc.want, got, \"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t}\n}",
    "e551b450b466d5af6639a408ad6d1cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - math.IsNaN(l)\n\t// - math.IsNaN(u)\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0) \u0026\u0026 len(dst)%1 == 1 \u0026\u0026 l != u\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0) \u0026\u0026 len(dst)%1 == 1 \u0026\u0026 l == u\n\t// - math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0) \u0026\u0026 len(dst)%1 == 0\n\t// - math.IsInf(l, 0)\n\t// - math.IsInf(u, 0)\n\t// - normal cases\n\n\tt.Run(\"len(dst) \u003c 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"math.IsNaN(l)\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(dst[i]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d, but got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1 at last index, but got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"math.IsNaN(u)\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 0, math.NaN())\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0 at first index, but got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(dst[i+1]) {\n\t\t\t\tt.Errorf(\"Expected NaN at index %d, but got %v\", i+1, dst[i+1])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0) \u0026\u0026 len(dst)%1 == 1 \u0026\u0026 l != u\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, but got %v\", i, dst[i])\n\t\t\t}\n\t\t\tif !math.IsInf(dst[len(dst)-i-1], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at index %d, but got %v\", len(dst)-i-1, dst[len(dst)-i-1])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)/2] != 0 {\n\t\t\tt.Errorf(\"Expected 0 at middle index, but got %v\", dst[len(dst)/2])\n\t\t}\n\t})\n\n\tt.Run(\"math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0) \u0026\u0026 len(dst)%1 == 1 \u0026\u0026 l == u\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, but got %v\", i, dst[i])\n\t\t\t}\n\t\t\tif !math.IsInf(dst[len(dst)-i-1], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, but got %v\", len(dst)-i-1, dst[len(dst)-i-1])\n\t\t\t}\n\t\t}\n\t\tif !math.IsInf(dst[len(dst)/2], 1) {\n\t\t\tt.Errorf(\"Expected +Inf at middle index, but got %v\", dst[len(dst)/2])\n\t\t}\n\t})\n\n\tt.Run(\"math.IsInf(l, 0) \u0026\u0026 math.IsInf(u, 0) \u0026\u0026 len(dst)%1 == 0\", func(t *testing.T) {\n\t\tdst := make([]float64, 4)\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, but got %v\", i, dst[i])\n\t\t\t}\n\t\t\tif !math.IsInf(dst[len(dst)-i-1], -1) {\n\t\t\t\tt.Errorf(\"Expected -Inf at index %d, but got %v\", len(dst)-i-1, dst[len(dst)-i-1])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"math.IsInf(l, 0)\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsInf(dst[i], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, but got %v\", i, dst[i])\n\t\t\t}\n\t\t}\n\t\tif dst[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Expected 1 at last index, but got %v\", dst[len(dst)-1])\n\t\t}\n\t})\n\n\tt.Run(\"math.IsInf(u, 0)\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\tif dst[0] != 0 {\n\t\t\tt.Errorf(\"Expected 0 at first index, but got %v\", dst[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsInf(dst[i+1], 1) {\n\t\t\t\tt.Errorf(\"Expected +Inf at index %d, but got %v\", i+1, dst[i+1])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"normal cases\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\tdst []float64\n\t\t\tl   float64\n\t\t\tu   float64\n\t\t}{\n\t\t\t{make([]float64, 3), 0, 2},\n\t\t\t{make([]float64, 4), -1, 3},\n\t\t\t{make([]float64, 5), -2, 2},\n\t\t}\n\t\tfor i, tc := range testCases {\n\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t\tstep := (tc.u - tc.l) / float64(len(tc.dst)-1)\n\t\t\tfor j := range tc.dst {\n\t\t\t\texpected := tc.l + step*float64(j)\n\t\t\t\tif tc.dst[j] != expected {\n\t\t\t\t\tt.Errorf(\"Test case %d: expected %v at index %d, but got %v\", i, expected, j, tc.dst[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}",
    "e56decab21bda765dea786add27026fb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/test\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twantI int\n\t}{\n\t\t{n: 2, l: 0, u: 2, v: -1, wantI: 0},\n\t\t{n: 2, l: 0, u: 2, v: 0, wantI: 0},\n\t\t{n: 2, l: 0, u: 2, v: 0.5, wantI: 0},\n\t\t{n: 2, l: 0, u: 2, v: 1, wantI: 0},\n\t\t{n: 2, l: 0, u: 2, v: 1.5, wantI: 1},\n\t\t{n: 2, l: 0, u: 2, v: 2, wantI: 1},\n\t\t{n: 2, l: 0, u: 2, v: 3, wantI: 1},\n\n\t\t{n: 2, l: 2, u: 0, v: 3, wantI: 0},\n\t\t{n: 2, l: 2, u: 0, v: 2, wantI: 0},\n\t\t{n: 2, l: 2, u: 0, v: 1.5, wantI: 0},\n\t\t{n: 2, l: 2, u: 0, v: 1, wantI: 1},\n\t\t{n: 2, l: 2, u: 0, v: 0.5, wantI: 1},\n\t\t{n: 2, l: 2, u: 0, v: 0, wantI: 1},\n\t\t{n: 2, l: 2, u: 0, v: -1, wantI: 1},\n\n\t\t{n: 10, l: 0, u: 10, v: -1, wantI: 0},\n\t\t{n: 10, l: 0, u: 10, v: 0, wantI: 0},\n\t\t{n: 10, l: 0, u: 10, v: 1, wantI: 1},\n\t\t{n: 10, l: 0, u: 10, v: 2, wantI: 2},\n\t\t{n: 10, l: 0, u: 10, v: 9, wantI: 9},\n\t\t{n: 10, l: 0, u: 10, v: 10, wantI: 9},\n\t\t{n: 10, l: 0, u: 10, v: 11, wantI: 9},\n\t} {\n\t\tgotI := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif gotI != tc.wantI {\n\t\t\tt.Errorf(\"Case %d- mismatch. Want %v, got %v\", i, tc.wantI, gotI)\n\t\t}\n\t}\n\tnans := []float64{math.NaN()}\n\tfor i := range nans {\n\t\tfor _, j := range []int{-2, -1, 0, 1, 2} {\n\t\t\tfor _, k := range []int{-2, -1, 0, 1, 2} {\n\t\t\t\tgotI := NearestIdxForSpan(2, nans[i], nans[i], 0)\n\t\t\t\tif gotI != 0 {\n\t\t\t\t\tt.Errorf(\"NaNs produced unexpected result\")\n\t\t\t\t}\n\t\t\t\tgotI = NearestIdxForSpan(2, float64(j), nans[i], 0)\n\t\t\t\tif gotI != 0 {\n\t\t\t\t\tt.Errorf(\"NaNs produced unexpected result\")\n\t\t\t\t}\n\t\t\t\tgotI = NearestIdxForSpan(2, nans[i], float64(k), 0)\n\t\t\t\tif gotI != 1 {\n\t\t\t\t\tt.Errorf(\"NaNs produced unexpected result\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinfs := []float64{math.Inf(-1), math.Inf(1)}\n\tfor i := range infs {\n\t\tfor j := range infs {\n\t\t\tfor _, k := range []float64{-1, 0, 1} {\n\t\t\t\tgotI := NearestIdxForSpan(2, infs[i], infs[j], k)\n\t\t\t\tif gotI != 0 {\n\t\t\t\t\tt.Errorf(\"Infs produced unexpected result\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{-2, -1, 0, 1} {\n\t\ttest.Panic(t, \"NearestIdxForSpan\", func() { NearestIdxForSpan(n, 0, 1, 0) })\n\t}\n}\n",
    "e5e9fa216268e609baeb416605b77cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various combinations of n, l, u, and v.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\twant     int\n\t}{\n\t\t// n = 2\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{2, 1, 0, 0.5, 0},\n\t\t// n = 3\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{3, 0, 1, 0.7, 2},\n\t\t{3, 1, 0, 0.3, 2},\n\t\t{3, 1, 0, 0.7, 0},\n\t\t// n = 4\n\t\t{4, 0, 1, 0.2, 0},\n\t\t{4, 0, 1, 0.5, 2},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{4, 1, 0, 0.2, 3},\n\t\t{4, 1, 0, 0.5, 1},\n\t\t{4, 1, 0, 0.8, 0},\n\t\t// Special cases for Inf and NaN.\n\t\t{4, math.NaN(), 1, 0.5, 3},\n\t\t{4, 0, math.NaN(), 0.5, 0},\n\t\t{4, math.Inf(-1), math.Inf(1), 0.5, 2},\n\t\t{4, math.Inf(1), math.Inf(-1), 0.5, 1},\n\t\t{4, math.Inf(-1), math.Inf(-1), 0.5, 0},\n\t\t// Special cases for v outside (l, u) and (u, l).\n\t\t{4, 0, 1, -1, 0},\n\t\t{4, 0, 1, 2, 3},\n\t\t{4, 1, 0, -1, 3},\n\t\t{4, 1, 0, 2, 0},\n\t\t// Special cases for v exactly halfway between.\n\t\t{4, 0, 1, 0.25, 1},\n\t\t{4, 0, 1, 0.75, 2},\n\t\t{4, 1, 0, 0.25, 2},\n\t\t{4, 1, 0, 0.75, 1},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", i, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "e7908f6ba9246e52947f0c450542ee07": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"empty\", args{[]float64{}}, 1},\n\t\t{\"one\", args{[]float64{2}}, 2},\n\t\t{\"many\", args{[]float64{2, 3, 4}}, 24},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7de2bec59d8d297fc181da6f481f74b": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\ty:      []float64{1, 2, 3, 4},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{1, 1, 1, 1},\n\t\t\twant:   []float64{3, 4, 5, 6},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\ty:      []float64{1, 2, 3, 4},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{1, 1, 1},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t} {\n\t\tvar dst []float64\n\t\tif !test.panics {\n\t\t\tdst = make([]float64, len(test.y))\n\t\t}\n\t\tpanicked, msg := testlapack.CatchPanic(func() {\n\t\t\tAddScaledTo(dst, test.y, test.alpha, test.s)\n\t\t})\n\t\tif panicked != test.panics {\n\t\t\tt.Errorf(\"Test %d: Panic mismatch. Got %v, want %v\", i, panicked, test.panics)\n\t\t}\n\t\tif panicked {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := range dst {\n\t\t\tif dst[j] != test.want[j] {\n\t\t\t\tt.Errorf(\"Test %d: dst[%d] mismatch. Want %v, got %v\", i, j, test.want, dst)\n\t\t\t}\n\t\t}\n\t}\n}",
    "e8244b76a457320d0ab3b95b58a6c2da": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that panics occur as expected\n\ttestPanic := func(t *testing.T, dst []float64, l, u float64) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, l, u)\n\t}\n\tt.Run(\"TestPanics\", func(t *testing.T) {\n\t\tt.Run(\"EmptySlice\", func(t *testing.T) { testPanic(t, []float64{}, 0, 10) })\n\t\tt.Run(\"SingleElementSlice\", func(t *testing.T) { testPanic(t, []float64{1}, 0, 10) })\n\t})\n\n\ttestSpan := func(t *testing.T, dst []float64, l, u float64, expected []float64) {\n\t\tSpan(dst, l, u)\n\t\tif len(dst) != len(expected) {\n\t\t\tt.Errorf(\"Result slice has unexpected length, expected %v, got %v\", len(expected), len(dst))\n\t\t}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != expected[i] {\n\t\t\t\tt.Errorf(\"Unexpected value at position %v, expected %v, got %v\", i, expected[i], dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tt.Run(\"SimpleSpans\", func(t *testing.T) {\n\t\tt.Run(\"TwoElements\", func(t *testing.T) { testSpan(t, make([]float64, 2), 0, 10, []float64{0, 10}) })\n\t\tt.Run(\"OddElements\", func(t *testing.T) { testSpan(t, make([]float64, 5), 0, 10, []float64{0, 2.5, 5, 7.5, 10}) })\n\t\tt.Run(\"EvenElements\", func(t *testing.T) { testSpan(t, make([]float64, 6), 0, 10, []float64{0, 2, 4, 6, 8, 10}) })\n\t})\n\n\tt.Run(\"InfinitySpans\", func(t *testing.T) {\n\t\tt.Run(\"PosInf\", func(t *testing.T) { testSpan(t, make([]float64, 4), 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)}) })\n\t\tt.Run(\"NegInf\", func(t *testing.T) { testSpan(t, make([]float64, 4), math.Inf(-1), 0, []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0}) })\n\t\tt.Run(\"BothInfSame\", func(t *testing.T) { testSpan(t, make([]float64, 4), math.Inf(-1), math.Inf(-1), []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}) })\n\t\tt.Run(\"BothInfDiff\", func(t *testing.T) { testSpan(t, make([]float64, 4), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1), math.Inf(1)}) })\n\t\tt.Run(\"BothInfDiffOdd\", func(t *testing.T) { testSpan(t, make([]float64, 5), math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}) })\n\t})\n\n\tt.Run(\"NaNSpan\", func(t *testing.T) {\n\t\tt.Run(\"LowerNaN\", func(t *testing.T) { testSpan(t, make([]float64, 4), math.NaN(), 10, []float64{math.NaN(), math.NaN(), math.NaN(), 10}) })\n\t\tt.Run(\"UpperNaN\", func(t *testing.T) { testSpan(t, make([]float64, 4), 0, math.NaN(), []float64{0, math.NaN(), math.NaN(), math.NaN()}) })\n\t})\n}\n",
    "e846085b6c4d3e90047c324e42424143": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"two elements, below\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"two elements, within\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"two elements, above\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, below\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, second\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, above\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 4.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN returns -1\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif len(tt.args.s) \u003c 2 || !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\t\t\t// panic expected\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Within() panicked for valid input\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Within(tt.args.s, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e84c735c076f2f8bd8d768404cfa6161": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various inputs.\n\ttestCases := []struct {\n\t\tn        int\n\t\tl, u     float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t// Basic cases.\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\n\t\t// Edge cases.\n\t\t{2, 0, 1, 0, 0},\n\t\t{2, 0, 1, 1, 1},\n\t\t{10, 0, 1, 0.5, 5},\n\n\t\t// Cases with NaN and Inf.\n\t\t{10, math.NaN(), 10, 5, 0},\n\t\t{10, 0, math.NaN(), 5, 9},\n\t\t{10, math.Inf(-1), math.Inf(1), 5, 5},\n\t\t{10, 0, 10, math.Inf(1), 9},\n\t\t{10, 0, 10, math.Inf(-1), 0},\n\n\t\t// Cases with reversed bounds.\n\t\t{10, 10, 0, 5, 5},\n\t\t{10, 10, 0, -1, 9},\n\t\t{10, 10, 0, 11, 0},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tactual := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v, got %v\", i, tc.expected, actual)\n\t\t}\n\t}\n\n\t// Test panicking for n \u003c 2.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}",
    "eaffafaa2e0ca1f7561e224cb9d3208c": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"Empty Slice\", args{[]float64{}}, 1},\n\t\t{\"Single Element\", args{[]float64{2}}, 4},\n\t\t{\"Multiple Elements\", args{[]float64{2, 3, 4}}, 48},\n\t\t{\"Zero in Slice\", args{[]float64{2, 0, 4}}, 0},\n\t\t{\"Negative Elements\", args{[]float64{-2, 3, -4}}, 48},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2979221b37e0bc94da0f2b22cd5473": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{5, 6, 7, 8}\n\ts3 := []float64{1, 2}\n\ts4 := []float64{}\n\n\t// Test cases for L = 2\n\tif got, want := Distance(s1, s2, 2), 8; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = 1\n\tif got, want := Distance(s1, s2, 1), 16; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for L = infinity\n\tif got, want := Distance(s1, s2, math.Inf(1)), 4; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, math.Inf(1)) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for other L values\n\tif got, want := Distance(s1, s2, 3), math.Pow(96, 1.0/3); got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 3) = %v, want %v\", s1, s2, got, want)\n\t}\n\n\t// Test cases for empty slices\n\tif got, want := Distance(s4, s4, 2), 0; got != want {\n\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s4, s4, got, want)\n\t}\n\n\t// Test cases for slices with different lengths\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic with different length slices\")\n\t\t}\n\t}()\n\tDistance(s1, s3, 2)\n}\n",
    "ed4c3249384c384098afcc70d1b2cbca": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\t// Test cases with expected results\n\ttestCases := []struct {\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 15},\n\t\t{[]float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{[]float64{1e-10, 1e-10, 1e-10, 1e-10}, 4e-10},\n\t\t{[]float64{1e10, 1, -1e10}, 1},\n\t}\n\n\t// Iterate over the test cases\n\tfor _, tc := range testCases {\n\t\t// Calculate the sum using SumCompensated\n\t\tactual := SumCompensated(tc.input)\n\n\t\t// Check if the result is within the acceptable tolerance\n\t\tif math.Abs(actual-tc.expected) \u003e 1e-14 {\n\t\t\tt.Errorf(\"SumCompensated(%v) = %v, expected %v\", tc.input, actual, tc.expected)\n\t\t}\n\t}\n}",
    "edd6222fcf0881ddecd2e6230084c628": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that a length 1 slice panics.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\ts := make([]float64, 1)\n\tSpan(s, 0, 10)\n}\n\nfunc TestSpanBasic(t *testing.T) {\n\ts := make([]float64, 2)\n\tSpan(s, 0, 10)\n\tif s[0] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[0])\n\t}\n\tif s[1] != 10 {\n\t\tt.Errorf(\"Expected 10, got %v\", s[1])\n\t}\n\ts = make([]float64, 3)\n\tSpan(s, 0, 10)\n\tif s[0] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[0])\n\t}\n\tif s[1] != 5 {\n\t\tt.Errorf(\"Expected 5, got %v\", s[1])\n\t}\n\tif s[2] != 10 {\n\t\tt.Errorf(\"Expected 10, got %v\", s[2])\n\t}\n\n\ts = make([]float64, 4)\n\tSpan(s, 0, 10)\n\tif s[0] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[0])\n\t}\n\tif s[1] != 10.0/3.0 {\n\t\tt.Errorf(\"Expected 10/3, got %v\", s[1])\n\t}\n\tif s[2] != 20.0/3.0 {\n\t\tt.Errorf(\"Expected 20/3, got %v\", s[2])\n\t}\n\tif s[3] != 10 {\n\t\tt.Errorf(\"Expected 10, got %v\", s[3])\n\t}\n}\n\nfunc TestSpanInf(t *testing.T) {\n\t// Test the infinity cases\n\ts := make([]float64, 2)\n\tSpan(s, math.Inf(1), math.Inf(1))\n\tif !math.IsInf(s[0], 1) {\n\t\tt.Errorf(\"Expected +Inf, got %v\", s[0])\n\t}\n\tif !math.IsInf(s[1], 1) {\n\t\tt.Errorf(\"Expected +Inf, got %v\", s[1])\n\t}\n\n\tSpan(s, 0, math.Inf(1))\n\tif s[0] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[0])\n\t}\n\tif !math.IsInf(s[1], 1) {\n\t\tt.Errorf(\"Expected +Inf, got %v\", s[1])\n\t}\n\n\tSpan(s, math.Inf(-1), 0)\n\tif !math.IsInf(s[0], -1) {\n\t\tt.Errorf(\"Expected -Inf, got %v\", s[0])\n\t}\n\tif s[1] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[1])\n\t}\n\n\tSpan(s, math.Inf(-1), math.Inf(1))\n\tif !math.IsInf(s[0], -1) {\n\t\tt.Errorf(\"Expected -Inf, got %v\", s[0])\n\t}\n\tif !math.IsInf(s[1], 1) {\n\t\tt.Errorf(\"Expected +Inf, got %v\", s[1])\n\t}\n\n\ts = make([]float64, 3)\n\tSpan(s, math.Inf(-1), math.Inf(1))\n\tif !math.IsInf(s[0], -1) {\n\t\tt.Errorf(\"Expected -Inf, got %v\", s[0])\n\t}\n\tif s[1] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[1])\n\t}\n\tif !math.IsInf(s[2], 1) {\n\t\tt.Errorf(\"Expected +Inf, got %v\", s[2])\n\t}\n}\n\nfunc TestSpanNaN(t *testing.T) {\n\t// Test the NaN cases\n\ts := make([]float64, 2)\n\tSpan(s, math.NaN(), math.NaN())\n\tif !math.IsNaN(s[0]) {\n\t\tt.Errorf(\"Expected NaN, got %v\", s[0])\n\t}\n\tif !math.IsNaN(s[1]) {\n\t\tt.Errorf(\"Expected NaN, got %v\", s[1])\n\t}\n\n\tSpan(s, 0, math.NaN())\n\tif s[0] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[0])\n\t}\n\tif !math.IsNaN(s[1]) {\n\t\tt.Errorf(\"Expected +Inf, got %v\", s[1])\n\t}\n\n\tSpan(s, math.NaN(), 0)\n\tif !math.IsNaN(s[0]) {\n\t\tt.Errorf(\"Expected NaN, got %v\", s[0])\n\t}\n\tif s[1] != 0 {\n\t\tt.Errorf(\"Expected 0, got %v\", s[1])\n\t}\n}\n",
    "ede839d8aa21a2a990793caf464a7fa3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 0, i: 0},\n\t\t{n: 2, l: -1, u: 1, v: 1, i: 1},\n\t\t{n: 2, l: -1, u: 1, v: 2, i: 1},\n\n\t\t{n: 3, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 3, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 3, l: -1, u: 1, v: 1, i: 2},\n\t\t{n: 3, l: -1, u: 1, v: 2, i: 2},\n\n\t\t{n: 4, l: -1, u: 1, v: -2, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: -1, i: 0},\n\t\t{n: 4, l: -1, u: 1, v: 0, i: 1},\n\t\t{n: 4, l: -1, u: 1, v: 1, i: 3},\n\t\t{n: 4, l: -1, u: 1, v: 2, i: 3},\n\n\t\t{n: 10, l: 0, u: 10, v: -1, i: 0},\n\t\t{n: 10, l: 0, u: 10, v: 0, i: 0},\n\t\t{n: 10, l: 0, u: 10, v: 1, i: 1},\n\t\t{n: 10, l: 0, u: 10, v: 9, i: 9},\n\t\t{n: 10, l: 0, u: 10, v: 10, i: 9},\n\t\t{n: 10, l: 0, u: 10, v: 11, i: 9},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got idx %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n}\nfunc TestNearestIdxForSpanNaN(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: math.NaN(), u: 1, v: 2, i: 0},\n\t\t{n: 2, l: -1, u: math.NaN(), v: 2, i: 1},\n\t\t{n: 2, l: math.NaN(), u: math.NaN(), v: 2, i: 0},\n\t\t{n: 10, l: math.NaN(), u: 1, v: 2, i: 9},\n\t\t{n: 10, l: -1, u: math.NaN(), v: 2, i: 0},\n\t\t{n: 10, l: math.NaN(), u: math.NaN(), v: 2, i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got idx %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\ti int\n\t}{\n\t\t{n: 2, l: 1, u: 10, i: 0},\n\t\t{n: 2, l: -1, u: -10, i: 0},\n\t\t{n: 2, l: -10, u: 1, i: 0},\n\t\t{n: 10, l: 1, u: 10, i: 0},\n\t\t{n: 10, l: -1, u: -10, i: 0},\n\t\t{n: 10, l: -10, u: 1, i: 0},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, math.NaN())\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = NaN: got idx %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, i, test.i)\n\t\t}\n\t}\n}\nfunc TestNearestIdxForSpanInf(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t// u == l and both inf\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t{n: 10, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1), i: 0},\n\t\t{n: 10, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1), i: 0},\n\t\t// u != l and both inf, odd n\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: -1, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 1, i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: -1, i: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 1, i: 1},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), i: 2},\n\t\t{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t\t// u != l and both inf, even n\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: -1, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 1, i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: -1, i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 1, i: 0},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), i: 1},\n\t\t{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: -1, i: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 1, i: 3},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1), i: 3},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: -1, i: 3},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: 0, i: 3},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: 1, i: 0},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1), i: 3},\n\t\t{n: 4, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1), i: 0},\n\t\t// only l inf\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: -10, i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: 0, i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: 10, i: 1},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: math.Inf(-1), u: 1, v: math.Inf(1), i: 1},\n\t\t{n: 3, l: math.Inf(-1), u: 1, v: -10, i: 2},\n\t\t{n: 3, l: math.Inf(-1), u: 1, v: 0, i: 2},\n\t\t{n: 3, l: math.Inf(-1), u: 1, v: 10, i: 2},\n\t\t{n: 3, l: math.Inf(-1), u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: math.Inf(-1), u: 1, v: math.Inf(1), i: 2},\n\t\t{n: 10, l: math.Inf(-1), u: 1, v: -10, i: 9},\n\t\t{n: 10, l: math.Inf(-1), u: 1, v: 0, i: 9},\n\t\t{n: 10, l: math.Inf(-1), u: 1, v: 10, i: 9},\n\t\t{n: 10, l: math.Inf(-1), u: 1, v: math.Inf(-1), i: 0},\n\t\t{n: 10, l: math.Inf(-1), u: 1, v: math.Inf(1), i: 9},\n\t\t// only u inf\n\t\t{n: 2, l: -1, u: math.Inf(1), v: -10, i: 0},\n\t\t{n: 2, l: -1, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 2, l: -1, u: math.Inf(1), v: 10, i: 1},\n\t\t{n: 2, l: -1, u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: -1, u: math.Inf(1), v: math.Inf(1), i: 1},\n\t\t{n: 3, l: -1, u: math.Inf(1), v: -10, i: 0},\n\t\t{n: 3, l: -1, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 3, l: -1, u: math.Inf(1), v: 10, i: 2},\n\t\t{n: 3, l: -1, u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 3, l: -1, u: math.Inf(1), v: math.Inf(1), i: 2},\n\t\t{n: 10, l: -1, u: math.Inf(1), v: -10, i: 0},\n\t\t{n: 10, l: -1, u: math.Inf(1), v: 0, i: 0},\n\t\t{n: 10, l: -1, u: math.Inf(1), v: 10, i: 9},\n\t\t{n: 10, l: -1, u: math.Inf(1), v: math.Inf(-1), i: 0},\n\t\t{n: 10, l: -1, u: math.Inf(1), v: math.Inf(1), i: 9},\n\t\t// v inf\n\t\t{n: 2, l: 1, u: 10, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: 1, u: 10, v: math.Inf(1), i: 1},\n\t\t{n: 2, l: -10, u: -1, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: -10, u: -1, v: math.Inf(1), i: 1},\n\t\t{n: 2, l: -10, u: 10, v: math.Inf(-1), i: 0},\n\t\t{n: 2, l: -10, u: 10, v: math.Inf(1), i: 1},\n\t\t{n: 10, l: 1, u: 10, v: math.Inf(-1), i: 0},\n\t\t{n: 10, l: 1, u: 10, v: math.Inf(1), i: 9},\n\t\t{n: 10, l: -10, u: -1, v: math.Inf(-1), i: 0},\n\t\t{n: 10, l: -10, u: -1, v: math.Inf(1), i: 9},\n\t\t{n: 10, l: -10, u: 10, v: math.Inf(-1), i: 0},\n\t\t{n: 10, l: -10, u: 10, v: math.Inf(1), i: 9},\n\t} {\n\t\ti := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif i != test.i {\n\t\t\tt.Errorf(\"Case n = %v, l = %v, u = %v, v = %v: got idx %v, want %v\",\n\t\t\t\ttest.n, test.l, test.u, test.v, i, test.i)\n\t\t}\n\t}\n\n}\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tfor _, n := range []int{0, 1, -1, -10} {\n\t\tpanicked := testlapack.Panics(func() { NearestIdxForSpan(n, 1, 2, 1.5) })\n\t\tif !panicked {\n\t\t\tt.Errorf(\"Expected panic for n = %v\", n)\n\t\t}\n\t}\n}\n",
    "ee11c775a2b30640658618f6276f10f9": "package floats\n\nimport \"testing\"\n\nfunc TestEqualApprox(t *testing.T) {\n\ts1 := []float64{1, 2, 3, 4}\n\ts2 := []float64{1, 2, 3, 4}\n\ts3 := []float64{1, 2, 3}\n\ts4 := []float64{1, 2, 3, 5}\n\n\tif !EqualApprox(s1, s2, 1e-10) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-10) to be true\", s1, s2)\n\t}\n\n\tif EqualApprox(s1, s3, 1e-10) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-10) to be false\", s1, s3)\n\t}\n\n\tif EqualApprox(s1, s4, 1e-10) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1e-10) to be false\", s1, s4)\n\t}\n\n\tif !EqualApprox(s1, s4, 1) {\n\t\tt.Errorf(\"Expected EqualApprox(%v, %v, 1) to be true\", s1, s4)\n\t}\n}",
    "eee73366a6b12e52db5a164b7574ac06": "package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttol := 1e-15\n\ts := []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\t// Test cases:\n\t// Find first 3 even numbers.\n\tinds, err := Find(nil, func(v float64) bool { return int(v)%2 == 0 }, s, 3)\n\tif err != nil {\n\t\tt.Errorf(\"Find returned error when it should not have: %v\", err)\n\t}\n\texpectedInds := []int{1, 3, 5}\n\tif !Equal(inds, expectedInds) {\n\t\tt.Errorf(\"Find returned incorrect indices. Expected %v, got %v.\", expectedInds, inds)\n\t}\n\t// Find all even numbers.\n\tinds, err = Find(inds, func(v float64) bool { return int(v)%2 == 0 }, s, -1)\n\tif err != nil {\n\t\tt.Errorf(\"Find returned error when it should not have: %v\", err)\n\t}\n\texpectedInds = []int{1, 3, 5, 7, 9}\n\tif !Equal(inds, expectedInds) {\n\t\tt.Errorf(\"Find returned incorrect indices. Expected %v, got %v.\", expectedInds, inds)\n\t}\n\t// Look for too many and return an error.\n\t_, err = Find(nil, func(v float64) bool { return int(v)%2 == 0 }, s, 6)\n\tif err == nil {\n\t\tt.Errorf(\"Find did not return an error when it should have.\")\n\t}\n\t// Find zero elements, should return empty slice and no error.\n\tinds, err = Find(nil, func(v float64) bool { return true }, s, 0)\n\tif err != nil {\n\t\tt.Errorf(\"Find returned error when it should not have: %v\", err)\n\t}\n\tif len(inds) != 0 {\n\t\tt.Errorf(\"Find returned a non-empty slice when it should have returned an empty slice: %v\", inds)\n\t}\n\t// Find all elements.\n\tinds, err = Find(nil, func(v float64) bool { return true }, s, -1)\n\tif err != nil {\n\t\tt.Errorf(\"Find returned error when it should not have: %v\", err)\n\t}\n\texpectedInds = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tif !Equal(inds, expectedInds) {\n\t\tt.Errorf(\"Find returned incorrect indices. Expected %v, got %v.\", expectedInds, inds)\n\t}\n\n}\n",
    "ef173baae917f51659bbeea6f5a88278": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, test := range []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\twant     int\n\t\twantPanic bool\n\t}{\n\t\t{[]float64{0, 1}, 0.5, 0, false},\n\t\t{[]float64{0, 1}, 0.0, 0, false},\n\t\t{[]float64{0, 1}, 1.0, -1, false},\n\t\t{[]float64{0, 1}, -1.0, -1, false},\n\t\t{[]float64{0, 1}, 2.0, -1, false},\n\t\t{[]float64{0, 1, 2}, 0.5, 0, false},\n\t\t{[]float64{0, 1, 2}, 1.0, 0, false},\n\t\t{[]float64{0, 1, 2}, 1.5, 1, false},\n\t\t{[]float64{-1, -0.5, -0.25, 0}, -0.3, 1, false},\n\t\t{[]float64{0, 1, math.NaN()}, 0.5, 0, false},\n\t\t{[]float64{0, 1, math.NaN()}, 1.5, -1, false},\n\t\t{[]float64{}, 0.0, -1, true},\n\t\t{[]float64{0}, 0.0, -1, true},\n\t\t{[]float64{1, 0}, 0.5, -1, true},\n\t} {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\terr := recover()\n\t\t\t\tif !test.wantPanic \u0026\u0026 err != nil {\n\t\t\t\t\tt.Errorf(\"Test %d - Unexpected panic: %v\", i, err)\n\t\t\t\t}\n\t\t\t\tif test.wantPanic \u0026\u0026 err == nil {\n\t\t\t\t\tt.Errorf(\"Test %d - Expected panic, but none occurred\", i)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\thave := Within(test.s, test.v)\n\t\t\tif test.wantPanic {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif have != test.want {\n\t\t\t\tt.Errorf(\"Test %d - Input: s = %v, v = %v; Expected: %v, but got: %v\", i, test.s, test.v, test.want, have)\n\t\t\t}\n\t\t}()\n\t}\n}\n",
    "f000ba2650b7d541450f4670b4290607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - Empty slice\n\t// - Slice with one element\n\t// - Slice with two elements\n\t// - Slice with multiple elements\n\t// - l == u\n\t// - l \u003e u\n\t// - l and/or u are NaN\n\t// - l and/or u are Inf\n\n\t// Empty slice\n\t{\n\t\tdst := make([]float64, 0)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\n\t// Slice with one element\n\t{\n\t\tdst := make([]float64, 1)\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, 0, 1)\n\t}\n\t// Slice with two elements\n\t{\n\t\tdst := make([]float64, 2)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\t// Slice with multiple elements\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 1)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l == u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 1)\n\t\twant := []float64{1, 1, 1, 1, 1}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// l \u003e u\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 1, 0)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 0) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\t// l and/or u are NaN\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 1)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\n\t\tSpan(dst, 0, math.NaN())\n\t\twant = []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t}\n\t// l and/or u are Inf\n\t{\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 1)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span(%v, Inf, 1) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\n\t\tSpan(dst, 0, math.Inf(1))\n\t\twant = []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Span(%v, 0, Inf) = %v, want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\t// In this case, the output is undefined in the original function.\n\t\t// we will just check if the function didn't panic\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 0) {\n\t\t\t\tt.Errorf(\"Span(%v, -Inf, Inf) = %v, want non-Inf values\", dst, dst)\n\t\t\t}\n\t\t}\n\n\t}\n}\n",
    "f0b30df2d6d93e47dff67646e0ce6c10": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// n \u003c 2 should panic\n\tassert.Panics(t, func() { NearestIdxForSpan(1, 0, 1, 0.5) })\n\n\t// NaN handling\n\tassert.Equal(t, -1, NearestIdxForSpan(2, 0, 1, math.NaN()))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, math.NaN(), 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.NaN(), 1, 0.5))\n\n\t// Inf handling\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(-1), math.Inf(1), 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(3, math.Inf(-1), math.Inf(1), 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, math.Inf(1), math.Inf(1), 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 1, math.Inf(1), 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, math.Inf(-1), 1, 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 1, -1, math.Inf(-1)))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, -1, 1, math.Inf(-1)))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, -1, 1, math.Inf(1)))\n\n\t// Basic cases\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, 0))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 1))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 0, 1, 0.1))\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 0, 1, 0.9))\n\tassert.Equal(t, 2, NearestIdxForSpan(3, 0, 1, 0.6))\n\n\t// Reversed bounds\n\tassert.Equal(t, 1, NearestIdxForSpan(2, 1, 0, 0))\n\tassert.Equal(t, 0, NearestIdxForSpan(2, 1, 0, 1))\n\n\t// More complex cases\n\tassert.Equal(t, 4, NearestIdxForSpan(10, -1, 1, 0.5))\n\tassert.Equal(t, 0, NearestIdxForSpan(10, -1, 1, -1.1))\n\tassert.Equal(t, 9, NearestIdxForSpan(10, -1, 1, 1.1))\n}\n",
    "f15c3362d300b641bf4f7188dbe271b2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases for various inputs\n\ttestCases := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    4,\n\t\t\twant: []float64{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -2,\n\t\t\tu:    2,\n\t\t\twant: []float64{-2, -1, 0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"SmallSpan\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNCaseU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCasePositive\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseNegative\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseMixed\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleL\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    4,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4},\n\t\t},\n\t\t{\n\t\t\tname: \"InfCaseSingleU\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tfor i := range got {\n\t\t\t\tif !AlmostEqual(got[i], tc.want[i]) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t\t\tbreak // Avoid spamming output with errors for each element\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Span panics when len(dst) \u003c 2\n\tt.Run(\"PanicOnShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with len(dst) \u003c 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 1)\n\t})\n}\n\n// AlmostEqual is a helper function to compare floats for approximate equality\nfunc AlmostEqual(a, b float64) bool {\n\tconst epsilon = 1e-10 // Small tolerance value\n\treturn math.Abs(a-b) \u003c= epsilon\n}\n",
    "f2c99ede0b70b8c7222aa22af27455ed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, testCase := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{s: []float64{1,2,3}, want: 0},\n\t\t{s: []float64{3,2,1}, want: 2},\n\t\t{s: []float64{2,1,3}, want: 1},\n\t\t{s: []float64{1,1,1}, want: 0},\n\t\t{s: []float64{math.NaN(), 2, 3}, want: 1},\n\t\t{s: []float64{2, math.NaN(), 3}, want: 0},\n\t\t{s: []float64{2, 3, math.NaN()}, want: 0},\n\t} {\n\t\tgot := MinIdx(testCase.s)\n\t\tif got != testCase.want {\n\t\t\tt.Errorf(\"Test case %v: got %v, want %v\", i, got, testCase.want)\n\t\t}\n\t}\n}",
    "f2d0a4e0607696b81d0f7831b78f1a69": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ts := []float64{1, 2, 3}\n\tt := []float64{4, 5, 6}\n\tdst := make([]float64, len(s))\n\twant := []float64{4, 10, 18}\n\n\tMulTo(dst, s, t)\n\tfor i, v := range dst {\n\t\tif v != want[i] {\n\t\t\tt.Errorf(\"Got %v, want %v\", dst, want)\n\t\t\tbreak\n\t\t}\n\t}\n}\n",
    "f2f791bd017a2c0391ee414f8e34deb6": "package floats\n\nimport \"testing\"\n\nfunc TestArgsortLess(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.a.Less(tt.args.i, tt.args.j); got != tt.want {\n\t\t\t\tt.Errorf(\"argsort.Less() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4050e94ad42ab51bda296b51cea2843": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases:\n\t// - len(dst) \u003c 2\n\t// - l and u are regular\n\t// - l or u is NaN\n\t// - l and u are both Inf with the same sign\n\t// - l or u is Inf\n\tt.Run(\"ShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"RegularSpan\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, 0, 4)\n\t\twant := []float64{0, 1, 2, 3, 4}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 3)\n\t\tSpan(dst, 1, 3)\n\t\twant = []float64{1, 2, 3}\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NaNCase\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.NaN(), 4)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 4}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.NaN())\n\t\twant = []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tfor i := range dst {\n\t\t\tif math.IsNaN(dst[i]) != math.IsNaN(want[i]) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"InfCase\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\t\twant = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], -1) != math.IsInf(want[i], -1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, math.Inf(1), 4)\n\t\twant = []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 4}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tSpan(dst, 0, math.Inf(1))\n\t\twant = []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tfor i := range dst {\n\t\t\tif math.IsInf(dst[i], 1) != math.IsInf(want[i], 1) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", want, dst)\n\t\t\t}\n\t\t}\n\t})\n}\n",
    "f51a1aaeae1dd7bf0c8e26f89b8b78ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\t// Test case 1: Basic case\n\tdst := make([]float64, 5)\n\tl := 1.0\n\tu := 10.0\n\texpected := []float64{1.0, 2.154434690042291, 4.641588833612778, 10.0, 21.544346900422908}\n\tLogSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.Abs(dst[i]-expected[i]) \u003e 1e-15 {\n\t\t\tt.Errorf(\"TestLogSpan Case 1 Failed: Expected %v, Got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 2: Negative input\n\tdst = make([]float64, 5)\n\tl = -1.0\n\tu = 10.0\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tLogSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif math.IsNaN(dst[i]) != math.IsNaN(expected[i]) {\n\t\t\tt.Errorf(\"TestLogSpan Case 2 Failed: Expected %v, Got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 3: Zero input\n\tdst = make([]float64, 5)\n\tl = 0.0\n\tu = 10.0\n\texpected = []float64{0.0, 0.0, 0.0, 0.0, 0.0}\n\tLogSpan(dst, l, u)\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"TestLogSpan Case 3 Failed: Expected %v, Got %v\", expected, dst)\n\t\t}\n\t}\n\n\t// Test case 4: Length of dst less than 2\n\tdst = make([]float64, 1)\n\tl = 1.0\n\tu = 10.0\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"TestLogSpan Case 4 Failed: Expected panic, Got no panic\")\n\t\t}\n\t}()\n\tLogSpan(dst, l, u)\n\n}",
    "f5730e5037fa3baa3a7797e3cf5e3a11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Parallel()\n\tfor i, test := range []struct {\n\t\ts   []float64\n\t\twant int\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, 0},\n\t\t{[]float64{4, 3, 2, 1}, 3},\n\t\t{[]float64{1, 2, 1, 0}, 3},\n\t\t{[]float64{1, 0, 1, 0}, 1},\n\t\t{[]float64{-1, math.NaN(), -2, 1}, 2},\n\t} {\n\t\tgot := MinIdx(test.s)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d:  Got %d want %d\", i, got, test.want)\n\t\t}\n\t}\n}\n",
    "f5bab763ada8fe7c36081efa09724629": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tfor i := 0; i \u003c 200; i++ {\n\t\tn := rand.Intn(1000)\n\t\tdst := make([]float64, n)\n\t\ts := make([]float64, n)\n\t\tfor i := range dst {\n\t\t\tdst[i] = rand.Float64()\n\t\t}\n\t\tfor i := range s {\n\t\t\ts[i] = rand.Float64()\n\t\t}\n\t\twant := make([]float64, n)\n\t\tfor i := range want {\n\t\t\twant[i] = dst[i] + s[i]\n\t\t}\n\t\tAdd(dst, s)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Add mismatch at element %v, got %v, want %v\", i, dst, want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check panic for unequal lengths\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"The code did not panic\")\n\t\t\t}\n\t\t}()\n\t\tAdd(dst, s[:n/2])\n\t}\n}",
    "f609d4620b7ad1d4e4f0ba7a78ef6ae8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases with different n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, 0, 10, 5, 5},\n\t\t{10, 0, 10, -1, 0},\n\t\t{10, 0, 10, 11, 9},\n\t\t{10, -5, 5, 0, 5},\n\t\t{10, -5, 5, -6, 0},\n\t\t{10, -5, 5, 6, 9},\n\t\t{11, -5, 5, -5, 0},\n\t\t{11, -5, 5, 5, 10},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\n\t// Test cases with NaN and Inf values.\n\tnan := math.NaN()\n\tinf := math.Inf(1)\n\n\ttestCasesNaNInf := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, nan, 0},\n\t\t{3, 0, 1, inf, 2},\n\t\t{4, 0, 1, -inf, 0},\n\t\t{10, 0, nan, 5, 9},\n\t\t{10, nan, 10, 5, 0},\n\t\t{10, nan, nan, 5, 0},\n\t\t{10, inf, inf, 5, 0},\n\t\t{10, -inf, -inf, 5, 0},\n\t\t{10, -inf, inf, 5, 5},\n\t\t{11, -inf, inf, 5, 5},\n\t\t{10, -inf, inf, inf, 9},\n\t\t{10, -inf, inf, -inf, 0},\n\t}\n\n\tfor _, tc := range testCasesNaNInf {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n}",
    "f6c14f0baeb9d56eb54d29effcc34ad0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttol := 1e-15\n\tfor i, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t\ti int\n\t}{\n\t\t{[]float64{0, 1}, -1e-15, -2},\n\t\t{[]float64{0, 1}, 0, 0},\n\t\t{[]float64{0, 1}, 0.5, 0},\n\t\t{[]float64{0, 1}, 1, -1},\n\t\t{[]float64{0, 1}, 1.1, -2},\n\t\t{[]float64{-1e15, 0, 1e15}, -2e15, -2},\n\t\t{[]float64{-1e15, 0, 1e15}, -1, -2},\n\t\t{[]float64{-1e15, 0, 1e15}, -1e-15, -2},\n\t\t{[]float64{-1e15, 0, 1e15}, 0, 0},\n\t\t{[]float64{-1e15, 0, 1e15}, 0.5, 0},\n\t\t{[]float64{-1e15, 0, 1e15}, 1, 1},\n\t\t{[]float64{-1e15, 0, 1e15}, 2e15, -2},\n\t} {\n\t\tgot := Within(c.s, c.v)\n\t\tif got != c.i {\n\t\t\tt.Errorf(\"case %d: different got vs exp:\\ngot: %v\\nexp: %v\\n\", i, got, c.i)\n\t\t}\n\t}\n\n\t// NaN cases\n\tfor i, c := range []struct {\n\t\ts []float64\n\t\tv float64\n\t}{\n\t\t{[]float64{0, 1}, math.NaN()},\n\t\t{[]float64{-1e15, 0, 1e15}, math.NaN()},\n\t} {\n\t\tgot := Within(c.s, c.v)\n\t\tif got != -2 {\n\t\t\tt.Errorf(\"case %d: expected -2 for NaN but got %v\", i, got)\n\t\t}\n\t}\n\t// Test panics\n\tn := 10\n\ts := make([]float64, n)\n\tfor i := range s {\n\t\ts[i] = float64(i)\n\t}\n\t// short span\n\trecoverPanic(t, \"shortSpan\", func() { Within(s[:1], 2) })\n\n\t// unsorted\n\ts[0], s[1] = s[1], s[0]\n\trecoverPanic(t, \"sorted\", func() { Within(s, 2) })\n}\n\nfunc recoverPanic(t *testing.T, msg string, f func()) {\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"function did not panic when testing: %s\", msg)\n\t\t}\n\t\t// Compare the recovered message to the expected.\n\t\t// Using string comparison because we're\n\t\t// comparing error messages, which are strings.\n\t\trm, ok := r.(string)\n\t\tif !ok {\n\t\t\tt.Errorf(\"panic did not return a string when testing: %s\", msg)\n\t\t}\n\t\tif rm != \"floats: input slice not sorted\" \u0026\u0026 rm != shortSpan {\n\t\t\tt.Errorf(\"got different panic message when testing: %s\\ngot: %q\\nexp: %q\", msg, rm, \"floats: input slice not sorted\")\n\t\t}\n\t}()\n\tf()\n}",
    "f8164ef3c4d50b252e6a8135c40a0ab5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\tt.Parallel()\n\tfor _, c := range []struct {\n\t\tinput []float64\n\t\twant  float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 3.407605964444382},\n\t\t{[]float64{-1, 0, 1}, 1.5413248546129181},\n\t\t{[]float64{1e-10, 1e-20, 1e-30}, 1.0000000001e-10},\n\t\t{[]float64{math.Inf(1), 1, 2}, math.Inf(1)},\n\t\t{[]float64{math.Inf(-1), 1, 2}, 2.6931471805599454},\n\t} {\n\t\tgot := LogSumExp(c.input)\n\t\tif !close(got, c.want) {\n\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", c.input, got, c.want)\n\t\t}\n\t}\n\n\t// Test panicking with empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"LogSumExp did not panic with empty slice\")\n\t\t}\n\t}()\n\tLogSumExp([]float64{})\n}\n\nconst eps = 1e-15\n\n// equal returns true if the values a and b are within eps of each other.\nfunc close(a, b float64) bool {\n\tif math.IsNaN(a) \u0026\u0026 math.IsNaN(b) {\n\t\treturn true\n\t}\n\treturn math.Abs(a-b) \u003c= eps\n}\n",
    "f8a59234d5fba12b9c07d35cf59640d8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"Empty\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"One Element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"Sorted\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1, 2, 3},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse Sorted\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3, 2, 1},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{2, 1, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Unsorted\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{2, 1, 3},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{1, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Duplicates\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{2, 1, 3, 1, 2},\n\t\t\t\tinds: []int{0, 1, 2, 3, 4},\n\t\t\t},\n\t\t\twant: []int{1, 3, 0, 4, 2},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsort(tt.args.dst, tt.args.inds)\n\t\t\tif !reflect.DeepEqual(tt.args.inds, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", tt.args.inds, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fbcec84a399d16e857a04dd4101ba926": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Verify that panics occur for invalid lengths.\n\tfor i := 0; i \u003c 2; i++ {\n\t\tvar dst []float64\n\t\tif i == 1 {\n\t\t\tdst = make([]float64, 1)\n\t\t}\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Span did not panic with length %d\", i)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tSpan(dst, 0, 1)\n\t\t}()\n\t}\n\n\t// Test some valid cases.\n\tfor _, c := range []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{5, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t\t{6, -1, 1, []float64{-1, -0.6, -0.2, 0.2, 0.6, 1}},\n\t\t{11, -5, 5, []float64{-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5}},\n\t} {\n\t\tdst := make([]float64, c.n)\n\t\tgot := Span(dst, c.l, c.u)\n\t\tif got != dst {\n\t\t\tt.Errorf(\"Span(%v,%f,%f) did not return same slice\", dst, c.l, c.u)\n\t\t}\n\t\tif len(got) != len(c.want) {\n\t\t\tt.Errorf(\"Span(...) returned slice with length %d, want length %d\", len(got), len(c.want))\n\t\t}\n\t\tfor i, v := range got {\n\t\t\tif v != c.want[i] {\n\t\t\t\tt.Errorf(\"Span(...)[%d] = %v, want %v\", i, v, c.want[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test the case where l \u003e u.\n\tdst := make([]float64, 5)\n\tgot := Span(dst, 1, 0)\n\tif got != dst {\n\t\tt.Errorf(\"Span(%v,%f,%f) did not return same slice\", dst, 1, 0)\n\t}\n\tif len(got) != 5 {\n\t\tt.Errorf(\"Span(...) returned slice with length %d, want length %d\", len(got), 5)\n\t}\n\tfor i := 1; i \u003c 4; i++ {\n\t\tif got[i] \u003c= got[i-1] {\n\t\t\tt.Errorf(\"Span(...)[%d] = %v, want value less than %v\", i, got[i], got[i-1])\n\t\t}\n\t}\n\n\t// Test special cases for Inf and NaN\n\tinfP := math.Inf(1)\n\tinfN := math.Inf(-1)\n\tfor _, c := range []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{5, math.NaN(), 0, []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 0}},\n\t\t{5, 0, math.NaN(), []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}},\n\t\t{5, infP, infP, []float64{infP, infP, infP, infP, infP}},\n\t\t{5, infN, infN, []float64{infN, infN, infN, infN, infN}},\n\t\t{5, infP, infN, []float64{infP, infP, 0, infN, infN}},\n\t\t{5, infN, infP, []float64{infN, infN, 0, infP, infP}},\n\t\t{6, infP, infN, []float64{infP, infP, infP, infN, infN, infN}},\n\t\t{6, infN, infP, []float64{infN, infN, infN, infP, infP, infP}},\n\t\t{5, infP, 0, []float64{infP, infP, infP, infP, 0}},\n\t\t{5, 0, infP, []float64{0, infP, infP, infP, infP}},\n\t\t{5, infN, 0, []float64{infN, infN, infN, infN, 0}},\n\t\t{5, 0, infN, []float64{0, infN, infN, infN, infN}},\n\t} {\n\t\tdst := make([]float64, c.n)\n\t\tgot := Span(dst, c.l, c.u)\n\t\tif got != dst {\n\t\t\tt.Errorf(\"Span(%v,%f,%f) did not return same slice\", dst, c.l, c.u)\n\t\t}\n\t\tif len(got) != len(c.want) {\n\t\t\tt.Errorf(\"Span(...) returned slice with length %d, want length %d\", len(got), len(c.want))\n\t\t}\n\t\tfor i, v := range got {\n\t\t\tif math.IsNaN(v) \u0026\u0026 !math.IsNaN(c.want[i]) {\n\t\t\t\tt.Errorf(\"Span(...)[%d] = %v, want %v\", i, v, c.want[i])\n\t\t\t}\n\t\t\tif !math.IsNaN(v) \u0026\u0026 math.IsNaN(c.want[i]) {\n\t\t\t\tt.Errorf(\"Span(...)[%d] = %v, want %v\", i, v, c.want[i])\n\t\t\t}\n\t\t\tif !math.IsNaN(v) \u0026\u0026 v != c.want[i] {\n\t\t\t\tt.Errorf(\"Span(...)[%d] = %v, want %v\", i, v, c.want[i])\n\t\t\t}\n\t\t}\n\t}\n\n}",
    "fdddd85e91abddc251b9da767bee01fa": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats/testlapack\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tfor i, test := range []struct {\n\t\ts []float64\n\t\tt []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\t[]float64{1,2,3,4},\n\t\t\t[]float64{1,1,1,1},\n\t\t\t[]float64{2,3,4,5},\n\t\t},\n\t\t{\n\t\t\t[]float64{1,1,1,1},\n\t\t\t[]float64{1,2,3,4},\n\t\t\t[]float64{2,3,4,5},\n\t\t},\n\t\t{\n\t\t\t[]float64{0,0,0,0},\n\t\t\t[]float64{1,2,3,4},\n\t\t\t[]float64{1,2,3,4},\n\t\t},\n\t\t{\n\t\t\t[]float64{1,2,3,4},\n\t\t\t[]float64{0,0,0,0},\n\t\t\t[]float64{1,2,3,4},\n\t\t},\n\t} {\n\t\tdst := make([]float64, len(test.s))\n\t\tgot := AddTo(dst, test.s, test.t)\n\t\tif !testlapack.EqualApprox(got, test.want, 1e-14) {\n\t\t\tt.Errorf(\"Test %v : mismatch. Want %v, got %v\", i, test.want, got)\n\t\t}\n\t}\n}",
    "fe478ab38e642e30157bc134e5ad80b3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases:\n\t//   - Various values of n, l, u, and v\n\t//   - Special cases for Inf, NaN, and v outside (l, u)\n\n\ttests := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 2},\n\t\t{10, 0.0, 1.0, 0.5, 5},\n\t\t{11, 0.0, 1.0, 0.5, 5},\n\n\t\t{10, -1.0, 1.0, 0.0, 5},\n\t\t{10, -1.0, 1.0, -0.5, 2},\n\t\t{10, -1.0, 1.0, 0.5, 7},\n\n\t\t{10, 0.0, 10.0, 5.0, 5},\n\t\t{10, 0.0, 10.0, 2.5, 2},\n\t\t{10, 0.0, 10.0, 7.5, 7},\n\n\t\t// Special cases for Inf and NaN\n\t\t{10, math.Inf(-1), math.Inf(1), 0.0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.NaN(), 1.0, 0.0, 9},\n\t\t{10, 0.0, math.NaN(), 0.0, 0},\n\t\t{10, 0.0, 1.0, math.NaN(), 0},\n\n\t\t// v outside (l, u)\n\t\t{10, 0.0, 1.0, -1.0, 0},\n\t\t{10, 0.0, 1.0, 2.0, 9},\n\t\t{10, 1.0, 0.0, -1.0, 9},\n\t\t{10, 1.0, 0.0, 2.0, 0},\n\t}\n\n\tfor i, test := range tests {\n\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Test %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, test.n, test.l, test.u, test.v, got, test.want)\n\t\t}\n\t}\n\n\t// Test panics for n \u003c 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"NearestIdxForSpan did not panic for n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0.0, 1.0, 0.5)\n}",
    "fffbfad0db7ae393fa0704ea9b316d33": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\t// Test cases for various n, l, u, and v values.\n\ttestCases := []struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t\twant int\n\t}{\n\t\t{2, 0, 1, 0.5, 1},\n\t\t{3, 0, 1, 0.3, 0},\n\t\t{4, 0, 1, 0.8, 3},\n\t\t{10, -1, 1, 0, 5},\n\t\t{10, -1, 1, -1.1, 0},\n\t\t{10, -1, 1, 1.1, 9},\n\t\t{11, -1, 1, 0, 5},\n\t\t{11, -1, 1, -1.1, 0},\n\t\t{11, -1, 1, 1.1, 10},\n\t\t// Cases with NaN and Inf values.\n\t\t{10, math.NaN(), 1, 0.5, 9},\n\t\t{10, 0, math.NaN(), 0.5, -1},\n\t\t{10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{10, math.Inf(-1), math.Inf(1), math.Inf(1), 9},\n\t\t{11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{11, math.Inf(-1), math.Inf(1), math.Inf(1), 10},\n\t\t{10, math.Inf(-1), 0, -1, 9},\n\t\t{10, 0, math.Inf(1), 1, 9},\n\t\t{10, 1, -1, 0.5, 9},\n\t\t{10, 1, -1, 1.1, 0},\n\t\t{10, 1, -1, -1.1, 9},\n\t\t{10, 0, 1, math.Inf(-1), 0},\n\t\t{10, 0, 1, math.Inf(1), 9},\n\t\t{10, 1, 0, math.Inf(-1), 9},\n\t\t{10, 1, 0, math.Inf(1), 0},\n\t}\n\tfor i, tc := range testCases {\n\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"Test case %d: NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\",\n\t\t\t\ti, tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t}\n\t}\n\t// Test case with n \u003c 2 to trigger panic.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\n}\n"
}