{
    "0026966f482687b357882089f4e9ee0f": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{6, 0.0, 1.0, 0.2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "00ff8da04f0e838382a81a82fbe07efe": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tL:    2,\n\t\t\twant: 5.477225575051661,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, -2, 3, -4},\n\t\t\tL:    1,\n\t\t\twant: 10,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinity norm\",\n\t\t\ts:    []float64{1, -2, 3, -4},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Norm(tt.s, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "013e5ee407fb258d6a8c3fda98af7c6a": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0}, 0, 10, []float64{0, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0215348bb87bbfbf266f19937ec2247e": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{5, 6, 7}, []float64{2, 3, 4}},\n\t\t{[]float64{10, 20, 30}, []float64{3, 6, 9}},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tSub(test.dst, test.s)\n\n\t\tfor i := 0; i \u003c len(test.dst); i++ {\n\t\t\texpected := dstCopy[i] - test.s[i]\n\t\t\tif test.dst[i] != expected {\n\t\t\t\tt.Errorf(\"Subtraction incorrect. Expected: %v, Got: %v\", expected, test.dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n",
    "028e90cbce778d1961c87aa647c65dad": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/yourusername/yourproject/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{3, 0.0, 1.0, 0.75, 2},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "02c76544e44aa50c3890e81b07f8e90f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.6, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.0, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02d05743532d1daecf41e66d43e30cae": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.1, 0},\n\t\t{6, 0.0, 1.0, 0.9, 5},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{3, 0.0, 1.0, -1.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "02dace20380755f8b679152b01cb1c37": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 0, []float64{math.Inf(1), 0, 0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02fbbeaf9207bbe077f089b5539b257d": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0448c285f2fcbc79b86a5077593f1471": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 3, []float64{1, 2, 3}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 15}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -2, 2, []float64{-2, -1, 0, 1, 2}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tt.Run(\"Panic for length less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{0}, 1, 3)\n\t})\n}",
    "0481378a1b09214b71ea7267f94d33e1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{3.0, 1.0, 4.0, 1.0, 5.0}, 1},\n\t\t{\"Test2\", []float64{10.0, 20.0, 30.0, 40.0, 50.0}, 0},\n\t\t{\"Test3\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "049bf5e147c76a4cefac4edd03539ef1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 2.0, 1.5, 2},\n\t\t{4, 0.0, 3.0, 2.5, 3},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "0509e0638a4b45d441f01d4ba3e331eb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttests := []struct {\n\t\tc    float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{2.0, []float64{1.0, 2.0, 3.0}, []float64{2.0, 4.0, 6.0}},\n\t\t{0.5, []float64{4.0, 6.0, 8.0}, []float64{2.0, 3.0, 4.0}},\n\t\t{3.0, []float64{0.0, 0.0, 0.0}, []float64{0.0, 0.0, 0.0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tfloats.Scale(tt.c, tt.dst)\n\t\tif !floats.Equal(tt.dst, tt.want) {\n\t\t\tt.Errorf(\"Scale(%v, %v) = %v; want %v\", tt.c, tt.dst, tt.dst, tt.want)\n\t\t}\n\t}\n}",
    "078c692d78e6f34adcf892727898b8a7": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 2, 3, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\twant: []float64{-10, -5, 0, 5, 10},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "07a3669a4df39454690361c55d14ee12": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 3},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "082fe751a23930a68a019f44025e09cd": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{1, 1, 1, 1, 1, 1}, 1, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, test.dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(dstCopy) {\n\t\t\tt.Errorf(\"Length of mutated slice changed\")\n\t\t}\n\n\t\tfor i := range result {\n\t\t\texpected := test.l + (test.u-test.l)/float64(len(test.dst)-1)*float64(i)\n\t\t\tif result[i] != expected {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected, i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "08367c21374f71c8896f648b0805835b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0843ef585b873a1a79ee4ad7a8360783": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t\t{11, 0, 10, 5, 5},\n\t\t{12, 0, 10, 5, 6},\n\t\t{13, 0, 10, 5, 6},\n\t\t{14, 0, 10, 5, 7},\n\t\t{15, 0, 10, 5, 7},\n\t\t{16, 0, 10, 5, 8},\n\t\t{17, 0, 10, 5, 8},\n\t\t{18, 0, 10, 5, 9},\n\t\t{19, 0, 10, 5, 9},\n\t\t{20, 0, 10, 5, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "08d82e43185b5ac68d847ab24ea6f61b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{3, 0.0, 1.0, -1.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "092d969bdc8d331e1383b09ae960574d": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0a4296a1d29592be5b3cbae3eddad4e4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %v, but got %v\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"Expected first element to be %v, but got %v\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Expected last element to be %v, but got %v\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}\n",
    "0a81dba7d0fdfeb9b2ee90d5fffab1ef": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.0, 1},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 1.0, 2},\n\t\t{5, 0.0, 1.0, 1.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "0b097e9900feb8b9e641c792209cf25f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{3.5, 2.0, 5.1, 1.2, 4.8}, 3},\n\t\t{\"Test case 2\", []float64{10.5, 20.0, 5.1, 1.2, 4.8}, 3},\n\t\t{\"Test case 3\", []float64{3.5, 2.0, 5.1, 1.2, 1.2}, 3},\n\t\t{\"Test case 4\", []float64{3.5, 2.0, 5.1, 1.2, 1.2, 1.2}, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0b471cefc5359254a2f629459fb3aade": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %v, but got %v\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"Expected first element to be %v, but got %v\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Expected last element to be %v, but got %v\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}",
    "0c3582a382574f253a9d3e2de6f04b2e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices with NaN\",\n\t\t\tslice1:   []float64{1.0, 2.0, math.NaN()},\n\t\t\tslice2:   []float64{1.0, 2.0, math.NaN()},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices without NaN\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different values\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Same(tt.slice1, tt.slice2)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0cbfee12334c61b215b68e7039d3e04c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "0d144bb389e3e2f7fce75bb9ab4c36ba": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{4, 0, 10, 5, 1},\n\t\t{3, 0, 10, 15, 2},\n\t\t{5, 0, 10, -5, 0},\n\t\t{2, 0, 0, 0, 0},\n\t\t{2, 10, 0, 0, 1},\n\t\t{3, 10, 0, 0, 2},\n\t\t{4, 10, 0, 0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "0d37d4ebe8ea732945906d799178ed91": "package floats\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"count positive numbers\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 0\n\t\t\t},\n\t\t\ts:        []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"count even numbers\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn int(x)%2 == 0\n\t\t\t},\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"count numbers greater than 10\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x \u003e 10\n\t\t\t},\n\t\t\ts:        []float64{15.0, 20.0, 5.0, 8.0, 12.0},\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Count(tt.f, tt.s)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d38cf851eedbeb3bf60880a2ff1cb98": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 10, 3.0000000000000004},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "0e04172c6c2d5d231457bf49bbcc2001": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.25, 1.5, 1.75, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, 0, 5, 0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e9561493f6229f9472a0d33b0425509": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Expected result: %v, got: %v\", dst, result)\n\t\t}\n\t}\n}",
    "0f3a51095de34ca23f6513dd63718b5b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    10,\n\t\t\twant: []float64{1, 3.1622776601683795, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0.1,\n\t\t\tu:    1000,\n\t\t\twant: []float64{0.1, 1, 10, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\tdst:  []float64{0, 0},\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\twant: []float64{0, 0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0fd11dba8dbc082251b5cc7acfffe5cd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}, []float64{11, 13, 15}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8}, nil}, // mismatched lengths\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := AddTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v; want %v\", tt.dst, tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "10520592a0f56f200f0a6b8fc4e6f903": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different elements\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.slice1, tt.slice2, func(a, b float64) bool {\n\t\t\t\treturn a == b\n\t\t\t})\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "11f572eb365996ad3a7cf07e62825761": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.slice, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "1233b208bd7b9681685f0e7a71169e0f": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 10.0, 5.0, 2},\n\t\t{4, 0.0, 10.0, 15.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "128299297328105251c94c426bd401ac": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 1.0, 5.0, 3.0, 1},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t\t{6, 0.0, 100.0, 50.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "156e9026367d2431fbba36241809755c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    floats.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    floats.Inf(-1),\n\t\t\tu:    floats.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Panic case\",\n\t\t\tdst:  []float64{0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif len(tt.dst) \u003c 2 {\n\t\t\t\t\t\tt.Errorf(\"Expected panic due to short destination slice, but no panic occurred\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length to be %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\tfor i, val := range result {\n\t\t\t\tif val != tt.dst[i] {\n\t\t\t\t\tt.Errorf(\"Expected value at index %d to be %f, but got %f\", i, tt.dst[i], val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "16389cca552661e959b771ae10933bd1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1, 2, 3, 4, 5}, 2.5, 1},\n\t\t{[]float64{1, 2, 3, 4, 5}, 3.8, 3},\n\t\t{[]float64{1, 2, 3, 4, 5}, 0, 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, 6, 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.NaN(), 0},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(1), 4},\n\t\t{[]float64{1, 2, 3, 4, 5}, math.Inf(-1), 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v and %v, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "16b961141bad023dbcab537e8956f070": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Check if the length of the result is the same as the input slice\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\t// Check if the first element is l and the last element is u\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "175bec1e74ac88c0ebf6618319ad2aea": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, 0, 0, []float64{0, 0, 0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := floats.Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "178631791ebe40ac3e37a083dbafcaf0": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 5, 6}, []float64{-3, -3, -3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{0, 0, 0}, []float64{4, 5, 6}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := SubTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "17b48362ee126933a53c1a193c164509": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\tresult: []float64{15, 18, 21},\n\t\t},\n\t\t{\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ty:      []float64{1, 2, 3},\n\t\t\talpha:  0.5,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tresult: []float64{3, 4.5, 6},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\t\tif !reflect.DeepEqual(test.dst, test.result) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.result, test.dst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1830f8f917008a5af3ab25c87b2ae2dc": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0.0, 10.0, 4.0, 1},\n\t\t{3, 0.0, 10.0, 15.0, 2},\n\t\t{4, -10.0, 10.0, 0.0, 2},\n\t\t{6, -5.0, 5.0, -3.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "18f63684bb35c6121ee813332812b6fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1968ed211494d5115fccc7fbe0d9b841": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 2, []float64{1, 1.5, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), math.Inf(1), []float64{math.Inf(-1), 0, math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 2, []float64{math.NaN(), math.NaN(), 2}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b2aa9741f579897b5c9a00dec4d507": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{2, 3, 4}, []float64{0.5, 0.6666666666666666, 0.75}},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{1, 2, 3}},\n\t}\n\n\tfor _, test := range tests {\n\t\tMul(test.dst, test.s)\n\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, test.dst)\n\t\t}\n\t}\n}",
    "1ad9c3bf09c1a9d8050c0ee5abf9560b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}},\n\t\t{[]float64{10, 20, 30}, []float64{1, 2, 3}},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tAdd(test.dst, test.s)\n\n\t\tfor i := 0; i \u003c len(test.dst); i++ {\n\t\t\texpected := dstCopy[i] + test.s[i]\n\t\t\tif test.dst[i] != expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", expected, test.dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n",
    "1c4cb9f8a7e88f9578abe483cfc61f88": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{\"Test case 2\", []float64{5.0, 5.0, 5.0, 5.0}, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 3.0, 2.0, 1.0}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c5f72f2d5979de07ba7baa8000ca229": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{1, 1.5, 2, 2.5, 3}, 1, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.dst, dst)\n\t\t}\n\t}\n}",
    "1ca3cc76bc3280f4036eb5e02262113a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %v, but got %v\", len(test.dst), len(result))\n\t\t}\n\n\t\tfor i := 0; i \u003c len(result); i++ {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %v, but got %v\", test.dst[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "1d6ce67971a15d6b9f8427cb2884ae20": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 0},\n\t\t{\"Single element slice\", []float64{5.5}, 5.5},\n\t\t{\"Multiple elements\", []float64{1.1, 2.2, 3.3, 4.4, 5.5}, 16.5},\n\t\t{\"Negative numbers\", []float64{-1.1, -2.2, -3.3, -4.4, -5.5}, -16.5},\n\t\t{\"Mixed numbers\", []float64{1.1, -2.2, 3.3, -4.4, 5.5}, 3.3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.s)\n\t\t\tif math.Abs(got-tt.want) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1fdd45a9c18c7c68f389281bb34338b8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "1fe92cb8cfb822ebbb0cb855c24a048d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    3.6,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    5.5,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "200507033a4953d93b579d69ed390e88": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1, 2, 3, 4, 5}, 4},\n\t\t{\"Test case 2\", []float64{5, 4, 3, 2, 1}, 0},\n\t\t{\"Test case 3\", []float64{1, 5, 3, 5, 2}, 1},\n\t\t{\"Test case 4\", []float64{1, 1, 1, 1, 1}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20b1c7750ca546302f3faea997b5b38d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 2},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 3},\n\t\t{9, 0, 10, 5, 3},\n\t\t{10, 0, 10, 5, 4},\n\t\t{11, 0, 10, 5, 4},\n\t\t{12, 0, 10, 5, 4},\n\t\t{13, 0, 10, 5, 5},\n\t\t{14, 0, 10, 5, 5},\n\t\t{15, 0, 10, 5, 5},\n\t\t{16, 0, 10, 5, 6},\n\t\t{17, 0, 10, 5, 6},\n\t\t{18, 0, 10, 5, 6},\n\t\t{19, 0, 10, 5, 7},\n\t\t{20, 0, 10, 5, 7},\n\t\t{21, 0, 10, 5, 7},\n\t\t{22, 0, 10, 5, 8},\n\t\t{23, 0, 10, 5, 8},\n\t\t{24, 0, 10, 5, 8},\n\t\t{25, 0, 10, 5, 9},\n\t\t{26, 0, 10, 5, 9},\n\t\t{27, 0, 10, 5, 9},\n\t\t{28, 0, 10, 5, 10},\n\t\t{29, 0, 10, 5, 10},\n\t\t{30, 0, 10, 5, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "210f3b2cc25d3852c35a761e34477c91": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-package-path/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Valid Span\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Span\",\n\t\t\tdst:  []float64{0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special Cases\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special Cases\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"The code did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tfloats.Span(tt.dst, tt.l, tt.u)\n\t\t})\n\t}\n}",
    "213b596d12483bcacb7cf3ba03419666": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\tv:        1.5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "226111ab2928dc905e44814f6f9015be": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:    2,\n\t\t\twant: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:    1,\n\t\t\twant: 15,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinity norm\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Norm(tt.s, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v; want %v\", tt.s, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "22bd207af381f87686834da5d600c1ad": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.6, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "252ed22fd9f5304c94adacddc06a1137": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Has NaN value\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0, 101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0, 108.0, 109.0, 110.0, 111.0, 112.0, 113.0, 114.0, 115.0, 116.0, 117.0, 118.0, 119.0, 120.0, 121.0, 122.0, 123.0, 124.0, 125.0, 126.0, 127.0, 128.0, 129.0, 130.0, 131.0, 132.0, 133.0, 134.0, 135.0, 136.0, 137.0, 138.0, 139.0, 140.0, 141.0, 142.0, 143.0, 144.0, 145.0, 146.0, 147.0, 148.0, 149.0, 150.0, 151.0, 152.0, 153.0, 154.0, 155.0, 156.0, 157.0, 158.0, 159.0, 160.0, 161.0, 162.0, 163.0, 164.0, 165.0, 166.0, 167.0, 168.0, 169.0, 170.0, 171.0, 172.0, 173.0, 174.0, 175.0, 176.0, 177.0, 178.0, 179.0, 180.0, 181.0, 182.0, 183.0, 184.0, 185.0, 186.0, 187.0, 188.0, 189.0, 190.0, 191.0, 192.0, 193.0, 194.0, 195.0, 196.0, 197.0, 198.0, 199.0, 200.0, 201.0, 202.0, 203.0, 204.0, 205.0, 206.0, 207.0, 208.0, 209.0, 210.0, 211.0, 212.0, 213.0, 214.0, 215.0, 216.0, 217.0, 218.0, 219.0, 220.0, 221.0, 222.0, 223.0, 224.0, 225.0, 226.0, 227.0, 228.0, 229.0, 230.0, 231.0, 232.0, 233.0, 234.0, 235.0, 236.0, 237.0, 238.0, 239.0, 240.0, 241.0, 242.0, 243.0, 244.0, 245.0, 246.0, 247.0, 248.0, 249.0, 250.0, 251.0, 252.0, 253.0, 254.0, 255.0, 256.0, 257.0, 258.0, 259.0, 260.0, 261.0, 262.0, 263.0, 264.0, 265.0, 266.0, 267.0, 268.0, 269.0, 270.0, 271.0, 272.0, 273.0, 274.0, 275.0, 276.0, 277.0, 278.0, 279.0, 280.0, 281.0, 282.0, 283.0, 284.0, 285.0, 286.0, 287.0, 288.0, 289.0, 290.0, 291.0, 292.0, 293.0, 294.0, 295.0, 296.0, 297.0, 298.0, 299.0, 300.0, 301.0, 302.0, 303.0, 304.0, 305.0, 306.0, 307.0, 308.0, 309.0, 310.0, 311.0, 312.0, 313.0, 314.0, 315.0, 316.0, 317.0, 318.0, 319.0, 320.0, 321.0, 322.0, 323.0, 324.0, 325.0, 326.0, 327.0, 328.0, 329.0, 330.0, 331.0, 332.0, 333.0, 334.0, 335.0, 336.0, 337.0, 338.0, 339.0, 340.0, 341.0, 342.0, 343.0, 344.0, 345.0, 346.0, 347.0, 348.0, 349.0, 350.0, 351.0, 352.0, 353.0, 354.0, 355.0, 356.0, 357.0, 358.0, 359.0, 360.0, 361.0, 362.0, 363.0, 364.0, 365.0, 366.0, 367.0, 368.0, 369.0, 370.0, 371.0, 372.0, 373.0, 374.0, 375.0, 376.0, 377.0, 378.0, 379.0, 380.0, 381.0, 382.0, 383.0, 384.0, 385.0, 386.0, 387.0, 388.0, 389.0, 390.0, 391.0, 392.0, 393.0, 394.0, 395.0, 396.0, 397.0, 398.0, 399.0, 400.0, 401.0, 402.0, 403.0, 404.0, 405.0, 406.0, 407.0, 408.0, 409.0, 410.0, 411.0, 412.0, 413.0, 414.0, 415.0, 416.0, 417.0, 418.0, 419.0, 420.0, 421.0, 422.0, 423.0, 424.0, 425.0, 426.0, 427.0, 428.0, 429.0, 430.0, 431.0, 432.0, 433.0, 434.0, 435.0, 436.0, 437.0, 438.0, 439.0, 440.0, 441.0, 442.0, 443.0, 444.0, 445.0, 446.0, 447.0, 448.0, 449.0, 450.0, 451.0, 452.0, 453.0, 454.0, 455.0, 456.0, 457.0, 458.0, 459.0, 460.0, 461.0, 462.0, 463.0, 464.0, 465.0, 466.0, 467.0, 468.0, 469.0, 470.0, 471.0, 472.0, 473.0, 474.0, 475.0, 476.0, 477.0, 478.0, 479.0, 480.0, 481.0, 482.0, 483.0, 484.0, 485.0, 486.0, 487.0, 488.0, 489.0, 490.0, 491.0, 492.0, 493.0, 494.0, 495.0, 496.0, 497.0, 498.0, 499.0, 500.0, 501.0, 502.0, 503.0, 504.0, 505.0, 506.0, 507.0, 508.0, 509.0, 510.0, 511.0, 512.0, 513.0, 514.0, 515.0, 516.0, 517.0, 518.0, 519.0, 520.0, 521.0, 522.0, 523.0, 524.0, 525.0, 526.0, 527.0, 528.0, 529.0, 530.0, 531.0, 532.0, 533.0, 534.0, 535.0, 536.0, 537.0, 538.0, 539.0, 540.0, 541.0, 542.0, 543.0, 544.0, 545.0, 546.0, 547.0, 548.0, 549.0, 550.0, 551.0, 552.0, 553.0, 554.0, 555.0, 556.0, 557.0, 558.0, 559.0, 560.0, 561.0, 562.0, 563.0, 564.0, 565.0, 566.0, 567.0, 568.0, 569.0, 570.0, 571.0, 572.0, 573.0, 574.0, 575.0, 576.0, 577.0, 578.0, 579.0, 580.0, 581.0, 582.0, 583.0, 584.0, 585.0, 586.0, 587.0, 588.0, 589.0, 590.0, 591.0, 592.0, 593.0, 594.0, 595.0, 596.0, 597.0, 598.0, 599.0, 600.0, 601.0, 602.0, 603.0, 604.0, 605.0, 606.0, 607.0, 608.0, 609.0, 610.0, 611.0, 612.0, 613.0, 614.0, 615.0, 616.0, 617.0, 618.0, 619.0, 620.0, 621.0, 622.0, 623.0, 624.0, 625.0, 626.0, 627.0, 628.0, 629.0, 630.0, 631.0, 632.0, 633.0, 634.0, 635.0, 636.0, 637.0, 638.0, 639.0, 640.0, 641.0, 642.0, 643.0, 644.0, 645.0, 646.0, 647.0, 648.0, 649.0, 650.0, 651.0, 652.0, 653.0, 654.0, 655.0, 656.0, 657.0, 658.0, 659.0, 660.0, 661.0, 662.0, 663.0, 664.0, 665.0, 666.0, 667.0, 668.0, 669.0, 670.0, 671.0, 672.0, 673.0, 674.0, 675.0, 676.0, 677.0, 678.0, 679.0, 680.0, 681.0, 682.0, 683.0, 684.0, 685.0, 686.0, 687.0, 688.0, 689.0, 690.0, 691.0, 692.0, 693.0, 694.0, 695.0, 696.0, 697.0, 698.0, 699.0, 700.0, 701.0, 702.0, 703.0, 704.0, 705.0, 706.0, 707.0, 708.0, 709.0, 710.0, 711.0, 712.0, 713.0, 714.0, 715.0, 716.0, 717.0, 718.0, 719.0, 720.0, 721.0, 722.0, 723.0, 724.0, 725.0, 726.0, 727.0, 728.0, 729.0, 730.0, 731.0, 732.0, 733.0, 734.0, 735.0, 736.0, 737.0, 738.0, 739.0, 740.0, 741.0, 742.0, 743.0, 744.0, 745.0, 746.0, 747.0, 748.0, 749.0, 750.0, 751.0, 752.0, 753.0, 754.0, 755.0, 756.0, 757.0, 758.0, 759.0, 760.0, 761.0, 762.0, 763.0, 764.0, 765.0, 766.0, 767.0, 768.0, 769.0, 770.0, 771.0, 772.0, 773.0, 774.0, 775.0, 776.0, 777.0, 778.0, 779.0, 780.0, 781.0, 782.0, 783.0, 784.0, 785.0, 786.0, 787.0, 788.0, 789.0, 790.0, 791.0, 792.0, 793.0, 794.0, 795.0, 796.0, 797.0, 798.0, 799.0, 800.0, 801.0, 802.0, 803.0, 804.0, 805.0, 806.0, 807.0,",
    "253f0b1f1c4b549501d40eca15d5eced": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 1},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 2},\n\t\t{7, 0, 10, 5, 2},\n\t\t{8, 0, 10, 5, 3},\n\t\t{9, 0, 10, 5, 3},\n\t\t{10, 0, 10, 5, 4},\n\t\t{11, 0, 10, 5, 4},\n\t\t{12, 0, 10, 5, 4},\n\t\t{13, 0, 10, 5, 5},\n\t\t{14, 0, 10, 5, 5},\n\t\t{15, 0, 10, 5, 6},\n\t\t{16, 0, 10, 5, 6},\n\t\t{17, 0, 10, 5, 6},\n\t\t{18, 0, 10, 5, 7},\n\t\t{19, 0, 10, 5, 7},\n\t\t{20, 0, 10, 5, 8},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "25ce682804023f9a12509c8ac3f9216a": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case: NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case: Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(0),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(0)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26a35a13561a9794e4226386d82986f3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "273f0a878b8e6f3562e9f28f044dc394": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6},\n\t\t\texpected: 2.1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "275967bd3d165d6f5e107ac14d6101cc": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.1, 0},\n\t\t{6, 0.0, 1.0, 0.9, 5},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 0.0, 10.0, 7.5, 2},\n\t\t{5, 0.0, 10.0, 2.5, 0},\n\t\t{6, 0.0, 10.0, 9.0, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "27980de3e3145bbf91a6bce006ce4d0c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{3, 1, 4, 1, 5, 9, 2, 6, 5, 3}, 1},\n\t\t{\"Test2\", []float64{5, 4, 3, 2, 1}, 4},\n\t\t{\"Test3\", []float64{1, 1, 1, 1, 1}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "2799b7f6d5b93f89992e821705bebff0": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 3.0, 3},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "28520fc1a5692c9c87d9da5daba3a32d": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{3.5, 2.0, 5.1, 1.2, 4.8},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{10.0, 20.0, 5.0, 15.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "288f617c62576d3f1a88038094c17195": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{3.5, 2.0, 5.5, 1.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{10.0, 20.0, 5.0, 15.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index: %d, but got: %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "28ebcdc9ba99fb1af3edf4495a630a68": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{3.5, 2.0, 1.0, 4.5},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{10.0, 5.0, 8.0, 3.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "28f9800a7a4182bbc7af30b587ca4260": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected: %v, but got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29038392105c5bc234f760656fcb22e2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 2.0, 1.0}, 2},\n\t\t{\"Test case 2\", []float64{3.0, 2.0, 1.0, 2.0, 3.0}, 0},\n\t\t{\"Test case 3\", []float64{1.0, 1.0, 1.0, 1.0, 1.0}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2912766f5fa08aadae1282284cedee38": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 100, []float64{0, 33.333333333333336, 66.66666666666667, 100}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 1, []float64{0, 0.25, 0.5, 0.75, 1}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic when length of dst is less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic when length of dst is less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 10)\n}",
    "29321ecf0482984dd39ea3b7ce875e3b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Add your assertions here to validate the result\n\t\t})\n\t}\n}\n",
    "29360998acd13b342952710bb8afacf3": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 3, []float64{1, 2, 3}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 15}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -5, 5, []float64{-5, 0, 5, 10, 15}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 1, 3)\n}",
    "295ed50fd8578a673bb2e3fcc8350d9c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test Case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"Test Case 2\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{\"Test Case 3\", []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6}, 2.1},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(test.input)\n\t\t\tif math.Abs(result-test.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29b9b1c0f0123acdc4bd5a5dcb577350": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{\"Test2\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},\n\t\t{\"Test3\", []float64{1.0, 1.0, 1.0, 1.0, 1.0}, 0},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 3.0, 2.0}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2a86c48c0b34e51f7e81c07ad226cfc8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Subtracting two slices of equal length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: []float64{3, 3, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"Subtracting two slices of different length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\tt:    []float64{1, 2},\n\t\t\twant: nil, // Expecting panic due to different lengths\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif !reflect.DeepEqual(tt.want, tt.dst) {\n\t\t\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", tt.dst, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tSubTo(tt.dst, tt.s, tt.t)\n\t\t})\n\t}\n}\n",
    "2adf7865b18d991dea53dc6df7a87df3": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1.0},\n\t\t{\"Single element slice\", []float64{5.0}, 5.0},\n\t\t{\"Multiple elements\", []float64{2.0, 3.0, 4.0}, 2.0 * 3.0 * 4.0},\n\t\t{\"Zero value\", []float64{2.0, 0.0, 4.0}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c01766532bd63aa2abc38cc94eb14e6": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{1, 2, 3, 4, 5, 6}, 1, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", test.u, result[len(result)-1])\n\t\t}\n\n\t\tfor i := 1; i \u003c len(result)-1; i++ {\n\t\t\texpected := test.l + float64(i)*(test.u-test.l)/float64(len(result)-1)\n\t\t\tif math.Abs(result[i]-expected) \u003e 1e-9 {\n\t\t\t\tt.Errorf(\"Expected element at index %d to be %f, but got %f\", i, expected, result[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "2c0b11a375fc921998c1c9c945a1e821": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 10.0, 5.0, 2},\n\t\t{5, 0.0, 10.0, 5.0, 2},\n\t\t{6, 0.0, 10.0, 5.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "2d185405319948d8cbedc6a6a50ab7fc": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{2, 1, 3}, []float64{2, 5, 2}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5}, []float64{2, 1, 3}, []float64{}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := DivTo(tt.dst, tt.s, tt.t)\n\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\tt.Errorf(\"DivTo(%v, %v, %v) = %v; want %v\", tt.dst, tt.s, tt.t, got, tt.want)\n\t\t}\n\t}\n}",
    "2d9592ac59a1a355ee03def9ab0094c3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.0, 1},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 1.0, 2},\n\t\t{5, 0.0, 1.0, 1.0, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "2e64769798a5cc94d729f8d90e29adfd": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tc   float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 2, []float64{4, 5, 6}, []float64{8, 10, 12}},\n\t\t{[]float64{1, 2, 3}, 0, []float64{4, 5, 6}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3}, -1, []float64{4, 5, 6}, []float64{-4, -5, -6}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := ScaleTo(tt.dst, tt.c, tt.s)\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tt.want[i] {\n\t\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e8f04b46a7cc612ea38ffd806e2eb04": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 3, []float64{1, 2, 3}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 15}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic when length of dst is less than 2\n\tt.Run(\"Panic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{0}, 1, 3)\n\t})\n}",
    "2f1a12d46d26c88d281ab17f5d43f813": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.6,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.5,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "3089a094a99d51ef78034874e78c9a53": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test1\", []float64{1, 2, 3}, 3.4076059644443803},\n\t\t{\"Test2\", []float64{0, 0, 0}, 0},\n\t\t{\"Test3\", []float64{1, 1, 1, 1}, 1.5514447114146858},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "30dee26f57fa90a8a53794231ce2c69e": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Equal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal length slices\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Single slice\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "310cb20bedefcc5ffc221258026fc89f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Check if the length of the result matches the length of the destination\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\t// Check if the first element is l and the last element is u\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "315d479ff232fd65956f9b3da7e0e12b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -10.0, 10.0, 0.0, 2},\n\t\t{5, 0.0, 100.0, 50.0, 2},\n\t\t{6, -100.0, 100.0, 75.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "31da813b746c7eabd381b135198484d7": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "32bb0402b219e3687bbce36b83414407": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -1},\n\t\t{\"Test4\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 3.5, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "345c9a3be0ead2a6bb443889e1480273": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span test case 1\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 3.3333333333333335, 6.666666666666667, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span test case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    5,\n\t\t\twant: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span test case 3\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\twant: []float64{-10, 0, 10},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "34830695dc149b4a5cc409e9b2a8f053": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"Test2\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{\"Test3\", []float64{0.01, 0.02, 0.03, 0.04, 0.05}, 0.15},\n\t\t{\"Test4\", []float64{0.001, 0.002, 0.003, 0.004, 0.005}, 0.015},\n\t\t{\"Test5\", []float64{0.0001, 0.0002, 0.0003, 0.0004, 0.0005}, 0.0015},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.s)\n\t\t\tif math.Abs(got-tt.want) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34c0d99226cdf4b4227be15a1f145e68": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{3, 0.0, 1.0, -0.5, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{3, 1.0, 0.0, 0.5, 0},\n\t\t{3, 1.0, 0.0, 1.5, 2},\n\t\t{3, 1.0, 0.0, -0.5, 2},\n\t\t{3, 1.0, 0.0, 2.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "34ff38c1847746783a7293319ecf85f8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := floats.Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"Expected no error, but got: %v\", err)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"Expected error: %v, but got no error\", tt.err)\n\t\t\t}\n\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.expected), len(result))\n\t\t\t}\n\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected[i], result[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "356d6aedd0b043c46f7fcf7e3ff1cbc9": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        floats.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "358cb99636fbb9e701ee9e0d5a0edac1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 0.0, 100.0, 50.0, 2},\n\t\t{5, 0.0, 1000.0, 500.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "35e4e0a40afe6a5e168783bb39d5cb1d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.8, 3},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 6.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v and %v, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdx_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tNearestIdx([]float64{}, 3.0)\n}",
    "36b46310cb1e47d0cbd345cbb5e97feb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "3777da618e67948fe1f0988381d359df": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test Case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"Test Case 2\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{\"Test Case 3\", []float64{-1.0, -2.0, -3.0, -4.0, -5.0}, -15.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "382421897ddac293a7eaf5803663f8ba": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{5, 5, 5}, []float64{2, 3, 4}},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\t\tfloats.Sub(dst, test.s)\n\n\t\tfor i := 0; i \u003c len(dst); i++ {\n\t\t\texpected := test.dst[i] - test.s[i]\n\t\t\tif dst[i] != expected {\n\t\t\t\tt.Errorf(\"Subtraction error: expected %f, got %f\", expected, dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n",
    "3843bad289f379e1a739b632988424fb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := floats.Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"Expected no error, but got: %v\", err)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"Expected error: %v, but got no error\", tt.err)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Errorf(\"Expected error: %v, but got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.expected), len(result))\n\t\t\t}\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected result %v, but got %v\", tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "39db05dc4a24eb9227f51017d3d973fe": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 1},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 2},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 3},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "3a76d4dd149871d67008d88252023be3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{3.5, 2.0, 5.1, 1.2}, 3},\n\t\t{\"Test2\", []float64{0.0, 0.0, 0.0, 0.0}, 0},\n\t\t{\"Test3\", []float64{10.5, 8.2, 6.7, 9.1}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3adb71339e22f88f256492a10f5ad403": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -10.0, 10.0, 0.0, 2},\n\t\t{5, 0.0, 100.0, 75.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "3bddc91a49dd0c307d9de0e1281590c7": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0}, 0, 10, []float64{0, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := floats.Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d239a05153f127756cc4206cf13ce2f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{0.01, 0.02, 0.03, 0.04, 0.05},\n\t\t\texpected: 0.15,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f1fcb2afc428a0210f30e3b742123c1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 10.0, 5.5, 2},\n\t\t{5, -5.0, 5.0, 3.0, 4},\n\t\t{6, 0.0, 100.0, 50.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "3fa7e3b95f5c707b1cf62da5c1bdb6f4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\tdst := []float64{1.0, 2.0, 3.0, 4.0}\n\tc := 5.0\n\texpected := []float64{6.0, 7.0, 8.0, 9.0}\n\n\tfloats.AddConst(c, dst)\n\n\tfor i := range dst {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %f but got %f at index %d\", expected[i], dst[i], i)\n\t\t}\n\t}\n}",
    "402da2b0239a95cd0ad9382497c83698": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0, 0, 0, 0}, 1, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, expected)\n\t\t}\n\t}\n}",
    "408bf5d6763678341e7519c97944b765": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"your-package-path/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 2, []float64{1, 1.5, 2}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 5, 10, 15}},\n\t\t{[]float64{0, 0, 0, 0, 0}, -1, 1, []float64{-1, -0.5, 0, 0.5, 1}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4171fcb628d4c71d3830d56fe113e994": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, -0.5, 0},\n\t\t{4, 0.0, 1.0, -0.25, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "425513ae8a69a98a714e8b3f95e333d2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t\t{11, 0, 10, 5, 5},\n\t\t{12, 0, 10, 5, 6},\n\t\t{13, 0, 10, 5, 6},\n\t\t{14, 0, 10, 5, 7},\n\t\t{15, 0, 10, 5, 7},\n\t\t{16, 0, 10, 5, 8},\n\t\t{17, 0, 10, 5, 8},\n\t\t{18, 0, 10, 5, 9},\n\t\t{19, 0, 10, 5, 9},\n\t\t{20, 0, 10, 5, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4255a92f176f4d91698166bcd5e8c176": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{1.5, 2.5, 3.5}, []float64{0.5, 1.5, 2.5}},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\t\tMul(dst, test.s)\n\n\t\tfor i := 0; i \u003c len(dst); i++ {\n\t\t\texpected := test.dst[i] * test.s[i]\n\t\t\tif dst[i] != expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", expected, dst[i])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test panic if argument lengths do not match\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Mul did not panic\")\n\t\t}\n\t}()\n\tMul([]float64{1, 2}, []float64{1, 2, 3})\n}\n\nfunc TestMul_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Mul did not panic\")\n\t\t}\n\t}()\n\tMul([]float64{1, 2}, []float64{1, 2, 3})\n}",
    "427a068f7b9d98292d45ba8f0298d820": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 100, []float64{0, 33.333333333333336, 66.66666666666667, 100}},\n\t\t{[]float64{0, 0, 0}, 0, 0, []float64{0, 0, 0}},\n\t\t{[]float64{0, 0}, -10, 10, []float64{-10, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "437c902372f0d98605b3971c25a238e2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "43b37766db5973e6b66d2f8e975f0b50": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{0},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tif err != nil \u0026\u0026 tt.err == nil {\n\t\t\t\tt.Errorf(\"Expected no error, but got %v\", err)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 tt.err != nil {\n\t\t\t\tt.Errorf(\"Expected error %v, but got no error\", tt.err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43da2b9b629e14fe67c3831d7c5be202": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 5, 2},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 15, 3},\n\t\t{2, 0, 10, 5, 0},\n\t\t{5, 0, 10, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "448e96e64dc8a814b9196333c8e74a69": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 1.0, 0.2, 0},\n\t\t{4, 0.0, 1.0, 0.8, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{3, 1.0, 0.0, 0.5, 2},\n\t\t{3, 1.0, 0.0, 1.0, 0},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "44b252eb7d64662d0890dd69335bcff7": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4511cbb301b7d8bfcf0b0dedbc359aa4": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, 0, 0, []float64{0, 0, 0}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 10, []float64{math.NaN(), math.NaN(), 10}},\n\t\t{[]float64{0, 0, 0}, 10, math.NaN(), []float64{10, math.NaN(), math.NaN()}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "453441fed479c6b931c95d8e6a2dc624": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0.0, 10.0, 4.0, 2},\n\t\t{3, 0.0, 10.0, 12.0, 2},\n\t\t{4, 0.0, 10.0, 7.5, 2},\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t\t{6, 0.0, 10.0, 10.0, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "45a30c5828885a89ba83eb56d93bcb68": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4627622097568676db1c4bb86f0f6c45": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{6, 0.0, 1.0, 0.2, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "4779c1536b5e5170e27ec9a3d10c39ae": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCumProd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3, 4}, []float64{1, 2, 3, 4}, []float64{1, 2, 6, 24}},\n\t\t{[]float64{1, 2, 3, 4}, []float64{2, 3, 4, 5}, []float64{2, 6, 24, 120}},\n\t\t{[]float64{1, 2, 3, 4}, []float64{0, 0, 0, 0}, []float64{0, 0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := CumProd(test.dst, test.s)\n\t\tif !Equal(result, test.expected) {\n\t\t\tt.Errorf(\"Expected %v but got %v\", test.expected, result)\n\t\t}\n\t}\n}",
    "47f60ea89af4f421e1d95c0dab96a75e": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{\"Test2\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},\n\t\t{\"Test3\", []float64{1.0, 1.0, 1.0, 1.0, 1.0}, 0},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 3.0, 2.0, 1.0}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "485f3f9430a5c1ee9fe363f2c8c5ca6b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{3.5, 2.0, 5.1, 1.2, 4.8}, 3},\n\t\t{\"Test2\", []float64{10.5, 20.0, 5.1, 15.2, 4.8}, 4},\n\t\t{\"Test3\", []float64{3.5, 2.0, 5.1, 1.2, 1.2}, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4902acfcc99189c581fc8a8766675600": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "498646d911c3405408999849c323ca03": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "49ba2faa968d0b16296a65774ac0301a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "49f1f6060a6fe1ef71ebca94b2d03f19": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t\t{5, 0.0, 1.0, 2.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4a76c915a614c1a32e928870371d7c11": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0.0, 10.0, 4.0, 1},\n\t\t{5, 0.0, 10.0, 7.5, 3},\n\t\t{5, 0.0, 10.0, 12.0, 4},\n\t\t{5, 10.0, 0.0, 4.0, 3},\n\t\t{5, 10.0, 0.0, 7.5, 1},\n\t\t{5, 10.0, 0.0, 12.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4b1a23c141eedc527eec4c3fbbbf89e3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 5, 6}, []float64{-3, -3, -3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{0, 0, 0}, []float64{4, 5, 6}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\tfor i := range got {\n\t\t\tif got[i] != tt.want[i] {\n\t\t\t\tt.Errorf(\"SubTo(%v, %v, %v) = %v, want %v\", tt.dst, tt.s, tt.t, got, tt.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}",
    "4ba005c9cdfe22faa8fc506e95a25089": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{2, -1.0, 1.0, 0.0, 1},\n\t\t{3, -1.0, 1.0, -0.5, 0},\n\t\t{4, -1.0, 1.0, 0.5, 2},\n\t\t{5, -1.0, 1.0, -0.2, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4c6cdb436525f21ceeedad76790926b9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "4cbcd075e4543798c309fb6ee26e85d1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{4, 0.0, 1.0, -1.0, 0},\n\t\t{5, 0.0, 1.0, 1.5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "4e1af0d7b8ed5d716b99fd19e75c5557": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{5.0, 7.0, 9.0}},\n\t\t{[]float64{0.0, 0.0, 0.0}, []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{0.0, 0.0, 0.0}, []float64{1.0, 2.0, 3.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tfloats.Add(test.dst, test.s)\n\t\tif !floats.Equal(test.dst, test.want) {\n\t\t\tt.Errorf(\"Add(%v, %v) = %v, want %v\", test.dst, test.s, test.dst, test.want)\n\t\t}\n\t}\n}\n",
    "4eb979ccf40b8e4948c951fe71f3192c": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 2.5, 2}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{1, 2}, []float64{}}, // Should panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"MulTo did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := MulTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "4ee2b8620a8d952f91ac91175e990d11": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "50a644966ebeb9b5f9f075ffe29701a4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    floats.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    floats.Inf(-1),\n\t\t\tu:    floats.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}",
    "50bf89e11cdfc6a5f67944e93b69ded7": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := floats.Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) || !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected %v, %v but got %v, %v\", tt.expected, tt.err, result, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5100393d9c20179d1f466df07560df26": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 2, []float64{4, 5, 6}, []float64{9, 12, 15}},\n\t\t{[]float64{0, 0, 0}, 1, []float64{1, 2, 3}, []float64{1, 2, 3}},\n\t\t{[]float64{1, 2, 3}, 0, []float64{4, 5, 6}, []float64{1, 2, 3}},\n\t}\n\n\tfor _, test := range tests {\n\t\tfloats.AddScaled(test.dst, test.alpha, test.s)\n\t\tif !floats.Equal(test.dst, test.result) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.result, test.dst)\n\t\t}\n\t}\n}",
    "513e0f7a072d293d0d8efdd905153883": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{1, 2, 3}, []float64{3, 3, 3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 5, 6}, []float64{-3, -3, -3}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{0, 0, 0}, []float64{4, 5, 6}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := SubTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51de97e964a1fffb9b422eb59da5400d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{4, 6, 8}, []float64{2, 3, 4}, []float64{2, 2, 2}},\n\t\t{[]float64{10, 15, 20}, []float64{5, 3, 4}, []float64{2, 5, 5}},\n\t}\n\n\tfor _, test := range tests {\n\t\tDiv(test.dst, test.s)\n\t\tfor i := range test.dst {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, test.dst)\n\t\t\t}\n\t\t}\n\t}\n}",
    "51e62d3003c1cef2b289488bb49642bc": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{3, 1.0, 0.0, 0.5, 0},\n\t\t{3, 1.0, 0.0, 1.0, 2},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t\t{3, 1.0, 1.0, 1.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "51e6755e7f508768bca93b584325caa1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{5, 0.0, 1.0, 0.2, 1},\n\t\t{5, 0.0, 1.0, 0.8, 3},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 1.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "51f37ea8b340d88b86dd6365594f823f": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: 3.4076059644443806,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\ts:    []float64{0, 0, 0},\n\t\t\twant: 0.6931471805599453,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\ts:    []float64{-1, -2, -3},\n\t\t\twant: -0.3068528194400547,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "535e683dd7462e2c87fae6b37215e513": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "54cf5f7fc12931717650aaf61a9e1990": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{3, 0.0, 1.0, 0.0, 1},\n\t\t{3, 0.0, 1.0, 0.25, 1},\n\t\t{3, 0.0, 1.0, 0.75, 2},\n\t\t{3, 0.0, 1.0, 0.1, 1},\n\t\t{3, 0.0, 1.0, 0.9, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "5510c4a37a65894d6414bbbb693794cd": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{2, 0.0, 0.0, 0.0, 0},\n\t\t{3, 1.0, 0.0, 0.5, 2},\n\t\t{4, 1.0, 1.0, 1.0, 0},\n\t\t{5, 1.0, 1.0, 1.0, 0},\n\t\t{3, 0.0, 0.0, 0.0, 0},\n\t\t{4, 0.0, 0.0, 0.0, 0},\n\t\t{5, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "553492048d9a895e0c7a6480f8a52aa9": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -10,\n\t\t\tu:    -5,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf and NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    floats.NaN(),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Check if the length of the result is the same as the input\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\t// Check if the first element is l and the last element is u\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "557c377cf77cfee5862a9c9ac824624d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{\"Test case 2\", []float64{0.1, 0.2, 0.3}, 0.6},\n\t\t{\"Test case 3\", []float64{0.01, 0.02, 0.03}, 0.06},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "566741d6f8a87aed21ab7e8ff5149d73": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.2, 0},\n\t\t{3, 0.0, 1.0, 0.8, 2},\n\t\t{5, 0.0, 10.0, 5.0, 2},\n\t\t{5, 0.0, 10.0, 15.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "585b7ac09a3b8d7ae48ddfa3fb2ed341": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10, 15},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(0),\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(0)},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c241954b2664727c41d7721efab838": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{5.0, 7.0, 9.0}},\n\t\t{[]float64{0.0, 0.0, 0.0}, []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{0.0, 0.0, 0.0}, []float64{1.0, 2.0, 3.0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tdst := make([]float64, len(tt.dst))\n\t\tcopy(dst, tt.dst)\n\t\tAdd(dst, tt.s)\n\t\tif !reflect.DeepEqual(dst, tt.want) {\n\t\t\tt.Errorf(\"Add(%v, %v) = %v, want %v\", tt.dst, tt.s, dst, tt.want)\n\t\t}\n\t}\n}",
    "596038e104a8cfd0669b4e0ae9d834d2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test case 1: k \u003c 0\n\tslice := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\tf := func(x float64) bool {\n\t\treturn x \u003e 2.0\n\t}\n\tinds, err := Find(nil, f, slice, -1)\n\tif err != nil {\n\t\tt.Errorf(\"Expected error to be nil, got %v\", err)\n\t}\n\texpected := []int{2, 3, 4}\n\tfor i, val := range inds {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Expected index %d, got %d\", expected[i], val)\n\t\t}\n\t}\n\n\t// Test case 2: k \u003e 0\n\tinds, err = Find(nil, f, slice, 2)\n\tif err != nil {\n\t\tt.Errorf(\"Expected error to be nil, got %v\", err)\n\t}\n\texpected = []int{2, 3}\n\tfor i, val := range inds {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Expected index %d, got %d\", expected[i], val)\n\t\t}\n\t}\n\n\t// Test case 3: k \u003e 0 but not enough elements found\n\tinds, err = Find(nil, f, slice, 5)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n}\n",
    "59cfb0df3d116931d8ef233f5c4d4ba1": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Span with N=5\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=3\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=4\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.3333333333333333, 1.6666666666666665, 2},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59e9807e410b3b1e42476d1626350de1": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.NaN(), 10},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, math.NaN()},\n\t\t{[]float64{0, 0, 0, 0, 0}, math.Inf(0), 10},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, math.Inf(0)},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, expected)\n\t\t}\n\t}\n}",
    "5a067b714f12586ffcf7e6ed3a76e094": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Example 1\",\n\t\t\tinput:    []float64{3.5, 2.0, 5.1, 1.2},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Example 2\",\n\t\t\tinput:    []float64{10.5, 8.2, 6.7, 9.1},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Example 3\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5aa15949cd7c6551c734080cf1d8b245": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 4},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 10.0, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Additional test cases for panics\n\tt.Run(\"Panic: short span\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t\t}\n\t\t}()\n\t\tWithin([]float64{1.0}, 2.0)\n\t})\n\n\tt.Run(\"Panic: input slice not sorted\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t\t}\n\t\t}()\n\t\tWithin([]float64{3.0, 2.0, 1.0}, 2.0)\n\t})\n}\n",
    "5cab14684e3236374aff22310a463d29": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourusername/yourpackagename/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{\"Test case 2\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},\n\t\t{\"Test case 3\", []float64{1.0, 1.0, 1.0, 1.0, 1.0}, 0},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 3.0, 2.0, 1.0}, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5cfd5efc057e14d6f915e2f0e3a7a4e1": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\ts1:   []float64{},\n\t\t\ts2:   []float64{},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Equal(tt.s1, tt.s2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5db0ca7cc9e199b358e4086356bd249f": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L2 norm of {3, 4}\",\n\t\t\tslice:    []float64{3, 4},\n\t\t\tL:        2,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm of {3, 4}\",\n\t\t\tslice:    []float64{3, 4},\n\t\t\tL:        1,\n\t\t\texpected: 7,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity norm of {3, 4, -5}\",\n\t\t\tslice:    []float64{3, 4, -5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5e5b494cf15f876e881c448b70eb2381": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Subtracting two slices of equal length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: []float64{3, 3, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"Subtracting two slices of different length\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\tt:    []float64{1, 2},\n\t\t\twant: nil, // Expecting panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"SubTo did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "5ec0328f90a34d616e3b204f7b27312c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{6, 0.0, 1.0, 0.9, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "61372161edf3c9defd238b1135cd48bc": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Add your assertions here based on the expected behavior of Span\n\t\t})\n\t}\n}",
    "619b5b88adc14dd5e12b4896a2e60292": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{3.0, 2.0, 1.0, 2.0, 3.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "63eb0a38dfc2724cfeb1f978ccfde92a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "63fa0b8a84228ec317cfed7688363a0a": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(test.dst, result) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.dst, result)\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.dst, dstCopy) {\n\t\t\tt.Errorf(\"Expected original dst to remain unchanged, but it was modified\")\n\t\t}\n\t}\n}",
    "6413829de65ffe830657a47656e35ce0": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{6, 0.0, 1.0, 0.5, 2},\n\t\t{7, 0.0, 1.0, 0.5, 3},\n\t\t{8, 0.0, 1.0, 0.5, 3},\n\t\t{4, 0.0, 10.0, 5.5, 2},\n\t\t{4, 10.0, 0.0, 5.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, -1.0, 0},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t\t{4, 0.0, 1.0, 0.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "656d8243e7ab61dd1b5d5d4c0a1c2a51": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Span with N=5\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=3\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=4\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, -2.5, 0, 2.5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65a07e02fcce872028436f8a915909a7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.6, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fd8ad4512dfef4102fe3bfb9270a4f": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, test.dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(dstCopy) {\n\t\t\tt.Errorf(\"Span did not preserve the length of the slice\")\n\t\t}\n\n\t\tfor i := range result {\n\t\t\texpected := test.l + (test.u-test.l)/float64(len(test.dst)-1)*float64(i)\n\t\t\tif result[i] != expected {\n\t\t\t\tt.Errorf(\"Span did not calculate the correct value at index %d\", i)\n\t\t\t}\n\t\t}\n\t}\n}",
    "6614f0f640bed3219f6edca88d44dd37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t\t{11, 0, 10, 5, 5},\n\t\t{12, 0, 10, 5, 6},\n\t\t{13, 0, 10, 5, 6},\n\t\t{14, 0, 10, 5, 7},\n\t\t{15, 0, 10, 5, 7},\n\t\t{16, 0, 10, 5, 8},\n\t\t{17, 0, 10, 5, 8},\n\t\t{18, 0, 10, 5, 9},\n\t\t{19, 0, 10, 5, 9},\n\t\t{20, 0, 10, 5, 10},\n\t\t{21, 0, 10, 5, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "662f2e407358b89be4281a5a18880939": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        float64(math.Inf(1)),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test other L distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: 3.3019272488946263,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "66d292c1ce226e5c8864cc13fe05bc21": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{5, 0.0, 1.0, 0.2, 1},\n\t\t{5, 0.0, 1.0, 0.8, 3},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 1.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "67dd6295b47259e6fb279f0555c34da2": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}}, false},\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68474e5a72e61670a6cb46b5ac1305bf": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1.0},\n\t\t{\"Single element slice\", []float64{5.0}, 5.0},\n\t\t{\"Multiple elements\", []float64{2.0, 3.0, 4.0}, 24.0},\n\t\t{\"Zero value\", []float64{2.0, 0.0, 4.0}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68899a430ddf4f6f239e756b66bbbffb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\"Same slices\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{\"Different lengths\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{\"Different values\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 4.0, 3.0}, false},\n\t\t{\"NaN values\", []float64{1.0, math.NaN(), 3.0}, []float64{1.0, math.NaN(), 3.0}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Same(tt.slice1, tt.slice2)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68e0afb435fbddde65eef21993523abe": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -1},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 6.0, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "690866bf0f92f2e1f2a6c438c10bc8eb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "6930d616072f2ca90b31519426117788": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test1\", []float64{1, 2, 3}, 3.40760596444438},\n\t\t{\"Test2\", []float64{0, 0, 0}, 0.6931471805599453},\n\t\t{\"Test3\", []float64{-1, -2, -3}, -0.3068528194400547},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "69897caeb65fe72f7aa78c474973b3a4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.25, 1},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.75, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "6aede9c09c69006b852dd6e16ffad905": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6af629ddd937cab703589d0bb7a8abe6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 1.0, 5.0, 3.0, 1},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t\t{6, 0.0, 100.0, 50.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "6bfc7b9f97ba65b7653d66b1e69f0b80": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\tf    func(float64, float64) bool\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices with same length and elements\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\tf:    func(a, b float64) bool { return a == b },\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with different length\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0},\n\t\t\tf:    func(a, b float64) bool { return a == b },\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with different elements\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 4.0, 3.0},\n\t\t\tf:    func(a, b float64) bool { return a == b },\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := EqualFunc(tt.s1, tt.s2, tt.f)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "6c7c9566e0529939e343a754e38af8a8": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0}, 0, 10, []float64{0, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 10)\n}",
    "6d06d0759e4be25c7b630ad5ceb5bc13": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "6d21515f8125323eb177cf800f931b07": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\t}\n}",
    "6deba74db0b90460246258ff700fb465": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, test.dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(dstCopy) {\n\t\t\tt.Errorf(\"Length of mutated slice changed\")\n\t\t}\n\n\t\tfor i := range result {\n\t\t\texpected := test.l + (test.u-test.l)/float64(len(result)-1)*float64(i)\n\t\t\tif result[i] != expected {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, got %f\", expected, i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "6f60e11c27d167cc98a6c777b2ed309f": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "6f8f0cf089b9296b93c93e650fdcf0f6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.8, 3},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "705779804a0d6e416d989d33e5d71d2c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 3.0, 3},\n\t\t{5, 0.0, 100.0, 50.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "70ef5cf162ccbbbeaffa61109d9d5327": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.0, 1},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 1.0, 2},\n\t\t{5, 0.0, 1.0, 1.0, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "719fbaed10eb9f84af07d905fd6dc8b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test Case 1\", []float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{\"Test Case 2\", []float64{0.1, 0.2, 0.3}, 0.6},\n\t\t{\"Test Case 3\", []float64{0.01, 0.02, 0.03}, 0.06},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "72080191d1a0f6a037ea1ba79b729034": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\ts1:   []float64{1, 2, 3},\n\t\t\ts2:   []float64{4, 5, 6},\n\t\t\twant: 32,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\ts1:   []float64{0.5, 0.5, 0.5},\n\t\t\ts2:   []float64{2, 2, 2},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\ts1:   []float64{1, 0, -1},\n\t\t\ts2:   []float64{1, 0, -1},\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Dot(tt.s1, tt.s2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Dot() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "731ef9c1650a0835b8d91c3e5645ea3d": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\t}\n}",
    "7342be149dca4d93bbc1c7058fc4b165": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Same slices with same values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Same slices with different values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Same slices with NaN values\",\n\t\t\ts:        []float64{math.NaN(), 2.0, 3.0},\n\t\t\tt:        []float64{math.NaN(), 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different length slices\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Same(tt.s, tt.t)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "735adf687a18e301fe773c3aa12dfa6b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{3, 0.0, 1.0, 0.75, 2},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{3, 0.0, 1.0, 0.1, 0},\n\t\t{3, 0.0, 1.0, 0.9, 2},\n\t\t{3, 0.0, 1.0, 0.4, 1},\n\t\t{3, 0.0, 1.0, 0.6, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "742c3a0e60b52275548045f9937128ed": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\tdst := []float64{3.5, 1.2, 4.7, 2.3}\n\tinds := make([]int, len(dst))\n\texpectedDst := []float64{1.2, 2.3, 3.5, 4.7}\n\texpectedInds := []int{1, 3, 0, 2}\n\n\tfloats.ArgsortStable(dst, inds)\n\n\tif !reflect.DeepEqual(dst, expectedDst) {\n\t\tt.Errorf(\"Expected sorted dst to be %v, but got %v\", expectedDst, dst)\n\t}\n\n\tif !reflect.DeepEqual(inds, expectedInds) {\n\t\tt.Errorf(\"Expected inds to be %v, but got %v\", expectedInds, inds)\n\t}\n}",
    "74b6c2682cd0091c2b1d38011061c6ec": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"AddTo test case 1\",\n\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\ts:    []float64{4.0, 5.0, 6.0},\n\t\t\tt:    []float64{7.0, 8.0, 9.0},\n\t\t\twant: []float64{12.0, 15.0, 18.0},\n\t\t},\n\t\t{\n\t\t\tname: \"AddTo test case 2\",\n\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\ts:    []float64{4.0, 5.0, 6.0},\n\t\t\tt:    []float64{7.0, 8.0, 9.0, 10.0}, // mismatched lengths\n\t\t\twant: nil, // expect panic\n\t\t},\n\t\t{\n\t\t\tname: \"AddTo test case 3\",\n\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\ts:    []float64{4.0, 5.0, 6.0, 7.0}, // mismatched lengths\n\t\t\tt:    []float64{7.0, 8.0, 9.0},\n\t\t\twant: nil, // expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Errorf(\"AddTo did not panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tAddTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7531e22078872885620137b8f10e36fa": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 2}, nil}, // mismatched lengths\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := AddTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "75568582d0db1dd3b3d9aaadf9b871d7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{1.0, 2.0},\n\t\t\tv:        1.5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "764003bc0b16664630dab25d0a7361f9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "7775eae90044d2b83c4ba237a18e6524": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.6, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.0, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "77b93326ee7c291bfa127d16988aa7d8": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, expected)\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\n\tSpan([]float64{1}, 0, 10)\n}",
    "79104be89c9c1a79798d2bc6dce60d34": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Span with N=5\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=3\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=4\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, -1.6666666666666667, 1.6666666666666667, 5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79ba96a414ec58600a22cf4d6a65c7d9": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 2.0, 2},\n\t\t{5, -10.0, 0.0, -5.0, 4},\n\t\t{6, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "79f3aca3977491f8d5f9776daa658477": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ae0b412168e3741e885695e100e10dc": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 100, []float64{0, 33.333333333333336, 66.66666666666667, 100}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 1000, []float64{0, 250, 500, 750, 1000}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\n\tSpan([]float64{0}, 0, 10)\n}",
    "7ba6c1a9d9cfc826feb1c6cc29a7d1d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{0.1, -0.2, 0.3, -0.4, 0.5},\n\t\t\texpected: 0.3,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7be2cfa5773f77e57f0b52a902a37906": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{6, 0.0, 1.0, 0.5, 2},\n\t\t{7, 0.0, 1.0, 0.5, 3},\n\t\t{8, 0.0, 1.0, 0.5, 3},\n\t\t{9, 0.0, 1.0, 0.5, 4},\n\t\t{10, 0.0, 1.0, 0.5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "7ce7e0ff5d5a26e4ace3cfba39e5cd75": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find all elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2, 3, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 3 elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, -2, 3, -4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{0, 1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not enough elements found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3, -4, -5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected result to be %v, but got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected error to be %v, but got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dbdc50dd0c7ca092a6eb33c2b115cb4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}}, false},\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dee733e37d1cd403fa43e560561b44b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %v, but got %v\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"Expected first element to be %v, but got %v\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Expected last element to be %v, but got %v\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}",
    "7e067ec2eec8c0ce92a797561684a201": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, -0.5, 0},\n\t\t{4, 0.0, 1.0, -0.5, 0},\n\t\t{5, 0.0, 1.0, -0.5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "7e0e584ee99bb04f534bf4a061567134": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find all elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 1, 2, 3, 4},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first 2 elements\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{-1, -2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not enough elements found\",\n\t\t\tinds:     nil,\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3, -4, -5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e338ea1edf5d53d16546d7262adfbf3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{6, 0.0, 1.0, 0.9, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "7f25d22513ef6e04b64a192ed3cfc5b0": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{6, 0.0, 1.0, 0.1, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "7f3a126a386b9ed26bfb0769fd5122a4": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{\"Test case 2\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 0},\n\t\t{\"Test case 3\", []float64{1.0, 5.0, 3.0, 5.0, 2.0}, 1},\n\t\t{\"Test case 4\", []float64{1.0, 1.0, 1.0, 1.0, 1.0}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f6810e613aee48e70477e69512564f4": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}, {7.0, 8.0, 9.0}},\n\t\t\twant:   false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "7f69ce5884584bab680bef849c1ae2aa": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "806936f5d9d784f8306b0ac2a5943872": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"All slices have equal length\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Slices have different lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"No input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "809daefdfb910db4c42b0f1b1277fcbe": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test Span with valid inputs\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 3.3333333333333335, 6.666666666666667, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with NaN\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with Inf\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{0, 0, 0, 0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "80ffe1ef1dc80434c8321ba0d2fb1c7c": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\t}\n}",
    "8164f904edbace0e687a6eb1a01a3af5": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "820e22f4df79d99e681e83421197f3ad": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        floats.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.slice, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "8237b765f07159af3926d27949397523": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span test case 1\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span test case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.5, 2, 2.5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span test case 3\",\n\t\t\tdst:  []float64{0, 0},\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\twant: []float64{-10, 10},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "82cfd02b37e335e4d6d30fe85596f5fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8316756719bd266dc16a02ec38ac71fe": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t\t{11, 0, 10, 5, 5},\n\t\t{12, 0, 10, 5, 6},\n\t\t{13, 0, 10, 5, 6},\n\t\t{14, 0, 10, 5, 7},\n\t\t{15, 0, 10, 5, 7},\n\t\t{16, 0, 10, 5, 8},\n\t\t{17, 0, 10, 5, 8},\n\t\t{18, 0, 10, 5, 9},\n\t\t{19, 0, 10, 5, 9},\n\t\t{20, 0, 10, 5, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "833b21a0075c577fde94c189898f66a9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs argsort\n\t\ti    int\n\t\tj    int\n\t}{\n\t\t{\n\t\t\tname: \"Swap elements at index 0 and 1\",\n\t\t\targs: argsort{s: []float64{1, 2, 3}},\n\t\t\ti:    0,\n\t\t\tj:    1,\n\t\t},\n\t\t{\n\t\t\tname: \"Swap elements at index 1 and 2\",\n\t\t\targs: argsort{s: []float64{1, 2, 3}},\n\t\t\ti:    1,\n\t\t\tj:    2,\n\t\t},\n\t\t{\n\t\t\tname: \"Swap elements at index 0 and 2\",\n\t\t\targs: argsort{s: []float64{1, 2, 3}},\n\t\t\ti:    0,\n\t\t\tj:    2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.args.Swap(tt.i, tt.j)\n\n\t\t\tif tt.args.s[tt.i] != tt.args.s[tt.j] {\n\t\t\t\tt.Errorf(\"Swap did not work as expected. Expected: %v, Got: %v\", tt.args.s[tt.j], tt.args.s[tt.i])\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cba209de73be9fc8a65c3115cd478d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test case 1\n\tinds := []int{}\n\tf := func(x float64) bool {\n\t\treturn x \u003e 0\n\t}\n\ts := []float64{1, -2, 3, -4, 5}\n\tk := 2\n\texpected := []int{0, 2}\n\tresult, err := Find(inds, f, s, k)\n\tif err != nil {\n\t\tt.Errorf(\"Test case 1 failed: %v\", err)\n\t}\n\tfor i, val := range result {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Test case 1 failed. Expected: %v, Got: %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 2\n\tinds = []int{}\n\tf = func(x float64) bool {\n\t\treturn x \u003c 0\n\t}\n\ts = []float64{1, -2, 3, -4, 5}\n\tk = -1\n\texpected = []int{1, 3}\n\tresult, err = Find(inds, f, s, k)\n\tif err != nil {\n\t\tt.Errorf(\"Test case 2 failed: %v\", err)\n\t}\n\tfor i, val := range result {\n\t\tif val != expected[i] {\n\t\t\tt.Errorf(\"Test case 2 failed. Expected: %v, Got: %v\", expected, result)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Test case 3\n\tinds = []int{}\n\tf = func(x float64) bool {\n\t\treturn x == 0\n\t}\n\ts = []float64{1, -2, 3, -4, 5}\n\tk = 3\n\texpectedErr := \"floats: insufficient elements found\"\n\t_, err = Find(inds, f, s, k)\n\tif err.Error() != expectedErr {\n\t\tt.Errorf(\"Test case 3 failed. Expected error: %v, Got: %v\", expectedErr, err)\n\t}\n}",
    "84cf1db0881ba9374d11a631125e887c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t\t{5, 0.0, 1.0, 2.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "84fc49945a232770c24f21a053cee5a1": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t\t{11, 0, 10, 5, 5},\n\t\t{12, 0, 10, 5, 6},\n\t\t{13, 0, 10, 5, 6},\n\t\t{14, 0, 10, 5, 7},\n\t\t{15, 0, 10, 5, 7},\n\t\t{16, 0, 10, 5, 8},\n\t\t{17, 0, 10, 5, 8},\n\t\t{18, 0, 10, 5, 9},\n\t\t{19, 0, 10, 5, 9},\n\t\t{20, 0, 10, 5, 10},\n\t\t{21, 0, 10, 5, 10},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "8660c16f640958be268b424125fc3fec": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(55),\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "876a136b2371b18a843f206bffeb3c2a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "88a0193ded84b9e893d23ff426b1843c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, -1, -1},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "8900aa68771056c6d140df5d1c575cfa": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Span with N=5\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=3\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=4\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, -1.6666666666666667, 1.6666666666666667, 5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8957cbfb628c000e6a23a0af86dc0e6d": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, float64('a'), 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}\n",
    "8a268a807febdd1589044723d42783f7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.0, 1},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 1.0, 2},\n\t\t{5, 0.0, 1.0, 1.0, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "8d7bf8dcb492c4994dab8bf626b97ed0": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(test.dst, result) {\n\t\t\tt.Errorf(\"Span did not mutate the slice correctly. Expected: %v, Got: %v\", test.dst, result)\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.dst, dstCopy) {\n\t\t\tt.Errorf(\"Span mutated the original slice. Expected: %v, Got: %v\", dstCopy, test.dst)\n\t\t}\n\t}\n}",
    "8db84bf8b529bb0fc69aa47c2d3ac7c6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4.2, 3},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 6.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v and %v, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "8f9e9416d8c0aaecb379aacadcf67c50": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 3.0, 3},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "9012a9920bb033f073d1054b802c5912": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t} else {\n\t\t\t\tfor i := range result {\n\t\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "90eda1a8282de7144480b0cef156e607": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1, 2, 3, 4, 5}, 4},\n\t\t{\"Test2\", []float64{5, 4, 3, 2, 1}, 0},\n\t\t{\"Test3\", []float64{1, 3, 2, 5, 4}, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9303356005fcdaa7752836a212c96a6f": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.slice, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "930bfa10b6dc4b7a361ff5e9c117915b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test1\", []float64{1, 2, 3}, 3.4076059644443805},\n\t\t{\"Test2\", []float64{0, 0, 0}, 1.0986122886681098},\n\t\t{\"Test3\", []float64{-1, -2, -3}, -0.3068528194400547},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "93bb65f0c24933e8c6e5822ca34a87d6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1, 2, 3, 4, 5},\n\t\t\texpected: []float64{5, 4, 3, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{5, 4, 3, 2, 1},\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1, 3, 5, 7, 9},\n\t\t\texpected: []float64{9, 7, 5, 3, 1},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tReverse(tt.input)\n\t\t\tif !reflect.DeepEqual(tt.input, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}",
    "95db695f7002f97cfcc763d5f131bde2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 1},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 2},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 3},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "971cdb9966ab10f3b6a66f22cf666530": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\ttolerance float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices within tolerance\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.1, 2.1, 3.1},\n\t\t\ttolerance: 0.2,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.1, 2.1},\n\t\t\ttolerance: 0.2,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slices with elements outside tolerance\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.1, 2.1, 3.5},\n\t\t\ttolerance: 0.2,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := EqualApprox(test.slice1, test.slice2, test.tolerance)\n\t\t\tassert.Equal(t, test.expected, result)\n\t\t})\n\t}\n}",
    "97f6a508a005bcc949f1573f054387f8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 3.0, 3},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "98455f52f62b2e50bb908d3d0ed0a1ec": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-package-path/floats\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1.0},\n\t\t{\"Single element slice\", []float64{5.0}, 5.0},\n\t\t{\"Multiple elements\", []float64{2.0, 3.0, 4.0}, 24.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v; want %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "9968eecfdf30082706212c97588e7293": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 5.451914395937264,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\ts:    []float64{0, 0, 0, 0, 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\ts:    []float64{-1, -2, -3, -4, -5},\n\t\t\twant: -0.3068528194400547,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 4\",\n\t\t\ts:    []float64{math.Inf(-1), math.Inf(1)},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "99d6db2036d4ac3edc0116983f0e560d": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Infinity Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        float64(''),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Zero Length Slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a496ba17ec527d8f006609f6f843ff6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 1, 1}},\n\t\t{[]float64{4, 6, 8}, []float64{2, 3, 4}, []float64{2, 2, 2}},\n\t\t{[]float64{10, 15, 20}, []float64{5, 3, 2}, []float64{2, 5, 10}},\n\t}\n\n\tfor _, test := range tests {\n\t\tDiv(test.dst, test.s)\n\t\tfor i := range test.dst {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, test.dst)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n",
    "9a6f496faafe107e1f1f8261c46d7bf1": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.8, 3},\n\t\t{[]float64{5.0, 4.0, 3.0, 2.0, 1.0}, 2.5, 3},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 6.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v and %v, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "9a98ff29fee4e9f72e766486242fbc11": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-package-path/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of result to be %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tfor i := 0; i \u003c len(result); i++ {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected result[%d] to be %f, but got %f\", i, test.dst[i], result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\n```",
    "9ab1d4dcd4e6e4dd07be351879e21a61": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 0.0, 10.0, 5.0, 2},\n\t\t{5, 0.0, 10.0, 5.0, 2},\n\t\t{6, 0.0, 10.0, 5.0, 3},\n\t\t{7, 0.0, 10.0, 5.0, 3},\n\t\t{8, 0.0, 10.0, 5.0, 4},\n\t\t{9, 0.0, 10.0, 5.0, 4},\n\t\t{10, 0.0, 10.0, 5.0, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "9b77ccabddafb9d8dc5b4b9224996375": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\tresult: []float64{15, 18, 21},\n\t\t},\n\t\t{\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ty:      []float64{1, 2, 3},\n\t\t\talpha:  0.5,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tresult: []float64{3, 4.5, 6},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tif !reflect.DeepEqual(test.dst, test.result) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.result, test.dst)\n\t\t}\n\t}\n}",
    "9c55932632ea7107edec31327f638aa7": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -0},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9cb0d360d85ad376bf2194447eafd178": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{\"No NaN values\", []float64{1.0, 2.0, 3.0}, false},\n\t\t{\"Contains NaN\", []float64{1.0, 2.0, 3.0, floats.NaN()}, true},\n\t\t{\"Empty slice\", []float64{}, false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.HasNaN(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected HasNaN(%v) to be %v, but got %v\", tt.input, tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "9d291a0a7219e71f1248386c72c4ebdd": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "9d4ab18a2d3be262fae27fe7439bf295": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not enough elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e6b0f9dd9f49f75a5ba370e3a417163": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "a016dbc2f0d6caf11e2cb0a3b863ab48": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 2.0, 3},\n\t\t{5, 0.0, 100.0, 75.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "a27f6a53f7ef837c6a2016083242e078": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test Span with valid input\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 3.3333333333333335, 6.666666666666667, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with NaN values\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with Inf values\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2bf07ba250a0365f9ac0b0f63d41c94": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "a3fe2ed40acd3b91aacc802c7c7b7333": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.6,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{10.0, 20.0, 30.0, 40.0, 50.0},\n\t\t\tv:        25.0,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{5.0, 15.0, 25.0, 35.0, 45.0},\n\t\t\tv:        22.0,\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a41f57f74af72aeefcd635aa831db8f0": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 4},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 6.0, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a47dd1cdc3dc83bbdb439193cd64f607": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{5, 0.0, 1.0, 0.1, 0},\n\t\t{5, 0.0, 1.0, 0.9, 4},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 1.0, 4},\n\t\t{5, 1.0, 0.0, 0.5, 2},\n\t\t{5, 1.0, 0.0, 0.1, 4},\n\t\t{5, 1.0, 0.0, 0.9, 0},\n\t\t{5, 1.0, 0.0, 0.0, 4},\n\t\t{5, 1.0, 0.0, 1.0, 0},\n\t\t{5, 1.0, 1.0, 0.5, 2},\n\t\t{5, 1.0, 1.0, 0.1, 0},\n\t\t{5, 1.0, 1.0, 0.9, 4},\n\t\t{5, 1.0, 1.0, 0.0, 0},\n\t\t{5, 1.0, 1.0, 1.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "a497dd8b46bc2c813c600319f2b295de": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 3},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -1},\n\t\t{\"Test4\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 2.5, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := Within(tt.s, tt.v)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4b60974e46bfdf6e006c7d82aaa379c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "a4d1d307540cd4a4d2ac0b2fb9d31721": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Infinity norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.slice, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a521218401b9b8dba09f0819080b73d1": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, -1, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "a54d54664865f2c31b2989b19aa1f707": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Expected result: %v, but got: %v\", dst, result)\n\t\t}\n\t}\n}\n",
    "a5e41a7195939f58c03fbd26820a8ba7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.8, 3},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{[]float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdx(test.s, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For %v and %v, expected %d but got %d\", test.s, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "a69b30c54f2b14f26c3f18c8767573b0": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    2,\n\t\t\twant: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    3,\n\t\t\twant: 3.3019272488946263,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Distance(tt.s, tt.t, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "a7d15f2cc559aa317134a3b5cf5abf3b": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{0, 1, 2}},\n\t\t{[]float64{5, 5, 5}, []float64{2, 3, 4}, []float64{3, 2, 1}},\n\t\t{[]float64{0, 0, 0}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tfloats.Sub(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub(%v, %v), got %v, want %v\", tt.dst, tt.s, tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a9d4441a857e403200ecd0cceab9906d": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.5, 2, 2.5},\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 3\",\n\t\t\tdst:  []float64{0, 0},\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\twant: []float64{-10, 10},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aaf32cd17c4604ddafa4458bb47ea3c4": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Span with N=5\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=3\",\n\t\t\tdst:  []float64{0, 0, 0},\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=4\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, -2.5, 0, 2.5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ab7dc606c0b084ab5d94a2ed91fc6c4b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{2, 1, 3}, []float64{2, 5, 2}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, []float64{2, 1, 3}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := DivTo(test.dst, test.s, test.t)\n\t\tif !Equal(got, test.want) {\n\t\t\tt.Errorf(\"DivTo(%v, %v, %v) = %v, want %v\", test.dst, test.s, test.t, got, test.want)\n\t\t}\n\t}\n}",
    "abb812288b8de738509d66c3ec95412e": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.8,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "adc5acf237e9d9e0b0eaa3cab7609c7a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\ti    int\n\t\tj    int\n\t\twant argsort\n\t}{\n\t\t{\n\t\t\tname: \"Swap elements at indices 0 and 1\",\n\t\t\ta: argsort{inds: []int{1, 2, 3, 4}},\n\t\t\ti: 0,\n\t\t\tj: 1,\n\t\t\twant: argsort{inds: []int{2, 1, 3, 4}},\n\t\t},\n\t\t{\n\t\t\tname: \"Swap elements at indices 2 and 3\",\n\t\t\ta: argsort{inds: []int{1, 2, 3, 4}},\n\t\t\ti: 2,\n\t\t\tj: 3,\n\t\t\twant: argsort{inds: []int{1, 2, 4, 3}},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.a.Swap(tt.i, tt.j)\n\t\t\tif !equal(tt.a.inds, tt.want.inds) {\n\t\t\t\tt.Errorf(\"Swap() = %v, want %v\", tt.a.inds, tt.want.inds)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "af54b607219a486ffb62bfa2478b3568": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}}, false},\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t\t{\"Single slice\", [][]float64{{1, 2, 3}}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af91ec866fc2f872635e8cfdd90e66fa": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\ts1:   []float64{},\n\t\t\ts2:   []float64{},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Equal(tt.s1, tt.s2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afb6691cc094d2b363d8525e14a19ac8": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestCumSum(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0, 0}, []float64{1, 2, 3, 4}, []float64{1, 3, 6, 10}},\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{1, 3, 6}},\n\t\t{[]float64{0, 0, 0, 0}, []float64{1, -2, 3, -4}, []float64{1, -1, 2, -2}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := floats.CumSum(tt.dst, tt.s); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"CumSum() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afc5e1b592f391571a48959e2f9e490f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{0, 0, 0, 0, 0},\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Count(tt.f, tt.s)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b023a706762e4bc46743e63893e9d4ca": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},\n\t\t{[]float64{0, 0}, []float64{1, 2}, []float64{3}, nil},\n\t\t{[]float64{0, 0}, []float64{1}, []float64{2, 3}, nil},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := MulTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b057253b10925d31efe70b9b96fdeb78": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -1},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -1},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.0, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0f9a3504d61dd97d7d30c129c71d603": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Value within slice range\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value at beginning of slice\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value at end of slice\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    5.0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value below slice range\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value above slice range\",\n\t\t\tslice:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tvalue:    6.0,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b1237c007a154e7551e96e4abef395ac": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tvalue    float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.slice, tt.value)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b171a68a65a0482c47261417a55b4971": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 10.0, 5.0, 2},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t\t{6, 0.0, 100.0, 50.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "b19603c719cd669e4b4e7417b1673a44": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -1},\n\t\t{\"Test case 4\", []float64{1.0, 2.0}, 1.5, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b1c211d15e5b97db52c1164cf02ab259": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, -5.0, 5.0, 2.0, 3},\n\t\t{5, -10.0, 10.0, 0.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "b213bf54d996e0039fda47719746bfab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0},\n\t\t\texpected: 6.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3},\n\t\t\texpected: 0.6,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b24730c325c23f8e9cf5a440666a54cd": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b247c18384f0d8daf42cbf9e1815e8cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{\"Test2\", []float64{0.1, 0.2, 0.3}, 0.6},\n\t\t{\"Test3\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b274b8c757536346f03da55ed0a60c98": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl, u, v float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 0},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 1},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 2},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 3},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "b2b41c0984a6fc130569c29ce9ac8aed": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t// Add your test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b39b4e92d68ff04931e1f9c49dce0d52": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, float64('a'), 0}, // should panic\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif recover() == nil {\n\t\t\t\t\tt.Errorf(\"Distance did not panic for test case: %v\", test)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdistance := floats.Distance(test.s, test.t, test.L)\n\t\t\tif distance != test.result {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t\t}\n\t\t}()\n\t}\n}",
    "b40f3129f28d9f1eeaeb9805d894b2d5": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: 3.3019272488946263,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", tt.s, tt.t, tt.L, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "b453eeefaf291a83ffcb9e4516aac460": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "b4b092207079221ea52e0eecea53fb6f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Max Absolute Value Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        -1,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L3 Distance\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: 3.3019272488946263,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Distance(tt.s, tt.t, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b517facd54cabc2f4032e18bd4d107cd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{1, 2, 3}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tMul(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b62580acc0fe992fad3b01981ef69e94": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8, 9}, []float64{11, 13, 15}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{7, 8}, nil}, // mismatched lengths\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := AddTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b62c0496f8758e4bda8819180b790391": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdistance := Distance(test.s, test.t, test.L)\n\t\tif distance != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, distance, test.result)\n\t\t}\n\t}\n}",
    "b7f2edbdc613f82d19b5b99c215ff5f3": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(test.dst, result) {\n\t\t\tt.Errorf(\"Span did not mutate the slice as expected. Expected: %v, Got: %v\", test.dst, result)\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.dst, dstCopy) {\n\t\t\tt.Errorf(\"Span mutated the original slice. Original: %v, Mutated: %v\", dstCopy, test.dst)\n\t\t}\n\t}\n}",
    "b89f9f1089868798b9e02bcd5e68794b": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", test.dst, test.l, test.u, result, expected)\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\n\tSpan([]float64{1}, 0, 10)\n}",
    "b8a05ba3a712e311a1d2e9009147f26b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 4},\n\t\t{\"Test4\", []float64{1.0, 2.0}, 1.5, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b90b25d30caac34e602553815fe2c041": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"Test2\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{\"Test3\", []float64{0.01, 0.02, 0.03, 0.04, 0.05}, 0.15},\n\t\t{\"Test4\", []float64{10.0, 20.0, 30.0, 40.0, 50.0}, 150.0},\n\t\t{\"Test5\", []float64{0.001, 0.002, 0.003, 0.004, 0.005}, 0.015},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tt.s)\n\t\t\tif math.Abs(got-tt.want) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ba6c5492461668b1361d8b51e520bf52": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{1, 1, 1, 1, 1}, 1, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tdstCopy := make([]float64, len(test.dst))\n\t\tcopy(dstCopy, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, test.dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(dstCopy) {\n\t\t\tt.Errorf(\"Length of mutated slice changed\")\n\t\t}\n\n\t\tfor i := range result {\n\t\t\texpected := test.l + (test.u-test.l)/float64(len(test.dst)-1)*float64(i)\n\t\t\tif result[i] != expected {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected, i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "bd09c4b3139e4799017cb559fa235589": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\t\tfor i, val := range result {\n\t\t\tif val != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected value %f at index %d, but got %f\", test.dst[i], i, val)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "bd0baf941d695935d5dc6dc476aff106": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{5, 0.0, 1.0, 0.2, 1},\n\t\t{5, 0.0, 1.0, 0.8, 3},\n\t\t{5, 0.0, 1.0, 1.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "bdbac0eb9fce9bd1874ee7d0e7ca5d5a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\tdst := []float64{1.0, 2.0, 3.0}\n\talpha := 2.0\n\ts := []float64{0.5, 1.0, 1.5}\n\n\tfloats.AddScaled(dst, alpha, s)\n\n\texpected := []float64{2.0, 4.0, 6.0}\n\n\tfor i := 0; i \u003c len(dst); i++ {\n\t\tif dst[i] != expected[i] {\n\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", expected[i], i, dst[i])\n\t\t}\n\t}\n}\n\nfunc TestAddScaled_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tdst := []float64{1.0, 2.0}\n\talpha := 2.0\n\ts := []float64{0.5, 1.0, 1.5}\n\n\tfloats.AddScaled(dst, alpha, s)\n}",
    "bf076eed918d7c3223f67e7e25518cf2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Same slices with same values\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Same slices with different values\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slices with NaN values\",\n\t\t\tslice1:   []float64{math.NaN(), 2.0, 3.0},\n\t\t\tslice2:   []float64{math.NaN(), 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slices with different lengths\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Same(tt.slice1, tt.slice2)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfda35f3c18a5baeca503393dbab6526": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 1, 2},\n\t\t{[]float64{0, 0, 0, 0, 0, 0, 0}, 1, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, expected)\n\t\t}\n\t}\n}",
    "c0ec03dca8cd07a84c9284fb4860376c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.0, 1},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 1.0, 2},\n\t\t{5, 0.0, 1.0, 1.0, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "c0edc28b0bb8ad039cd83dc2899be0c1": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 4, 9}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{3, 2, 1}, []float64{3, 4, 3}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, []float64{1, 2, 3}, nil},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := MulTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c219c9759b2b913ab17a36a30c8a5282": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  [][]float64\n\t\toutput bool\n\t}{\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}}, false},\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tt.input...)\n\t\t\tif result != tt.output {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.output, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c245931e3d9384bd8814b85c1d7c28c5": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.6, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.0, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c319c9163393d0f1a232cc36990f80f8": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Panic case for length less than 2\",\n\t\t\tdst:  []float64{0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif len(tt.dst) \u003c 2 {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for length less than 2, but no panic occurred\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length to be %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\tif result[0] != tt.l {\n\t\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", tt.l, result[0])\n\t\t\t}\n\n\t\t\tif result[len(result)-1] != tt.u {\n\t\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", tt.u, result[len(result)-1])\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "c36fad062905512cad6644b00bea6fb9": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t\t{5, 0.0, 1.0, 2.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "c424d8a35f7c8b05e45733b34ada50f6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 1},\n\t\t{4, 0.0, 1.0, 0.0, 1},\n\t\t{5, 0.0, 1.0, 0.0, 2},\n\t\t{2, 0.0, 1.0, -0.5, 0},\n\t\t{3, 0.0, 1.0, -0.5, 0},\n\t\t{4, 0.0, 1.0, -0.5, 0},\n\t\t{5, 0.0, 1.0, -0.5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "c4347345bb3b757aabbc440dd959adf5": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"All positive values\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{\"All negative values\", []float64{-5.0, -4.0, -3.0, -2.0, -1.0}, 0},\n\t\t{\"Mixed values\", []float64{-2.0, 5.0, -1.0, 3.0, 0.0}, 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Add more test cases as needed\n}\n",
    "c44e095c6325fd9ca41dd7c3957a9234": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c50cc8843b4580e570dbf84f66a3386f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) || !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Test %s failed - Expected: %v, %v, Got: %v, %v\", tt.name, tt.expected, tt.err, result, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "c5390b0747a0390f595f5a93fd3be797": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0}, 0, 10, []float64{0, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic for length less than 2\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 10)\n}",
    "c63de35547795507c7e26f34c81f2123": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 1, 1}, []float64{0, 1, 2}},\n\t\t{[]float64{5, 5, 5}, []float64{2, 3, 4}, []float64{3, 2, 1}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tfloats.Sub(tt.dst, tt.s)\n\t\tif !floats.Equal(tt.dst, tt.want) {\n\t\t\tt.Errorf(\"Sub(%v, %v) = %v, want %v\", tt.dst, tt.s, tt.dst, tt.want)\n\t\t}\n\t}\n}",
    "c66f332326724bc488067fc1ae2dee45": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 1, 10, []float64{1, 10, 100}},\n\t\t{[]float64{0, 0, 0, 0}, 2, 5, []float64{2, 3.1622776601683795, 5, 7.905694150420948}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0, []float64{0, 0, 0, 0, 0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c67238fc1cdc7f32abd6e8a9759afd8f": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tfor i := 0; i \u003c len(result); i++ {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", test.dst[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\nfunc TestSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tfloats.Span([]float64{1}, 0, 10)\n}",
    "c68f0eeab1152e158103052b21dc3f6f": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 5, 6}},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5}, []float64{}}, // Test case for panic\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, test.dst)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tMul(test.dst, test.s)\n\t\t}()\n\t}\n}",
    "c6e905e1ad53e35ccd01273d9f1d7878": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "c70bd4226e4382659ab756194d226ddb": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, 4},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 6.0, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c84004bbf3a69183c622f48e660f5b13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, math.Inf(1), 3},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "c9072aa3fc2774f4553a579a976d9871": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := make([]float64, len(test.dst))\n\t\tcopy(dst, test.dst)\n\n\t\tresult := Span(dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, dst) {\n\t\t\tt.Errorf(\"Span did not return the mutated slice\")\n\t\t}\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"First element should be %f, but got %f\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Last element should be %f, but got %f\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}",
    "c9a488ed3661683813cdc9acf0983fe4": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 0, []float64{math.Inf(1), 0, 0}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), 0, math.Inf(1)}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ca0939efcf7f3a8da4f08dbb68580e05": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Same slices with same values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Same slices with different values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slices with different lengths\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slices with NaN values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, floats.NaN()},\n\t\t\tt:        []float64{1.0, 2.0, 3.0, floats.NaN()},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Same(tt.s, tt.t)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected Same(%v, %v) to be %v, but got %v\", tt.s, tt.t, tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "ca5c8d4320f117c218de35798e287ba6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{7, 0, 10, 5, 3},\n\t\t{8, 0, 10, 5, 4},\n\t\t{9, 0, 10, 5, 4},\n\t\t{10, 0, 10, 5, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "cad7b02fd7a43024f9e31aaa000ba4d7": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.0, 1},\n\t\t{4, 1.0, 5.0, 3.0, 1},\n\t\t{5, 0.0, 100.0, 50.0, 2},\n\t\t{6, 0.0, 1.0, 0.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "cb2f4ecce6f8ce30d05a1cb5dedc4149": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 4\",\n\t\t\ts:        []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t\tv:        3.5,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb50929c3d31ad17a3f460bf88000ad7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0}, 6.0},\n\t\t{\"Test2\", []float64{0.1, 0.2, 0.3}, 0.6},\n\t\t{\"Test3\", []float64{0.5, 0.5, 0.5}, 1.5},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.s); !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\tconst tol = 1e-9\n\treturn math.Abs(a-b) \u003c tol\n}",
    "cb535218c3f70cf84aad141358af65fc": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) returned %v, expected %v\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "cba9f4ddaeffe47ca5b276cb857f5a91": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        floats.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.slice, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "cbb8d4e698be7f05734f9a6261da1335": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test Span with valid input\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 3.3333333333333335, 6.666666666666667, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with NaN\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Span with Inf\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd1af6b4b2cac1a9911a1fa1e5f63565": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.0, 2},\n\t\t{4, 0.0, 1.0, 1.0, 3},\n\t\t{5, 0.0, 1.0, 1.0, 4},\n\t\t{3, 0.0, 1.0, 0.0, 1},\n\t\t{4, 0.0, 1.0, 0.0, 1},\n\t\t{5, 0.0, 1.0, 0.0, 2},\n\t\t{3, 0.0, 1.0, 0.25, 1},\n\t\t{4, 0.0, 1.0, 0.25, 1},\n\t\t{5, 0.0, 1.0, 0.25, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "cd2551357bf5a4761b1d93b27199cd8e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6},\n\t\t\texpected: 2.1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd59b1cd0bb3ec2ddb479fb44184b611": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Distance(test.s, test.t, test.L)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f; want %f\", test.s, test.t, test.L, result, test.expected)\n\t\t}\n\t}\n}",
    "cdbdf12b54f31cf75f3fe8b5f104b1b6": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %v, but got %v\", len(test.dst), len(result))\n\t\t}\n\n\t\tfor i := range result {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected %v at index %v, but got %v\", test.dst[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "cec8ccef0f30afa2aa52c89fdd1aaf3a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -5, 3, -7, 9},\n\t\t\tL:        floats.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test zero length slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tt.slice, tt.L)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "ced77cd244892a4bc6b7d487dd1b6d4a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tc   float64\n\t\ts   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, 2, []float64{4, 5, 6}, []float64{8, 10, 12}},\n\t\t{[]float64{0, 0, 0}, 3, []float64{7, 8, 9}, []float64{21, 24, 27}},\n\t\t{[]float64{10, 20, 30}, 0, []float64{1, 2, 3}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := ScaleTo(test.dst, test.c, test.s)\n\t\tfor i := range got {\n\t\t\tif got[i] != test.want[i] {\n\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) = %v, want %v\", test.dst, test.c, test.s, got, test.want)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}",
    "cee9aea2c702fc18ba210f59a68d56ab": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{1, 1, 1, 1, 1, 1}, 1, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span did not return the expected result. Expected: %v, Got: %v\", expected, result)\n\t\t}\n\t}\n}",
    "cf3d2ac834f186c8f0097e850e7bbbbe": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice1   []float64\n\t\tslice2   []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different lengths\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different elements\",\n\t\t\tslice1:   []float64{1.0, 2.0, 3.0},\n\t\t\tslice2:   []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tt.slice1, tt.slice2, func(a, b float64) bool {\n\t\t\t\treturn a == b\n\t\t\t})\n\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfbb4651815b01c03980fee9bcea668b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 10.0, 5.5, 2},\n\t\t{4, -5.0, 5.0, 3.0, 3},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "cfc03b5acebd84a7b4d5789bde286391": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{1, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        1,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d00820bb1a4bd89672dcb2c82326bc12": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},\n\t\t{[]float64{0, 0, 0}, []float64{4, 5, 6}, []float64{0, 0, 0}},\n\t\t{[]float64{1, 2, 3}, []float64{0, 0, 0}, []float64{0, 0, 0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tMul(test.dst, test.s)\n\t\tfor i := 0; i \u003c len(test.dst); i++ {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", test.expected, test.dst)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\nfunc TestMul_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tMul([]float64{1, 2, 3}, []float64{4, 5})\n}",
    "d03fbbedb07ba59353ee3aa2469554c4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 3 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, -1, -2, -3},\n\t\t\tk:        3,\n\t\t\texpected: []int{0, 1, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, -1, -2, -3},\n\t\t\tk:        -1,\n\t\t\texpected: []int{3, 4, 5},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Not enough elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{-1, -2, -3},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := floats.Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Expected error %v, but got %v\", tt.err, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d0618cf3772a1cbdb3f414697491934f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 3\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 10 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\tfor i := range result {\n\t\t\t\tif result[i] != tt.expected[i] {\n\t\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1ae84045c77da5ac561a7f186238cb5": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{6, 0.0, 1.0, 0.5, 2},\n\t\t{7, 0.0, 1.0, 0.5, 3},\n\t\t{8, 0.0, 1.0, 0.5, 3},\n\t\t{9, 0.0, 1.0, 0.5, 4},\n\t\t{10, 0.0, 1.0, 0.5, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}",
    "d1e51f3ebef2601345a50316d8222b28": "package floats_test\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t. \"your_module_path/floats\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\"Test case 1\", []float64{1, 2, 3}, 3.4076059644443803},\n\t\t{\"Test case 2\", []float64{0, 0, 0}, 0.6931471805599453},\n\t\t{\"Test case 3\", []float64{-1, -2, -3}, -0.3068528194400547},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Add more test cases as needed\n```",
    "d21d94f17836ef34ef6e24fe8f5c1794": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\"Equal lengths\", [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, true},\n\t\t{\"Different lengths\", [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8}}, false},\n\t\t{\"Empty slices\", [][]float64{}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d2d4683e15ed6c7820e9cc788de1ae6c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"Test Case 1\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Case 2\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) || !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"Test Case %s failed. Expected: %v, %v, Got: %v, %v\", tt.name, tt.expected, tt.err, result, err)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d3f731fcec5e030b686db890c77b0152": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.5, 1},\n\t\t{\"Test5\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4.5, 3},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d472e2d93552a6c0dda8754ae8121fc6": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Span with N=5\",\n\t\t\tdst:      []float64{0, 0, 0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with N=3\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        1,\n\t\t\tu:        2,\n\t\t\texpected: []float64{1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"Span with N=2\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\tl:        -5,\n\t\t\tu:        5,\n\t\t\texpected: []float64{-5, 5},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Panic for short destination slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for short destination slice\")\n\t\t\t}\n\t\t}()\n\n\t\tSpan([]float64{0}, 0, 10)\n\t})\n}",
    "d54d5f470d5f7010a1f68fb43aacbcd4": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0.0, 10.0, 4.5, 2},\n\t\t{3, 0.0, 10.0, 15.0, 2},\n\t\t{4, 0.0, 10.0, 10.0, 3},\n\t\t{2, 0.0, 10.0, 5.0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "d54f36e019297f6ad65085cc8a881991": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your_module_name/floats\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\ttol  float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices within tolerance\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.1, 2.1, 3.1},\n\t\t\ttol:  0.2,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.1, 2.1},\n\t\t\ttol:  0.2,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Slices with elements outside tolerance\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.1, 2.1, 3.5},\n\t\t\ttol:  0.2,\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.EqualApprox(tt.s1, tt.s2, tt.tol)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "d7391925b9ae35074c2ad1cdf8cee8b0": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\twant bool\n\t}{\n\t\t{\"Equal slices\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, true},\n\t\t{\"Different lengths\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0}, false},\n\t\t{\"Different values\", []float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 4.0}, false},\n\t\t{\"Empty slices\", []float64{}, []float64{}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Equal(tt.s1, tt.s2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d799b91a3bd21a0eb9863753a3943661": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0, 10, 5, 1},\n\t\t{3, 0, 10, 5, 1},\n\t\t{4, 0, 10, 5, 2},\n\t\t{5, 0, 10, 5, 2},\n\t\t{6, 0, 10, 5, 3},\n\t\t{3, 0, 10, 15, 2},\n\t\t{3, 0, 10, -5, 0},\n\t\t{3, 0, 10, 0, 1},\n\t\t{3, 10, 0, 5, 1},\n\t\t{3, 10, 0, 15, 0},\n\t\t{3, 10, 0, -5, 2},\n\t\t{3, 10, 0, 0, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "d7b6ea6bd6829ec9f86229042aa6cc5b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.6, 3},\n\t\t{2, -1.0, 1.0, 0.0, 1},\n\t\t{3, -1.0, 1.0, -0.5, 0},\n\t\t{4, -1.0, 1.0, 0.5, 2},\n\t\t{5, -1.0, 1.0, -0.8, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "d8099fc547bc3e0cba409e34e0be5d49": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\t// Add your assertions here\n\t\t\t// For example, check if the length of result is the same as the length of tt.dst\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length to be %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\t\t})\n\t}\n}",
    "d91536c4291955fa1cb968ab179e0f7a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{3, 0.0, 1.0, -0.5, 0},\n\t\t{3, 1.0, 0.0, 0.5, 2},\n\t\t{3, 1.0, 0.0, 1.5, 0},\n\t\t{3, 1.0, 0.0, -0.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "d9c055ec104c56718a9f735546ef9f34": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{3, 0.0, 1.0, -0.5, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{3, 0.0, 1.0, -1.0, 0},\n\t\t{3, 1.0, 0.0, 0.5, 1},\n\t\t{3, 1.0, 0.0, 1.5, 1},\n\t\t{3, 1.0, 0.0, -0.5, 2},\n\t\t{3, 1.0, 0.0, 2.0, 0},\n\t\t{3, 1.0, 0.0, -1.0, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "db0efa97eac5aa38beace3d862c72995": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "dc0c51f114dd31f4e8df118530ca14e5": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{3, 0.0, 1.0, 0.75, 2},\n\t\t{3, 1.0, 0.0, 0.5, 1},\n\t\t{3, 1.0, 0.0, 1.5, 0},\n\t\t{3, 1.0, 0.0, -0.5, 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "dc352efe1934cd3627e87fc74681474a": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\"All positive values\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 4},\n\t\t{\"All negative values\", []float64{-5.0, -4.0, -3.0, -2.0, -1.0}, 4},\n\t\t{\"Mixed positive and negative values\", []float64{-5.0, 4.0, -3.0, 2.0, -1.0}, 1},\n\t\t{\"Repeated maximum value\", []float64{1.0, 2.0, 3.0, 3.0, 5.0}, 2},\n\t\t{\"Empty slice\", []float64{}, -1}, // Expecting a panic\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tif tt.expected == -1 {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for empty slice, but no panic occurred\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := floats.MaxIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d for input %v\", tt.expected, result, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "dcd2c202fca790496c6f66029cca00a0": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\texpected := make([]float64, len(test.dst))\n\t\tcopy(expected, test.dst)\n\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif !reflect.DeepEqual(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, expected)\n\t\t}\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\n\tSpan([]float64{1}, 0, 10)\n}",
    "dcfe3ecfae6fa288d7bcd0d33508722c": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Span with N=5\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=3\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -5,\n\t\t\tu:    5,\n\t\t\twant: []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Test Span with N=4\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    1,\n\t\t\tu:    2,\n\t\t\twant: []float64{1, 1.3333333333333333, 1.6666666666666665, 2},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Test Span panic\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 10)\n\t})\n}",
    "de0f41c026a90025ceeee7a8b47d9b51": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.5, 1},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "df7fb887ea18e4ff6789fa276836ed07": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case with NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Special case with Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0, 0},\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0511d81fad1093714fcf21a2a02a933": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t. \"your_module_path/floats\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1.0},\n\t\t{\"Single element slice\", []float64{5.0}, 5.0},\n\t\t{\"Multiple elements\", []float64{2.0, 3.0, 4.0}, 24.0},\n\t\t{\"Zero value\", []float64{2.0, 0.0, 4.0}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v; want %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e0de08f91bb8621093aea8a6f6895828": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tdst := []float64{3.5, 1.2, 4.8, 2.1}\n\tinds := make([]int, len(dst))\n\tArgsort(dst, inds)\n\n\texpectedDst := []float64{1.2, 2.1, 3.5, 4.8}\n\texpectedInds := []int{1, 3, 0, 2}\n\n\tif !reflect.DeepEqual(dst, expectedDst) {\n\t\tt.Errorf(\"Expected sorted dst to be %v, but got %v\", expectedDst, dst)\n\t}\n\n\tif !reflect.DeepEqual(inds, expectedInds) {\n\t\tt.Errorf(\"Expected inds to be %v, but got %v\", expectedInds, inds)\n\t}\n}",
    "e23f0499b54dde9b7d452678e119f319": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{5, 0, 10, 4, 2},\n\t\t{3, 0, 10, 15, 2},\n\t\t{4, 0, 10, 5, 2},\n\t\t{2, 0, 10, 5, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "e25ace83e9153cf53faa9bc86e8579de": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 1},\n\t\t{2, 0.0, 1.0, 0.2, 0},\n\t\t{3, 0.0, 1.0, 0.2, 0},\n\t\t{4, 0.0, 1.0, 0.2, 0},\n\t\t{5, 0.0, 1.0, 0.2, 0},\n\t\t{2, 0.0, 1.0, 0.8, 1},\n\t\t{3, 0.0, 1.0, 0.8, 1},\n\t\t{4, 0.0, 1.0, 0.8, 1},\n\t\t{5, 0.0, 1.0, 0.8, 1},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "e36e2d6500656f6ab7d05eebfb5207f7": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.6, 2},\n\t\t{\"Test case 2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test case 3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, 4},\n\t\t{\"Test case 4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.0, 2},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdx(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e3d4b6f7a4af707bc819ae7f7d99fff2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslice    []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Test L2 norm\",\n\t\t\tslice:    []float64{1, 2, 3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 7.416198487095663,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test L1 norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        1,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Inf norm\",\n\t\t\tslice:    []float64{1, -2, 3, -4, 5},\n\t\t\tL:        floats.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test empty slice\",\n\t\t\tslice:    []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := floats.Norm(tc.slice, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "e3debfe533834eb7a925993f5da8abed": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tdst := []float64{3.5, 1.2, 4.8, 2.1}\n\tinds := make([]int, len(dst))\n\texpectedDst := []float64{1.2, 2.1, 3.5, 4.8}\n\texpectedInds := []int{1, 3, 0, 2}\n\n\tfloats.Argsort(dst, inds)\n\n\tif !reflect.DeepEqual(dst, expectedDst) {\n\t\tt.Errorf(\"Expected sorted dst to be %v, but got %v\", expectedDst, dst)\n\t}\n\n\tif !reflect.DeepEqual(inds, expectedInds) {\n\t\tt.Errorf(\"Expected inds to be %v, but got %v\", expectedInds, inds)\n\t}\n}",
    "e46741c04a2ae3e8fb5d63a0dfcf1389": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -1},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -1},\n\t\t{\"Test4\", []float64{1.0, 2.0}, 1.5, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e4b1a35bdcaef67e0246950a70f8a28b": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{2, 0.0, 1.0, 1.0, 1},\n\t\t{3, 0.0, 1.0, 1.0, 1},\n\t\t{4, 0.0, 1.0, 1.0, 1},\n\t\t{5, 0.0, 1.0, 1.0, 2},\n\t\t{2, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "e551b450b466d5af6639a408ad6d1cd2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0, 0}, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tif result[0] != test.l {\n\t\t\tt.Errorf(\"Expected first element to be %f, but got %f\", test.l, result[0])\n\t\t}\n\n\t\tif result[len(result)-1] != test.u {\n\t\t\tt.Errorf(\"Expected last element to be %f, but got %f\", test.u, result[len(result)-1])\n\t\t}\n\t}\n}\n",
    "e56decab21bda765dea786add27026fb": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 2},\n\t\t{5, 0.0, 1.0, 0.1, 0},\n\t\t{6, 0.0, 1.0, 0.9, 5},\n\t\t{2, 0.0, 0.0, 0.0, 0},\n\t\t{3, 1.0, 0.0, 0.5, 2},\n\t\t{4, 1.0, 1.0, 1.0, 0},\n\t\t{5, 0.0, 0.0, 0.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "e5e9fa216268e609baeb416605b77cd2": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 10.0, 5.0, 2},\n\t\t{5, 0.0, 10.0, 5.0, 2},\n\t\t{6, 0.0, 10.0, 5.0, 2},\n\t\t{7, 0.0, 10.0, 5.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "e7908f6ba9246e52947f0c450542ee07": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/yourmodule/floats\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1},\n\t\t{\"Single element\", []float64{5}, 5},\n\t\t{\"Multiple elements\", []float64{2, 3, 4}, 24},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, but got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7de2bec59d8d297fc181da6f481f74b": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\tresult []float64\n\t}{\n\t\t{\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\tresult: []float64{18, 21, 24},\n\t\t},\n\t\t{\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ty:      []float64{1, 2, 3},\n\t\t\talpha:  0.5,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tresult: []float64{3, 4.5, 6},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tAddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\tif !reflect.DeepEqual(test.dst, test.result) {\n\t\t\tt.Errorf(\"Expected %v, but got %v\", test.result, test.dst)\n\t\t}\n\t}\n}",
    "e8244b76a457320d0ab3b95b58a6c2da": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for NaN\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    0,\n\t\t\tu:    floats.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Special case for Inf\",\n\t\t\tdst:  []float64{0, 0, 0, 0},\n\t\t\tl:    floats.Inf(-1),\n\t\t\tu:    floats.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.Span(tt.dst, tt.l, tt.u)\n\n\t\t\tif len(result) != len(tt.dst) {\n\t\t\t\tt.Errorf(\"Expected result length %d, but got %d\", len(tt.dst), len(result))\n\t\t\t}\n\n\t\t\tfor i, val := range result {\n\t\t\t\tif val != tt.dst[i] {\n\t\t\t\t\tt.Errorf(\"Expected value %f at index %d, but got %f\", tt.dst[i], i, val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "e846085b6c4d3e90047c324e42424143": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, 0},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.5, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := Within(tt.s, tt.v)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e84c735c076f2f8bd8d768404cfa6161": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t\t{5, 0.0, 1.0, 2.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, Got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "eaffafaa2e0ca1f7561e224cb9d3208c": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Empty slice\", []float64{}, 1},\n\t\t{\"Single element slice\", []float64{5}, 5},\n\t\t{\"Multiple elements\", []float64{2, 3, 4}, 24},\n\t\t{\"Negative numbers\", []float64{-2, -3, -4}, -24},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Prod(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2979221b37e0bc94da0f2b22cd5473": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\tresult float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 2, 5.196152422706632},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 1, 9},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, 3, 3.3019272488946263},\n\t\t{[]float64{1, 2, 3}, []float64{4, 5, 6}, float64('a'), 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.Distance(test.s, test.t, test.L)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v; want %v\", test.s, test.t, test.L, result, test.result)\n\t\t}\n\t}\n}",
    "ed4c3249384c384098afcc70d1b2cbca": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\"Test case 1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 15.0},\n\t\t{\"Test case 2\", []float64{0.1, 0.2, 0.3, 0.4, 0.5}, 1.5},\n\t\t{\"Test case 3\", []float64{0.01, 0.02, 0.03, 0.04, 0.05}, 0.15},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tt.input)\n\t\t\tif math.Abs(result-tt.expected) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"Expected %f, but got %f\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}",
    "edd6222fcf0881ddecd2e6230084c628": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 1, []float64{0, 0.5, 1}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0}, 0, 0, []float64{0, 0}},\n\t\t{[]float64{0, 0}, math.NaN(), 1, []float64{math.NaN(), 1}},\n\t\t{[]float64{0, 0}, 1, math.NaN(), []float64{1, math.NaN()}},\n\t\t{[]float64{0, 0}, math.Inf(0), math.Inf(0), []float64{math.Inf(0), math.Inf(0)}},\n\t\t{[]float64{0, 0}, math.Inf(0), 1, []float64{math.Inf(0), 1}},\n\t\t{[]float64{0, 0}, 1, math.Inf(1), []float64{1, math.Inf(1)}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ede839d8aa21a2a990793caf464a7fa3": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\tresult int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{3, 0.0, 1.0, 1.5, 2},\n\t\t{4, 0.0, 1.0, 1.5, 2},\n\t\t{5, 0.0, 1.0, 1.5, 3},\n\t\t{3, 0.0, 1.0, 0.0, 0},\n\t\t{4, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{3, 0.0, 1.0, 2.0, 2},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t\t{5, 0.0, 1.0, 2.0, 4},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.result, result)\n\t\t}\n\t}\n}\n",
    "ee11c775a2b30640658618f6276f10f9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttests := []struct {\n\t\tslice1 []float64\n\t\tslice2 []float64\n\t\ttol    float64\n\t\texpected bool\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.0, 2.0, 3.0}, 0.1, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.1, 2.1, 3.1}, 0.1, true},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.2, 2.2, 3.2}, 0.1, false},\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{1.1, 2.1}, 0.1, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := EqualApprox(test.slice1, test.slice2, test.tol)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected EqualApprox(%v, %v, %f) to be %t, but got %t\", test.slice1, test.slice2, test.tol, test.expected, result)\n\t\t}\n\t}\n}\n",
    "eee73366a6b12e52db5a164b7574ac06": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t}{\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003e 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t},\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x \u003c 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 3},\n\t\t},\n\t\t{\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x == 0 },\n\t\t\ts:        []float64{1, -2, 3, -4, 5},\n\t\t\tk:        3,\n\t\t\texpected: []int{},\n\t\t},\n\t}\n\n\t// Run tests\n\tfor _, test := range tests {\n\t\tresult, err := Find(test.inds, test.f, test.s, test.k)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Find returned an error: %v\", err)\n\t\t}\n\t\tif !equalSlices(result, test.expected) {\n\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) = %v; want %v\", test.inds, test.f, test.s, test.k, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc equalSlices(s1, s2 []int) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "ef173baae917f51659bbeea6f5a88278": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Valid case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Edge case - lower bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Edge case - upper bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value not found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        6.0,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Within(tt.s, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f000ba2650b7d541450f4670b4290607": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, 0, math.Inf(1), []float64{0, math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), 0, []float64{math.Inf(1), 0, 0}},\n\t\t{[]float64{0, 0, 0}, math.Inf(1), math.Inf(1), []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t{[]float64{0, 0, 0}, math.Inf(-1), 0, []float64{math.Inf(-1), 0, 0}},\n\t\t{[]float64{0, 0, 0}, 0, math.NaN(), []float64{0, math.NaN(), math.NaN()}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), 0, []float64{math.NaN(), 0, 0}},\n\t\t{[]float64{0, 0, 0}, math.NaN(), math.NaN(), []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t{[]float64{0, 0, 0}, 5, 10, []float64{5, 7.5, 10}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t}\n\t}\n}",
    "f0b30df2d6d93e47dff67646e0ce6c10": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 3},\n\t\t{3, math.NaN(), 1.0, 0.5, 2},\n\t\t{3, 0.0, math.NaN(), 0.5, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), 0.0, 0},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{3, math.Inf(-1), math.Inf(1), math.Inf(1), 2},\n\t\t{3, math.Inf(-1), math.Inf(1), 0.5, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "f15c3362d300b641bf4f7188dbe271b2": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0}, 0, 0, []float64{0, 0, 0}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := floats.Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f2c99ede0b70b8c7222aa22af27455ed": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{3.0, 1.0, 4.0, 1.0, 5.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{1.0, 1.0, 1.0, 1.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f2d0a4e0607696b81d0f7831b78f1a69": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2}, []float64{4, 5, 6}, nil},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{4, 5}, nil},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{4, 10, 18}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) = %v; want %v\", tt.dst, tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2f791bd017a2c0391ee414f8e34deb6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLess(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs argsort\n\t\ti    int\n\t\tj    int\n\t\twant bool\n\t}{\n\t\t// Add test cases here\n\t\t{\n\t\t\tname: \"Test case 1\",\n\t\t\targs: argsort{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\ti:    2,\n\t\t\tj:    3,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test case 2\",\n\t\t\targs: argsort{s: []float64{5.0, 4.0, 3.0, 2.0, 1.0}},\n\t\t\ti:    0,\n\t\t\tj:    4,\n\t\t\twant: false,\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.args.Less(tt.i, tt.j); got != tt.want {\n\t\t\t\tt.Errorf(\"Less() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f4050e94ad42ab51bda296b51cea2843": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10, []float64{0, 5, 10}},\n\t\t{[]float64{0, 0, 0, 0}, 0, 10, []float64{0, 3.3333333333333335, 6.666666666666667, 10}},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 10, []float64{0, 2.5, 5, 7.5, 10}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := Span(tt.dst, tt.l, tt.u); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for length less than 2\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 0, 10)\n}",
    "f51a1aaeae1dd7bf0c8e26f89b8b78ab": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Test LogSpan with valid input\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    1,\n\t\t\tu:    100,\n\t\t\twant: []float64{1, 10, 100, 1000, 10000},\n\t\t},\n\t\t{\n\t\t\tname: \"Test LogSpan with negative bounds\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -1,\n\t\t\tu:    -10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Test LogSpan with zero bounds\",\n\t\t\tdst:  make([]float64, 4),\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\twant: []float64{0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Test LogSpan with insufficient length\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    1,\n\t\t\tu:    10,\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSpan(tt.dst, tt.l, tt.u)\n\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f5730e5037fa3baa3a7797e3cf5e3a11": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1\",\n\t\t\tinput:    []float64{3.5, 2.0, 5.1, 1.2, 4.8},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2\",\n\t\t\tinput:    []float64{10.5, 20.0, 5.1, 1.2, 4.8},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3\",\n\t\t\tinput:    []float64{3.5, 2.0, 1.2, 1.2, 4.8},\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := floats.MinIdx(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected index %d, but got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f5bab763ada8fe7c36081efa09724629": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tdst      []float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{[]float64{1.0, 2.0, 3.0}, []float64{4.0, 5.0, 6.0}, []float64{5.0, 7.0, 9.0}},\n\t\t{[]float64{10.0, 20.0, 30.0}, []float64{40.0, 50.0, 60.0}, []float64{50.0, 70.0, 90.0}},\n\t\t{[]float64{0.0, 0.0, 0.0}, []float64{0.0, 0.0, 0.0}, []float64{0.0, 0.0, 0.0}},\n\t}\n\n\tfor _, test := range tests {\n\t\tfloats.Add(test.dst, test.s)\n\t\tfor i := range test.dst {\n\t\t\tif test.dst[i] != test.expected[i] {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", test.expected[i], i, test.dst[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Add more test cases as needed\nfunc TestAdd_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"The code did not panic as expected\")\n\t\t}\n\t}()\n\n\tfloats.Add([]float64{1.0, 2.0}, []float64{3.0, 4.0, 5.0})\n}",
    "f609d4620b7ad1d4e4f0ba7a78ef6ae8": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/path/to/your/package/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{5, 0.0, 1.0, 0.2, 1},\n\t\t{5, 0.0, 1.0, 0.8, 3},\n\t\t{5, 0.0, 1.0, 0.0, 0},\n\t\t{5, 0.0, 1.0, 1.0, 4},\n\t\t{5, 0.0, 1.0, -1.0, 0},\n\t\t{5, 0.0, 1.0, 2.0, 4},\n\t\t{5, 1.0, 0.0, 0.5, 2},\n\t\t{5, 1.0, 0.0, 0.0, 4},\n\t\t{5, 1.0, 0.0, 1.0, 0},\n\t\t{5, 1.0, 0.0, -1.0, 4},\n\t\t{5, 1.0, 0.0, 2.0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f, expected %d, but got %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n",
    "f6c14f0baeb9d56eb54d29effcc34ad0": "package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"Test1\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 3.5, 2},\n\t\t{\"Test2\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 0.5, -2},\n\t\t{\"Test3\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 5.0, -2},\n\t\t{\"Test4\", []float64{1.0, 2.0, 3.0, 4.0, 5.0}, 2.0, 0},\n\t\t{\"Test5\", []float64{5.0, 4.0, 3.0, 2.0, 1.0}, 3.5, -1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual := Within(tt.s, tt.v)\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %d, but got %d\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8164ef3c4d50b252e6a8135c40a0ab5": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Test Case 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\twant: 3.4076059644443805,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 2\",\n\t\t\ts:    []float64{0, 0, 0},\n\t\t\twant: 0.6931471805599453,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Case 3\",\n\t\t\ts:    []float64{-1, -2, -3},\n\t\t\twant: -0.3068528194400547,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "f8a59234d5fba12b9c07d35cf59640d8": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your/package/floats\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\tdst := []float64{3.5, 1.2, 4.7, 2.1}\n\tinds := []int{0, 1, 2, 3}\n\n\tfloats.Argsort(dst, inds)\n\n\texpectedDst := []float64{1.2, 2.1, 3.5, 4.7}\n\texpectedInds := []int{1, 3, 0, 2}\n\n\tif !reflect.DeepEqual(dst, expectedDst) {\n\t\tt.Errorf(\"Expected sorted dst to be %v, but got %v\", expectedDst, dst)\n\t}\n\n\tif !reflect.DeepEqual(inds, expectedInds) {\n\t\tt.Errorf(\"Expected inds to be %v, but got %v\", expectedInds, inds)\n\t}\n}",
    "fbcec84a399d16e857a04dd4101ba926": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}{\n\t\t{[]float64{0, 0, 0}, 0, 10},\n\t\t{[]float64{1, 2, 3, 4, 5}, 1, 5},\n\t\t{[]float64{0, 0, 0, 0, 0}, 0, 0},\n\t\t{[]float64{1, 1, 1, 1, 1, 1}, 1, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := Span(test.dst, test.l, test.u)\n\n\t\tif len(result) != len(test.dst) {\n\t\t\tt.Errorf(\"Expected length of %d, but got %d\", len(test.dst), len(result))\n\t\t}\n\n\t\tfor i := range result {\n\t\t\tif result[i] != test.dst[i] {\n\t\t\t\tt.Errorf(\"Expected %f at index %d, but got %f\", test.dst[i], i, result[i])\n\t\t\t}\n\t\t}\n\t}\n}",
    "fdddd85e91abddc251b9da767bee01fa": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t\twant []float64\n\t}{\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{4, 5, 6}, []float64{5, 7, 9}},\n\t\t{[]float64{1, 2, 3}, []float64{1, 2, 3}, []float64{1, 2}, nil}, // mismatched lengths\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := AddTo(tt.dst, tt.s, tt.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fe478ab38e642e30157bc134e5ad80b3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 10.0, 7.0, 3},\n\t\t{3, -5.0, 5.0, 0.0, 1},\n\t\t{4, -10.0, -5.0, -7.5, 1},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}",
    "fffbfad0db7ae393fa0704ea9b316d33": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{2, 0.0, 1.0, 0.5, 1},\n\t\t{3, 0.0, 1.0, 0.5, 1},\n\t\t{4, 0.0, 1.0, 0.5, 1},\n\t\t{5, 0.0, 1.0, 0.5, 2},\n\t\t{4, 0.0, 1.0, 0.25, 0},\n\t\t{4, 0.0, 1.0, 0.75, 3},\n\t\t{4, 0.0, 1.0, 1.0, 3},\n\t\t{4, 0.0, 1.0, -1.0, 0},\n\t\t{4, 0.0, 1.0, 2.0, 3},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For n=%d, l=%f, u=%f, v=%f - Expected: %d, but got: %d\", test.n, test.l, test.u, test.v, test.expected, result)\n\t\t}\n\t}\n}\n"
}