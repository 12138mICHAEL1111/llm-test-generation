{
    "0215348bb87bbfbf266f19937ec2247e": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3, 4, 5}\n\t\ts := []float64{0.5, 1, 1.5, 2, 2.5}\n\t\texpected := []float64{0.5, 1, 1.5, 2, 2.5}\n\n\t\tSub(dst, s)\n\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3, 4, 5}\n\t\ts := []float64{0.5, 1, 1.5}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Sub() did not panic with unequal length slices\")\n\t\t\t}\n\t\t}()\n\t\tSub(dst, s)\n\t})\n}",
    "02fbbeaf9207bbe077f089b5539b257d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0481378a1b09214b71ea7267f94d33e1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice\",\n\t\t\ts:    []float64{1.0, 2.0, 0.5, 3.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN(), 3.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: func() int {\n\t\t\t\tdefer func() {\n\t\t\t\t\trecover()\n\t\t\t\t}()\n\t\t\t\treturn MinIdx([]float64{})\n\t\t\t}(),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "00ff8da04f0e838382a81a82fbe07efe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02c76544e44aa50c3890e81b07f8e90f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple nearest values\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0448c285f2fcbc79b86a5077593f1471": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "049bf5e147c76a4cefac4edd03539ef1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.7,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0509e0638a4b45d441f01d4ba3e331eb": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tc    float64\n\t\tdst  []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tc:    2.0,\n\t\t\tdst:  []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\tc:    2.0,\n\t\t\tdst:  []float64{1.0},\n\t\t\twant: []float64{2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\tc:    3.0,\n\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\twant: []float64{3.0, 6.0, 9.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tScale(tt.c, tt.dst)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Scale(%v, %v) = %v, want %v\", tt.c, tt.dst, tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02d05743532d1daecf41e66d43e30cae": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0026966f482687b357882089f4e9ee0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v < l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v > u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "013e5ee407fb258d6a8c3fda98af7c6a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid length\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02dace20380755f8b679152b01cb1c37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"zero element dst\",\n\t\t\tdst:    []float64{},\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "028e90cbce778d1961c87aa647c65dad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, odd n, v Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, even n\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"finite l, Inf u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf, l = u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v -Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v -Inf, l = u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v < l\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    0.1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v > u\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    1.1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v between l and u\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    0.75,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v between u and l\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0.5,\n\t\t\tv:    0.75,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "07a3669a4df39454690361c55d14ee12": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    10,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside (l, u)\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside (u, l)\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    11,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "078c692d78e6f34adcf892727898b8a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0b097e9900feb8b9e641c792209cf25f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice\",\n\t\t\ts:    []float64{5.0, 2.0, 3.0, 1.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN\",\n\t\t\ts:    []float64{5.0, 2.0, math.NaN(), 1.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "082fe751a23930a68a019f44025e09cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf lower and upper bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "08367c21374f71c8896f648b0805835b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "092d969bdc8d331e1383b09ae960574d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0843ef585b873a1a79ee4ad7a8360783": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0c3582a382574f253a9d3e2de6f04b2e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed NaN and non-NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "08d82e43185b5ac68d847ab24ea6f61b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is in the middle of the range\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0a4296a1d29592be5b3cbae3eddad4e4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expected == nil {\n\t\t\t\t// Expect a panic\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t\t} else {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d37d4ebe8ea732945906d799178ed91": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"all true\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"all false\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"some true\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x > 3.0\n\t\t\t},\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x > 0.0\n\t\t\t},\n\t\t\ts:        []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Count(tc.f, tc.s)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Count(%v, %v) = %d, expected %d\", tc.f, tc.s, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0b471cefc5359254a2f629459fb3aade": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is -Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0a81dba7d0fdfeb9b2ee90d5fffab1ef": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is finite, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is finite, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, l is finite, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, l is finite, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between l and u, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between l and u, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0cbfee12334c61b215b68e7039d3e04c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e9561493f6229f9472a0d33b0425509": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5.0,\n\t\t\tu:      -1.0,\n\t\t\twant:   []float64{-5.0, -3.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 5.0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d144bb389e3e2f7fce75bb9ab4c36ba": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is between l and u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is between l and u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d38cf851eedbeb3bf60880a2ff1cb98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) panicked: %v\", tc.s, tc.t, tc.L, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(got-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0fd11dba8dbc082251b5cc7acfffe5cd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twant:   []float64{11, 13, 15},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"AddTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := AddTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e04172c6c2d5d231457bf49bbcc2001": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expected == nil {\n\t\t\t\t// Expect a panic\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t\t} else {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "10520592a0f56f200f0a6b8fc4e6f903": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tf        func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unequal lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"unequal elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.1, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"equal with tolerance\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0001},\n\t\t\tf:        func(a, b float64) bool { return a-b < 0.001 },\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tc.s1, tc.s2, tc.f)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v, %v) = %v, expected %v\", tc.s1, tc.s2, tc.f, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "11f572eb365996ad3a7cf07e62825761": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0f3a51095de34ca23f6513dd63718b5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{1, 3.1622776601683795, 10, 31.622776601683793, 100},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -1,\n\t\t\tu:        100,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        100,\n\t\t\texpected: []float64{0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        -100,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\texpected: []float64{0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1,\n\t\t\tu:        100,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := LogSpan(tc.dst, tc.l, tc.u)\n\t\t\tif len(result) != len(tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected result length: got %d, want %d\", len(result), len(tc.expected))\n\t\t\t}\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(result[i]) != math.IsNaN(tc.expected[i]) || !EqualApprox([]float64{result[i]}, []float64{tc.expected[i]}, 1e-10) {\n\t\t\t\t\tt.Errorf(\"unexpected result at index %d: got %f, want %f\", i, result[i], tc.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "17b48362ee126933a53c1a193c164509": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\tt.Run(\"valid input\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ty := []float64{4, 5, 6}\n\t\talpha := 2.0\n\t\ts := []float64{7, 8, 9}\n\n\t\texpected := []float64{18, 21, 24}\n\t\tresult := AddScaledTo(dst, y, alpha, s)\n\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"mismatched slice lengths\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ty := []float64{4, 5, 6}\n\t\talpha := 2.0\n\t\ts := []float64{7, 8}\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddScaledTo() did not panic with mismatched slice lengths\")\n\t\t\t}\n\t\t}()\n\n\t\t_ = AddScaledTo(dst, y, alpha, s)\n\t})\n}",
    "16389cca552661e959b771ae10933bd1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest value with NaN\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\tv:    3.2,\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "128299297328105251c94c426bd401ac": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, even n\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1,\n\t\t\tv:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v <= l\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    0.4,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v >= u\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    1.1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "156e9026367d2431fbba36241809755c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expected == nil {\n\t\t\t\t// Expect a panic\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.c)\n\t\t\t} else {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "178631791ebe40ac3e37a083dbafcaf0": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\twant:   []float64{3, 3, 3},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6, 7},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "18f63684bb35c6121ee813332812b6fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "19b2aa9741f579897b5c9a00dec4d507": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 3, 4},\n\t\t\texpect: []float64{0.5, 2.0 / 3, 0.75},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 3},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Mul panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(test.dst))\n\t\t\tcopy(dst, test.dst)\n\t\t\tMul(dst, test.s)\n\n\t\t\tif !reflect.DeepEqual(dst, test.expect) {\n\t\t\t\tt.Errorf(\"Mul(%v, %v) = %v, want %v\", test.dst, test.s, dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "16b961141bad023dbcab537e8956f070": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1233b208bd7b9681685f0e7a71169e0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v is equal to l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v is equal to u\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "175bec1e74ac88c0ebf6618319ad2aea": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ad9c3bf09c1a9d8050c0ee5abf9560b": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\texpect: []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(test.dst))\n\t\t\tcopy(dst, test.dst)\n\t\t\tAdd(dst, test.s)\n\n\t\t\tif !reflect.DeepEqual(dst, test.expect) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1968ed211494d5115fccc7fbe0d9b841": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, expected %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1830f8f917008a5af3ab25c87b2ae2dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with the same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with the opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c4cb9f8a7e88f9578abe483cfc61f88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice, max value at index 0\",\n\t\t\ts:    []float64{10.0, 5.0, 7.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty slice, max value at index 2\",\n\t\t\ts:    []float64{5.0, 7.0, 10.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty slice, multiple max values\",\n\t\t\ts:    []float64{10.0, 10.0, 7.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty slice, all NaN values\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0, // should panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"MaxIdx did not panic for empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := MaxIdx(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1d6ce67971a15d6b9f8427cb2884ae20": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: 42.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"large and small elements\",\n\t\t\tinput:    []float64{1e20, 1e-20},\n\t\t\texpected: 1e20 + 1e-20,\n\t\t},\n\t\t{\n\t\t\tname:     \"all zeros\",\n\t\t\tinput:    []float64{0, 0, 0, 0, 0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed signs\",\n\t\t\tinput:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\texpected: 3.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{1.0, math.NaN(), 3.0, -4.0, 5.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif !Same([]float64{result}, []float64{tc.expected}) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1c5f72f2d5979de07ba7baa8000ca229": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -10.0,\n\t\t\tu:        0.0,\n\t\t\texpected: []float64{-10.0, -7.5, -5.0, -2.5, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif tc.expected == nil {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !Same(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1fe92cb8cfb822ebbb0cb855c24a048d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value in slice\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value not in slice\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value closest to first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value closest to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.9,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value in slice\",\n\t\t\ts:        []float64{1.0, math.NaN(), 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "200507033a4953d93b579d69ed390e88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, max at beginning\",\n\t\t\tinput:    []float64{100.0, 50.0, 75.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, max in middle\",\n\t\t\tinput:    []float64{50.0, 100.0, 75.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, max at end\",\n\t\t\tinput:    []float64{50.0, 75.0, 100.0},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, max repeated\",\n\t\t\tinput:    []float64{100.0, 100.0, 75.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice with NaN values\",\n\t\t\tinput:    []float64{math.NaN(), 50.0, 75.0, 100.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero length slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0, // This will cause a panic\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.name == \"zero length slice\" {\n\t\t\t\t\t\t// Expected panic, do nothing\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := MaxIdx(tc.input)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d, expected %d\", tc.input, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ca3cc76bc3280f4036eb5e02262113a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -5.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{-5.0, 0.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.c, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "252ed22fd9f5304c94adacddc06a1137": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"no NaN\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"has NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "226111ab2928dc905e44814f6f9015be": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1fdd45a9c18c7c68f389281bb34338b8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20b1c7750ca546302f3faea997b5b38d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "210f3b2cc25d3852c35a761e34477c91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\twant:   []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 2.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "22bd207af381f87686834da5d600c1ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value with multiple matches\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tt.s, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "213b596d12483bcacb7cf3ba03419666": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at the end\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "28520fc1a5692c9c87d9da5daba3a32d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"non-empty slice\",\n\t\t\tinput:    []float64{5.0, 2.0, 3.0, 1.0, 4.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice with NaN\",\n\t\t\tinput:    []float64{5.0, 2.0, math.NaN(), 1.0, 4.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := MinIdx(tc.input)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, expected %d\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "273f0a878b8e6f3562e9f28f044dc394": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small elements\",\n\t\t\ts:    []float64{1e20, 1e-20, 1e-20, 1e-20, 1e-20},\n\t\t\twant: 1.00000000000000001e+20,\n\t\t},\n\t\t{\n\t\t\tname: \"all zeros\",\n\t\t\ts:    []float64{0, 0, 0, 0, 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed signs\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif !Same([]float64{got}, []float64{tc.want}) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "288f617c62576d3f1a88038094c17195": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, no NaNs\",\n\t\t\ts:    []float64{5.0, 2.0, 7.0, 3.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, with NaNs\",\n\t\t\ts:    []float64{math.NaN(), 2.0, 7.0, 3.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, all NaNs\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "27980de3e3145bbf91a6bce006ce4d0c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at start\",\n\t\t\ts:    []float64{0.0, 1.0, 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at end\",\n\t\t\ts:    []float64{1.0, 2.0, 0.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum in middle\",\n\t\t\ts:    []float64{1.0, 0.0, 2.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum repeated\",\n\t\t\ts:    []float64{0.0, 0.0, 1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{math.NaN(), 1.0, 0.0},\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "28ebcdc9ba99fb1af3edf4495a630a68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, no NaN\",\n\t\t\ts:    []float64{5.0, 2.0, 7.0, 3.0, 9.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, with NaN\",\n\t\t\ts:    []float64{math.NaN(), 2.0, 7.0, 3.0, 9.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := MinIdx(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26a35a13561a9794e4226386d82986f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-inf norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29038392105c5bc234f760656fcb22e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN(), 2.0, 1.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "253f0b1f1c4b549501d40eca15d5eced": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, v = 0\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, v = 1\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, v = l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u, v = u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "28f9800a7a4182bbc7af30b587ca4260": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "275967bd3d165d6f5e107ac14d6101cc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v < l\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "25ce682804023f9a12509c8ac3f9216a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\twant:   []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:      \"length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is -Inf, u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf, u is Inf\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf, u is finite\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is finite, u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualFunc(got, tt.want, func(a, b float64) bool {\n\t\t\t\treturn math.Abs(a-b) < 1e-14\n\t\t\t}) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29b9b1c0f0123acdc4bd5a5dcb577350": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple max values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 3.0, 3.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "295ed50fd8578a673bb2e3fcc8350d9c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: 42.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"large and small elements\",\n\t\t\tinput:    []float64{1e10, 1e-10, 1e10, 1e-10, 1e10},\n\t\t\texpected: 3.0000000000000004e+10,\n\t\t},\n\t\t{\n\t\t\tname:     \"all zeros\",\n\t\t\tinput:    []float64{0, 0, 0, 0, 0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed positive and negative\",\n\t\t\tinput:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\texpected: 3.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"all NaNs\",\n\t\t\tinput:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif !floatEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.IsNaN(a) && math.IsNaN(b) || math.Abs(a-b) <= 1e-14*math.Max(math.Abs(a), math.Abs(b))\n}",
    "2799b7f6d5b93f89992e821705bebff0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v has same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v has opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2adf7865b18d991dea53dc6df7a87df3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{2.0},\n\t\t\texpected: 2.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{2.0, 3.0, 4.0},\n\t\t\texpected: 0.16666666666666666,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative elements\",\n\t\t\tinput:    []float64{-2.0, 3.0, -4.0},\n\t\t\texpected: -24.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2a86c48c0b34e51f7e81c07ad226cfc8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{-3, -3, -3},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{0, 0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panics {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic %v\", r, tt.panics)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2912766f5fa08aadae1282284cedee38": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid span\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf l and Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked = %v, wantPanic = %v\", r != nil, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29360998acd13b342952710bb8afacf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l and Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29321ecf0482984dd39ea3b7ce875e3b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c01766532bd63aa2abc38cc94eb14e6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d185405319948d8cbedc6a6a50ab7fc": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tt:      []float64{2, 4, 6},\n\t\t\twant:   []float64{5, 5, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{10, 20},\n\t\t\tt:      []float64{2, 4, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length different from s\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tt:      []float64{2, 4, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"DivTo() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := DivTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c0b11a375fc921998c1c9c945a1e821": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e64769798a5cc94d729f8d90e29adfd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tc      float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{8, 10, 12},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\tdst:    []float64{},\n\t\t\tc:      2,\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"ScaleTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := ScaleTo(tt.dst, tt.c, tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "30dee26f57fa90a8a53794231ce2c69e": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"all slices have equal length\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices have different lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"no input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3089a094a99d51ef78034874e78c9a53": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076,\n\t\t},\n\t\t{\n\t\t\tname: \"with large values\",\n\t\t\ts:    []float64{1000.0, 1001.0, 1002.0},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with small values\",\n\t\t\ts:    []float64{-1000.0, -1001.0, -1002.0},\n\t\t\twant: -1000.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif math.Abs(got-tt.want) > 1e-4 {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %f, want %f\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2f1a12d46d26c88d281ab17f5d43f813": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value with duplicates\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:        3.0,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdx did not panic for empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tt.s, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e8f04b46a7cc612ea38ffd806e2eb04": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d9592ac59a1a355ee03def9ab0094c3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is +Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is +Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is +Inf, v is 0\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, u is +Inf, v is 0\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, u is +Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, u is +Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l == u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "32bb0402b219e3687bbce36b83414407": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice length less than 2\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice not sorted\",\n\t\t\ts:        []float64{5.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "315d479ff232fd65956f9b3da7e0e12b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34830695dc149b4a5cc409e9b2a8f053": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\ts:    []float64{1e20, 1e20, 1e20, 1e20, 1e20},\n\t\t\twant: 5e20,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\ts:    []float64{1e-20, 1e-20, 1e-20, 1e-20, 1e-20},\n\t\t\twant: 5e-20,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\ts:    []float64{1e20, 1e-20, 1e20, 1e-20, 1e20},\n\t\t\twant: 3e20 + 2e-20,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "310cb20bedefcc5ffc221258026fc89f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\twant:   []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN lower bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN upper bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf lower bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with -Inf lower bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf upper bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with -Inf upper bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{0, 0, math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf lower and upper bounds\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with -Inf lower and upper bounds\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "356d6aedd0b043c46f7fcf7e3ff1cbc9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L-norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "345c9a3be0ead2a6bb443889e1480273": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "31da813b746c7eabd381b135198484d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34ff38c1847746783a7293319ecf85f8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"find all elements satisfying f\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\tk:    -1,\n\t\t\twant: []int{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"find first k elements satisfying f\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\tk:    2,\n\t\t\twant: []int{2, 3},\n\t\t},\n\t\t{\n\t\t\tname:    \"insufficient elements found\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 2 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       3,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"zero elements requested\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\tk:    0,\n\t\t\twant: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "35e4e0a40afe6a5e168783bb39d5cb1d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nearest values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:    3.0,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34c0d99226cdf4b4227be15a1f145e68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, l is finite\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3777da618e67948fe1f0988381d359df": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\ts:    []float64{1e20, 1e20, -1e20, -1e20},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\ts:    []float64{1e-20, 1e-20, -1e-20, -1e-20},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\ts:    []float64{1e20, 1e-20, -1e20, -1e-20},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif math.Abs(got-tc.want) > 1e-14 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "358cb99636fbb9e701ee9e0d5a0edac1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is in the middle of the range\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "382421897ddac293a7eaf5803663f8ba": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 1, 1.5, 2},\n\t\t\texpect: []float64{0.5, 1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 1},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t} else if tc.expect == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic, but no panic occurred\")\n\t\t\t\t} else {\n\t\t\t\t\t// Compare the result\n\t\t\t\t\tif !EqualApprox(tc.dst, tc.expect, 1e-10) {\n\t\t\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", tc.dst, tc.expect)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSub(tc.dst, tc.s)\n\t\t})\n\t}\n}",
    "3a76d4dd149871d67008d88252023be3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min at start\",\n\t\t\ts:    []float64{0.0, 1.0, 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min in middle\",\n\t\t\ts:    []float64{1.0, 0.0, 2.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min at end\",\n\t\t\ts:    []float64{1.0, 2.0, 0.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min repeated\",\n\t\t\ts:    []float64{0.0, 0.0, 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{math.NaN(), 1.0, 0.0},\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d239a05153f127756cc4206cf13ce2f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with NaN\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"with large and small values\",\n\t\t\ts:    []float64{1e300, 1e-300, 1e300, 1e-300, 1e300},\n\t\t\twant: 3.000000000000001e+300,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif !Same([]float64{got}, []float64{tc.want}) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3843bad289f379e1a739b632988424fb": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3fa7e3b95f5c707b1cf62da5c1bdb6f4": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tc        float64\n\t\tdst      []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tc:        1.0,\n\t\t\tdst:      []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tc:        2.5,\n\t\t\tdst:      []float64{3.0},\n\t\t\texpected: []float64{5.5},\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tc:        -1.0,\n\t\t\tdst:      []float64{1.0, 2.0, 3.0},\n\t\t\texpected: []float64{0.0, 1.0, 2.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tAddConst(tc.c, tc.dst)\n\t\t\tif !Equal(tc.dst, tc.expected) {\n\t\t\t\tt.Errorf(\"AddConst(%f, %v) = %v, expected %v\", tc.c, tc.dst, tc.dst, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "36b46310cb1e47d0cbd345cbb5e97feb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is less than l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is greater than u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between l and u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3bddc91a49dd0c307d9de0e1281590c7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l and Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "39db05dc4a24eb9227f51017d3d973fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u, finite l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3adb71339e22f88f256492a10f5ad403": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, Inf u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, Inf u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"finite l, Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        0.5,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4255a92f176f4d91698166bcd5e8c176": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"equal lengths\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5, 6},\n\t\t\twant: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{4, 5},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Mul() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tMul(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f1fcb2afc428a0210f30e3b742123c1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "402da2b0239a95cd0ad9382497c83698": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\twant:   []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 1\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "408bf5d6763678341e7519c97944b765": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"zero element dst\",\n\t\t\tdst:    []float64{},\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43b37766db5973e6b66d2f8e975f0b50": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "427a068f7b9d98292d45ba8f0298d820": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l and Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4171fcb628d4c71d3830d56fe113e994": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "437c902372f0d98605b3971c25a238e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v outside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v outside (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        2,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "44b252eb7d64662d0890dd69335bcff7": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "425513ae8a69a98a714e8b3f95e333d2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v has same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v has opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "448e96e64dc8a814b9196333c8e74a69": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "485f3f9430a5c1ee9fe363f2c8c5ca6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice\",\n\t\t\ts:    []float64{5.0, 2.0, 3.0, 1.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN\",\n\t\t\ts:    []float64{5.0, 2.0, math.NaN(), 1.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43da2b9b629e14fe67c3831d7c5be202": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n, v positive\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n, v negative\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, finite u, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u, finite l, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v negative, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v positive, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -0.1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4511cbb301b7d8bfcf0b0dedbc359aa4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4779c1536b5e5170e27ec9a3d10c39ae": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCumProd(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\ts:      []float64{5},\n\t\t\twant:   []float64{5},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple elements\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\ts:      []float64{2, 3, 4, 5, 6},\n\t\t\twant:   []float64{2, 6, 24, 120, 720},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatched lengths\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\ts:      []float64{2, 3, 4, 5, 6},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panics {\n\t\t\t\t\tt.Errorf(\"CumProd() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := CumProd(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"CumProd() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47f60ea89af4f421e1d95c0dab96a75e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0, 4.0, -5.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "453441fed479c6b931c95d8e6a2dc624": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is in the middle of the range\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "498646d911c3405408999849c323ca03": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L=1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L=2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L=3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1.0/3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"L=Inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative L\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    -2,\n\t\t\twant: math.Pow(1.0/math.Pow(1, -2)+1.0/math.Pow(2, -2)+1.0/math.Pow(3, -2), -1.0/2),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4627622097568676db1c4bb86f0f6c45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4e1af0d7b8ed5d716b99fd19e75c5557": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5, 6}\n\t\texpected := []float64{5, 7, 9}\n\n\t\tAdd(dst, s)\n\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Add() did not panic with unequal length slices\")\n\t\t\t}\n\t\t}()\n\t\tAdd(dst, s)\n\t})\n}",
    "45a30c5828885a89ba83eb56d93bcb68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4b1a23c141eedc527eec4c3fbbbf89e3": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length different from s\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2},\n\t\t\tt:      []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4902acfcc99189c581fc8a8766675600": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        -0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "49ba2faa968d0b16296a65774ac0301a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, l is finite\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "49f1f6060a6fe1ef71ebca94b2d03f19": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4c6cdb436525f21ceeedad76790926b9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatched slice lengths\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4eb979ccf40b8e4948c951fe71f3192c": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 3, 4},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{2, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{2, 3, 4},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"MulTo() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4ba005c9cdfe22faa8fc506e95a25089": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4cbcd075e4543798c309fb6ee26e85d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5100393d9c20179d1f466df07560df26": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5, 6}\n\t\talpha := 2.0\n\t\texpected := []float64{9, 12, 15}\n\n\t\tAddScaled(dst, alpha, s)\n\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5}\n\t\talpha := 2.0\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddScaled() did not panic with unequal slice lengths\")\n\t\t\t}\n\t\t}()\n\n\t\tAddScaled(dst, alpha, s)\n\t})\n}",
    "4a76c915a614c1a32e928870371d7c11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        7,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        7,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        7,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        8,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        8,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "513e0f7a072d293d0d8efdd905153883": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51de97e964a1fffb9b422eb59da5400d": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twantDst []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 4, 6},\n\t\t\twantDst: []float64{0.5, 0.5, 0.5},\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 4},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Div() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tDiv(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", tt.dst, tt.wantDst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "50bf89e11cdfc6a5f67944e93b69ded7": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:   \"find first k elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:      3,\n\t\t\twant:   []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find all elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:      -1,\n\t\t\twant:   []int{2, 3, 4, 5, 6},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 10 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:      3,\n\t\t\twant:   []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"find one element\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1},\n\t\t\tk:      1,\n\t\t\twant:   []int{2},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4ee2b8620a8d952f91ac91175e990d11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "50a644966ebeb9b5f9f075ffe29701a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51f37ea8b340d88b86dd6365594f823f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"all positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076, // Approximate expected value\n\t\t},\n\t\t{\n\t\t\tname: \"all negative values\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.6931, // Approximate expected value\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 3.4076, // Approximate expected value\n\t\t},\n\t\t{\n\t\t\tname: \"all zero values\",\n\t\t\ts:    []float64{0.0, 0.0, 0.0},\n\t\t\twant: math.Log(3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"one value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinity value\",\n\t\t\ts:    []float64{math.Inf(1), 1.0, 2.0},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity value\",\n\t\t\ts:    []float64{math.Inf(-1), 1.0, 2.0},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tc.s)\n\t\t\tif math.Abs(got-tc.want) > 1e-4 {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %f, want %f\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51e62d3003c1cef2b289488bb49642bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "535e683dd7462e2c87fae6b37215e513": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L = 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L = Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "557c377cf77cfee5862a9c9ac824624d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small elements\",\n\t\t\ts:    []float64{1e10, 1e-10},\n\t\t\twant: 1e10 + 1e-10,\n\t\t},\n\t\t{\n\t\t\tname: \"cancelling elements\",\n\t\t\ts:    []float64{1e10, -1e10},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif math.Abs(got-tc.want) > 1e-14 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "58c241954b2664727c41d7721efab838": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Add() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tAdd(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51e6755e7f508768bca93b584325caa1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 8,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n, v positive\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n, v negative\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, finite u, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u, finite l, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v negative, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v positive, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "54cf5f7fc12931717650aaf61a9e1990": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v in range\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v in range\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "553492048d9a895e0c7a6480f8a52aa9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "596038e104a8cfd0669b4e0ae9d834d2": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find all elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        -1,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first k elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find no elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find zero elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) returned error %v, expected error %v\", tc.inds, tc.f, tc.s, tc.k, err, tc.err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(inds, tc.expected) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) = %v, expected %v\", tc.inds, tc.f, tc.s, tc.k, inds, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "566741d6f8a87aed21ab7e8ff5149d73": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v <= l\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    0.4,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v >= u\",\n\t\t\tn:    10,\n\t\t\tl:    0.5,\n\t\t\tu:    1,\n\t\t\tv:    1.1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0.5,\n\t\t\tv:    0.7,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5a067b714f12586ffcf7e6ed3a76e094": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 0.5, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN(), 0.5, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0, // should panic\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"MinIdx() did not panic for empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := MinIdx(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5510c4a37a65894d6414bbbb693794cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "585b7ac09a3b8d7ae48ddfa3fb2ed341": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(0),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expected == nil {\n\t\t\t\t// Expect a panic\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.c)\n\t\t\t} else {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cab14684e3236374aff22310a463d29": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice with unique maximum\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty slice with multiple maximum values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0, // should panic\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN values\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\twant: 3,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cfd5efc057e14d6f915e2f0e3a7a4e1": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Equal(tc.s1, tc.s2)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v, expected %v\", tc.s1, tc.s2, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5aa15949cd7c6551c734080cf1d8b245": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tt.s) {\n\t\t\t\tsort.Float64s(tt.s)\n\t\t\t}\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5db0ca7cc9e199b358e4086356bd249f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59cfb0df3d116931d8ef233f5c4d4ba1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59e9807e410b3b1e42476d1626350de1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with +Inf l and +Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with +Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with +Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5e5b494cf15f876e881c448b70eb2381": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{0, 0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "619b5b88adc14dd5e12b4896a2e60292": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-5, -4, -3, -2, -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{-1, 2, -3, 4, -5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic on zero length slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"MaxIdx([]float64{}) did not panic\")\n\t\t\t}\n\t\t}()\n\t\tMaxIdx([]float64{})\n\t})\n}",
    "5ec0328f90a34d616e3b204f7b27312c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "61372161edf3c9defd238b1135cd48bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6413829de65ffe830657a47656e35ce0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v outside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v outside (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        2,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65a07e02fcce872028436f8a915909a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nearest values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:    3.0,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63fa0b8a84228ec317cfed7688363a0a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "67dd6295b47259e6fb279f0555c34da2": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"no input slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63eb0a38dfc2724cfeb1f978ccfde92a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is not Inf\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "656d8243e7ab61dd1b5d5d4c0a1c2a51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "662f2e407358b89be4281a5a18880939": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=2\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=Inf\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(36, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6614f0f640bed3219f6edca88d44dd37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fd8ad4512dfef4102fe3bfb9270a4f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68474e5a72e61670a6cb46b5ac1305bf": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{5.0},\n\t\t\texpected: 5.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{2.0, 3.0, 4.0},\n\t\t\texpected: 24.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"with zero\",\n\t\t\tinput:    []float64{2.0, 0.0, 4.0},\n\t\t\texpected: 0.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "66d292c1ce226e5c8864cc13fe05bc21": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u, finite l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, normal case\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68899a430ddf4f6f239e756b66bbbffb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN and non-NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6930d616072f2ca90b31519426117788": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076,\n\t\t},\n\t\t{\n\t\t\tname: \"large values\",\n\t\t\ts:    []float64{1000.0, 1001.0, 1002.0},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"small values\",\n\t\t\ts:    []float64{-1000.0, -1001.0, -1002.0},\n\t\t\twant: -1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{-1000.0, 1000.0, -1001.0, 1001.0, -1002.0, 1002.0},\n\t\t\twant: 1002.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif math.Abs(got-tt.want) > 1e-4 {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %f, want %f\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68e0afb435fbddde65eef21993523abe": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tt.s) {\n\t\t\t\tsort.Float64s(tt.s)\n\t\t\t}\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6aede9c09c69006b852dd6e16ffad905": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 7),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0.0, 0.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6bfc7b9f97ba65b7653d66b1e69f0b80": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tf        func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unequal lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"unequal elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.1, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"equal with custom function\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.1, 2.1, 3.1},\n\t\t\tf:        func(a, b float64) bool { return abs(a-b) < 0.1 },\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tc.s1, tc.s2, tc.f); got != tc.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v, %v) = %v, expected %v\", tc.s1, tc.s2, tc.f, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc abs(x float64) float64 {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}",
    "690866bf0f92f2e1f2a6c438c10bc8eb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "69897caeb65fe72f7aa78c474973b3a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within the range (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within the range (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6af629ddd937cab703589d0bb7a8abe6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6c7c9566e0529939e343a754e38af8a8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f8f0cf089b9296b93c93e650fdcf0f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d21515f8125323eb177cf800f931b07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d06d0759e4be25c7b630ad5ceb5bc13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.7,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6deba74db0b90460246258ff700fb465": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -10.0,\n\t\t\tu:        0.0,\n\t\t\texpected: []float64{-10.0, -7.5, -5.0, -2.5, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f60e11c27d167cc98a6c777b2ed309f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "719fbaed10eb9f84af07d905fd6dc8b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small elements\",\n\t\t\ts:    []float64{1e10, 1e-10},\n\t\t\twant: 1.00000000001e10,\n\t\t},\n\t\t{\n\t\t\tname: \"all zeros\",\n\t\t\ts:    []float64{0, 0, 0, 0, 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed signs\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaNs\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "72080191d1a0f6a037ea1ba79b729034": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal length slices\",\n\t\t\ts1:       []float64{1, 2, 3},\n\t\t\ts2:       []float64{4, 5, 6},\n\t\t\texpected: 32,\n\t\t},\n\t\t{\n\t\t\tname:     \"unequal length slices\",\n\t\t\ts1:       []float64{1, 2, 3},\n\t\t\ts2:       []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Dot(%v, %v) did not panic as expected\", tc.s1, tc.s2)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Dot(%v, %v) panicked: %v\", tc.s1, tc.s2, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Dot(tc.s1, tc.s2)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Dot(%v, %v) = %f, want %f\", tc.s1, tc.s2, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7342be149dca4d93bbc1c7058fc4b165": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "705779804a0d6e416d989d33e5d71d2c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "742c3a0e60b52275548045f9937128ed": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tinds   []int\n\t\twantDst []float64\n\t\twantInds []int\n\t}{\n\t\t{\n\t\t\tname:   \"sorted slice\",\n\t\t\tdst:    []float64{1, 2, 3, 4, 5},\n\t\t\tinds:   make([]int, 5),\n\t\t\twantDst: []float64{1, 2, 3, 4, 5},\n\t\t\twantInds: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsorted slice\",\n\t\t\tdst:    []float64{5, 2, 4, 1, 3},\n\t\t\tinds:   make([]int, 5),\n\t\t\twantDst: []float64{1, 2, 3, 4, 5},\n\t\t\twantInds: []int{3, 1, 4, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname:   \"slice with equal elements\",\n\t\t\tdst:    []float64{1, 2, 2, 3, 3},\n\t\t\tinds:   make([]int, 5),\n\t\t\twantDst: []float64{1, 2, 2, 3, 3},\n\t\t\twantInds: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\tdst:    []float64{},\n\t\t\tinds:   make([]int, 0),\n\t\t\twantDst: []float64{},\n\t\t\twantInds: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsortStable(tt.dst, tt.inds)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"ArgsortStable() dst = %v, want %v\", tt.dst, tt.wantDst)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tt.inds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"ArgsortStable() inds = %v, want %v\", tt.inds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "74b6c2682cd0091c2b1d38011061c6ec": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect []float64\n\t\tpanic  bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: []float64{11, 13, 15},\n\t\t\tpanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Mismatched lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t\tpanic:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t\tpanic:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panic && r == nil {\n\t\t\t\t\tt.Errorf(\"AddTo did not panic as expected\")\n\t\t\t\t} else if !tc.panic && r != nil {\n\t\t\t\t\tt.Errorf(\"AddTo panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddTo(tc.dst, tc.s, tc.t)\n\t\t\tif !Equal(result, tc.expect) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "70ef5cf162ccbbbeaffa61109d9d5327": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 8,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7531e22078872885620137b8f10e36fa": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: []float64{11, 15, 19},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == nil {\n\t\t\t\t\t\t// Expected a panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif !Equal(tc.dst, tc.expect) {\n\t\t\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", tc.dst, tc.expect)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddTo(tc.dst, tc.s, tc.t)\n\t\t\tif !Equal(result, tc.expect) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "731ef9c1650a0835b8d91c3e5645ea3d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0.0, 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t} else if r == nil && tc.expected == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else {\n\t\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\t\tif !Same(result, tc.expected) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t})\n\t}\n}",
    "75568582d0db1dd3b3d9aaadf9b871d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"at the beginning\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"at the end\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"outside the range\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.1,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"short span\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{5.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\tv:        2.5,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %f) = %d, want %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "735adf687a18e301fe773c3aa12dfa6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7775eae90044d2b83c4ba237a18e6524": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple nearest values\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tt.s, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "764003bc0b16664630dab25d0a7361f9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-inf norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\treturn // Expected panic for mismatched lengths\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(result-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "77b93326ee7c291bfa127d16988aa7d8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l and Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ba6c1a9d9cfc826feb1c6cc29a7d1d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive numbers\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0, -4.0, 5.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dbdc50dd0c7ca092a6eb33c2b115cb4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"no input slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79104be89c9c1a79798d2bc6dce60d34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79ba96a414ec58600a22cf4d6a65c7d9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ce7e0ff5d5a26e4ace3cfba39e5cd75": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:   \"find all elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      -1,\n\t\t\twant:   []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find first k elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 10 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"find zero elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{},\n\t\t\tk:      0,\n\t\t\twant:   []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ae0b412168e3741e885695e100e10dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 1, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79f3aca3977491f8d5f9776daa658477": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 1\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e0e584ee99bb04f534bf4a061567134": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:   \"find all elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      -1,\n\t\t\twant:   []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find first k elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 10 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"find zero elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{},\n\t\t\tk:      0,\n\t\t\twant:   []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7be2cfa5773f77e57f0b52a902a37906": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dee733e37d1cd403fa43e560561b44b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"two elements\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -10.0,\n\t\t\tu:        0.0,\n\t\t\texpected: []float64{-10.0, -7.5, -5.0, -2.5, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero length dst\",\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e067ec2eec8c0ce92a797561684a201": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.7,\n\t\t\texpected: 7,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f3a126a386b9ed26bfb0769fd5122a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-5, -4, -3, -2, -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{-1, 2, -3, 4, -5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"one NaN\",\n\t\t\ts:    []float64{1, 2, math.NaN(), 4, 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"zero length\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f6810e613aee48e70477e69512564f4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"all slices have equal length\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices have different lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"no input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "806936f5d9d784f8306b0ac2a5943872": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"no input slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f25d22513ef6e04b64a192ed3cfc5b0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e338ea1edf5d53d16546d7262adfbf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "820e22f4df79d99e681e83421197f3ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L-norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f69ce5884584bab680bef849c1ae2aa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "82cfd02b37e335e4d6d30fe85596f5fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L-norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8164f904edbace0e687a6eb1a01a3af5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-inf norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif !EqualApprox([]float64{result}, []float64{tc.expected}, 1e-10) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "833b21a0075c577fde94c189898f66a9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\t// Test case 1: Swap two elements\n\ta := argsort{s: []float64{1.0, 2.0, 3.0}, inds: []int{0, 1, 2}}\n\ta.Swap(0, 1)\n\tif a.s[0] != 2.0 || a.s[1] != 1.0 || a.s[2] != 3.0 {\n\t\tt.Errorf(\"Swap() failed to swap elements: got %v, want [2.0, 1.0, 3.0]\", a.s)\n\t}\n\n\t// Test case 2: Swap the same element\n\ta.Swap(1, 1)\n\tif a.s[0] != 2.0 || a.s[1] != 1.0 || a.s[2] != 3.0 {\n\t\tt.Errorf(\"Swap() modified the slice when swapping the same element: got %v, want [2.0, 1.0, 3.0]\", a.s)\n\t}\n\n\t// Test case 3: Swap out-of-bounds indices\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Swap() did not panic with out-of-bounds indices\")\n\t\t}\n\t}()\n\ta.Swap(-1, 0)\n}",
    "80ffe1ef1dc80434c8321ba0d2fb1c7c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif tc.expected == nil {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t} else if !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "809daefdfb910db4c42b0f1b1277fcbe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cba209de73be9fc8a65c3115cd478d": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8660c16f640958be268b424125fc3fec": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8237b765f07159af3926d27949397523": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8316756719bd266dc16a02ec38ac71fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cf1db0881ba9374d11a631125e887c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88a0193ded84b9e893d23ff426b1843c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "84fc49945a232770c24f21a053cee5a1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 1\",\n\t\t\tn:        0,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n, v positive\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n, v negative\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, finite u, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u, finite l, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v negative, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v positive, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8957cbfb628c000e6a23a0af86dc0e6d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-inf norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8db84bf8b529bb0fc69aa47c2d3ac7c6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8900aa68771056c6d140df5d1c575cfa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t} else if r == nil && tc.expected == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else {\n\t\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t})\n\t}\n}",
    "8d7bf8dcb492c4994dab8bf626b97ed0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, math.Inf, -math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "876a136b2371b18a843f206bffeb3c2a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "90eda1a8282de7144480b0cef156e607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0, 4.0, -5.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a268a807febdd1589044723d42783f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v outside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v outside (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        2,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "93bb65f0c24933e8c6e5822ca34a87d6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: []float64{1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tReverse(tt.s)\n\t\t\tif !reflect.DeepEqual(tt.s, tt.want) {\n\t\t\t\tt.Errorf(\"Reverse() = %v, want %v\", tt.s, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9303356005fcdaa7752836a212c96a6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-integer L\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1.5,\n\t\t\twant: math.Pow(1+4+27, 1/1.5),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9012a9920bb033f073d1054b802c5912": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"find all matching elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{1, -2, 3, 0, 4},\n\t\t\tk:       -1,\n\t\t\twant:    []int{0, 2, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"find first k matching elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{1, -2, 3, 0, 4},\n\t\t\tk:       2,\n\t\t\twant:    []int{0, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"find no matching elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{1, -2, 3, 0, 4},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8f9e9416d8c0aaecb379aacadcf67c50": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is greater than l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is less than u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "930bfa10b6dc4b7a361ff5e9c117915b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4520787991245185,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.6931471805599453,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed signs\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0},\n\t\t\twant: 2.4076059652679208,\n\t\t},\n\t\t{\n\t\t\tname: \"large values\",\n\t\t\ts:    []float64{700.0, 701.0, 702.0},\n\t\t\twant: 702.0,\n\t\t},\n\t\t{\n\t\t\tname: \"small values\",\n\t\t\ts:    []float64{-700.0, -701.0, -702.0},\n\t\t\twant: -702.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tt.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "971cdb9966ab10f3b6a66f22cf666530": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\ttol    float64\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\ttol:    1e-6,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0},\n\t\t\ttol:    1e-6,\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"within absolute tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0001},\n\t\t\ttol:    1e-4,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"within relative tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.01},\n\t\t\ttol:    0.01,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"outside tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.1},\n\t\t\ttol:    0.01,\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualApprox(tc.s1, tc.s2, tc.tol)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %t, want %t\", tc.s1, tc.s2, tc.tol, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "98455f52f62b2e50bb908d3d0ed0a1ec": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\tinput:    []float64{5.0},\n\t\t\texpected: 5.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements slice\",\n\t\t\tinput:    []float64{2.0, 3.0, 4.0},\n\t\t\texpected: 24.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative elements slice\",\n\t\t\tinput:    []float64{-2.0, 3.0, -4.0},\n\t\t\texpected: -24.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9968eecfdf30082706212c97588e7293": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076,\n\t\t},\n\t\t{\n\t\t\tname: \"with negative values\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0},\n\t\t\twant: 2.3132,\n\t\t},\n\t\t{\n\t\t\tname: \"with large values\",\n\t\t\ts:    []float64{700.0, 701.0, 702.0},\n\t\t\twant: 702.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with small values\",\n\t\t\ts:    []float64{-700.0, -701.0, -702.0},\n\t\t\twant: -702.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif math.Abs(got-tt.want) > 1e-4 {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %f, want %f\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a496ba17ec527d8f006609f6f843ff6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{2, 4, 6, 8},\n\t\t\texpect: []float64{0.5, 0.5, 0.5, 0.5},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 4, 6, 8},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tDiv(test.dst, test.s)\n\t\t\tif !reflect.DeepEqual(test.dst, test.expect) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", test.dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a6f496faafe107e1f1f8261c46d7bf1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple nearest values\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "95db695f7002f97cfcc763d5f131bde2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is -Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is 0\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "97f6a508a005bcc949f1573f054387f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n, v positive\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n, v negative\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, finite u, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    -10,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u, finite l, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    -10,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    10,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v < l\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v > u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v >= l\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v <= u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9cb0d360d85ad376bf2194447eafd178": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"no NaN\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"has NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "99d6db2036d4ac3edc0116983f0e560d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=2\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        3,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(27, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif !EqualApprox([]float64{result}, []float64{tc.expected}, 1e-10) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9ab1d4dcd4e6e4dd07be351879e21a61": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf and u is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf and u is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf and v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf and v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is outside (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is outside (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9b77ccabddafb9d8dc5b4b9224996375": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\texpect: []float64{6, 9, 12},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ty:      []float64{},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{},\n\t\t\texpect: []float64{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := AddScaledTo(tc.dst, tc.y, tc.alpha, tc.s)\n\t\t\tif len(tc.expect) != len(got) {\n\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) = %v, expected %v\", tc.dst, tc.y, tc.alpha, tc.s, got, tc.expect)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfor i := range got {\n\t\t\t\tif got[i] != tc.expect[i] {\n\t\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) = %v, expected %v\", tc.dst, tc.y, tc.alpha, tc.s, got, tc.expect)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d291a0a7219e71f1248386c72c4ebdd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L-norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a98ff29fee4e9f72e766486242fbc11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9c55932632ea7107edec31327f638aa7": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif sort.Float64sAreSorted(tc.s) {\n\t\t\t\tidx := Within(tc.s, tc.v)\n\t\t\t\tif idx != tc.expected {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d4ab18a2d3be262fae27fe7439bf295": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:   \"find all elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      -1,\n\t\t\twant:   []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find first k elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 10 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements with k=0\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      0,\n\t\t\twant:   []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e6b0f9dd9f49f75a5ba370e3a417163": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L = 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L = Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\treturn // Expected panic for mismatched lengths\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(result-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a3fe2ed40acd3b91aacc802c7c7b7333": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value with duplicates\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tt.s, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4d1d307540cd4a4d2ac0b2fb9d31721": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L-norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a016dbc2f0d6caf11e2cb0a3b863ab48": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a27f6a53f7ef837c6a2016083242e078": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a41f57f74af72aeefcd635aa831db8f0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tt.s) {\n\t\t\t\tsort.Float64s(tt.s)\n\t\t\t}\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a497dd8b46bc2c813c600319f2b295de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2bf07ba250a0365f9ac0b0f63d41c94": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=2\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Distance panics when the slice lengths don't match\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic when slice lengths didn't match\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1, 2, 3}, 2)\n}",
    "a521218401b9b8dba09f0819080b73d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) panicked: %v\", tc.s, tc.t, tc.L, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(got-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4b60974e46bfdf6e006c7d82aaa379c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a47dd1cdc3dc83bbdb439193cd64f607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with the same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with the opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a5e41a7195939f58c03fbd26820a8ba7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\tv:    2.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.2,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nearest values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:    3.0,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a7d15f2cc559aa317134a3b5cf5abf3b": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 1, 1.5, 2},\n\t\t\twant:   []float64{0.5, 1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 1},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Sub() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSub(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "adc5acf237e9d9e0b0eaa3cab7609c7a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\t// Test case 1: Swap two elements\n\ta := argsort{\n\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\tinds: []int{0, 1, 2},\n\t}\n\ta.Swap(0, 2)\n\tif a.inds[0] != 2 || a.inds[2] != 0 {\n\t\tt.Errorf(\"Swap did not swap the elements correctly. Expected [2, 1, 0], got %v\", a.inds)\n\t}\n\n\t// Test case 2: Swap the same element\n\ta.Swap(1, 1)\n\tif a.inds[1] != 1 {\n\t\tt.Errorf(\"Swap did not work correctly when swapping the same element. Expected [2, 1, 0], got %v\", a.inds)\n\t}\n}",
    "a54d54664865f2c31b2989b19aa1f707": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expected == nil {\n\t\t\t\t// Expect a panic\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.c)\n\t\t\t} else {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "abb812288b8de738509d66c3ec95412e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    2.5,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nearest values\",\n\t\t\ts:    []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\tv:    2.0,\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ab7dc606c0b084ab5d94a2ed91fc6c4b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect []float64\n\t\tpanic  bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tt:      []float64{2, 4, 6},\n\t\t\texpect: []float64{5, 5, 5},\n\t\t\tpanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Mismatched lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{10, 20},\n\t\t\tt:      []float64{2, 4, 6},\n\t\t\texpect: nil,\n\t\t\tpanic:  true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tt:      []float64{2, 4, 6},\n\t\t\texpect: nil,\n\t\t\tpanic:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panic && r == nil {\n\t\t\t\t\tt.Errorf(\"DivTo did not panic as expected\")\n\t\t\t\t} else if !tc.panic && r != nil {\n\t\t\t\t\tt.Errorf(\"DivTo panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := DivTo(tc.dst, tc.s, tc.t)\n\t\t\tif !Equal(got, tc.expect) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a69b30c54f2b14f26c3f18c8767573b0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\tpanics:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.panics {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af54b607219a486ffb62bfa2478b3568": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"all slices have equal length\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices have different lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"single slice\",\n\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"no slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a9d4441a857e403200ecd0cceab9906d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afb6691cc094d2b363d8525e14a19ac8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCumSum(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\tdst:    []float64{},\n\t\t\ts:      []float64{},\n\t\t\texpect: []float64{},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element\",\n\t\t\tdst:    []float64{0},\n\t\t\ts:      []float64{1},\n\t\t\texpect: []float64{1},\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple elements\",\n\t\t\tdst:    []float64{0, 0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\texpect: []float64{1, 3, 6, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatch length\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := CumSum(test.dst, test.s)\n\t\t\tif !reflect.DeepEqual(got, test.expect) {\n\t\t\t\tt.Errorf(\"CumSum(%v, %v) = %v, want %v\", test.dst, test.s, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afc5e1b592f391571a48959e2f9e490f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname: \"all elements pass the test\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x > 0\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"no elements pass the test\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x > 10\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"some elements pass the test\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x > 2\n\t\t\t},\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tf: func(x float64) bool {\n\t\t\t\treturn x > 0\n\t\t\t},\n\t\t\ts:        []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Count(tc.f, tc.s)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Count(%v, %v) = %d, expected %d\", tc.f, tc.s, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af91ec866fc2f872635e8cfdd90e66fa": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Equal(tc.s1, tc.s2)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v, expected %v\", tc.s1, tc.s2, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aaf32cd17c4604ddafa4458bb47ea3c4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower and upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t} else if r == nil && tc.expected == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else {\n\t\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\t\tif !Same(result, tc.expected) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t})\n\t}\n}",
    "b023a706762e4bc46743e63893e9d4ca": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{0, 0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"MulTo() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b057253b10925d31efe70b9b96fdeb78": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tt.s) {\n\t\t\t\tsort.Float64s(tt.s)\n\t\t\t}\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b1237c007a154e7551e96e4abef395ac": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, value in slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    2.0,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, value not in slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    2.5,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, value closest to first element\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, value closest to last element\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    3.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0f9a3504d61dd97d7d30c129c71d603": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted slice, value within range\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted slice, value at lower bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted slice, value at upper bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted slice, value below lower bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted slice, value above upper bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"sorted slice, value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{5.0, 2.0, 3.0, 1.0, 4.0},\n\t\t\tv:        3.5,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b213bf54d996e0039fda47719746bfab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: 42.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"large numbers\",\n\t\t\tinput:    []float64{1e20, 1e20, -1e20, -1e20},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"small numbers\",\n\t\t\tinput:    []float64{1e-20, 1e-20, -1e-20, -1e-20},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed numbers\",\n\t\t\tinput:    []float64{1e20, 1e-20, -1e20, -1e-20},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{1.0, math.NaN(), 3.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif math.IsNaN(tc.expected) {\n\t\t\t\tif !math.IsNaN(result) {\n\t\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, expected NaN\", tc.input, result)\n\t\t\t\t}\n\t\t\t} else if result != tc.expected {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b247c18384f0d8daf42cbf9e1815e8cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{42.0},\n\t\t\texpected: 42.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"large numbers\",\n\t\t\tinput:    []float64{1e20, 1e20, -1e20, -1e20},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"small numbers\",\n\t\t\tinput:    []float64{1e-20, 1e-20, -1e-20, -1e-20},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed numbers\",\n\t\t\tinput:    []float64{1e20, 1e-20, -1e20, -1e-20},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN values\",\n\t\t\tinput:    []float64{1.0, math.NaN(), 3.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif !math.IsNaN(tc.expected) && math.Abs(result-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t\tif math.IsNaN(tc.expected) && !math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b19603c719cd669e4b4e7417b1673a44": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value in the middle\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at the end\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b171a68a65a0482c47261417a55b4971": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b1c211d15e5b97db52c1164cf02ab259": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b274b8c757536346f03da55ed0a60c98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2b41c0984a6fc130569c29ce9ac8aed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b24730c325c23f8e9cf5a440666a54cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b517facd54cabc2f4032e18bd4d107cd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\texpect: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Mul panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tMul(test.dst, test.s)\n\t\t\tif !reflect.DeepEqual(test.dst, test.expect) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", test.dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b39b4e92d68ff04931e1f9c49dce0d52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) panicked: %v\", tc.s, tc.t, tc.L, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif !EqualApprox([]float64{result}, []float64{tc.expected}, 1e-10) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b40f3129f28d9f1eeaeb9805d894b2d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b62580acc0fe992fad3b01981ef69e94": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tdst := make([]float64, 3)\n\t\texpected := []float64{5, 7, 9}\n\n\t\tresult := AddTo(dst, s, t)\n\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"AddTo(%v, %v, %v) = %v, want %v\", dst, s, t, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"different length slices\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5}\n\t\tdst := make([]float64, 3)\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddTo(%v, %v, %v) did not panic\", dst, s, t)\n\t\t\t}\n\t\t}()\n\n\t\t_ = AddTo(dst, s, t)\n\t})\n\n\tt.Run(\"dst length mismatch\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tdst := make([]float64, 2)\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddTo(%v, %v, %v) did not panic\", dst, s, t)\n\t\t\t}\n\t\t}()\n\n\t\t_ = AddTo(dst, s, t)\n\t})\n}",
    "b4b092207079221ea52e0eecea53fb6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=2\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        3,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(27, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(result-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, expected %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b62c0496f8758e4bda8819180b790391": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tgot := Distance(s, t, 2)\n\t\twant := math.Sqrt(9 + 9 + 9)\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want %v\", s, t, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\ts := []float64{1, 2}\n\t\tt := []float64{4, 5, 6}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, 2) did not panic\", s, t)\n\t\t\t}\n\t\t}()\n\t\t_ = Distance(s, t, 2)\n\t})\n\n\tt.Run(\"empty slices\", func(t *testing.T) {\n\t\ts := []float64{}\n\t\tt := []float64{}\n\t\tgot := Distance(s, t, 2)\n\t\tif got != 0 {\n\t\t\tt.Errorf(\"Distance(%v, %v, 2) = %v, want 0\", s, t, got)\n\t\t}\n\t})\n\n\tt.Run(\"L1 norm\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tgot := Distance(s, t, 1)\n\t\twant := 9.0\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance(%v, %v, 1) = %v, want %v\", s, t, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"L-inf norm\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tgot := Distance(s, t, math.Inf(1))\n\t\twant := 3.0\n\t\tif got != want {\n\t\t\tt.Errorf(\"Distance(%v, %v, Inf) = %v, want %v\", s, t, got, want)\n\t\t}\n\t})\n}",
    "b90b25d30caac34e602553815fe2c041": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small elements\",\n\t\t\ts:    []float64{1e20, 1e-20},\n\t\t\twant: 1e20 + 1e-20,\n\t\t},\n\t\t{\n\t\t\tname: \"all zeros\",\n\t\t\ts:    []float64{0, 0, 0, 0, 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed signs\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b453eeefaf291a83ffcb9e4516aac460": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b7f2edbdc613f82d19b5b99c215ff5f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bdbac0eb9fce9bd1874ee7d0e7ca5d5a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\talpha := 2.0\n\t\ts := []float64{4, 5, 6}\n\t\texpected := []float64{9, 12, 15}\n\n\t\tAddScaled(dst, alpha, s)\n\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\talpha := 2.0\n\t\ts := []float64{4, 5}\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddScaled() did not panic with unequal length slices\")\n\t\t\t}\n\t\t}()\n\n\t\tAddScaled(dst, alpha, s)\n\t})\n}",
    "b8a05ba3a712e311a1d2e9009147f26b": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at the end\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif sort.Float64sAreSorted(tc.s) {\n\t\t\t\tidx := Within(tc.s, tc.v)\n\t\t\t\tif idx != tc.expected {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "b89f9f1089868798b9e02bcd5e68794b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l and Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ba6c5492461668b1361d8b51e520bf52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bf076eed918d7c3223f67e7e25518cf2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 4},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1, 2, math.NaN()},\n\t\t\tt:    []float64{1, 2, math.NaN()},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed NaN and non-NaN values\",\n\t\t\ts:    []float64{1, 2, math.NaN()},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c219c9759b2b913ab17a36a30c8a5282": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"no input slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd0baf941d695935d5dc6dc476aff106": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bd09c4b3139e4799017cb559fa235589": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0edc28b0bb8ad039cd83dc2899be0c1": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twant:   []float64{28, 40, 54},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"MulTo() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c4347345bb3b757aabbc440dd959adf5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0, -2.0, -1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -2.0, 1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c245931e3d9384bd8814b85c1d7c28c5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple nearest values\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c44e095c6325fd9ca41dd7c3957a9234": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"all slices have equal length\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices have different lengths\",\n\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"no input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfda35f3c18a5baeca503393dbab6526": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -5.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{-5.0, 0.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0ec03dca8cd07a84c9284fb4860376c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n, v positive\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n, v negative\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, finite u, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    -10,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u, finite l, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    -10,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    10,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v negative, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    -10,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v positive, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    -10,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v <= l\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v >= u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l < u, v in (l, u)\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v in (u, l)\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c63de35547795507c7e26f34c81f2123": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 1, 1.5, 2},\n\t\t\texpect: []float64{0.5, 1, 1.5, 2},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 1},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(tc.dst))\n\t\t\tcopy(dst, tc.dst)\n\t\t\tSub(dst, tc.s)\n\n\t\t\tif !Equal(dst, tc.expect) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c50cc8843b4580e570dbf84f66a3386f": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c36fad062905512cad6644b00bea6fb9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (l, u)\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (u, l)\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c319c9163393d0f1a232cc36990f80f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, math.Inf, -math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c68f0eeab1152e158103052b21dc3f6f": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\texpect: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"Mul panicked: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tMul(test.dst, test.s)\n\t\t\tif !reflect.DeepEqual(test.dst, test.expect) {\n\t\t\t\tt.Errorf(\"Mul(%v, %v) = %v, want %v\", test.dst, test.s, test.dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c66f332326724bc488067fc1ae2dee45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        100.0,\n\t\t\texpected: []float64{1.0, 3.1622776601683795, 10.0, 31.622776601683793, 100.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -1.0,\n\t\t\tu:        100.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        100.0,\n\t\t\texpected: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1.0,\n\t\t\tu:        100.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := LogSpan(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %f, %f) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c424d8a35f7c8b05e45733b34ada50f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c67238fc1cdc7f32abd6e8a9759afd8f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5390b0747a0390f595f5a93fd3be797": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 9),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0.0, 0.0, 0.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t} else if r == nil && tc.expected == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else {\n\t\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t})\n\t}\n}",
    "c70bd4226e4382659ab756194d226ddb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.5,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c84004bbf3a69183c622f48e660f5b13": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatched lengths\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ca0939efcf7f3a8da4f08dbb68580e05": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 4},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1, 2, math.NaN()},\n\t\t\tt:    []float64{1, 2, math.NaN()},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c6e905e1ad53e35ccd01273d9f1d7878": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb50929c3d31ad17a3f460bf88000ad7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small elements\",\n\t\t\ts:    []float64{1e20, 1e-20, 1e20, 1e-20, 1e20},\n\t\t\twant: 3e20,\n\t\t},\n\t\t{\n\t\t\tname: \"all zeros\",\n\t\t\ts:    []float64{0, 0, 0, 0, 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed signs\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c9a488ed3661683813cdc9acf0983fe4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l and Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ca5c8d4320f117c218de35798e287ba6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within the range\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c9072aa3fc2774f4553a579a976d9871": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantOk bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   nil,\n\t\t\twantOk: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantOk: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !tt.wantOk && got != nil {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want nil\", tt.dst, tt.l, tt.u, got)\n\t\t\t}\n\t\t\tif tt.wantOk && !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb2f4ecce6f8ce30d05a1cb5dedc4149": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cba9f4ddaeffe47ca5b276cb857f5a91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cad7b02fd7a43024f9e31aaa000ba4d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd2551357bf5a4761b1d93b27199cd8e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small elements\",\n\t\t\ts:    []float64{1e10, 1e-10},\n\t\t\twant: 1.00000000001e10,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed positive and negative elements\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN elements\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb535218c3f70cf84aad141358af65fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=2\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that Distance panics when the slice lengths don't match\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance did not panic when the slice lengths didn't match\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1, 2, 3}, 2)\n}",
    "cbb8d4e698be7f05734f9a6261da1335": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\twant:   []float64{-5, 0, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN lower bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN upper bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf lower bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      5,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf upper bound\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd59b1cd0bb3ec2ddb479fb44184b611": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9),\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices, L=2\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"General case, L=3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(math.Pow(3, 3)+math.Pow(3, 3)+math.Pow(3, 3), 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif !EqualApprox([]float64{result}, []float64{tc.expected}, 1e-10) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ced77cd244892a4bc6b7d487dd1b6d4a": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tc      float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{8, 10, 12},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\tdst:    []float64{},\n\t\t\tc:      2,\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"ScaleTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := ScaleTo(tt.dst, tt.c, tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cec8ccef0f30afa2aa52c89fdd1aaf3a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L-norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(1+8+27, 1/3.0),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cf3d2ac834f186c8f0097e850e7bbbbe": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\tf        func(float64, float64) bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\tf:        func(a, b float64) bool { return a == b },\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"custom equality function\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.1, 2.1, 3.1},\n\t\t\tf:        func(a, b float64) bool { return abs(a-b) < 0.1 },\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualFunc(tc.s1, tc.s2, tc.f)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v, %v) = %v, expected %v\", tc.s1, tc.s2, tc.f, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc abs(x float64) float64 {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}",
    "cdbdf12b54f31cf75f3fe8b5f104b1b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 6),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d00820bb1a4bd89672dcb2c82326bc12": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\texpect: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Mul panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(test.dst))\n\t\t\tcopy(dst, test.dst)\n\t\t\tMul(dst, test.s)\n\n\t\t\tif !reflect.DeepEqual(dst, test.expect) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cee9aea2c702fc18ba210f59a68d56ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l and Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfc03b5acebd84a7b4d5789bde286391": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f with non-empty inds\",\n\t\t\tinds:    []int{10, 20, 30},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{10, 20, 30, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd1af6b4b2cac1a9911a1fa1e5f63565": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with the same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with the opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with the same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with the opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is finite, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is finite, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, l is finite, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, l is finite, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is less than l, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is greater than u, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        2,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is less than u, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is greater than l, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d03fbbedb07ba59353ee3aa2469554c4": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find zero elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfbb4651815b01c03980fee9bcea668b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d0618cf3772a1cbdb3f414697491934f": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\twant     []int\n\t\twantErr  bool\n\t\twantInds []int\n\t}{\n\t\t{\n\t\t\tname:     \"Find first 2 elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\twant:     []int{2, 3},\n\t\t\twantErr:  false,\n\t\t\twantInds: []int{2, 3},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        -1,\n\t\t\twant:     []int{2, 3, 4},\n\t\t\twantErr:  false,\n\t\t\twantInds: []int{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find no elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\twant:     []int{},\n\t\t\twantErr:  true,\n\t\t\twantInds: []int{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Find 0 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        0,\n\t\t\twant:     []int{},\n\t\t\twantErr:  false,\n\t\t\twantInds: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tt.inds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"Find() inds = %v, want %v\", tt.inds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d21d94f17836ef34ef6e24fe8f5c1794": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"no input slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single slice\",\n\t\t\tslices:   [][]float64{{1, 2, 3}},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d2d4683e15ed6c7820e9cc788de1ae6c": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\twantInds []int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"find first k elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\twantInds: []int{2, 3},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        -1,\n\t\t\twantInds: []int{2, 3, 4},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotInds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotInds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", gotInds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1e51f3ebef2601345a50316d8222b28": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"all positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076, // Approximate expected value\n\t\t},\n\t\t{\n\t\t\tname: \"all negative values\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: 0.6931, // Approximate expected value\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 3.1269, // Approximate expected value\n\t\t},\n\t\t{\n\t\t\tname: \"all zero values\",\n\t\t\ts:    []float64{0.0, 0.0, 0.0},\n\t\t\twant: math.Log(3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"one value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinity value\",\n\t\t\ts:    []float64{math.Inf(1)},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity value\",\n\t\t\ts:    []float64{math.Inf(-1)},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %f, want %f\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) < 1e-4\n}",
    "d3f731fcec5e030b686db890c77b0152": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements slice, value in the middle\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements slice, value at the beginning\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements slice, value at the end\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements slice, value not present\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d7391925b9ae35074c2ad1cdf8cee8b0": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"different elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Equal(tc.s1, tc.s2)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v, expected %v\", tc.s1, tc.s2, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d54f36e019297f6ad65085cc8a881991": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\ttol    float64\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\ttol:    1e-6,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0},\n\t\t\ttol:    1e-6,\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"within absolute tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0001},\n\t\t\ttol:    1e-4,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"within relative tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.01},\n\t\t\ttol:    0.01,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"outside tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.1},\n\t\t\ttol:    0.01,\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualApprox(tc.s1, tc.s2, tc.tol)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %t, want %t\", tc.s1, tc.s2, tc.tol, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1ae84045c77da5ac561a7f186238cb5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        -1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d472e2d93552a6c0dda8754ae8121fc6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d799b91a3bd21a0eb9863753a3943661": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d8099fc547bc3e0cba409e34e0be5d49": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d54d5f470d5f7010a1f68fb43aacbcd4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, n is even, v is +Inf\",\n\t\t\tn:        6,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d91536c4291955fa1cb968ab179e0f7a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        7,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        8,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc352efe1934cd3627e87fc74681474a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at start\",\n\t\t\ts:    []float64{100.0, 50.0, 75.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max in middle\",\n\t\t\ts:    []float64{50.0, 100.0, 75.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at end\",\n\t\t\ts:    []float64{50.0, 75.0, 100.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max repeated\",\n\t\t\ts:    []float64{100.0, 100.0, 75.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{math.NaN(), 50.0, 75.0},\n\t\t\twant: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d9c055ec104c56718a9f735546ef9f34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is in the middle of the range\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d7b6ea6bd6829ec9f86229042aa6cc5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "db0efa97eac5aa38beace3d862c72995": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dcd2c202fca790496c6f66029cca00a0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dcfe3ecfae6fa288d7bcd0d33508722c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with dst length < 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0511d81fad1093714fcf21a2a02a933": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{5.0},\n\t\t\texpected: 5.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{2.0, 3.0, 4.0},\n\t\t\texpected: 24.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative elements\",\n\t\t\tinput:    []float64{-2.0, 3.0, -4.0},\n\t\t\texpected: -24.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero element\",\n\t\t\tinput:    []float64{2.0, 0.0, 4.0},\n\t\t\texpected: 0.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "df7fb887ea18e4ff6789fa276836ed07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0de08f91bb8621093aea8a6f6895828": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tinds     []int\n\t\texpected []float64\n\t\texpInds  []int\n\t}{\n\t\t{\n\t\t\tname:     \"sorted input\",\n\t\t\tdst:      []float64{1, 2, 3, 4, 5},\n\t\t\tinds:     make([]int, 5),\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t\texpInds:  []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted input\",\n\t\t\tdst:      []float64{5, 2, 4, 1, 3},\n\t\t\tinds:     make([]int, 5),\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t\texpInds:  []int{3, 1, 4, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"duplicate values\",\n\t\t\tdst:      []float64{5, 2, 4, 2, 3},\n\t\t\tinds:     make([]int, 5),\n\t\t\texpected: []float64{2, 2, 3, 4, 5},\n\t\t\texpInds:  []int{1, 3, 4, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty input\",\n\t\t\tdst:      []float64{},\n\t\t\tinds:     make([]int, 0),\n\t\t\texpected: []float64{},\n\t\t\texpInds:  []int{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tArgsort(test.dst, test.inds)\n\t\t\tif !reflect.DeepEqual(test.dst, test.expected) {\n\t\t\t\tt.Errorf(\"Argsort(%v) = %v, expected %v\", test.dst, test.dst, test.expected)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(test.inds, test.expInds) {\n\t\t\t\tt.Errorf(\"Argsort(%v) = %v, expected %v\", test.inds, test.inds, test.expInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc0c51f114dd31f4e8df118530ca14e5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3d4b6f7a4af707bc819ae7f7d99fff2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e36e2d6500656f6ab7d05eebfb5207f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value with duplicates\",\n\t\t\ts:        []float64{1, 2, 3, 3, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tt.s, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "de0f41c026a90025ceeee7a8b47d9b51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is even, v is +Inf\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, u is -Inf, n is even, v is -Inf\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -0.1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        1.1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        -0.1,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e23f0499b54dde9b7d452678e119f319": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3debfe533834eb7a925993f5da8abed": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tinds   []int\n\t\twant   []float64\n\t\twantInds []int\n\t}{\n\t\t{\n\t\t\tname:   \"sorted input\",\n\t\t\tdst:    []float64{1, 2, 3, 4, 5},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{1, 2, 3, 4, 5},\n\t\t\twantInds: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsorted input\",\n\t\t\tdst:    []float64{5, 2, 4, 1, 3},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{1, 2, 3, 4, 5},\n\t\t\twantInds: []int{3, 1, 4, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname:   \"duplicate values\",\n\t\t\tdst:    []float64{5, 2, 4, 2, 3},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{2, 2, 3, 4, 5},\n\t\t\twantInds: []int{1, 3, 4, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"empty input\",\n\t\t\tdst:    []float64{},\n\t\t\tinds:   make([]int, 0),\n\t\t\twant:   []float64{},\n\t\t\twantInds: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsort(tt.dst, tt.inds)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() dst = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tt.inds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"Argsort() inds = %v, want %v\", tt.inds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7908f6ba9246e52947f0c450542ee07": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{5},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{2, 3, 4, 5},\n\t\t\texpected: 120,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative elements\",\n\t\t\tinput:    []float64{-2, 3, -4, 5},\n\t\t\texpected: -120,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero element\",\n\t\t\tinput:    []float64{2, 0, 4, 5},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e25ace83e9153cf53faa9bc86e8579de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e46741c04a2ae3e8fb5d63a0dfcf1389": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\tpanics   bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v less than s[0]\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v greater than s[len(s)-1]\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.5,\n\t\t\texpected: -1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"len(s) < 2\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t\tpanics:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"s is not sorted\",\n\t\t\ts:        []float64{3.0, 1.0, 4.0, 2.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 0,\n\t\t\tpanics:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e551b450b466d5af6639a408ad6d1cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && test.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !Equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7de2bec59d8d297fc181da6f481f74b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{1, 1, 1},\n\t\t\texpect: []float64{6, 7, 8},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{1, 1, 1},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddScaledTo(tc.dst, tc.y, tc.alpha, tc.s)\n\t\t\tif tc.expect == nil {\n\t\t\t\tt.Errorf(\"Expected panic, but no panic occurred\")\n\t\t\t} else if !EqualApprox(result, tc.expect, 1e-14) {\n\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) = %v, want %v\", tc.dst, tc.y, tc.alpha, tc.s, result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e4b1a35bdcaef67e0246950a70f8a28b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.4,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v in (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v in (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.75,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eaffafaa2e0ca1f7561e224cb9d3208c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []float64{5},\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements\",\n\t\t\tinput:    []float64{2, 3, 4},\n\t\t\texpected: 24,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative elements\",\n\t\t\tinput:    []float64{-2, 3, -4},\n\t\t\texpected: -24,\n\t\t},\n\t\t{\n\t\t\tname:     \"zero element\",\n\t\t\tinput:    []float64{2, 0, 4},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e56decab21bda765dea786add27026fb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        3,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e8244b76a457320d0ab3b95b58a6c2da": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid span\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf lower and upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"span with length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e846085b6c4d3e90047c324e42424143": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value in the middle\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e5e9fa216268e609baeb416605b77cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v has same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v has opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2979221b37e0bc94da0f2b22cd5473": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-inf norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed4c3249384c384098afcc70d1b2cbca": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\ts:    []float64{1e20, 1e20, -1e20, -1e20},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\ts:    []float64{1e-20, 1e-20, -1e-20, -1e-20},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\ts:    []float64{1e20, 1e-20, -1e20, -1e-20},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eee73366a6b12e52db5a164b7574ac06": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"find first k elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"find all elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"find no elements\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ee11c775a2b30640658618f6276f10f9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\ttol    float64\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\ttol:    1e-6,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0},\n\t\t\ttol:    1e-6,\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"within absolute tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.01, 2.01, 3.01},\n\t\t\ttol:    0.02,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"within relative tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.01, 2.01, 3.01},\n\t\t\ttol:    0.02,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"outside tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.1, 2.1, 3.1},\n\t\t\ttol:    0.02,\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualApprox(tc.s1, tc.s2, tc.tol)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %t, want %t\", tc.s1, tc.s2, tc.tol, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e84c735c076f2f8bd8d768404cfa6161": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf(1), v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf(1), v is not equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf(0), v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(0),\n\t\t\tv:        math.Inf(0),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf(0), v is not equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(0),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf(-1), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf(1), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ef173baae917f51659bbeea6f5a88278": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       2.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than or equal to last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.0,\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value found\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Within(tt.s, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "edd6222fcf0881ddecd2e6230084c628": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, math.Inf, -math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ede839d8aa21a2a990793caf464a7fa3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2c99ede0b70b8c7222aa22af27455ed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at start\",\n\t\t\ts:    []float64{0.0, 1.0, 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at end\",\n\t\t\ts:    []float64{1.0, 2.0, 0.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum in middle\",\n\t\t\ts:    []float64{1.0, 0.0, 2.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum repeated\",\n\t\t\ts:    []float64{0.0, 0.0, 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{math.NaN(), 1.0, 0.0, math.NaN()},\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2f791bd017a2c0391ee414f8e34deb6": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLess(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ta        argsort\n\t\ti, j     int\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"i less than j\",\n\t\t\ta:        argsort{s: []float64{1.0, 2.0, 3.0}},\n\t\t\ti:        0,\n\t\t\tj:        1,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"i greater than j\",\n\t\t\ta:        argsort{s: []float64{3.0, 2.0, 1.0}},\n\t\t\ti:        0,\n\t\t\tj:        1,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"i equal to j\",\n\t\t\ta:        argsort{s: []float64{1.0, 2.0, 2.0}},\n\t\t\ti:        1,\n\t\t\tj:        2,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := tc.a.Less(tc.i, tc.j)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Less(%d, %d) = %t, expected %t\", tc.i, tc.j, actual, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2d0a4e0607696b81d0f7831b78f1a69": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twant:   []float64{28, 40, 54},\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"MulTo() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f000ba2650b7d541450f4670b4290607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"zero length dst\",\n\t\t\tdst:    []float64{},\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 6),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f15c3362d300b641bf4f7188dbe271b2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f0b30df2d6d93e47dff67646e0ce6c10": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f51a1aaeae1dd7bf0c8e26f89b8b78ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"positive l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      1,\n\t\t\tu:      100,\n\t\t\texpect: []float64{1, 3.1622776601683795, 10, 31.622776601683793, 100},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      -100,\n\t\t\tu:      -1,\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is zero\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      100,\n\t\t\texpect: []float64{0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      1,\n\t\t\tu:      100,\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := LogSpan(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.expect) {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f5bab763ada8fe7c36081efa09724629": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Add() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tAdd(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f5730e5037fa3baa3a7797e3cf5e3a11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all positive values\",\n\t\t\ts:    []float64{10.0, 20.0, 5.0, 15.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative values\",\n\t\t\ts:    []float64{-10.0, -20.0, -5.0, -15.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed positive and negative values\",\n\t\t\ts:    []float64{10.0, -20.0, 5.0, -15.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{10.0, math.NaN(), 5.0, -15.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0, // This will panic, as expected\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\t\t\t// Expected panic, do nothing\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"MinIdx(%v) panicked: %v\", tt.s, r)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8164ef3c4d50b252e6a8135c40a0ab5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative elements\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.6931,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed positive and negative elements\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 3.1269,\n\t\t},\n\t\t{\n\t\t\tname: \"all zero elements\",\n\t\t\ts:    []float64{0.0, 0.0, 0.0},\n\t\t\twant: math.Log(3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"large positive values\",\n\t\t\ts:    []float64{700.0, 701.0, 702.0},\n\t\t\twant: 702.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large negative values\",\n\t\t\ts:    []float64{-700.0, -701.0, -702.0},\n\t\t\twant: -702.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tc.s)\n\t\t\tif math.Abs(got-tc.want) > 1e-4 {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %f, want %f\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4050e94ad42ab51bda296b51cea2843": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, math.Inf, -math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8a59234d5fba12b9c07d35cf59640d8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tinds   []int\n\t\twant   []float64\n\t\twantInds []int\n\t}{\n\t\t{\n\t\t\tname:   \"sorted input\",\n\t\t\tdst:    []float64{1, 2, 3, 4, 5},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{1, 2, 3, 4, 5},\n\t\t\twantInds: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsorted input\",\n\t\t\tdst:    []float64{5, 2, 4, 1, 3},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{1, 2, 3, 4, 5},\n\t\t\twantInds: []int{3, 1, 4, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname:   \"duplicate values\",\n\t\t\tdst:    []float64{5, 2, 4, 2, 3},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{2, 2, 3, 4, 5},\n\t\t\twantInds: []int{1, 3, 4, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"empty input\",\n\t\t\tdst:    []float64{},\n\t\t\tinds:   make([]int, 0),\n\t\t\twant:   []float64{},\n\t\t\twantInds: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsort(tt.dst, tt.inds)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() dst = %v, want %v\", tt.dst, tt.want)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tt.inds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"Argsort() inds = %v, want %v\", tt.inds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f6c14f0baeb9d56eb54d29effcc34ad0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -2,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -2,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -2,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value in the middle\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at the beginning\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at the end\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fdddd85e91abddc251b9da767bee01fa": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twant:   []float64{11, 13, 15},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\twant:   []float64{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"AddTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := AddTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f609d4620b7ad1d4e4f0ba7a78ef6ae8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between l and u, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between l and u, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fffbfad0db7ae393fa0704ea9b316d33": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, odd n\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u, even n\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Normal case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fe478ab38e642e30157bc134e5ad80b3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v < l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0.1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v > u\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.9,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v < u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0.5,\n\t\t\tv:        0.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fbcec84a399d16e857a04dd4101ba926": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.expected == nil {\n\t\t\t\t// Expect a panic\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t\t} else {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}"
}