{
    "0481378a1b09214b71ea7267f94d33e1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\ts:    []float64{1.0, 2.5, 0.5, 3.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all equal\",\n\t\t\ts:    []float64{1.0, 1.0, 1.0, 1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"with NaNs\",\n\t\t\ts:    []float64{math.NaN(), 2.5, 0.5, 3.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "00ff8da04f0e838382a81a82fbe07efe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = 2\",\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tL:      2,\n\t\t\texpect: 5.477225575,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = 1\",\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tL:      1,\n\t\t\texpect: 10,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = inf\",\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 4,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = 3\",\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tL:      3,\n\t\t\texpect: 7.4035037,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.expect) > 1e-6 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02fbbeaf9207bbe077f089b5539b257d": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n    testCases := []struct {\n        name string\n        s    []float64\n        L    float64\n        want float64\n    }{\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            L:    2,\n            want: 0,\n        },\n        {\n            name: \"L2 norm\",\n            s:    []float64{1, 2, 3},\n            L:    2,\n            want: math.Sqrt(14),\n        },\n        {\n            name: \"L1 norm\",\n            s:    []float64{1, 2, 3},\n            L:    1,\n            want: 6,\n        },\n        {\n            name: \"L-inf norm\",\n            s:    []float64{1, 2, 3},\n            L:    math.Inf(1),\n            want: 3,\n        },\n        {\n            name: \"general L norm\",\n            s:    []float64{1, 2, 3},\n            L:    3,\n            want: math.Pow(1+8+27, 1/3.0),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := Norm(tc.s, tc.L)\n            if !floatEqual(got, tc.want) {\n                t.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n            }\n        })\n    }\n}\n\nfunc floatEqual(a, b float64) bool {\n    return math.Abs(a-b) < 1e-10\n}",
    "02c76544e44aa50c3890e81b07f8e90f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"closest value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple closest values\",\n\t\t\ts:        []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: 1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0215348bb87bbfbf266f19937ec2247e": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{0.5, 1, 1.5},\n\t\t\twant:   []float64{0.5, 1, 1.5},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{0.5, 1},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Sub(%v, %v) did not panic as expected\", tc.dst, tc.s)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Sub(%v, %v) panicked: %v\", tc.dst, tc.s, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSub(tc.dst, tc.s)\n\t\t\tif !reflect.DeepEqual(tc.dst, tc.want) {\n\t\t\t\tt.Errorf(\"Sub(%v, %v) = %v, want %v\", tc.dst, tc.s, tc.dst, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "02dace20380755f8b679152b01cb1c37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\texpect: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\texpect: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 1 panics\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      5.0,\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      1.0,\n\t\t\tu:      math.NaN(),\n\t\t\texpect: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      5.0,\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      1.0,\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{1.0, 2.0, 3.0, 4.0, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := Span(tc.dst, tc.l, tc.u)\n\t\t\tif tc.expect == nil {\n\t\t\t\tt.Errorf(\"expected Span to panic, but it did not\")\n\t\t\t} else if !EqualApprox(dst, tc.expect, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, dst, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0026966f482687b357882089f4e9ee0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %.2f, %.2f, %.2f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0448c285f2fcbc79b86a5077593f1471": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantNil bool\n\t}{\n\t\t{\n\t\t\tname:   \"simple\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantNil: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty dst\",\n\t\t\tdst:    make([]float64, 0),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\twantNil: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\twantNil: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantNil: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantNil: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t\twantNil: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t\twantNil: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t\twantNil: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif tt.wantNil {\n\t\t\t\tif got != nil {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want nil\", got)\n\t\t\t\t}\n\t\t\t} else if !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0509e0638a4b45d441f01d4ba3e331eb": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestScale(t *testing.T) {\n\tt.Run(\"Scale non-empty slice\", func(t *testing.T) {\n\t\tdst := []float64{1.0, 2.0, 3.0}\n\t\tc := 2.0\n\t\tScale(c, dst)\n\t\tassert.Equal(t, []float64{2.0, 4.0, 6.0}, dst)\n\t})\n\n\tt.Run(\"Scale empty slice\", func(t *testing.T) {\n\t\tdst := []float64{}\n\t\tc := 2.0\n\t\tScale(c, dst)\n\t\tassert.Empty(t, dst)\n\t})\n}",
    "02d05743532d1daecf41e66d43e30cae": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"valid input\",\n\t\t\tn:      10,\n\t\t\tl:      0.0,\n\t\t\tu:      1.0,\n\t\t\tv:      0.5,\n\t\t\texpect: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"v less than l\",\n\t\t\tn:      10,\n\t\t\tl:      0.0,\n\t\t\tu:      1.0,\n\t\t\tv:      -0.1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v greater than u\",\n\t\t\tn:      10,\n\t\t\tl:      0.0,\n\t\t\tu:      1.0,\n\t\t\tv:      1.1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"n less than 2\",\n\t\t\tn:      1,\n\t\t\tl:      0.0,\n\t\t\tu:      1.0,\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1.0,\n\t\t\tv:      0.5,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.0,\n\t\t\texpect: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is -Inf and u is +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is -Inf and v is +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      1.0,\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is -Inf and v is -Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      1.0,\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf and v is +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf and v is -Inf\",\n\t\t\tn:      10,\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "013e5ee407fb258d6a8c3fda98af7c6a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal length\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are positive Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is positive Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is positive Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panics {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "028e90cbce778d1961c87aa647c65dad": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    tests := []struct {\n        name  string\n        n     int\n        l     float64\n        u     float64\n        v     float64\n        want  int\n        panic bool\n    }{\n        {\n            name:  \"n < 2 panics\",\n            n:     1,\n            l:     0,\n            u:     1,\n            v:     0.5,\n            panic: true,\n        },\n        {\n            name:  \"v is NaN\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     math.NaN(),\n            want:  0,\n            panic: false,\n        },\n        {\n            name:  \"l is NaN, u is not\",\n            n:     10,\n            l:     math.NaN(),\n            u:     1,\n            v:     0.5,\n            want:  9,\n            panic: false,\n        },\n        {\n            name:  \"u is NaN\",\n            n:     10,\n            l:     0,\n            u:     math.NaN(),\n            v:     0.5,\n            want:  0,\n            panic: false,\n        },\n        {\n            name:  \"l and u are both Inf, v is Inf with same sign as l\",\n            n:     11,\n            l:     math.Inf(1),\n            u:     math.Inf(1),\n            v:     math.Inf(1),\n            want:  0,\n            panic: false,\n        },\n        {\n            name:  \"l and u are both Inf, v is Inf with opposite sign as l\",\n            n:     11,\n            l:     math.Inf(1),\n            u:     math.Inf(1),\n            v:     math.Inf(-1),\n            want:  6,\n            panic: false,\n        },\n        {\n            name:  \"l is Inf, v is equal to l\",\n            n:     10,\n            l:     math.Inf(1),\n            u:     1,\n            v:     math.Inf(1),\n            want:  0,\n            panic: false,\n        },\n        {\n            name:  \"u is Inf, v is equal to u\",\n            n:     10,\n            l:     0,\n            u:     math.Inf(1),\n            v:     math.Inf(1),\n            want:  9,\n            panic: false,\n        },\n        {\n            name:  \"v is -Inf, l < u\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     math.Inf(-1),\n            want:  0,\n            panic: false,\n        },\n        {\n            name:  \"v is Inf, l < u\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     math.Inf(1),\n            want:  9,\n            panic: false,\n        },\n        {\n            name:  \"v is -Inf, l > u\",\n            n:     10,\n            l:     1,\n            u:     0,\n            v:     math.Inf(-1),\n            want:  9,\n            panic: false,\n        },\n        {\n            name:  \"v is Inf, l > u\",\n            n:     10,\n            l:     1,\n            u:     0,\n            v:     math.Inf(1),\n            want:  0,\n            panic: false,\n        },\n        {\n            name:  \"normal case\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     0.5,\n            want:  5,\n            panic: false,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            defer func() {\n                r := recover()\n                if (r != nil) != tt.panic {\n                    t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n                }\n            }()\n\n            got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n            if got != tt.want {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n            }\n        })\n    }\n}",
    "049bf5e147c76a4cefac4edd03539ef1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v = NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = NaN, u = finite\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = finite, u = NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, u = Inf, n odd, v = finite\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0,\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, u = Inf, n odd, v = -Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, u = Inf, n odd, v = Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 4,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, u = Inf, n even, v = -Inf\",\n\t\t\tn:      4,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, u = Inf, n even, v = Inf\",\n\t\t\tn:      4,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, v = l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l = Inf, v = u\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      1,\n\t\t\tv:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u = Inf, v = u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u = Inf, v = -Inf\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v <= l\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      -1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v >= u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      2,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v >= l\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v <= u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      -1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l == u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      0,\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"general case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "07a3669a4df39454690361c55d14ee12": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"n < 2\", 1, 0, 1, 0, 0},\n\t\t{\"v = NaN\", 10, 0, 1, math.NaN(), 0},\n\t\t{\"l = NaN, u = finite\", 10, math.NaN(), 1, 0, 9},\n\t\t{\"l = NaN, u = finite, v = NaN\", 10, math.NaN(), 1, math.NaN(), 9},\n\t\t{\"u = NaN\", 10, 0, math.NaN(), 0, 0},\n\t\t{\"l = +Inf, u = +Inf, n odd, v = finite\", 11, math.Inf(1), math.Inf(1), 0, 5},\n\t\t{\"l = +Inf, u = +Inf, n odd, v = -Inf\", 11, math.Inf(1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"l = +Inf, u = +Inf, n odd, v = +Inf\", 11, math.Inf(1), math.Inf(1), math.Inf(1), 6},\n\t\t{\"l = +Inf, u = +Inf, n even, v = -Inf\", 10, math.Inf(1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"l = +Inf, u = +Inf, n even, v = +Inf\", 10, math.Inf(1), math.Inf(1), math.Inf(1), 5},\n\t\t{\"l = +Inf, v = l\", 10, math.Inf(1), 1, math.Inf(1), 0},\n\t\t{\"u = +Inf, v = u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{\"v = -Inf, l < u\", 10, 0, 1, math.Inf(-1), 0},\n\t\t{\"v = +Inf, l < u\", 10, 0, 1, math.Inf(1), 9},\n\t\t{\"v = -Inf, l > u\", 10, 1, 0, math.Inf(-1), 9},\n\t\t{\"v = +Inf, l > u\", 10, 1, 0, math.Inf(1), 0},\n\t\t{\"normal case\", 10, 0, 1, 0.5, 5},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "082fe751a23930a68a019f44025e09cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf lower and upper bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "078c692d78e6f34adcf892727898b8a7": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 1\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are positive infinity\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is positive infinity\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is positive infinity\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "092d969bdc8d331e1383b09ae960574d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Lp norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1.0/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "08367c21374f71c8896f648b0805835b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantOK bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal length\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 10},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"short dst\",\n\t\t\tdst:    []float64{0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\twantOK: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), 10},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN()},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0},\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), 10},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 10, 10},\n\t\t\twantOK: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tc.dst))\n\t\t\tcopy(dst, tc.dst)\n\t\t\tgot := Span(dst, tc.l, tc.u)\n\t\t\tif !approxEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t\tif (len(got) < 2) != !tc.wantOK {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v; want wantOK=%t\", tc.dst, tc.l, tc.u, got, tc.wantOK)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc approxEqual(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) > 1e-14 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "0b097e9900feb8b9e641c792209cf25f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"MinIdx did not panic on empty slice\")\n\t\t\t}\n\t\t}()\n\t\tMinIdx([]float64{})\n\t})\n\n\tt.Run(\"single element slice\", func(t *testing.T) {\n\t\tgot := MinIdx([]float64{42.0})\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"MinIdx() = %d, want %d\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"multiple elements slice\", func(t *testing.T) {\n\t\ts := []float64{5.0, 2.0, 7.0, 1.0, 3.0}\n\t\tgot := MinIdx(s)\n\t\twant := 3\n\t\tif got != want {\n\t\t\tt.Errorf(\"MinIdx() = %d, want %d\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"multiple minimum values\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 1.0, 3.0, 1.0}\n\t\tgot := MinIdx(s)\n\t\twant := 0\n\t\tif got != want {\n\t\t\tt.Errorf(\"MinIdx() = %d, want %d\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NaN values\", func(t *testing.T) {\n\t\ts := []float64{math.NaN(), 2.0, 1.0, math.NaN(), 3.0}\n\t\tgot := MinIdx(s)\n\t\twant := 2\n\t\tif got != want {\n\t\t\tt.Errorf(\"MinIdx() = %d, want %d\", got, want)\n\t\t}\n\t})\n}",
    "08d82e43185b5ac68d847ab24ea6f61b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2 should panic\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are +/- Inf, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are +/- Inf, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is +Inf, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is inside [l, u]\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is inside [u, l]\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0c3582a382574f253a9d3e2de6f04b2e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"one NaN\",\n\t\t\ts:        []float64{1, 2, math.NaN()},\n\t\t\tt:        []float64{1, 2, math.NaN()},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"different values\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 4},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif got := Same(tc.s, tc.t); got != tc.expected {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tc.s, tc.t, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0843ef585b873a1a79ee4ad7a8360783": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"n < 2\", 1, 0, 1, 0.5, 0},\n\t\t{\"NaN value\", 10, 0, 1, math.NaN(), 0},\n\t\t{\"l is NaN, u is not\", 10, math.NaN(), 1, 0.5, 9},\n\t\t{\"u is NaN\", 10, 0, math.NaN(), 0.5, 0},\n\t\t{\"l and u are ±Inf, n is odd, v is finite\", 5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{\"l and u are ±Inf, n is odd, v is -Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"l and u are ±Inf, n is odd, v is +Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{\"l and u are ±Inf, n is even, v is +Inf\", 6, math.Inf(-1), math.Inf(1), math.Inf(1), 5},\n\t\t{\"l is +Inf, v equals l\", 10, math.Inf(1), 1, math.Inf(1), 0},\n\t\t{\"u is +Inf, v equals u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{\"v is -Inf, l < u\", 10, 0, 1, math.Inf(-1), 0},\n\t\t{\"v is +Inf, l < u\", 10, 0, 1, math.Inf(1), 9},\n\t\t{\"v is -Inf, l > u\", 10, 1, 0, math.Inf(-1), 9},\n\t\t{\"v is +Inf, l > u\", 10, 1, 0, math.Inf(1), 0},\n\t\t{\"normal case\", 10, 0, 1, 0.5, 5},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0a4296a1d29592be5b3cbae3eddad4e4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"with valid input\", func(t *testing.T) {\n\t\t// Test cases with valid input\n\t\ttestCases := []struct {\n\t\t\tname   string\n\t\t\tdst    []float64\n\t\t\tl, u   float64\n\t\t\texpect []float64\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"equal spacing\",\n\t\t\t\tdst:    make([]float64, 5),\n\t\t\t\tl:      0.0,\n\t\t\t\tu:      10.0,\n\t\t\t\texpect: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"unequal spacing\",\n\t\t\t\tdst:    make([]float64, 3),\n\t\t\t\tl:      1.0,\n\t\t\t\tu:      10.0,\n\t\t\t\texpect: []float64{1.0, 5.5, 10.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"special case: l = Inf, u = Inf\",\n\t\t\t\tdst:    make([]float64, 5),\n\t\t\t\tl:      math.Inf(1),\n\t\t\t\tu:      math.Inf(1),\n\t\t\t\texpect: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"special case: l = Inf\",\n\t\t\t\tdst:    make([]float64, 5),\n\t\t\t\tl:      math.Inf(1),\n\t\t\t\tu:      10.0,\n\t\t\t\texpect: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"special case: u = Inf\",\n\t\t\t\tdst:    make([]float64, 5),\n\t\t\t\tl:      0.0,\n\t\t\t\tu:      math.Inf(1),\n\t\t\t\texpect: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"special case: l = NaN\",\n\t\t\t\tdst:    make([]float64, 5),\n\t\t\t\tl:      math.NaN(),\n\t\t\t\tu:      10.0,\n\t\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"special case: u = NaN\",\n\t\t\t\tdst:    make([]float64, 5),\n\t\t\t\tl:      0.0,\n\t\t\t\tu:      math.NaN(),\n\t\t\t\texpect: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(result, tc.expect) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expect)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"with invalid input\", func(t *testing.T) {\n\t\t// Test cases with invalid input\n\t\ttestCases := []struct {\n\t\t\tname string\n\t\t\tdst  []float64\n\t\t\tl, u float64\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"len(dst) < 2\",\n\t\t\t\tdst:  make([]float64, 1),\n\t\t\t\tl:    0.0,\n\t\t\t\tu:    10.0,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tc.dst, tc.l, tc.u)\n\t\t\t})\n\t\t}\n\t})\n}",
    "0d37d4ebe8ea732945906d799178ed91": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n    testCases := []struct {\n        name string\n        f    func(float64) bool\n        s    []float64\n        want int\n    }{\n        {\n            name: \"all true\",\n            f:    func(x float64) bool { return true },\n            s:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            want: 5,\n        },\n        {\n            name: \"all false\",\n            f:    func(x float64) bool { return false },\n            s:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            want: 0,\n        },\n        {\n            name: \"some true\",\n            f:    func(x float64) bool { return x > 3 },\n            s:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            want: 2,\n        },\n        {\n            name: \"empty slice\",\n            f:    func(x float64) bool { return true },\n            s:    []float64{},\n            want: 0,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := Count(tc.f, tc.s)\n            if got != tc.want {\n                t.Errorf(\"Count(%v, %v) = %v, want %v\", tc.f, tc.s, got, tc.want)\n            }\n        })\n    }\n}",
    "0a81dba7d0fdfeb9b2ee90d5fffab1ef": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"n less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 0, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0b471cefc5359254a2f629459fb3aade": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif test.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", test.dst, test.l, test.u)\n\t\t\t\t} else if !test.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d144bb389e3e2f7fce75bb9ab4c36ba": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is finite, u is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        -10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is outside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        10,\n\t\t\tv:        20,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is outside (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        -10,\n\t\t\tv:        -20,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        -10,\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0d38cf851eedbeb3bf60880a2ff1cb98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices L2 norm\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(9),\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices L1 norm\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices L-inf norm\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatched lengths\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.name == \"mismatched lengths\" {\n\t\t\t\t\t\t// Expected panic, so do nothing\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(got-tc.expect) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0f3a51095de34ca23f6513dd63718b5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        100.0,\n\t\t\texpected: []float64{1.0, 3.1622776601683795, 10.0, 31.622776601683793, 100.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero lower bound\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0.0,\n\t\t\tu:        100.0,\n\t\t\texpected: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative lower bound\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -10.0,\n\t\t\tu:        100.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1.0,\n\t\t\tu:        100.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := LogSpan(tc.dst, tc.l, tc.c)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %f, %f) = %v, expected %v\", tc.dst, tc.l, tc.c, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0fd11dba8dbc082251b5cc7acfffe5cd": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal lengths\",\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\tt:        []float64{7, 8, 9},\n\t\t\texpected: []float64{11, 15, 19},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Mismatched lengths\",\n\t\t\tdst:       []float64{1, 2, 3},\n\t\t\ts:         []float64{4, 5},\n\t\t\tt:         []float64{7, 8, 9},\n\t\t\texpected:  nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Mismatched dst length\",\n\t\t\tdst:       []float64{1, 2},\n\t\t\ts:         []float64{4, 5, 6},\n\t\t\tt:         []float64{7, 8, 9},\n\t\t\texpected:  nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"AddTo() unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddTo(tc.dst, tc.s, tc.t)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, expected %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e04172c6c2d5d231457bf49bbcc2001": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid length\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 7),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.c)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0cbfee12334c61b215b68e7039d3e04c": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\tl, u       float64\n\t\twant       []float64\n\t\twantPanic  bool\n\t\twantErrMsg string\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"single element dst\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twantPanic: true,\n\t\t\twantErrMsg: shortSpan,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf, u is +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\t// The original Span function does not seem to have a meaningful behavior for this case,\n\t\t\t// so we don't have a specific expected output.\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked unexpectedly: %v\", r)\n\t\t\t\t} else if tc.wantPanic && r != nil && r.(string) != tc.wantErrMsg {\n\t\t\t\t\tt.Errorf(\"Span() panicked with unexpected error message: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "10520592a0f56f200f0a6b8fc4e6f903": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\tf      func(float64, float64) bool\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\tf:      func(a, b float64) bool { return a == b },\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0},\n\t\t\tf:      func(a, b float64) bool { return a == b },\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different elements\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.1, 3.0},\n\t\t\tf:      func(a, b float64) bool { return a == b },\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"approx equal\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0001},\n\t\t\tf:      func(a, b float64) bool { return a == b },\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"approx equal with tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0001},\n\t\t\tf:      func(a, b float64) bool { return a-b < 0.0001 },\n\t\t\texpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualFunc(tc.s1, tc.s2, tc.f)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"EqualFunc(%v, %v, %v) = %v, want %v\", tc.s1, tc.s2, tc.f, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "0e9561493f6229f9472a0d33b0425509": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal endpoints\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        0,\n\t\t\texpected: []float64{0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Positive range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -10,\n\t\t\tu:        0,\n\t\t\texpected: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l, Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == nil {\n\t\t\t\t\t\t// Expected a panic\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "11f572eb365996ad3a7cf07e62825761": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tL     float64\n\t\twant  float64\n\t\ttol   float64\n\t}{\n\t\t{\n\t\t\tname:  \"empty slice\",\n\t\t\ts:     []float64{},\n\t\t\tL:     2,\n\t\t\twant:  0,\n\t\t\ttol:   1e-12,\n\t\t},\n\t\t{\n\t\t\tname:  \"L2 norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     2,\n\t\t\twant:  math.Sqrt(14),\n\t\t\ttol:   1e-12,\n\t\t},\n\t\t{\n\t\t\tname:  \"L1 norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     1,\n\t\t\twant:  6,\n\t\t\ttol:   1e-12,\n\t\t},\n\t\t{\n\t\t\tname:  \"L-inf norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     math.Inf(1),\n\t\t\twant:  3,\n\t\t\ttol:   1e-12,\n\t\t},\n\t\t{\n\t\t\tname:  \"arbitrary L norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     3,\n\t\t\twant:  math.Pow(1+8+27, 1/3),\n\t\t\ttol:   1e-12,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, tc.tol) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "16389cca552661e959b771ae10933bd1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN input\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nearest element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nearest element with tie\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:        3.0,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "178631791ebe40ac3e37a083dbafcaf0": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tt := []float64{0.5, 1.0, 1.5}\n\t\tdst := make([]float64, len(s))\n\t\texpected := []float64{0.5, 1.0, 1.5}\n\n\t\tresult := SubTo(dst, s, t)\n\t\tassert.Equal(t, expected, result)\n\t\tassert.Equal(t, expected, dst)\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tt := []float64{0.5, 1.0}\n\t\tdst := make([]float64, len(s))\n\n\t\tassert.Panics(t, func() {\n\t\t\tSubTo(dst, s, t)\n\t\t})\n\t})\n\n\tt.Run(\"dst length mismatch\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0}\n\t\tt := []float64{0.5, 1.0, 1.5}\n\t\tdst := make([]float64, len(s)-1)\n\n\t\tassert.Panics(t, func() {\n\t\t\tSubTo(dst, s, t)\n\t\t})\n\t})\n}",
    "16b961141bad023dbcab537e8956f070": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"regular case\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  []float64{0, 2.5, 5, 7.5, 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.NaN(),\n\t\t\tu:     10,\n\t\t\twant:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\twant:  []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are Inf\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\twant:  []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is Inf\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     10,\n\t\t\twant:  []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is Inf\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\twant:  []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"dst length less than 2\",\n\t\t\tdst:   make([]float64, 1),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\twant:  nil,\n\t\t\tpanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panic {\n\t\t\t\t\tt.Errorf(\"Span() = unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "156e9026367d2431fbba36241809755c": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test case 1: Normal behavior\n\tdst := make([]float64, 5)\n\tSpan(dst, 0.0, 10.0)\n\texpected := []float64{0.0, 2.5, 5.0, 7.5, 10.0}\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(dst, 0.0, 10.0): got %v, want %v\", dst, expected)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Test case 2: Destination slice length less than 2\n\tdst = make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span(dst, 0.0, 10.0) did not panic with dst length < 2\")\n\t\t}\n\t}()\n\tSpan(dst, 0.0, 10.0)\n\n\t// Test case 3: L is NaN\n\tdst = make([]float64, 5)\n\tSpan(dst, math.NaN(), 10.0)\n\texpected = []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0}\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(dst, math.NaN(), 10.0): got %v, want %v\", dst, expected)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Test case 4: U is NaN\n\tdst = make([]float64, 5)\n\tSpan(dst, 0.0, math.NaN())\n\texpected = []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(dst, 0.0, math.NaN()): got %v, want %v\", dst, expected)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Test case 5: L and U are Inf\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), math.Inf(1))\n\texpected = []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)}\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(dst, math.Inf(-1), math.Inf(1)): got %v, want %v\", dst, expected)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Test case 6: L is Inf\n\tdst = make([]float64, 5)\n\tSpan(dst, math.Inf(-1), 10.0)\n\texpected = []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0}\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(dst, math.Inf(-1), 10.0): got %v, want %v\", dst, expected)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Test case 7: U is Inf\n\tdst = make([]float64, 5)\n\tSpan(dst, 0.0, math.Inf(1))\n\texpected = []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)}\n\tfor i, v := range dst {\n\t\tif v != expected[i] {\n\t\t\tt.Errorf(\"Span(dst, 0.0, math.Inf(1)): got %v, want %v\", dst, expected)\n\t\t\treturn\n\t\t}\n\t}\n}",
    "19b2aa9741f579897b5c9a00dec4d507": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 3, 4},\n\t\t\texpect: []float64{0.5, 0.6666666666666666, 0.75},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 3},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expect == nil {\n\t\t\t\t\t\t// Expected panic\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tMul(test.dst, test.s)\n\t\t\tif !reflect.DeepEqual(test.dst, test.expect) {\n\t\t\t\tt.Errorf(\"Mul(%v, %v) = %v, want %v\", test.dst, test.s, test.dst, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "17b48362ee126933a53c1a193c164509": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal length slices\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\texpect: []float64{6, 9, 12},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal length slices\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ty:      []float64{},\n\t\t\talpha:  2,\n\t\t\ts:      []float64{},\n\t\t\texpect: []float64{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == nil {\n\t\t\t\t\t\t// Expected panic, test passed\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := AddScaledTo(tc.dst, tc.y, tc.alpha, tc.s)\n\t\t\tif !EqualFunc(got, tc.expect, func(a, b float64) bool { return a == b }) {\n\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %f, %v) = %v, want %v\", tc.dst, tc.y, tc.alpha, tc.s, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "18f63684bb35c6121ee813332812b6fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general Lp norm\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "128299297328105251c94c426bd401ac": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name  string\n        n     int\n        l     float64\n        u     float64\n        v     float64\n        want  int\n        wantP bool\n    }{\n        {\n            name:  \"n less than 2\",\n            n:     1,\n            l:     0,\n            u:     1,\n            v:     0.5,\n            want:  0,\n            wantP: true,\n        },\n        {\n            name:  \"v is NaN\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     math.NaN(),\n            want:  0,\n            wantP: false,\n        },\n        {\n            name:  \"l is NaN, u is not\",\n            n:     10,\n            l:     math.NaN(),\n            u:     1,\n            v:     0.5,\n            want:  9,\n            wantP: false,\n        },\n        {\n            name:  \"u is NaN\",\n            n:     10,\n            l:     0,\n            u:     math.NaN(),\n            v:     0.5,\n            want:  0,\n            wantP: false,\n        },\n        {\n            name:  \"l is -Inf, u is 0\",\n            n:     11,\n            l:     math.Inf(-1),\n            u:     0,\n            v:     0,\n            want:  5,\n            wantP: false,\n        },\n        {\n            name:  \"l is -Inf, u is 0, v is -Inf\",\n            n:     11,\n            l:     math.Inf(-1),\n            u:     0,\n            v:     math.Inf(-1),\n            want:  0,\n            wantP: false,\n        },\n        {\n            name:  \"l is -Inf, u is 0, v is Inf\",\n            n:     11,\n            l:     math.Inf(-1),\n            u:     0,\n            v:     math.Inf(1),\n            want:  10,\n            wantP: false,\n        },\n        {\n            name:  \"l is 0, v is l\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     0,\n            want:  0,\n            wantP: false,\n        },\n        {\n            name:  \"u is Inf, v is u\",\n            n:     10,\n            l:     0,\n            u:     math.Inf(1),\n            v:     math.Inf(1),\n            want:  9,\n            wantP: false,\n        },\n        {\n            name:  \"v is -Inf, l < u\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     math.Inf(-1),\n            want:  0,\n            wantP: false,\n        },\n        {\n            name:  \"v is Inf, l < u\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     math.Inf(1),\n            want:  9,\n            wantP: false,\n        },\n        {\n            name:  \"v is -Inf, l > u\",\n            n:     10,\n            l:     1,\n            u:     0,\n            v:     math.Inf(-1),\n            want:  9,\n            wantP: false,\n        },\n        {\n            name:  \"v is Inf, l > u\",\n            n:     10,\n            l:     1,\n            u:     0,\n            v:     math.Inf(1),\n            want:  0,\n            wantP: false,\n        },\n        {\n            name:  \"normal case\",\n            n:     10,\n            l:     0,\n            u:     1,\n            v:     0.5,\n            want:  5,\n            wantP: false,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            var got int\n            var panicked bool\n            func() {\n                defer func() {\n                    if r := recover(); r != nil {\n                        panicked = true\n                    }\n                }()\n                got = NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            }()\n\n            if panicked != tc.wantP {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked=%t, want=%t\", tc.n, tc.l, tc.u, tc.v, panicked, tc.wantP)\n            }\n\n            if !tc.wantP && got != tc.want {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n            }\n        })\n    }\n}",
    "1233b208bd7b9681685f0e7a71169e0f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = NaN, u = finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u = NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = -Inf, u = Inf, n odd, v = finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = -Inf, u = Inf, n odd, v = -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = -Inf, u = Inf, n odd, v = Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = -Inf, u = Inf, n even, v = -Inf\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = -Inf, u = Inf, n even, v = Inf\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = -Inf, v = l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u = Inf, v = u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        10,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "175bec1e74ac88c0ebf6618319ad2aea": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: func() []float64 {\n\t\t\t\tdst := make([]float64, 1)\n\t\t\t\tdst[0] = 0\n\t\t\t\treturn dst\n\t\t\t}(),\n\t\t},\n\t\t{\n\t\t\tname: \"less than 2 elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1ad9c3bf09c1a9d8050c0ee5abf9560b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5, 6}\n\t\texpected := []float64{5, 7, 9}\n\t\tAdd(dst, s)\n\t\tif !EqualApprox(dst, expected, 1e-14) {\n\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"unequal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Add() did not panic with unequal length slices\")\n\t\t\t}\n\t\t}()\n\t\tAdd(dst, s)\n\t})\n}",
    "1968ed211494d5115fccc7fbe0d9b841": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"length 2\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic on length less than 2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic with length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 10)\n\t})\n}",
    "1c4cb9f8a7e88f9578abe483cfc61f88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"non-empty slice with unique max value\",\n\t\t\ts:    []float64{1.0, 3.0, 2.0, 4.0, 1.5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"non-empty slice with multiple max values\",\n\t\t\ts:    []float64{1.0, 3.0, 4.0, 4.0, 1.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: func() int {\n\t\t\t\tdefer func() {\n\t\t\t\t\trecover()\n\t\t\t\t}()\n\t\t\t\treturn MaxIdx([]float64{})\n\t\t\t}(),\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN values\",\n\t\t\ts:    []float64{math.NaN(), 3.0, 2.0, 4.0, math.NaN()},\n\t\t\twant: 3,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1830f8f917008a5af3ab25c87b2ae2dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"invalid n - less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in v\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in l\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN in u\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in l and u, n odd, v not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in l and u, n odd, v Inf with same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in l and u, n odd, v Inf with opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in l and u, n even, v Inf with same sign as l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in l, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf in u, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v < l\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        -0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v > u\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        1.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        0.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "200507033a4953d93b579d69ed390e88": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: []float64{5.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: []float64{1.0, 3.0, 2.0, 5.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"with NaNs\",\n\t\t\targs: []float64{1.0, math.NaN(), 2.0, 5.0, 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaNs\",\n\t\t\targs: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: []float64{},\n\t\t\twant: 0, // Expect a panic, not this value\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"MaxIdx did not panic for empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tif got := MaxIdx(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1d6ce67971a15d6b9f8427cb2884ae20": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n    testCases := []struct {\n        name string\n        input []float64\n        expected float64\n    }{\n        {\n            name: \"empty slice\",\n            input: []float64{},\n            expected: 0.0,\n        },\n        {\n            name: \"single element\",\n            input: []float64{42.0},\n            expected: 42.0,\n        },\n        {\n            name: \"multiple elements\",\n            input: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            expected: 15.0,\n        },\n        {\n            name: \"large values\",\n            input: []float64{1e10, 1e10, 1e10, 1e10, 1e10},\n            expected: 5e10,\n        },\n        {\n            name: \"small values\",\n            input: []float64{1e-10, 1e-10, 1e-10, 1e-10, 1e-10},\n            expected: 5e-10,\n        },\n        {\n            name: \"mixed values\",\n            input: []float64{1.0, 1e10, 1e-10, 42.0, -1.0},\n            expected: 1.0 + 1e10 + 1e-10 + 42.0 - 1.0,\n        },\n        {\n            name: \"NaN values\",\n            input: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n            expected: math.NaN(),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := SumCompensated(tc.input)\n            if !math.Abs(result-tc.expected) < 1e-10 {\n                t.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "1ca3cc76bc3280f4036eb5e02262113a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l and Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"with dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// If we expect a panic, use the assert.Panics() function\n\t\t\tif tt.wantPanic {\n\t\t\t\tassert.Panics(t, func() { Span(tt.dst, tt.l, tt.u) })\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Otherwise, call the Span function and check the result\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1fe92cb8cfb822ebbb0cb855c24a048d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\tt.Run(\"simple case\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := 3.5\n\t\texpected := 2\n\t\tgot := NearestIdx(s, v)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d, want %d\", s, v, got, expected)\n\t\t}\n\t})\n\n\tt.Run(\"NaN value\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := math.NaN()\n\t\texpected := 0\n\t\tgot := NearestIdx(s, v)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d, want %d\", s, v, got, expected)\n\t\t}\n\t})\n\n\tt.Run(\"positive infinity\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := math.Inf(1)\n\t\texpected := 4\n\t\tgot := NearestIdx(s, v)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d, want %d\", s, v, got, expected)\n\t\t}\n\t})\n\n\tt.Run(\"negative infinity\", func(t *testing.T) {\n\t\ts := []float64{1.0, 2.0, 3.0, 4.0, 5.0}\n\t\tv := math.Inf(-1)\n\t\texpected := 0\n\t\tgot := NearestIdx(s, v)\n\t\tif got != expected {\n\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d, want %d\", s, v, got, expected)\n\t\t}\n\t})\n\n\tt.Run(\"zero length slice\", func(t *testing.T) {\n\t\ts := []float64{}\n\t\tv := 3.5\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %f) did not panic\", s, v)\n\t\t\t}\n\t\t}()\n\t\t_ = NearestIdx(s, v)\n\t})\n}",
    "1c5f72f2d5979de07ba7baa8000ca229": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && test.expected != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif test.expected == nil {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", test.dst, test.l, test.u)\n\t\t\t} else if !Equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "213b596d12483bcacb7cf3ba03419666": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value lower than first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value higher than last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slice length less than 2\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unsorted slice\",\n\t\t\ts:        []float64{5.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\tv:        2.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tc.s) {\n\t\t\t\tt.Errorf(\"Input slice %v is not sorted\", tc.s)\n\t\t\t}\n\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "252ed22fd9f5304c94adacddc06a1137": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"all finite values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"one NaN value\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "210f3b2cc25d3852c35a761e34477c91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid span\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "226111ab2928dc905e44814f6f9015be": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tL     float64\n\t\twant  float64\n\t\ttol   float64\n\t}{\n\t\t{\n\t\t\tname:  \"empty slice\",\n\t\t\ts:     []float64{},\n\t\t\tL:     2,\n\t\t\twant:  1,\n\t\t\ttol:   1e-14,\n\t\t},\n\t\t{\n\t\t\tname:  \"L2 norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     2,\n\t\t\twant:  math.Sqrt(14),\n\t\t\ttol:   1e-14,\n\t\t},\n\t\t{\n\t\t\tname:  \"L1 norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     1,\n\t\t\twant:  6,\n\t\t\ttol:   1e-14,\n\t\t},\n\t\t{\n\t\t\tname:  \"L-inf norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     math.Inf(1),\n\t\t\twant:  3,\n\t\t\ttol:   1e-14,\n\t\t},\n\t\t{\n\t\t\tname:  \"general L norm\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     3,\n\t\t\twant:  math.Pow(1+8+27, 1.0/3.0),\n\t\t\ttol:   1e-14,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, tc.tol) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "1fdd45a9c18c7c68f389281bb34338b8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not NaN\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\tv:      5,\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      5,\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   2,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, v = l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf, v = u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is outside (l, u), l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      -1,\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is outside (u, l), l > u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      0,\n\t\t\tv:      11,\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      5,\n\t\t\twant:   5,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      0,\n\t\t\tv:      5,\n\t\t\twant:   5,\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "22bd207af381f87686834da5d600c1ad": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nearest value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equidistant values\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:        3.0,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(test.s, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d, expected %d\", test.s, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "20b1c7750ca546302f3faea997b5b38d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"n less than 2\",\n\t\t\tn:     1,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN value\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN, u is finite\",\n\t\t\tn:     10,\n\t\t\tl:     math.NaN(),\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are both Inf with same sign\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are both Inf with opposite sign, n is odd\",\n\t\t\tn:     9,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0.0,\n\t\t\twant:  4,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are both Inf with opposite sign, n is even\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0.0,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is Inf, v == l\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is Inf, v == u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is -Inf, l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is Inf, l > u\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is within (l, u), l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is within (u, l), l > u\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) unexpected panic: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "27980de3e3145bbf91a6bce006ce4d0c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tinput []float64\n\t\twant  int\n\t}{\n\t\t{\n\t\t\tname:  \"empty slice\",\n\t\t\tinput: []float64{},\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"single element slice\",\n\t\t\tinput: []float64{42.0},\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple elements, no NaNs\",\n\t\t\tinput: []float64{10.0, 5.0, 7.0, 15.0},\n\t\t\twant:  1,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple elements, with NaNs\",\n\t\t\tinput: []float64{math.NaN(), 5.0, 7.0, math.NaN()},\n\t\t\twant:  1,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple elements, all NaNs\",\n\t\t\tinput: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant:  0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := MinIdx(tc.input)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tc.input, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "273f0a878b8e6f3562e9f28f044dc394": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n    // Test cases\n    testCases := []struct {\n        name     string\n        input    []float64\n        expected float64\n    }{\n        {\n            name:     \"Empty slice\",\n            input:    []float64{},\n            expected: 0.0,\n        },\n        {\n            name:     \"Single element slice\",\n            input:    []float64{42.0},\n            expected: 42.0,\n        },\n        {\n            name:     \"Positive numbers\",\n            input:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            expected: 15.0,\n        },\n        {\n            name:     \"Negative numbers\",\n            input:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n            expected: -15.0,\n        },\n        {\n            name:     \"Mixed numbers\",\n            input:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n            expected: 3.0,\n        },\n        {\n            name:     \"Very small numbers\",\n            input:    []float64{1e-20, 1e-20, 1e-20, 1e-20, 1e-20},\n            expected: 5e-20,\n        },\n        {\n            name:     \"Large numbers\",\n            input:    []float64{1e20, 1e20, 1e20, 1e20, 1e20},\n            expected: 5e20,\n        },\n        {\n            name:     \"NaN values\",\n            input:    []float64{1.0, math.NaN(), 3.0, -4.0, 5.0},\n            expected: math.NaN(),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := SumCompensated(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "253f0b1f1c4b549501d40eca15d5eced": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    tests := []struct {\n        name string\n        n    int\n        l    float64\n        u    float64\n        v    float64\n        want int\n    }{\n        {\"n < 2\", 1, 0, 1, 0.5, -1},\n        {\"NaN value\", 10, 0, 1, math.NaN(), 0},\n        {\"l is NaN, u is not\", 10, math.NaN(), 1, 0.5, 9},\n        {\"u is NaN\", 10, 0, math.NaN(), 0.5, 0},\n        {\"l and u are Inf, same sign\", 5, math.Inf(1), math.Inf(1), 0.5, 0},\n        {\"l and u are Inf, opposite sign\", 5, math.Inf(-1), math.Inf(1), 0.5, 2},\n        {\"l is Inf, v == l\", 10, math.Inf(1), 1, math.Inf(1), 0},\n        {\"l is Inf, v != l\", 10, math.Inf(1), 1, 0.5, 9},\n        {\"u is Inf, v == u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n        {\"u is Inf, v != u\", 10, 0, math.Inf(1), 0.5, 0},\n        {\"v is -Inf, l < u\", 10, 0, 1, math.Inf(-1), 0},\n        {\"v is Inf, l > u\", 10, 1, 0, math.Inf(1), 0},\n        {\"v is in (l, u)\", 10, 0, 1, 0.5, 5},\n        {\"v is in (u, l)\", 10, 1, 0, 0.5, 5},\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if tt.n < 2 {\n                defer func() {\n                    if r := recover(); r == nil {\n                        t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tt.n, tt.l, tt.u, tt.v)\n                    }\n                }()\n            }\n            got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n            if got != tt.want {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n            }\n        })\n    }\n}",
    "288f617c62576d3f1a88038094c17195": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t. \".\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"all positive\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative\",\n\t\t\ts:    []float64{-5, -4, -3, -2, -1},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1, -2, 3, -4, 5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN and values\",\n\t\t\ts:    []float64{1, math.NaN(), 3, -4, 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "26a35a13561a9794e4226386d82986f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-infinity norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\t// Check for panic\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\t// Expected a panic\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// Call the Distance function\n\t\t\tdistance := Distance(tc.s, tc.t, tc.L)\n\n\t\t\t// Check the result\n\t\t\tif distance != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f; expected %f\", tc.s, tc.t, tc.L, distance, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "28520fc1a5692c9c87d9da5daba3a32d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Non-empty slice with unique minimum\",\n\t\t\tinput:    []float64{5.0, 2.0, 9.0, 1.0, 4.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-empty slice with multiple minimum values\",\n\t\t\tinput:    []float64{1.0, 2.0, 1.0, 4.0, 1.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slice with all NaN values\",\n\t\t\tinput:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0, // This should panic\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.name == \"Empty slice\" {\n\t\t\t\t\t// Expected panic for empty slice\n\t\t\t\t\treturn\n\t\t\t\t} else if r != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := MinIdx(tc.input)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, expected %d\", tc.input, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29038392105c5bc234f760656fcb22e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-5, -4, -3, -2, -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1, -2, 3, -4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic on empty slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"MaxIdx([]float64{}) did not panic\")\n\t\t\t}\n\t\t}()\n\t\tMaxIdx([]float64{})\n\t})\n}",
    "28ebcdc9ba99fb1af3edf4495a630a68": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n    tests := []struct {\n        name string\n        s    []float64\n        want int\n    }{\n        {\n            name: \"non-empty slice, no NaNs\",\n            s:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            want: 0,\n        },\n        {\n            name: \"non-empty slice, with NaNs\",\n            s:    []float64{math.NaN(), 2.0, 3.0, 4.0, 5.0},\n            want: 1,\n        },\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            want: 0, // this will panic\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil {\n                    if tt.name == \"empty slice\" {\n                        // Expected panic, test passed\n                        return\n                    }\n                    t.Errorf(\"MinIdx(%v) panicked: %v\", tt.s, r)\n                }\n            }()\n\n            if got := MinIdx(tt.s); got != tt.want {\n                t.Errorf(\"MinIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n            }\n        })\n    }\n}",
    "275967bd3d165d6f5e107ac14d6101cc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2 should panic\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with the same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (l, u), l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (u, l), l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "28f9800a7a4182bbc7af30b587ca4260": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1.0/3.0),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "25ce682804023f9a12509c8ac3f9216a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"basic case\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 1.0, 5.0\n\t\texpected := []float64{1, 2, 3, 4, 5}\n\t\tresult := Span(dst, l, u)\n\t\tif !EqualFunc(result, expected, func(a, b float64) bool { return a == b }) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"short destination\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tl, u := 1.0, 5.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", dst, l, u)\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, l, u)\n\t})\n\n\tt.Run(\"NaN in lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.NaN(), 5.0\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5}\n\t\tresult := Span(dst, l, u)\n\t\tif !EqualFunc(result, expected, func(a, b float64) bool { return (math.IsNaN(a) && math.IsNaN(b)) || a == b }) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"NaN in upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 1.0, math.NaN()\n\t\texpected := []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tresult := Span(dst, l, u)\n\t\tif !EqualFunc(result, expected, func(a, b float64) bool { return (math.IsNaN(a) && math.IsNaN(b)) || a == b }) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"Inf in lower bound, Inf in upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.Inf(-1), math.Inf(1)\n\t\texpected := []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)}\n\t\tresult := Span(dst, l, u)\n\t\tif !EqualFunc(result, expected, func(a, b float64) bool { return (math.IsInf(a, 0) && math.IsInf(b, 0)) || a == b }) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"Inf in lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.Inf(1), 5.0\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5}\n\t\tresult := Span(dst, l, u)\n\t\tif !EqualFunc(result, expected, func(a, b float64) bool { return (math.IsInf(a, 1) && math.IsInf(b, 1)) || a == b }) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"Inf in upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 1.0, math.Inf(1)\n\t\texpected := []float64{1, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tresult := Span(dst, l, u)\n\t\tif !EqualFunc(result, expected, func(a, b float64) bool { return (math.IsInf(a, 1) && math.IsInf(b, 1)) || a == b }) {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n}",
    "2799b7f6d5b93f89992e821705bebff0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      math.NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\tv:      5,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf with the same sign\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      -10,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      -10,\n\t\t\texpect: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf, v == l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf, v == u\",\n\t\t\tn:      10,\n\t\t\tl:      -10,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      -10,\n\t\t\tu:      10,\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      -10,\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      -10,\n\t\t\tu:      10,\n\t\t\tv:      0,\n\t\t\texpect: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      -10,\n\t\t\tv:      0,\n\t\t\texpect: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2adf7865b18d991dea53dc6df7a87df3": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs []float64\n\t\twant float64\n\t}{\n\t\t{\"empty slice\", []float64{}, 1.0},\n\t\t{\"single element\", []float64{2.0}, 2.0},\n\t\t{\"multiple elements\", []float64{2.0, 3.0, 4.0}, 0.1666666666666667},\n\t\t{\"zero element\", []float64{0.0, 3.0, 4.0}, 0.0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "295ed50fd8578a673bb2e3fcc8350d9c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large, varying numbers\",\n\t\t\ts:    []float64{1e20, 1, -1e20, 1e-20},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large, alternating numbers\",\n\t\t\ts:    []float64{1e20, -1e20, 1e20, -1e20, 1e20},\n\t\t\twant: 1e20,\n\t\t},\n\t\t{\n\t\t\tname: \"small, varying numbers\",\n\t\t\ts:    []float64{1e-20, 1, -1e-20, 1e-20},\n\t\t\twant: 2.0000000000000002,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.s); !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) <= 1e-14*math.Max(math.Abs(a), math.Abs(b))\n}",
    "2a86c48c0b34e51f7e81c07ad226cfc8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"same length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname: \"different length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3, 4},\n\t\t\t\tt:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"dst length mismatch\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29b9b1c0f0123acdc4bd5a5dcb577350": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    []float64\n        expected int\n    }{\n        {\n            name:     \"happy path\",\n            input:    []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n            expected: 2,\n        },\n        {\n            name:     \"all equal\",\n            input:    []float64{1.0, 1.0, 1.0, 1.0, 1.0},\n            expected: 0,\n        },\n        {\n            name:     \"NaN\",\n            input:    []float64{1.0, math.NaN(), 3.0, 2.0, 1.0},\n            expected: 2,\n        },\n        {\n            name:     \"empty slice\",\n            input:    []float64{},\n            expected: 0, // expected panic\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil && tc.name == \"empty slice\" {\n                    // Expected panic, test passes\n                    return\n                } else if r != nil {\n                    t.Errorf(\"Unexpected panic: %v\", r)\n                }\n            }()\n\n            idx := MaxIdx(tc.input)\n            if idx != tc.expected {\n                t.Errorf(\"MaxIdx(%v) = %d, expected %d\", tc.input, idx, tc.expected)\n            }\n        })\n    }\n}",
    "29360998acd13b342952710bb8afacf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tdst       []float64\n\t\tl, u      float64\n\t\twant      []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:      \"short span\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"regular span\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d185405319948d8cbedc6a6a50ab7fc": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Equal lengths\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{10, 20, 30},\n\t\t\t\tt:   []float64{2, 4, 6},\n\t\t\t},\n\t\t\twant: []float64{5, 5, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{10, 20},\n\t\t\t\tt:   []float64{2, 4, 6},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t\tt:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := DivTo(tt.args.dst, tt.args.s, tt.args.t); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "29321ecf0482984dd39ea3b7ce875e3b": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantOk bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"short dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   nil,\n\t\t\twantOk: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantOk: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !tt.wantOk {\n\t\t\t\tif err := recover(); err == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !floats.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2912766f5fa08aadae1282284cedee38": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\tl, u       float64\n\t\twantDst    []float64\n\t\twantPanic  bool\n\t\tdescription string\n\t}{\n\t\t{\n\t\t\tname:       \"Basic span\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\twantDst:    []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span should create a set of N equally spaced points between l and u, where N is the length of the destination slice.\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Span with l = NaN\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.NaN(),\n\t\t\tu:          10.0,\n\t\t\twantDst:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"If l is NaN, Span should set all elements except the last to NaN and the last to u.\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Span with u = NaN\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0.0,\n\t\t\tu:          math.NaN(),\n\t\t\twantDst:    []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"If u is NaN, Span should set all elements except the first to NaN and the first to l.\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Span with l = +Inf and u = +Inf\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.Inf(1),\n\t\t\tu:          math.Inf(1),\n\t\t\twantDst:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"If l and u are both positive infinity, Span should set all elements to positive infinity.\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Span with l = -Inf and u = +Inf\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.Inf(-1),\n\t\t\tu:          math.Inf(1),\n\t\t\twantDst:    []float64{math.Inf(-1), -math.Inf(1)/2, 0, math.Inf(1)/2, math.Inf(1)},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"If l is negative infinity and u is positive infinity, Span should create a set of evenly spaced points between the two.\",\n\t\t},\n\t\t{\n\t\t\tname:       \"Span with length < 2\",\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\twantDst:    nil,\n\t\t\twantPanic:  true,\n\t\t\tdescription: \"Span should panic if the length of the destination slice is less than 2.\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotDst := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(gotDst, tc.wantDst) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", gotDst, tc.wantDst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e64769798a5cc94d729f8d90e29adfd": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tc        float64\n\t\ts        []float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"Basic scaling\",\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\tc:        2.0,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: []float64{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\tdst:      []float64{1, 2},\n\t\t\tc:        2.0,\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\tdst:      []float64{},\n\t\t\tc:        2.0,\n\t\t\ts:        []float64{},\n\t\t\texpected: []float64{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := ScaleTo(tt.dst, tt.c, tt.s)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"ScaleTo(%v, %f, %v) = %v, expected %v\", tt.dst, tt.c, tt.s, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c01766532bd63aa2abc38cc94eb14e6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 1\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && !tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t} else if r == nil && tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "30dee26f57fa90a8a53794231ce2c69e": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tslices  [][]float64\n\t\twant    bool\n\t}{\n\t\t{\n\t\t\tname:    \"all slices have equal length\",\n\t\t\tslices:  [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"slices have different lengths\",\n\t\t\tslices:  [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}, {7.0, 8.0, 9.0, 10.0}},\n\t\t\twant:    false,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\tslices:  [][]float64{},\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single slice\",\n\t\t\tslices:  [][]float64{{1.0, 2.0, 3.0}},\n\t\t\twant:    true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3089a094a99d51ef78034874e78c9a53": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4378770664093453,\n\t\t},\n\t\t{\n\t\t\tname: \"all values are negative\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.4802010820625674,\n\t\t},\n\t\t{\n\t\t\tname: \"some values are negative\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0},\n\t\t\twant: 2.4076059977153333,\n\t\t},\n\t\t{\n\t\t\tname: \"large values\",\n\t\t\ts:    []float64{100.0, 200.0, 300.0},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"small values\",\n\t\t\ts:    []float64{-100.0, -200.0, -300.0},\n\t\t\twant: -300.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2d9592ac59a1a355ee03def9ab0094c3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2 should panic\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf, u is +Inf, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf, u is +Inf, n is even\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf, v is +Inf\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is +Inf, v is +Inf\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (l, u), l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (u, l), l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2f1a12d46d26c88d281ab17f5d43f813": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        10.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest value with multiple matches\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\tv:        3.0,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(test.s, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", test.s, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2c0b11a375fc921998c1c9c945a1e821": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\twantIdx  int\n\t\twantPnic bool\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\twantPnic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\twantIdx:  0,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\twantIdx:  4,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\twantIdx:  0,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\twantIdx:  2,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\twantIdx:  2,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\twantIdx:  0,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\twantIdx:  4,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\twantIdx:  0,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\twantIdx:  4,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\twantIdx:  4,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\twantIdx:  0,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within the range (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\twantIdx:  2,\n\t\t\twantPnic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within the range (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\twantIdx:  2,\n\t\t\twantPnic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPnic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotIdx := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif gotIdx != tt.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, gotIdx, tt.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "2e8f04b46a7cc612ea38ffd806e2eb04": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"nan l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"nan u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "32bb0402b219e3687bbce36b83414407": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\tv:    1.0,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\ts:    []float64{3.0, 1.0, 4.0},\n\t\t\tv:    2.0,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    0.5,\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    3.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value in the middle\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value at the beginning\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value at the end\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    5.0,\n\t\t\twant: 4,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif len(tc.s) >= 2 {\n\t\t\t\tsort.Float64s(tc.s)\n\t\t\t}\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Within(%v, %.2f) = %d, want %d\", tc.s, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "310cb20bedefcc5ffc221258026fc89f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\tpanics   bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -10,\n\t\t\tu:        0,\n\t\t\texpected: []float64{-10, -5, 0},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        0,\n\t\t\texpected: []float64{0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"short dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "31da813b746c7eabd381b135198484d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v matches l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v matches u\",\n\t\t\tn:        10,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within [l, u], l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within [l, u], l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "356d6aedd0b043c46f7fcf7e3ff1cbc9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2.0,\n\t\t\twant: 0.0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    2.0,\n\t\t\twant: math.Sqrt(14.0),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    1.0,\n\t\t\twant: 6.0,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    3.0,\n\t\t\twant: math.Pow(14.0, 1.0/3.0),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "345c9a3be0ead2a6bb443889e1480273": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -5.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{-5.0, 0.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN lower bound\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN upper bound\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf lower bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf upper bound\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34830695dc149b4a5cc409e9b2a8f053": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed elements\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\ts:    []float64{1e9, 1e9, 1e9, 1e9, 1e9},\n\t\t\twant: 5e9,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\ts:    []float64{1e-9, 1e-9, 1e-9, 1e-9, 1e-9},\n\t\t\twant: 5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed large and small numbers\",\n\t\t\ts:    []float64{1e9, 1e-9, 1e9, 1e-9, 1e9},\n\t\t\twant: 3.00000001e9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0, math.NaN(), 5.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "34ff38c1847746783a7293319ecf85f8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\twantInds []int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"find all matching elements\",\n\t\t\tinds:     make([]int, 0),\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{1, -2, 3, 0, 4},\n\t\t\tk:        -1,\n\t\t\twantInds: []int{0, 2, 4},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first k matching elements\",\n\t\t\tinds:     make([]int, 0),\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{1, -2, 3, 0, 4},\n\t\t\tk:        2,\n\t\t\twantInds: []int{0, 2},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no matching elements\",\n\t\t\tinds:     make([]int, 0),\n\t\t\tf:        func(x float64) bool { return x < 0 },\n\t\t\ts:        []float64{1, 2, 3, 0, 4},\n\t\t\tk:        2,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"find zero elements\",\n\t\t\tinds:     make([]int, 0),\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        0,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotInds, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotInds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", gotInds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "315d479ff232fd65956f9b3da7e0e12b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is greater than l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is -Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is -Inf, v is less than u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        -11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is less than l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is greater than u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is greater than l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is less than u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3777da618e67948fe1f0988381d359df": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small numbers\",\n\t\t\ts:    []float64{1e100, 1e-100, 1e100, 1e-100, 1e100},\n\t\t\twant: 3.00000000000001e+100,\n\t\t},\n\t\t{\n\t\t\tname: \"near-cancelling numbers\",\n\t\t\ts:    []float64{1e100, -1e100, 1e100, -1e100, 1e100},\n\t\t\twant: 2.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.s); !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) < 1e-12\n}",
    "35e4e0a40afe6a5e168783bb39d5cb1d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value is exact match\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value is between two elements\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        1.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value is closer to second element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        1.7,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value is +Inf\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements, value is -Inf\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "358cb99636fbb9e701ee9e0d5a0edac1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with the same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3a76d4dd149871d67008d88252023be3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"non-empty slice\",\n\t\t\tinput:    []float64{5.0, 2.0, 8.0, 1.0, 6.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice with NaN\",\n\t\t\tinput:    []float64{5.0, 2.0, math.NaN(), 1.0, 6.0},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice with multiple minimum values\",\n\t\t\tinput:    []float64{1.0, 1.0, 2.0, 1.0, 6.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"MinIdx(%v) did not panic as expected\", tc.input)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"MinIdx(%v) panicked: %v\", tc.input, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MinIdx(tc.input)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "382421897ddac293a7eaf5803663f8ba": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal length\",\n\t\t\tdst:    []float64{1, 2, 3, 4, 5},\n\t\t\ts:      []float64{0.5, 0.5, 0.5, 0.5, 0.5},\n\t\t\texpect: []float64{0.5, 1.5, 2.5, 3.5, 4.5},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal length\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{0.5, 0.5, 0.5, 0.5, 0.5},\n\t\t\texpect: nil, // Should panic\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.expect == nil && r == nil {\n\t\t\t\t\tt.Errorf(\"Sub() did not panic as expected\")\n\t\t\t\t} else if tc.expect != nil && r != nil {\n\t\t\t\t\tt.Errorf(\"Sub() panicked unexpectedly: %v\", r)\n\t\t\t\t} else if tc.expect != nil {\n\t\t\t\t\tgot := make([]float64, len(tc.dst))\n\t\t\t\t\tcopy(got, tc.dst)\n\t\t\t\t\tSub(got, tc.s)\n\t\t\t\t\tif !EqualApprox(got, tc.expect, 1e-10) {\n\t\t\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", got, tc.expect)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tSub(tc.dst, tc.s)\n\t\t})\n\t}\n}",
    "3843bad289f379e1a739b632988424fb": "package floats\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n    tests := []struct {\n        name    string\n        inds    []int\n        f       func(float64) bool\n        s       []float64\n        k       int\n        want    []int\n        wantErr bool\n    }{\n        {\n            name:    \"find all elements satisfying f\",\n            inds:    make([]int, 0),\n            f:       func(x float64) bool { return x > 0 },\n            s:       []float64{1, -2, 3, 0, 4},\n            k:       -1,\n            want:    []int{0, 2, 4},\n            wantErr: false,\n        },\n        {\n            name:    \"find first k elements satisfying f\",\n            inds:    make([]int, 0),\n            f:       func(x float64) bool { return x > 0 },\n            s:       []float64{1, -2, 3, 0, 4},\n            k:       2,\n            want:    []int{0, 2},\n            wantErr: false,\n        },\n        {\n            name:    \"find no elements satisfying f\",\n            inds:    make([]int, 0),\n            f:       func(x float64) bool { return x < 0 },\n            s:       []float64{1, 2, 3, 0, 4},\n            k:       2,\n            want:    []int{},\n            wantErr: true,\n        },\n        {\n            name:    \"k is 0\",\n            inds:    make([]int, 0),\n            f:       func(x float64) bool { return x > 0 },\n            s:       []float64{1, -2, 3, 0, 4},\n            k:       0,\n            want:    []int{},\n            wantErr: false,\n        },\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Find(tt.inds, tt.f, tt.s, tt.k)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Find() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "34c0d99226cdf4b4227be15a1f145e68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tn       int\n\t\tl       float64\n\t\tu       float64\n\t\tv       float64\n\t\twant    int\n\t\twantPan bool\n\t}{\n\t\t{\n\t\t\tname:    \"n less than 2\",\n\t\t\tn:       1,\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\tv:       0.5,\n\t\t\twantPan: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is NaN\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\tv:       math.NaN(),\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is NaN, u is not NaN\",\n\t\t\tn:       10,\n\t\t\tl:       math.NaN(),\n\t\t\tu:       1,\n\t\t\tv:       0.5,\n\t\t\twant:    9,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is NaN\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\tv:       0.5,\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is +Inf, u is +Inf, n is odd, v is not Inf\",\n\t\t\tn:       5,\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       0.5,\n\t\t\twant:    2,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is +Inf, u is +Inf, n is odd, v is -Inf\",\n\t\t\tn:       5,\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(-1),\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is +Inf, u is +Inf, n is odd, v is +Inf\",\n\t\t\tn:       5,\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(1),\n\t\t\twant:    3,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is +Inf, n is even, v is -Inf\",\n\t\t\tn:       4,\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(-1),\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is +Inf, n is even, v is +Inf\",\n\t\t\tn:       4,\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(1),\n\t\t\twant:    3,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is -Inf, v is l\",\n\t\t\tn:       10,\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       0,\n\t\t\tv:       math.Inf(-1),\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is -Inf, v is u\",\n\t\t\tn:       10,\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       0,\n\t\t\tv:       0,\n\t\t\twant:    9,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is +Inf, v is u\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(1),\n\t\t\twant:    9,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is +Inf, v is -Inf\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(-1),\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is outside (l, u)\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\tv:       -1,\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is outside (l, u) and (u, l)\",\n\t\t\tn:       10,\n\t\t\tl:       1,\n\t\t\tu:       0,\n\t\t\tv:       2,\n\t\t\twant:    0,\n\t\t\twantPan: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"normal case\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       1,\n\t\t\tv:       0.5,\n\t\t\twant:    5,\n\t\t\twantPan: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPan && r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tc.n, tc.l, tc.u, tc.v)\n\t\t\t\t}\n\t\t\t\tif !tc.wantPan && r != nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tc.n, tc.l, tc.u, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3d239a05153f127756cc4206cf13ce2f": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n    testCases := []struct {\n        name string\n        input []float64\n        expected float64\n    }{\n        {\n            name: \"Empty slice\",\n            input: []float64{},\n            expected: 0,\n        },\n        {\n            name: \"Slice with positive numbers\",\n            input: []float64{1, 2, 3, 4, 5},\n            expected: 15,\n        },\n        {\n            name: \"Slice with negative numbers\",\n            input: []float64{-1, -2, -3, -4, -5},\n            expected: -15,\n        },\n        {\n            name: \"Slice with positive and negative numbers\",\n            input: []float64{1, -2, 3, -4, 5},\n            expected: 3,\n        },\n        {\n            name: \"Slice with very small numbers\",\n            input: []float64{1e-20, 2e-20, 3e-20, 4e-20, 5e-20},\n            expected: 15e-20,\n        },\n        {\n            name: \"Slice with NaN\",\n            input: []float64{1, 2, math.NaN(), 4, 5},\n            expected: math.NaN(),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := SumCompensated(tc.input)\n            if !math.IsNaN(tc.expected) && !math.IsNaN(result) {\n                if math.Abs(result-tc.expected) > 1e-10 {\n                    t.Errorf(\"SumCompensated(%v) = %f, expected %f\", tc.input, result, tc.expected)\n                }\n            } else if math.IsNaN(tc.expected) != math.IsNaN(result) {\n                t.Errorf(\"SumCompensated(%v) = %f, expected %f\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "36b46310cb1e47d0cbd345cbb5e97feb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3fa7e3b95f5c707b1cf62da5c1bdb6f4": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n    testCases := []struct {\n        name     string\n        c        float64\n        dst      []float64\n        expected []float64\n    }{\n        {\n            name:     \"Empty slice\",\n            c:        3.14,\n            dst:      []float64{},\n            expected: []float64{},\n        },\n        {\n            name:     \"Single element\",\n            c:        2.71,\n            dst:      []float64{5.0},\n            expected: []float64{7.71},\n        },\n        {\n            name:     \"Multiple elements\",\n            c:        1.0,\n            dst:      []float64{1.0, 2.0, 3.0},\n            expected: []float64{2.0, 3.0, 4.0},\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            AddConst(tc.c, tc.dst)\n            if !Equal(tc.dst, tc.expected) {\n                t.Errorf(\"AddConst(%v, %v) = %v, want %v\", tc.c, tc.dst, tc.dst, tc.expected)\n            }\n        })\n    }\n}",
    "3bddc91a49dd0c307d9de0e1281590c7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"length 2\",\n\t\t\tdst:      make([]float64, 2),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"length 1 (should panic)\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "39db05dc4a24eb9227f51017d3d973fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"valid case\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even, v is positive\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even, v is negative\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v is equal to l\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10.0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v is equal to u\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    5,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (l, u), l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (u, l), l > u\",\n\t\t\tn:    5,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    5.0,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3adb71339e22f88f256492a10f5ad403": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype testCase struct {\n\t\tname      string\n\t\tn         int\n\t\tl, u, v   float64\n\t\twantIdx   int\n\t\twantPanic bool\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname:      \"n less than 2\",\n\t\t\tn:         1,\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\tv:         0.5,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"l is NaN, u is not NaN\",\n\t\t\tn:         10,\n\t\t\tl:         math.NaN(),\n\t\t\tu:         1,\n\t\t\tv:         0.5,\n\t\t\twantIdx:   9,\n\t\t},\n\t\t{\n\t\t\tname:      \"u is NaN\",\n\t\t\tn:         10,\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\tv:         0.5,\n\t\t\twantIdx:   0,\n\t\t},\n\t\t{\n\t\t\tname:      \"l and u are both Inf\",\n\t\t\tn:         5,\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(1),\n\t\t\tv:         0.5,\n\t\t\twantIdx:   2,\n\t\t},\n\t\t{\n\t\t\tname:      \"l and u are both Inf, v is Inf\",\n\t\t\tn:         5,\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         math.Inf(1),\n\t\t\tv:         math.Inf(1),\n\t\t\twantIdx:   0,\n\t\t},\n\t\t{\n\t\t\tname:      \"l is Inf, v is less than l\",\n\t\t\tn:         10,\n\t\t\tl:         math.Inf(1),\n\t\t\tu:         10,\n\t\t\tv:         -5,\n\t\t\twantIdx:   0,\n\t\t},\n\t\t{\n\t\t\tname:      \"u is Inf, v is greater than u\",\n\t\t\tn:         10,\n\t\t\tl:         0,\n\t\t\tu:         math.Inf(1),\n\t\t\tv:         15,\n\t\t\twantIdx:   9,\n\t\t},\n\t\t{\n\t\t\tname:      \"l < u, v is less than l\",\n\t\t\tn:         10,\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\tv:         -5,\n\t\t\twantIdx:   0,\n\t\t},\n\t\t{\n\t\t\tname:      \"l < u, v is greater than u\",\n\t\t\tn:         10,\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\tv:         15,\n\t\t\twantIdx:   9,\n\t\t},\n\t\t{\n\t\t\tname:      \"l > u, v is greater than l\",\n\t\t\tn:         10,\n\t\t\tl:         10,\n\t\t\tu:         0,\n\t\t\tv:         5,\n\t\t\twantIdx:   0,\n\t\t},\n\t\t{\n\t\t\tname:      \"l > u, v is less than u\",\n\t\t\tn:         10,\n\t\t\tl:         10,\n\t\t\tu:         0,\n\t\t\tv:         -5,\n\t\t\twantIdx:   9,\n\t\t},\n\t\t{\n\t\t\tname:      \"normal case\",\n\t\t\tn:         10,\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\tv:         5,\n\t\t\twantIdx:   5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tc.n, tc.l, tc.u, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tc.n, tc.l, tc.u, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotIdx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif gotIdx != tc.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, gotIdx, tc.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4255a92f176f4d91698166bcd5e8c176": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twantDst []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twantDst: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"Different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Mul() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tMul(tt.dst, tt.s)\n\t\t\tif !reflect.DeepEqual(tt.dst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", tt.dst, tt.wantDst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "402da2b0239a95cd0ad9382497c83698": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tdst       []float64\n\t\tl         float64\n\t\tu         float64\n\t\twantDst   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:      \"empty dst\",\n\t\t\tdst:       []float64{},\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"single element dst\",\n\t\t\tdst:       []float64{0},\n\t\t\tl:         0,\n\t\t\tu:         1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"normal case\",\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\tl:         0,\n\t\t\tu:         2,\n\t\t\twantDst:   []float64{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname:      \"l is NaN\",\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\tl:         math.NaN(),\n\t\t\tu:         2,\n\t\t\twantDst:   []float64{math.NaN(), math.NaN(), 2},\n\t\t},\n\t\t{\n\t\t\tname:      \"u is NaN\",\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\tl:         0,\n\t\t\tu:         math.NaN(),\n\t\t\twantDst:   []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:      \"l and u are Inf\",\n\t\t\tdst:       []float64{0, 0, 0, 0},\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         math.Inf(1),\n\t\t\twantDst:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"l is Inf\",\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\tl:         math.Inf(-1),\n\t\t\tu:         2,\n\t\t\twantDst:   []float64{math.Inf(-1), math.Inf(-1), 2},\n\t\t},\n\t\t{\n\t\t\tname:      \"u is Inf\",\n\t\t\tdst:       []float64{0, 0, 0},\n\t\t\tl:         0,\n\t\t\tu:         math.Inf(1),\n\t\t\twantDst:   []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotDst := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(gotDst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", gotDst, tt.wantDst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "425513ae8a69a98a714e8b3f95e333d2": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/yourUsername/yourPackage/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"n < 2\", 1, 0, 1, 0.5, 0},\n\t\t{\"v is NaN\", 10, 0, 1, math.NaN(), 0},\n\t\t{\"l is NaN, u is finite\", 10, math.NaN(), 1, 0.5, 9},\n\t\t{\"u is NaN\", 10, 0, math.NaN(), 0.5, 0},\n\t\t{\"l and u are ±Inf, v is ±Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"l and u are ±Inf, v is ±Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{\"l and u are ±Inf, v is finite\", 5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{\"l is +Inf, v == l\", 10, math.Inf(1), 1, math.Inf(1), 0},\n\t\t{\"l is +Inf, v != l\", 10, math.Inf(1), 1, 0.5, 9},\n\t\t{\"u is +Inf, v == u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{\"u is +Inf, v != u\", 10, 0, math.Inf(1), 0.5, 0},\n\t\t{\"v is -Inf, l < u\", 10, 0, 1, math.Inf(-1), 0},\n\t\t{\"v is -Inf, l > u\", 10, 1, 0, math.Inf(-1), 9},\n\t\t{\"v is +Inf, l < u\", 10, 0, 1, math.Inf(1), 9},\n\t\t{\"v is +Inf, l > u\", 10, 1, 0, math.Inf(1), 0},\n\t\t{\"normal case\", 10, 0, 1, 0.5, 5},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "408bf5d6763678341e7519c97944b765": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"regular span\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"span with NaN l\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"span with NaN u\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf l and u\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf l\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf u\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"span with length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"span with length 1 (should panic)\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"span with length 1 (should panic)\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43b37766db5973e6b66d2f8e975f0b50": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements satisfying f\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements satisfying f\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"No elements satisfying f\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x < 0 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\t\ts:    []float64{-1, 0, 1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "3f1fcb2afc428a0210f30e3b742123c1": "// floats_test.go\n\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tn          int\n\t\tl, u, v    float64\n\t\twantIdx    int\n\t\twantPanic  bool\n\t}{\n\t\t{\n\t\t\tname: \"valid span\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twantIdx: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\tn:    1,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.NaN(),\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twantIdx: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5.0,\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and equal\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5.0,\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and n is odd\",\n\t\t\tn:    11,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5.0,\n\t\t\twantIdx: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and n is odd, v is negative\",\n\t\t\tn:    11,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    -5.0,\n\t\t\twantIdx: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and n is odd, v is positive\",\n\t\t\tn:    11,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5.0,\n\t\t\twantIdx: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v is equal to l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\tv:    math.Inf(1),\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v is equal to u\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twantIdx: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    math.Inf(1),\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    -1.0,\n\t\t\twantIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    11.0,\n\t\t\twantIdx: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than u, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    5.0,\n\t\t\twantIdx: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than l, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    5.0,\n\t\t\twantIdx: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tc.n, tc.l, tc.u, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.wantIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.wantIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "427a068f7b9d98292d45ba8f0298d820": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"short destination\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif test.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span did not panic as expected\")\n\t\t\t\t} else if !test.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !EqualApprox(result, test.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "44b252eb7d64662d0890dd69335bcff7": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\twantInds []int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"find first k elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\twantInds: []int{2, 3},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        -1,\n\t\t\twantInds: []int{2, 3, 4},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"k == 0\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        0,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"insufficient elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 2 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        4,\n\t\t\twantInds: []int{},\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgotInds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(gotInds, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", gotInds, tc.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4171fcb628d4c71d3830d56fe113e994": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"n less than 2\",\n\t\t\tn:     1,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is NaN\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN, u is not NaN\",\n\t\t\tn:     10,\n\t\t\tl:     math.NaN(),\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +/- Inf, n is odd, v is not Inf\",\n\t\t\tn:     11,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +/- Inf, n is odd, v is -Inf\",\n\t\t\tn:     11,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +/- Inf, n is odd, v is +Inf\",\n\t\t\tn:     11,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  10,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is +Inf, v equals l\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is +Inf, v equals u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is -Inf, l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is +Inf, l > u\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"normal case, l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"normal case, l > u\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4511cbb301b7d8bfcf0b0dedbc359aa4": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, 10.0)\n\t\tassert.Equal(t, []float64{1.0, 3.0, 5.0, 7.0, 10.0}, result)\n\t})\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\tdst := make([]float64, 0)\n\t\tassert.PanicsWithValue(t, shortSpan, func() {\n\t\t\tSpan(dst, 1.0, 10.0)\n\t\t})\n\t})\n\n\tt.Run(\"single element slice\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tassert.PanicsWithValue(t, shortSpan, func() {\n\t\t\tSpan(dst, 1.0, 10.0)\n\t\t})\n\t})\n\n\tt.Run(\"NaN in lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 10.0)\n\t\tassert.Equal(t, []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0}, result)\n\t})\n\n\tt.Run(\"NaN in upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, math.NaN())\n\t\tassert.Equal(t, []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}, result)\n\t})\n\n\tt.Run(\"Inf in lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(1), math.Inf(1))\n\t\tassert.Equal(t, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}, result)\n\t})\n\n\tt.Run(\"Inf in upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, math.Inf(1))\n\t\tassert.Equal(t, []float64{1.0, 1.0, 1.0, 1.0, math.Inf(1)}, result)\n\t})\n}",
    "437c902372f0d98605b3971c25a238e2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twantId int\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2 panics\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is finite\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twantId: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +/-Inf, n is odd, v is finite\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.5,\n\t\t\twantId: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +/-Inf, n is odd, v is -Inf\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +/-Inf, n is odd, v is +Inf\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twantId: 10,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +/-Inf, n is even, v is -Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +/-Inf, n is even, v is +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twantId: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, v is l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf, v is u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twantId: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v <= l\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      -0.1,\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v >= u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      1.1,\n\t\t\twantId: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v >= l\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      1.1,\n\t\t\twantId: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v <= u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      -0.1,\n\t\t\twantId: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twantId: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotId := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif gotId != tt.wantId {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, gotId, tt.wantId)\n\t\t\t}\n\t\t})\n\t}\n}",
    "448e96e64dc8a814b9196333c8e74a69": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        n        int\n        l        float64\n        u        float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"n < 2\",\n            n:        1,\n            l:        0,\n            u:        1,\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"NaN v\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        math.NaN(),\n            expected: 0,\n        },\n        {\n            name:     \"NaN l, non-NaN u\",\n            n:        10,\n            l:        math.NaN(),\n            u:        1,\n            v:        0.5,\n            expected: 9,\n        },\n        {\n            name:     \"NaN u\",\n            n:        10,\n            l:        0,\n            u:        math.NaN(),\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"Inf l and u, odd n\",\n            n:        11,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        0,\n            expected: 5,\n        },\n        {\n            name:     \"Inf l and u, even n, v is Inf\",\n            n:        10,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 9,\n        },\n        {\n            name:     \"Inf l and u, even n, v is not Inf\",\n            n:        10,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        0.5,\n            expected: 5,\n        },\n        {\n            name:     \"Inf l, finite u\",\n            n:        10,\n            l:        math.Inf(-1),\n            u:        1,\n            v:        0.5,\n            expected: 9,\n        },\n        {\n            name:     \"Inf u, finite l\",\n            n:        10,\n            l:        0,\n            u:        math.Inf(1),\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"Inf v, l < u\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"Inf v, l > u\",\n            n:        10,\n            l:        1,\n            u:        0,\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"v < l\",\n            n:        10,\n            l:        0.5,\n            u:        1,\n            v:        0.25,\n            expected: 0,\n        },\n        {\n            name:     \"v > u\",\n            n:        10,\n            l:        0,\n            u:        0.5,\n            v:        0.75,\n            expected: 9,\n        },\n        {\n            name:     \"l < u, normal case\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        0.5,\n            expected: 5,\n        },\n        {\n            name:     \"l > u, normal case\",\n            n:        10,\n            l:        1,\n            u:        0,\n            v:        0.5,\n            expected: 5,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            idx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            if idx != tc.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n            }\n        })\n    }\n}",
    "4779c1536b5e5170e27ec9a3d10c39ae": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCumProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\ts:      []float64{2, 3, 4, 5, 6},\n\t\t\texpect: []float64{2, 6, 24, 120, 720},\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\tdst:    make([]float64, 0),\n\t\t\ts:      []float64{},\n\t\t\texpect: []float64{},\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatched lengths\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\ts:      []float64{2, 3, 4, 5, 6},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := CumProd(tc.dst, tc.s)\n\t\t\tif !reflect.DeepEqual(result, tc.expect) {\n\t\t\t\tt.Errorf(\"CumProd() = %v, expected %v\", result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "453441fed479c6b931c95d8e6a2dc624": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.5,\n\t\t\tu:        1,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        0.5,\n\t\t\tv:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "47f60ea89af4f421e1d95c0dab96a75e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tin   []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\tin:   []float64{1, 2, 3, 4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\tin:   []float64{-5, -4, -3, -2, -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\tin:   []float64{-1, 2, -3, 4, -5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\tin:   []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"one NaN\",\n\t\t\tin:   []float64{1, math.NaN(), 3},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tin:   []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.in); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d, want %d\", tt.in, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test that MaxIdx panics on empty slice\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"MaxIdx did not panic on empty slice\")\n\t\t}\n\t}()\n\tMaxIdx([]float64{})\n}",
    "485f3f9430a5c1ee9fe363f2c8c5ca6b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"non-empty slice with unique minimum value\",\n\t\t\tinput:    []float64{3.0, 1.0, 2.0},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-empty slice with multiple minimum values\",\n\t\t\tinput:    []float64{1.0, 1.0, 2.0},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice with all NaN values\",\n\t\t\tinput:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.input == nil || len(tc.input) == 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"MinIdx did not panic for empty slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := MinIdx(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, expected %d\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "43da2b9b629e14fe67c3831d7c5be202": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"n less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, n is odd, v is not Inf\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, n is odd, v is -Inf\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, n is odd, v is +Inf\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, n is even, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are ±Inf, n is even, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v equals l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v does not equal l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v equals u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v does not equal u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        11.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        11.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 9,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "498646d911c3405408999849c323ca03": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tL     float64\n\t\twant  float64\n\t}{\n\t\t{\n\t\t\tname:  \"empty slice\",\n\t\t\ts:     []float64{},\n\t\t\tL:     2,\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"L = 1\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     1,\n\t\t\twant:  6,\n\t\t},\n\t\t{\n\t\t\tname:  \"L = 2\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     2,\n\t\t\twant:  math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname:  \"L = 3\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     3,\n\t\t\twant:  math.Pow(14, 1/3),\n\t\t},\n\t\t{\n\t\t\tname:  \"L = Inf\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     math.Inf(1),\n\t\t\twant:  3,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative L\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tL:     -1,\n\t\t\twant:  math.Pow(1+1/4+1/9, -1),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4627622097568676db1c4bb86f0f6c45": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf, n is odd, v is negative Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf, n is odd, v is positive Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, u is not\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, l is not\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is negative Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is positive Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4902acfcc99189c581fc8a8766675600": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is less than l\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is greater than u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        11.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"n is less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "45a30c5828885a89ba83eb56d93bcb68": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2 should panic\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not NaN\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both +Inf, n is odd, v is finite\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.5,\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both +Inf, n is odd, v is -Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both +Inf, n is odd, v is +Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both +Inf, n is even, v is -Inf\",\n\t\t\tn:      4,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both +Inf, n is even, v is +Inf\",\n\t\t\tn:      4,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, v == l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf, v == u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      0.5,\n\t\t\texpect: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, idx, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4b1a23c141eedc527eec4c3fbbbf89e3": "package floats_test\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{0.5, 1, 1.5},\n\t\t\twant:   []float64{0.5, 1, 1.5},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{0.5, 1},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{0.5, 1, 1.5},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.SubTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "49ba2faa968d0b16296a65774ac0301a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"n < 2\", 1, 0, 1, 0.5, 0},\n\t\t{\"NaN v\", 10, 0, 1, math.NaN(), 0},\n\t\t{\"NaN l\", 10, math.NaN(), 1, 0.5, 9},\n\t\t{\"NaN u\", 10, 0, math.NaN(), 0.5, 0},\n\t\t{\"Inf l, Inf u, odd n\", 11, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{\"Inf l, Inf u, odd n, v < 0\", 11, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{\"Inf l, Inf u, odd n, v > 0\", 11, math.Inf(-1), math.Inf(1), 1, 6},\n\t\t{\"Inf l, Inf u, even n\", 10, math.Inf(-1), math.Inf(1), 0, 5},\n\t\t{\"Inf l, Inf u, even n, v < 0\", 10, math.Inf(-1), math.Inf(1), -1, 0},\n\t\t{\"Inf l, Inf u, even n, v > 0\", 10, math.Inf(-1), math.Inf(1), 1, 5},\n\t\t{\"Inf l\", 10, math.Inf(-1), 1, 0, 0},\n\t\t{\"Inf l, v == l\", 10, math.Inf(-1), 1, math.Inf(-1), 0},\n\t\t{\"Inf u\", 10, 0, math.Inf(1), 1, 9},\n\t\t{\"Inf u, v == u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{\"Inf v, l < u\", 10, 0, 1, math.Inf(-1), 0},\n\t\t{\"Inf v, l > u\", 10, 1, 0, math.Inf(-1), 9},\n\t\t{\"Inf v, l == u\", 10, 0, 0, math.Inf(-1), 0},\n\t\t{\"Inf v, l == u\", 10, 0, 0, math.Inf(1), 0},\n\t\t{\"v <= l\", 10, 0, 1, -1, 0},\n\t\t{\"v >= u\", 10, 0, 1, 2, 9},\n\t\t{\"l < u\", 10, 0, 1, 0.5, 5},\n\t\t{\"l > u\", 10, 1, 0, 0.5, 5},\n\t\t{\"l == u\", 10, 0, 0, 0, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4e1af0d7b8ed5d716b99fd19e75c5557": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n    // Test cases\n    testCases := []struct {\n        name   string\n        dst    []float64\n        s      []float64\n        output []float64\n    }{\n        {\n            name:   \"Equal length\",\n            dst:    []float64{1, 2, 3},\n            s:      []float64{4, 5, 6},\n            output: []float64{5, 7, 9},\n        },\n        {\n            name:   \"Unequal length\",\n            dst:    []float64{1, 2},\n            s:      []float64{4, 5, 6},\n            output: nil, // Should panic\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil {\n                    if tc.output == nil {\n                        // Expected panic, test passed\n                        return\n                    }\n                    t.Errorf(\"Unexpected panic: %v\", r)\n                }\n            }()\n\n            Add(tc.dst, tc.s)\n            if !Equal(tc.dst, tc.output) {\n                t.Errorf(\"Expected %v, got %v\", tc.output, tc.dst)\n            }\n        })\n    }\n}",
    "49f1f6060a6fe1ef71ebca94b2d03f19": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both +Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both +Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4eb979ccf40b8e4948c951fe71f3192c": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\ts    []float64\n\t\tt    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"equal lengths\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{2, 3, 4},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\twant: []float64{2, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\tdst:  []float64{1, 2, 3},\n\t\t\ts:    []float64{2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"dst length different from s and t\",\n\t\t\tdst:  []float64{1, 2},\n\t\t\ts:    []float64{2, 3, 4},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\twant: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4c6cdb436525f21ceeedad76790926b9": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices, L=2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"different slices, L=1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices, L=inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1, 2},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    2,\n\t\t\twant: 0, // should panic\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"different lengths\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Distance did not panic for different lengths\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := floats.Distance(tt.s, tt.t, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tt.s, tt.t, tt.L, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4ba005c9cdfe22faa8fc506e95a25089": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        n        int\n        l        float64\n        u        float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"n < 2\",\n            n:        1,\n            l:        0,\n            u:        1,\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"NaN input\",\n            n:        10,\n            l:        0,\n            u:        10,\n            v:        math.NaN(),\n            expected: 0,\n        },\n        {\n            name:     \"l = NaN, u = finite\",\n            n:        10,\n            l:        math.NaN(),\n            u:        10,\n            v:        5,\n            expected: 9,\n        },\n        {\n            name:     \"l = NaN, u = NaN\",\n            n:        10,\n            l:        math.NaN(),\n            u:        math.NaN(),\n            v:        5,\n            expected: 0,\n        },\n        {\n            name:     \"l = +Inf, u = +Inf, v = +Inf\",\n            n:        10,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"l = +Inf, u = +Inf, v = -Inf\",\n            n:        10,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        math.Inf(-1),\n            expected: 9,\n        },\n        {\n            name:     \"l = +Inf, u = +Inf, v = 0\",\n            n:        5,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        0,\n            expected: 2,\n        },\n        {\n            name:     \"l = -Inf, u = +Inf, v = 0\",\n            n:        5,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        0,\n            expected: 2,\n        },\n        {\n            name:     \"l < u, v <= l\",\n            n:        10,\n            l:        0,\n            u:        10,\n            v:        -1,\n            expected: 0,\n        },\n        {\n            name:     \"l < u, v >= u\",\n            n:        10,\n            l:        0,\n            u:        10,\n            v:        11,\n            expected: 9,\n        },\n        {\n            name:     \"l > u, v >= l\",\n            n:        10,\n            l:        10,\n            u:        0,\n            v:        11,\n            expected: 0,\n        },\n        {\n            name:     \"l > u, v <= u\",\n            n:        10,\n            l:        10,\n            u:        0,\n            v:        -1,\n            expected: 9,\n        },\n        {\n            name:     \"normal case\",\n            n:        10,\n            l:        0,\n            u:        10,\n            v:        5,\n            expected: 5,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            idx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            if idx != tc.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n            }\n        })\n    }\n}",
    "4cbcd075e4543798c309fb6ee26e85d1": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name  string\n        n     int\n        l, u  float64\n        v     float64\n        want  int\n        panic bool\n    }{\n        {\"n < 2\", 1, 0, 1, 0, 0, true},\n        {\"NaN v\", 10, 0, 1, math.NaN(), 0, false},\n        {\"NaN l\", 10, math.NaN(), 1, 0, 9, false},\n        {\"NaN u\", 10, 0, math.NaN(), 0, 0, false},\n        {\"Inf l and u, odd n\", 5, math.Inf(-1), math.Inf(1), 0, 2, false},\n        {\"Inf l and u, even n\", 6, math.Inf(-1), math.Inf(1), 0, 3, false},\n        {\"Inf l\", 10, math.Inf(-1), 1, 0, 9, false},\n        {\"Inf u\", 10, 0, math.Inf(1), 1, 0, false},\n        {\"Inf v, l < u\", 10, 0, 1, math.Inf(-1), 0, false},\n        {\"Inf v, l > u\", 10, 1, 0, math.Inf(1), 9, false},\n        {\"v <= l\", 10, 0, 1, -1, 0, false},\n        {\"v >= u\", 10, 0, 1, 2, 9, false},\n        {\"l < u, v in range\", 10, 0, 1, 0.5, 5, false},\n        {\"l > u, v in range\", 10, 1, 0, 0.5, 5, false},\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            defer func() {\n                r := recover()\n                if (r != nil) != tc.panic {\n                    t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tc.n, tc.l, tc.u, tc.v, r)\n                }\n            }()\n\n            got := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            if got != tc.want {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n            }\n        })\n    }\n}",
    "513e0f7a072d293d0d8efdd905153883": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tdst := make([]float64, len(s))\n\t\texpected := []float64{-3, -3, -3}\n\n\t\tresult := SubTo(dst, s, t)\n\n\t\tassert.Equal(t, expected, result)\n\t\tassert.Equal(t, expected, dst)\n\t})\n\n\tt.Run(\"different length slices\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5}\n\t\tdst := make([]float64, len(s))\n\n\t\tassert.Panics(t, func() {\n\t\t\tSubTo(dst, s, t)\n\t\t})\n\t})\n}",
    "5100393d9c20179d1f466df07560df26": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n    // Test case 1: Slices of equal length\n    dst1 := []float64{1.0, 2.0, 3.0}\n    s1 := []float64{4.0, 5.0, 6.0}\n    alpha1 := 2.0\n    expected1 := []float64{9.0, 12.0, 15.0}\n    AddScaled(dst1, alpha1, s1)\n    if !Equal(dst1, expected1) {\n        t.Errorf(\"TestAddScaled: expected %v, got %v\", expected1, dst1)\n    }\n\n    // Test case 2: Slices of unequal length\n    dst2 := []float64{1.0, 2.0, 3.0}\n    s2 := []float64{4.0, 5.0}\n    alpha2 := 2.0\n    func() {\n        defer func() {\n            if r := recover(); r == nil {\n                t.Errorf(\"TestAddScaled: expected panic for unequal slice lengths\")\n            }\n        }()\n        AddScaled(dst2, alpha2, s2)\n    }()\n}",
    "50bf89e11cdfc6a5f67944e93b69ded7": "// floats_test.go\n\npackage floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"find all matching elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{1, -2, 3, 4, -5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{0, 2, 3},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first k matching elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{1, -2, 3, 4, -5},\n\t\t\tk:        2,\n\t\t\texpected: []int{0, 2},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no matching elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x < 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      errors.New(\"floats: insufficient elements found\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"find one matching element\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 2, -3, 4, -5},\n\t\t\tk:        1,\n\t\t\texpected: []int{1},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no elements with k = 0\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif err != tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: got %v, want %v\", err, tc.err)\n\t\t\t}\n\t\t\tif !Equal(inds, tc.expected) {\n\t\t\t\tt.Errorf(\"unexpected result: got %v, want %v\", inds, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51de97e964a1fffb9b422eb59da5400d": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twanted []float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3, 4},\n\t\t\ts:      []float64{2, 4, 6, 8},\n\t\t\twanted: []float64{0.5, 0.5, 0.5, 0.5},\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 4, 6, 8},\n\t\t\twanted: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.wanted == nil {\n\t\t\t\t\t\t// Expected panic\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Div(%v, %v) panicked: %v\", test.dst, test.s, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tDiv(test.dst, test.s)\n\t\t\tif !reflect.DeepEqual(test.dst, test.wanted) {\n\t\t\t\tt.Errorf(\"Div(%v, %v) = %v, wanted %v\", test.dst, test.s, test.dst, test.wanted)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4a76c915a614c1a32e928870371d7c11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"n < 2\",\n\t\t\tn:     1,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is NaN\",\n\t\t\tn:     5,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN, u is not NaN\",\n\t\t\tn:     5,\n\t\t\tl:     math.NaN(),\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  4,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tn:     5,\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +Inf\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +Inf, n is odd, v is not Inf\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0.5,\n\t\t\twant:  1,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +Inf, n is odd, v is -Inf\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +Inf, n is odd, v is +Inf\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  3,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is +Inf, v == l\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is +Inf, v == u\",\n\t\t\tn:     5,\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  4,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is -Inf, l < u\",\n\t\t\tn:     5,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is +Inf, l < u\",\n\t\t\tn:     5,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  4,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is -Inf, l > u\",\n\t\t\tn:     5,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  4,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is +Inf, l > u\",\n\t\t\tn:     5,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is within (l, u)\",\n\t\t\tn:     5,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  2,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is within (u, l)\",\n\t\t\tn:     5,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     0.5,\n\t\t\twant:  2,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "4ee2b8620a8d952f91ac91175e990d11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"invalid n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %.2f, %.2f, %.2f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "50a644966ebeb9b5f9f075ffe29701a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\tt.Errorf(\"Span() = %v, expected %v\", result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51f37ea8b340d88b86dd6365594f823f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.40176,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.40176,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 2.31326,\n\t\t},\n\t\t{\n\t\t\tname: \"all zeros\",\n\t\t\ts:    []float64{0.0, 0.0, 0.0},\n\t\t\twant: math.Log(3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"one value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinity\",\n\t\t\ts:    []float64{math.Inf(1), 1.0, 2.0},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\ts:    []float64{math.Inf(-1), 1.0, 2.0},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif math.Abs(got-tt.want) > 1e-5 {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51e62d3003c1cef2b289488bb49642bc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"n less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        11.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        11.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 9,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "535e683dd7462e2c87fae6b37215e513": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts, t     []float64\n\t\tL        float64\n\t\texpected float64\n\t\twantsPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"equal slices, L = 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"equal slices, L = 2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"equal slices, L = inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"different slices, L = 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"different slices, L = 2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"different slices, L = inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"mismatched lengths\",\n\t\t\ts:          []float64{1, 2, 3},\n\t\t\tt:          []float64{4, 5},\n\t\t\tL:          1,\n\t\t\twantsPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantsPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %.2f) did not panic\", tc.s, tc.t, tc.L)\n\t\t\t\t} else if !tc.wantsPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %.2f) panicked: %v\", tc.s, tc.t, tc.L, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %.2f) = %.2f, want %.2f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "51e6755e7f508768bca93b584325caa1": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-organization/your-project/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"less than two elements\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 8,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, odd n\",\n\t\t\tn:        9,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := floats.NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "557c377cf77cfee5862a9c9ac824624d": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n    testCases := []struct {\n        name string\n        s    []float64\n        want float64\n    }{\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            want: 0,\n        },\n        {\n            name: \"single element\",\n            s:    []float64{1.0},\n            want: 1.0,\n        },\n        {\n            name: \"multiple elements\",\n            s:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            want: 15.0,\n        },\n        {\n            name: \"with very small numbers\",\n            s:    []float64{1e-20, 1e-20, 1e-20, 1e-20, 1e-20},\n            want: 5e-20,\n        },\n        {\n            name: \"with very large numbers\",\n            s:    []float64{1e20, 1e20, 1e20, 1e20, 1e20},\n            want: 5e20,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := SumCompensated(tc.s)\n            if math.Abs(got-tc.want) > 1e-14 {\n                t.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n            }\n        })\n    }\n}",
    "58c241954b2664727c41d7721efab838": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{5, 7, 9},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Mismatched lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Add() did not panic\")\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Add() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(tc.dst))\n\t\t\tcopy(dst, tc.dst)\n\t\t\tAdd(dst, tc.s)\n\n\t\t\tif !reflect.DeepEqual(dst, tc.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "54cf5f7fc12931717650aaf61a9e1990": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        n        int\n        l, u, v  float64\n        expected int\n    }{\n        {\"n less than 2\", 1, 0, 1, 0.5, 0},\n        {\"v is NaN\", 10, 0, 10, math.NaN(), 0},\n        {\"l is NaN, u is not\", 10, math.NaN(), 10, 5, 9},\n        {\"u is NaN\", 10, 0, math.NaN(), 5, 0},\n        {\"l and u are ±Inf, v is ±Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n        {\"l and u are ±Inf, v is ±Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n        {\"l and u are ±Inf, v is ±Inf, n is odd\", 5, math.Inf(-1), math.Inf(1), 0, 2},\n        {\"l and u are ±Inf, v is ±Inf, n is odd\", 5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n        {\"l is +Inf, v == l\", 10, math.Inf(1), 10, math.Inf(1), 0},\n        {\"l is +Inf, v != l\", 10, math.Inf(1), 10, 5, 9},\n        {\"u is +Inf, v == u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n        {\"u is +Inf, v != u\", 10, 0, math.Inf(1), 5, 0},\n        {\"v is -Inf, l < u\", 10, 0, 10, math.Inf(-1), 0},\n        {\"v is -Inf, l > u\", 10, 10, 0, math.Inf(-1), 9},\n        {\"v is +Inf, l < u\", 10, 0, 10, math.Inf(1), 9},\n        {\"v is +Inf, l > u\", 10, 10, 0, math.Inf(1), 0},\n        {\"v is inside [l, u]\", 10, 0, 10, 5, 5},\n        {\"v is outside [l, u]\", 10, 0, 10, -1, 0},\n        {\"v is outside [u, l]\", 10, 10, 0, 11, 9},\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            if got != tc.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n            }\n        })\n    }\n}",
    "5510c4a37a65894d6414bbbb693794cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"n less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\tv:        5.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf and of the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf and of opposite signs\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "553492048d9a895e0c7a6480f8a52aa9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty dst\",\n\t\t\tdst:      []float64{},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      []float64{0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"two element dst\",\n\t\t\tdst:      []float64{0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"three element dst\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      []float64{0, 0, 0, 0},\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      []float64{0, 0, 0},\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && !tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %g, %g) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "596038e104a8cfd0669b4e0ae9d834d2": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"find first k elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find all elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) error = %v, expected error = %v\", tc.inds, tc.f, tc.s, tc.k, err, tc.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(inds, tc.expected) {\n\t\t\t\tt.Errorf(\"Find(%v, %v, %v, %v) = %v, expected %v\", tc.inds, tc.f, tc.s, tc.k, inds, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "566741d6f8a87aed21ab7e8ff5149d73": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is outside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is outside (u, l)\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (l, u)\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "585b7ac09a3b8d7ae48ddfa3fb2ed341": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname: \"regular case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"l = NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u = NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l = +Inf, u = -Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l = +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u = +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:      \"dst length < 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantPanic = %v\", r, tc.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5cab14684e3236374aff22310a463d29": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0, 2.0, 1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5a067b714f12586ffcf7e6ed3a76e094": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n    tests := []struct {\n        name string\n        in   []float64\n        want int\n    }{\n        {\n            name: \"empty slice\",\n            in:   []float64{},\n            want: 0, // should panic\n        },\n        {\n            name: \"single element slice\",\n            in:   []float64{42},\n            want: 0,\n        },\n        {\n            name: \"multiple elements, no NaN\",\n            in:   []float64{5, 2, 7, 1, 9},\n            want: 3,\n        },\n        {\n            name: \"multiple elements, with NaN\",\n            in:   []float64{5, 2, math.NaN(), 1, 9},\n            want: 1,\n        },\n        {\n            name: \"multiple elements, all NaN\",\n            in:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n            want: 0, // should panic\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if len(tt.in) == 0 {\n                defer func() {\n                    if r := recover(); r == nil {\n                        t.Errorf(\"MinIdx() did not panic on empty slice\")\n                    }\n                }()\n            }\n\n            got := MinIdx(tt.in)\n            if got != tt.want {\n                t.Errorf(\"MinIdx(%v) = %d, want %d\", tt.in, got, tt.want)\n            }\n        })\n    }\n}",
    "59cfb0df3d116931d8ef233f5c4d4ba1": "package floats\n\nimport (\n    \"math\"\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    tests := []struct {\n        name   string\n        dst    []float64\n        l      float64\n        u      float64\n        want   []float64\n        wantPanic bool\n    }{\n        {\n            name:   \"basic case\",\n            dst:    make([]float64, 5),\n            l:      0.0,\n            u:      10.0,\n            want:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n            wantPanic: false,\n        },\n        {\n            name:   \"dst length < 2\",\n            dst:    make([]float64, 1),\n            l:      0.0,\n            u:      10.0,\n            wantPanic: true,\n        },\n        {\n            name:   \"l is NaN\",\n            dst:    make([]float64, 5),\n            l:      math.NaN(),\n            u:      10.0,\n            want:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n            wantPanic: false,\n        },\n        {\n            name:   \"u is NaN\",\n            dst:    make([]float64, 5),\n            l:      0.0,\n            u:      math.NaN(),\n            want:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n            wantPanic: false,\n        },\n        {\n            name:   \"l and u are Inf\",\n            dst:    make([]float64, 5),\n            l:      math.Inf(1),\n            u:      math.Inf(1),\n            want:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n            wantPanic: false,\n        },\n        {\n            name:   \"l is Inf\",\n            dst:    make([]float64, 5),\n            l:      math.Inf(1),\n            u:      10.0,\n            want:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n            wantPanic: false,\n        },\n        {\n            name:   \"u is Inf\",\n            dst:    make([]float64, 5),\n            l:      0.0,\n            u:      math.Inf(1),\n            want:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n            wantPanic: false,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            defer func() {\n                r := recover()\n                if (r != nil) != tt.wantPanic {\n                    t.Errorf(\"Span() panicked: %v\", r)\n                }\n            }()\n\n            got := Span(tt.dst, tt.l, tt.u)\n            if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Span() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "5cfd5efc057e14d6f915e2f0e3a7a4e1": "package floats\n\nimport \"testing\"\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts1   []float64\n\t\ts2   []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal lengths\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal elements\",\n\t\t\ts1:   []float64{1.0, 2.0, 3.0},\n\t\t\ts2:   []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\ts1:   []float64{},\n\t\t\ts2:   []float64{},\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.s1, tt.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v, want %v\", tt.s1, tt.s2, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5db0ca7cc9e199b358e4086356bd249f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L > 0\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "59e9807e410b3b1e42476d1626350de1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl, u float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"single element dst\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"panic for short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0, 10)\n\t})\n}",
    "5aa15949cd7c6551c734080cf1d8b245": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\tpanics   bool\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\tpanics:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Single-element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\tpanics:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\tpanics:   true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value less than minimum\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value greater than or equal to maximum\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t\tpanics:   false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Value found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t\tpanics:   false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Within(tc.s, tc.v)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5e5b494cf15f876e881c448b70eb2381": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"same length\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twant:   []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname:   \"different length\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3, 4},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length mismatch\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"SubTo() panic = %v, wantPanic %v\", r, tc.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := SubTo(tc.dst, tc.s, tc.t)\n\t\t\tif !reflect.DeepEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "619b5b88adc14dd5e12b4896a2e60292": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\targs: []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: []float64{-1.0, -2.0, -3.0, -2.0, -1.0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\targs: []float64{-1.0, 2.0, -3.0, 2.0, 1.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\targs: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65a07e02fcce872028436f8a915909a7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\texpIdx int\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      1.0,\n\t\t\texpIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.NaN(),\n\t\t\texpIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"positive infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(1),\n\t\t\texpIdx: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"negative infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(-1),\n\t\t\texpIdx: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"nearest value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      2.5,\n\t\t\texpIdx: 1,\n\t\t},\n\t\t{\n\t\t\tname:   \"nearest value with duplicates\",\n\t\t\ts:      []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\tv:      2.0,\n\t\t\texpIdx: 1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := NearestIdx(test.s, test.v)\n\t\t\tif idx != test.expIdx {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", test.s, test.v, idx, test.expIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5ec0328f90a34d616e3b204f7b27312c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tn       int\n\t\tl       float64\n\t\tu       float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"n < 2\",\n\t\t\tn:       1,\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\tv:       5,\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is NaN\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\tv:       math.NaN(),\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is NaN, u is not NaN\",\n\t\t\tn:       10,\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10,\n\t\t\tv:       5,\n\t\t\twant:    9,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is NaN\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\tv:       5,\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l and u are both Inf with same sign\",\n\t\t\tn:       5,\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       0,\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:       5,\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       0,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:       6,\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       0,\n\t\t\twant:    3,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is Inf, v == l\",\n\t\t\tn:       10,\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       10,\n\t\t\tv:       math.Inf(-1),\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is Inf, v == u\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(1),\n\t\t\tv:       math.Inf(1),\n\t\t\twant:    9,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is -Inf, l < u\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\tv:       math.Inf(-1),\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is +Inf, l > u\",\n\t\t\tn:       10,\n\t\t\tl:       10,\n\t\t\tu:       0,\n\t\t\tv:       math.Inf(1),\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is within (l, u)\",\n\t\t\tn:       10,\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\tv:       5,\n\t\t\twant:    5,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is within (u, l)\",\n\t\t\tn:       10,\n\t\t\tl:       10,\n\t\t\tu:       0,\n\t\t\tv:       5,\n\t\t\twant:    5,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "61372161edf3c9defd238b1135cd48bc": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        dst      []float64\n        l        float64\n        u        float64\n        expected []float64\n    }{\n        {\n            name:     \"basic case\",\n            dst:      make([]float64, 5),\n            l:        1.0,\n            u:        5.0,\n            expected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n        },\n        {\n            name:     \"with negative values\",\n            dst:      make([]float64, 3),\n            l:        -2.0,\n            u:        2.0,\n            expected: []float64{-2.0, 0.0, 2.0},\n        },\n        {\n            name:     \"with NaN l\",\n            dst:      make([]float64, 3),\n            l:        math.NaN(),\n            u:        5.0,\n            expected: []float64{math.NaN(), math.NaN(), 5.0},\n        },\n        {\n            name:     \"with NaN u\",\n            dst:      make([]float64, 3),\n            l:        1.0,\n            u:        math.NaN(),\n            expected: []float64{1.0, math.NaN(), math.NaN()},\n        },\n        {\n            name:     \"with Inf l and u\",\n            dst:      make([]float64, 5),\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            expected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n        },\n        {\n            name:     \"with Inf l\",\n            dst:      make([]float64, 3),\n            l:        math.Inf(-1),\n            u:        5.0,\n            expected: []float64{math.Inf(-1), math.Inf(-1), 5.0},\n        },\n        {\n            name:     \"with Inf u\",\n            dst:      make([]float64, 3),\n            l:        1.0,\n            u:        math.Inf(1),\n            expected: []float64{1.0, math.Inf(1), math.Inf(1)},\n        },\n        {\n            name:     \"with dst length < 2\",\n            dst:      make([]float64, 1),\n            l:        1.0,\n            u:        5.0,\n            expected: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            if tc.expected == nil {\n                defer func() {\n                    if r := recover(); r == nil {\n                        t.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n                    }\n                }()\n                Span(tc.dst, tc.l, tc.u)\n            } else {\n                result := Span(tc.dst, tc.l, tc.u)\n                if !Equal(result, tc.expected) {\n                    t.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n                }\n            }\n        })\n    }\n}",
    "63eb0a38dfc2724cfeb1f978ccfde92a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf, v is Inf, n is even\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf, v is Inf, n is odd\",\n\t\t\tn:        9,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "63fa0b8a84228ec317cfed7688363a0a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"happy path\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length < 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "67dd6295b47259e6fb279f0555c34da2": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}, {7.0, 8.0, 9.0, 10.0}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"no input slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6413829de65ffe830657a47656e35ce0": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/gonum/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := floats.NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "662f2e407358b89be4281a5a18880939": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal slices (L=2)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal slices (L=2)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(9 + 9 + 9),\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices (L=2)\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Equal slices (L=1)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal slices (L=1)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"Equal slices (L=Inf)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal slices (L=Inf)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"Mixed slices (L=2.5)\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2.5,\n\t\t\texpect: math.Pow(9+9+9, 1/2.5),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", tc.s, tc.t, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic when slices have different lengths\n\tt.Run(\"Panic on different lengths\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Distance did not panic when slices had different lengths\")\n\t\t\t}\n\t\t}()\n\t\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n\t})\n}",
    "68474e5a72e61670a6cb46b5ac1305bf": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{3.14},\n\t\t\twant: 3.14,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{2.0, 3.0, 4.0},\n\t\t\twant: 24.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with zero\",\n\t\t\ts:    []float64{2.0, 0.0, 4.0},\n\t\t\twant: 0.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Prod(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "656d8243e7ab61dd1b5d5d4c0a1c2a51": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\tl, u       float64\n\t\twantDst    []float64\n\t\twantPanic  bool\n\t\tdescription string\n\t}{\n\t\t{\n\t\t\tname:       \"basic\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\twantDst:    []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with length 5, starting at 0, ending at 10\",\n\t\t},\n\t\t{\n\t\t\tname:       \"length 2\",\n\t\t\tdst:        make([]float64, 2),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\twantDst:    []float64{0.0, 10.0},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with length 2, starting at 0, ending at 10\",\n\t\t},\n\t\t{\n\t\t\tname:       \"length 1\",\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\twantPanic:  true,\n\t\t\tdescription: \"Span with length 1, should panic\",\n\t\t},\n\t\t{\n\t\t\tname:       \"l is NaN\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.NaN(),\n\t\t\tu:          10.0,\n\t\t\twantDst:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with l being NaN\",\n\t\t},\n\t\t{\n\t\t\tname:       \"u is NaN\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0.0,\n\t\t\tu:          math.NaN(),\n\t\t\twantDst:    []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with u being NaN\",\n\t\t},\n\t\t{\n\t\t\tname:       \"l and u are both Inf\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.Inf(1),\n\t\t\tu:          math.Inf(1),\n\t\t\twantDst:    []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with l and u being both positive Inf\",\n\t\t},\n\t\t{\n\t\t\tname:       \"l is Inf, u is finite\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          math.Inf(1),\n\t\t\tu:          10.0,\n\t\t\twantDst:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with l being positive Inf and u being finite\",\n\t\t},\n\t\t{\n\t\t\tname:       \"l is finite, u is Inf\",\n\t\t\tdst:        make([]float64, 5),\n\t\t\tl:          0.0,\n\t\t\tu:          math.Inf(1),\n\t\t\twantDst:    []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t\twantPanic:  false,\n\t\t\tdescription: \"Span with l being finite and u being positive Inf\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantPanic = %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgotDst := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(gotDst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", gotDst, tt.wantDst)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6614f0f640bed3219f6edca88d44dd37": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2 panics\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with same sign\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:        12,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        -1.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -1.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        -1.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        -1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        -1.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        -1.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68899a430ddf4f6f239e756b66bbbffb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tt:      []float64{1.0, 2.0, 3.0},\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tt:      []float64{1.0, 2.0},\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different values\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tt:      []float64{1.0, 2.0, 4.0},\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN values\",\n\t\t\ts:      []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:      []float64{1.0, math.NaN(), 3.0},\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"mix of NaN and non-NaN values\",\n\t\t\ts:      []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:      []float64{1.0, 2.0, 3.0},\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif Same(tc.s, tc.t) != tc.expect {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, expected %v\", tc.s, tc.t, Same(tc.s, tc.t), tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "65fd8ad4512dfef4102fe3bfb9270a4f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative bounds\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -5.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{-5.0, -2.5, 0.0, 2.5, 5.0},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Destination length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Lower bound is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Upper bound is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Both bounds are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Lower bound is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Upper bound is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t\tif (len(got) < 2) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Span() error = %v, wantErr %v\", len(got) < 2, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}",
    "68e0afb435fbddde65eef21993523abe": "package floats\n\nimport (\n    \"math\"\n    \"sort\"\n    \"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n    t.Run(\"valid input\", func(t *testing.T) {\n        s := []float64{0.0, 1.0, 2.0, 3.0, 4.0}\n        testCases := []struct {\n            name string\n            v    float64\n            want int\n        }{\n            {\"value less than first element\", -1.0, -1},\n            {\"value greater than or equal to last element\", 4.0, -1},\n            {\"value NaN\", math.NaN(), -1},\n            {\"value within range\", 2.5, 2},\n        }\n        for _, tc := range testCases {\n            t.Run(tc.name, func(t *testing.T) {\n                got := Within(s, tc.v)\n                if got != tc.want {\n                    t.Errorf(\"Within(%v, %v) = %v, want %v\", s, tc.v, got, tc.want)\n                }\n            })\n        }\n    })\n\n    t.Run(\"invalid input\", func(t *testing.T) {\n        t.Run(\"len(s) < 2\", func(t *testing.T) {\n            s := []float64{0.0}\n            defer func() {\n                if r := recover(); r == nil {\n                    t.Errorf(\"Within(%v, 0.5) did not panic\", s)\n                }\n            }()\n            Within(s, 0.5)\n        })\n\n        t.Run(\"s not sorted\", func(t *testing.T) {\n            s := []float64{2.0, 1.0, 3.0}\n            defer func() {\n                if r := recover(); r == nil {\n                    t.Errorf(\"Within(%v, 1.5) did not panic\", s)\n                }\n            }()\n            Within(s, 1.5)\n        })\n    })\n}",
    "66d292c1ce226e5c8864cc13fe05bc21": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"panics with n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = NaN, u = finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = finite, u = NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = Inf, n odd, v = finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = Inf, n odd, v = -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = Inf, n odd, v = Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = finite, u = Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6930d616072f2ca90b31519426117788": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: []float64{},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.407605811330171,\n\t\t},\n\t\t{\n\t\t\tname: \"large values\",\n\t\t\targs: []float64{1000.0, 1001.0, 1002.0},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"small values\",\n\t\t\targs: []float64{-1000.0, -1001.0, -1002.0},\n\t\t\twant: -1000.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\targs: []float64{-1000.0, 1000.0, -1001.0, 1001.0, -1002.0, 1002.0},\n\t\t\twant: 1002.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "690866bf0f92f2e1f2a6c438c10bc8eb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"short span\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN, l is finite\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- inf, v is 0\",\n\t\t\tn:        5,\n\t\t\tl:        -math.Inf,\n\t\t\tu:        math.Inf,\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- inf, v is +inf\",\n\t\t\tn:        5,\n\t\t\tl:        -math.Inf,\n\t\t\tu:        math.Inf,\n\t\t\tv:        math.Inf,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- inf, v is -inf\",\n\t\t\tn:        5,\n\t\t\tl:        -math.Inf,\n\t\t\tu:        math.Inf,\n\t\t\tv:        -math.Inf,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is less than l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is greater than u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        1.5,\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is greater than l\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is less than u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        -0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6bfc7b9f97ba65b7653d66b1e69f0b80": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n    type testCase struct {\n        name   string\n        s1     []float64\n        s2     []float64\n        f      func(float64, float64) bool\n        expect bool\n    }\n\n    testCases := []testCase{\n        {\n            name:   \"equal slices\",\n            s1:     []float64{1.0, 2.0, 3.0},\n            s2:     []float64{1.0, 2.0, 3.0},\n            f:      func(a, b float64) bool { return a == b },\n            expect: true,\n        },\n        {\n            name:   \"different lengths\",\n            s1:     []float64{1.0, 2.0, 3.0},\n            s2:     []float64{1.0, 2.0},\n            f:      func(a, b float64) bool { return a == b },\n            expect: false,\n        },\n        {\n            name:   \"different elements\",\n            s1:     []float64{1.0, 2.0, 3.0},\n            s2:     []float64{1.0, 3.0, 2.0},\n            f:      func(a, b float64) bool { return a == b },\n            expect: false,\n        },\n        {\n            name:   \"approximate equality\",\n            s1:     []float64{1.0, 2.0, 3.0},\n            s2:     []float64{1.001, 2.001, 3.001},\n            f:      func(a, b float64) bool { return a-b < 0.01 },\n            expect: true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            actual := EqualFunc(tc.s1, tc.s2, tc.f)\n            if actual != tc.expect {\n                t.Errorf(\"EqualFunc(%v, %v, %v) = %v, want %v\", tc.s1, tc.s2, tc.f, actual, tc.expect)\n            }\n        })\n    }\n}",
    "6aede9c09c69006b852dd6e16ffad905": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 3),\n\t\t\tl:        -2.0,\n\t\t\tu:        2.0,\n\t\t\texpected: []float64{-2.0, 0.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        0.0,\n\t\t\texpected: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 7),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1.0, _, _, _, _},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !Equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d21515f8125323eb177cf800f931b07": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6c7c9566e0529939e343a754e38af8a8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"basic\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\texpect: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 3),\n\t\t\tl:      -10,\n\t\t\tu:      0,\n\t\t\texpect: []float64{-10, -5, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN start\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN end\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\texpect: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf start\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf end\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf both\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{math.Inf(-1), -math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"short dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expect, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "69897caeb65fe72f7aa78c474973b3a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2 should panic\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN, should return 0\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN, should return n-1\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN, should return 0\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd, v is finite, should return n/2\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd, v is -Inf, should return 0\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is odd, v is +Inf, should return n/2+1\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even, v is -Inf, should return 0\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even, v is +Inf, should return n/2\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite, v is l, should return n-1\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v is u, should return n-1\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u, should return 0\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l < u, should return n-1\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l > u, should return n-1\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u, should return 0\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6f8f0cf089b9296b93c93e650fdcf0f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Nearest value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Nearest value with multiple occurrences\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 4.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6deba74db0b90460246258ff700fb465": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative range\",\n\t\t\tdst:  make([]float64, 3),\n\t\t\tl:    -10.0,\n\t\t\tu:    0.0,\n\t\t\twant: []float64{-10.0, -5.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"equal endpoints\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    5.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{5.0, 5.0, 5.0, 5.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"length less than 2\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are +/- Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is -Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6af629ddd937cab703589d0bb7a8abe6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l, finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n, v Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        1,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v Inf, l == u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v < l\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        2,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        2,\n\t\t\tv:        3,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        2,\n\t\t\tv:        1.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        5,\n\t\t\tl:        2,\n\t\t\tu:        1,\n\t\t\tv:        1.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "6d06d0759e4be25c7b630ad5ceb5bc13": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        n        int\n        l        float64\n        u        float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"n < 2\",\n            n:        1,\n            l:        0,\n            u:        1,\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"NaN input value\",\n            n:        5,\n            l:        0,\n            u:        10,\n            v:        math.NaN(),\n            expected: 0,\n        },\n        {\n            name:     \"l is NaN, u is not NaN\",\n            n:        5,\n            l:        math.NaN(),\n            u:        10,\n            v:        5,\n            expected: 4,\n        },\n        {\n            name:     \"u is NaN\",\n            n:        5,\n            l:        0,\n            u:        math.NaN(),\n            v:        5,\n            expected: 0,\n        },\n        {\n            name:     \"l and u are both Inf with same sign\",\n            n:        5,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        0,\n            expected: 0,\n        },\n        {\n            name:     \"l and u are both Inf with opposite signs, n is odd\",\n            n:        5,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        0,\n            expected: 2,\n        },\n        {\n            name:     \"l and u are both Inf with opposite signs, n is even\",\n            n:        4,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        0,\n            expected: 2,\n        },\n        {\n            name:     \"l is Inf, v is equal to l\",\n            n:        5,\n            l:        math.Inf(-1),\n            u:        10,\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"u is Inf, v is equal to u\",\n            n:        5,\n            l:        0,\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 4,\n        },\n        {\n            name:     \"v is -Inf, l < u\",\n            n:        5,\n            l:        0,\n            u:        10,\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"v is +Inf, l > u\",\n            n:        5,\n            l:        10,\n            u:        0,\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"v is within (l, u), l < u\",\n            n:        5,\n            l:        0,\n            u:        10,\n            v:        5,\n            expected: 2,\n        },\n        {\n            name:     \"v is within (u, l), l > u\",\n            n:        5,\n            l:        10,\n            u:        0,\n            v:        5,\n            expected: 2,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            idx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            if idx != tc.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n            }\n        })\n    }\n}",
    "6f60e11c27d167cc98a6c777b2ed309f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v = l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v = u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is negative Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is positive Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "72080191d1a0f6a037ea1ba79b729034": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal length slices\",\n\t\t\ts1:       []float64{1, 2, 3},\n\t\t\ts2:       []float64{4, 5, 6},\n\t\t\texpected: 32,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal length slices\",\n\t\t\ts1:       []float64{1, 2},\n\t\t\ts2:       []float64{4, 5, 6},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Dot(tc.s1, tc.s2)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Dot(%v, %v) = %v, want %v\", tc.s1, tc.s2, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "719fbaed10eb9f84af07d905fd6dc8b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive elements\",\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 15,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\ts:    []float64{-1, -2, -3, -4, -5},\n\t\t\twant: -15,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed elements\",\n\t\t\ts:    []float64{1, -2, 3, -4, 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"large slice\",\n\t\t\ts:    []float64{1e300, 1e-300, 1e300, 1e-300},\n\t\t\twant: 2e300,\n\t\t},\n\t\t{\n\t\t\tname: \"large positive and negative values\",\n\t\t\ts:    []float64{1e300, -1e300, 1e300, -1e300},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif !floatEqual(got, tc.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.IsNaN(a) && math.IsNaN(b) || math.Abs(a-b) < 1e-14\n}",
    "705779804a0d6e416d989d33e5d71d2c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "70ef5cf162ccbbbeaffa61109d9d5327": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\"n < 2\", 1, 0.0, 1.0, 0.5, 0},\n\t\t{\"v is NaN\", 10, 0.0, 1.0, math.NaN(), 0},\n\t\t{\"l is NaN, u is not\", 10, math.NaN(), 1.0, 0.5, 9},\n\t\t{\"u is NaN\", 10, 0.0, math.NaN(), 0.5, 0},\n\t\t{\"l and u are both Inf, n is odd\", 5, math.Inf(-1), math.Inf(1), 0.0, 2},\n\t\t{\"l and u are both Inf, n is odd, v is Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{\"l and u are both Inf, n is odd, v is -Inf\", 5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"l and u are both Inf, n is even\", 4, math.Inf(-1), math.Inf(1), 0.0, 2},\n\t\t{\"l is Inf, v == l\", 10, math.Inf(-1), 1.0, math.Inf(-1), 0},\n\t\t{\"u is Inf, v == u\", 10, 0.0, math.Inf(1), math.Inf(1), 8},\n\t\t{\"v is -Inf, l < u\", 10, 0.0, 1.0, math.Inf(-1), 0},\n\t\t{\"v is -Inf, l > u\", 10, 1.0, 0.0, math.Inf(-1), 9},\n\t\t{\"v is +Inf, l < u\", 10, 0.0, 1.0, math.Inf(1), 9},\n\t\t{\"v is +Inf, l > u\", 10, 1.0, 0.0, math.Inf(1), 0},\n\t\t{\"v is in range\", 10, 0.0, 1.0, 0.5, 5},\n\t\t{\"v is in range, l > u\", 10, 1.0, 0.0, 0.5, 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7342be149dca4d93bbc1c7058fc4b165": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN()},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := floats.Same(tt.s, tt.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "74b6c2682cd0091c2b1d38011061c6ec": "package floats\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/gonum/floats\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\tt.Run(\"happy path\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tdst := make([]float64, 3)\n\n\t\tresult := AddTo(dst, s, t)\n\n\t\tif !floats.Equal(result, []float64{5, 7, 9}) {\n\t\t\tt.Errorf(\"expected [5, 7, 9], got %v\", result)\n\t\t}\n\t})\n\n\tt.Run(\"different lengths\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5}\n\t\tdst := make([]float64, 3)\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic, got none\")\n\t\t\t}\n\t\t}()\n\n\t\tAddTo(dst, s, t)\n\t})\n\n\tt.Run(\"bad dst length\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tdst := make([]float64, 2)\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic, got none\")\n\t\t\t}\n\t\t}()\n\n\t\tAddTo(dst, s, t)\n\t})\n}",
    "7531e22078872885620137b8f10e36fa": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\t// Test case: Equal length slices\n\tdst := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\tt := []float64{7, 8, 9}\n\texpected := []float64{11, 15, 19}\n\tresult := AddTo(dst, s, t)\n\tif !Equal(result, expected) {\n\t\tt.Errorf(\"AddTo() = %v, want %v\", result, expected)\n\t}\n\n\t// Test case: Unequal length slices\n\tdst = []float64{1, 2, 3}\n\ts = []float64{4, 5}\n\tt = []float64{7, 8, 9}\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddTo() did not panic with unequal length slices\")\n\t\t\t}\n\t\t}()\n\t\tAddTo(dst, s, t)\n\t}()\n\n\t// Test case: Unequal dst and s/t lengths\n\tdst = []float64{1, 2}\n\ts = []float64{4, 5, 6}\n\tt = []float64{7, 8, 9}\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddTo() did not panic with unequal dst and s/t lengths\")\n\t\t\t}\n\t\t}()\n\t\tAddTo(dst, s, t)\n\t}()\n}",
    "764003bc0b16664630dab25d0a7361f9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\tt.Run(\"valid input\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5, 6}\n\t\tL := 2.0\n\n\t\tdistance := Distance(s, t, L)\n\t\texpected := math.Sqrt(9 + 9 + 9)\n\t\tif distance != expected {\n\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", s, t, L, distance, expected)\n\t\t}\n\t})\n\n\tt.Run(\"empty slice\", func(t *testing.T) {\n\t\ts := []float64{}\n\t\tt := []float64{}\n\t\tL := 2.0\n\n\t\tdistance := Distance(s, t, L)\n\t\tif distance != 0 {\n\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want 0\", s, t, L, distance)\n\t\t}\n\t})\n\n\tt.Run(\"different lengths\", func(t *testing.T) {\n\t\ts := []float64{1, 2, 3}\n\t\tt := []float64{4, 5}\n\t\tL := 2.0\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) did not panic\", s, t, L)\n\t\t\t}\n\t\t}()\n\t\t_ = Distance(s, t, L)\n\t})\n}",
    "742c3a0e60b52275548045f9937128ed": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"sorted input\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1, 2, 3, 4, 5},\n\t\t\t\tinds: make([]int, 5),\n\t\t\t},\n\t\t\twant: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted input\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{5, 2, 4, 1, 3},\n\t\t\t\tinds: make([]int, 5),\n\t\t\t},\n\t\t\twant: []int{3, 1, 4, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate values\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1, 2, 2, 3, 3},\n\t\t\t\tinds: make([]int, 5),\n\t\t\t},\n\t\t\twant: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"empty input\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: make([]int, 0),\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"mismatched lengths\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1, 2, 3},\n\t\t\t\tinds: make([]int, 4),\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsortStable(tt.args.dst, tt.args.inds)\n\t\t\tif !reflect.DeepEqual(tt.args.inds, tt.want) {\n\t\t\t\tt.Errorf(\"ArgsortStable() = %v, want %v\", tt.args.inds, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "731ef9c1650a0835b8d91c3e5645ea3d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"valid input\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:    \"dst length less than 2\",\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0.0,\n\t\t\tu:       10.0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is +Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif tt.wantErr {\n\t\t\t\tif err := recover(); err == nil {\n\t\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !EqualApprox(got, tt.want, 1e-10) {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "75568582d0db1dd3b3d9aaadf9b871d7": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        0.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{1.0, 3.0, 2.0},\n\t\t\tv:        2.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than minimum\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to maximum\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        3.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value found\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at first index\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"value at last index\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: 4,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %.2f) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %.2f) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %.2f) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7775eae90044d2b83c4ba237a18e6524": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"positive infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"negative infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"closest value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      2.1,\n\t\t\twant:   1,\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple closest values\",\n\t\t\ts:      []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\tv:      2.0,\n\t\t\twant:   1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) panicked: %v\", tt.s, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "735adf687a18e301fe773c3aa12dfa6b": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    tests := []struct {\n        name     string\n        n        int\n        l        float64\n        u        float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"n < 2\",\n            n:        1,\n            l:        0.0,\n            u:        1.0,\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"v is NaN\",\n            n:        10,\n            l:        0.0,\n            u:        1.0,\n            v:        math.NaN(),\n            expected: 0,\n        },\n        {\n            name:     \"l is NaN, u is not\",\n            n:        10,\n            l:        math.NaN(),\n            u:        1.0,\n            v:        0.5,\n            expected: 9,\n        },\n        {\n            name:     \"u is NaN\",\n            n:        10,\n            l:        0.0,\n            u:        math.NaN(),\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"l and u are +Inf, v is 0\",\n            n:        5,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        0.0,\n            expected: 2,\n        },\n        {\n            name:     \"l and u are +Inf, v is -Inf\",\n            n:        5,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"l and u are +Inf, v is +Inf\",\n            n:        5,\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"l is +Inf, v is l\",\n            n:        10,\n            l:        math.Inf(1),\n            u:        1.0,\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"u is +Inf, v is u\",\n            n:        10,\n            l:        0.0,\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 9,\n        },\n        {\n            name:     \"v is -Inf, l < u\",\n            n:        10,\n            l:        0.0,\n            u:        1.0,\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"v is +Inf, l > u\",\n            n:        10,\n            l:        1.0,\n            u:        0.0,\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"l < u, normal case\",\n            n:        10,\n            l:        0.0,\n            u:        1.0,\n            v:        0.5,\n            expected: 5,\n        },\n        {\n            name:     \"l > u, v >= l\",\n            n:        10,\n            l:        1.0,\n            u:        0.0,\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"l > u, v <= u\",\n            n:        10,\n            l:        1.0,\n            u:        0.0,\n            v:        0.5,\n            expected: 9,\n        },\n    }\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            got := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n            if got != test.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n            }\n        })\n    }\n}",
    "77b93326ee7c291bfa127d16988aa7d8": "package floats\n\nimport (\n    \"math\"\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    tests := []struct {\n        name   string\n        dst    []float64\n        l      float64\n        u      float64\n        want   []float64\n        wantPanic bool\n    }{\n        {\n            name:   \"Basic case\",\n            dst:    make([]float64, 5),\n            l:      0.0,\n            u:      10.0,\n            want:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n        },\n        {\n            name:   \"Negative range\",\n            dst:    make([]float64, 3),\n            l:      -10.0,\n            u:      -5.0,\n            want:   []float64{-10.0, -7.5, -5.0},\n        },\n        {\n            name:   \"Zero range\",\n            dst:    make([]float64, 3),\n            l:      5.0,\n            u:      5.0,\n            want:   []float64{5.0, 5.0, 5.0},\n        },\n        {\n            name:   \"Inf, Inf\",\n            dst:    make([]float64, 5),\n            l:      math.Inf(1),\n            u:      math.Inf(1),\n            want:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n        },\n        {\n            name:   \"NaN, float64\",\n            dst:    make([]float64, 3),\n            l:      math.NaN(),\n            u:      5.0,\n            want:   []float64{math.NaN(), math.NaN(), 5.0},\n        },\n        {\n            name:   \"float64, NaN\",\n            dst:    make([]float64, 3),\n            l:      5.0,\n            u:      math.NaN(),\n            want:   []float64{5.0, math.NaN(), math.NaN()},\n        },\n        {\n            name:   \"Insufficient length\",\n            dst:    make([]float64, 1),\n            l:      0.0,\n            u:      10.0,\n            wantPanic: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            var gotPanic bool\n            func() {\n                defer func() {\n                    if r := recover(); r != nil {\n                        gotPanic = true\n                    }\n                }()\n                got := Span(tt.dst, tt.l, tt.u)\n                if !reflect.DeepEqual(got, tt.want) {\n                    t.Errorf(\"Span() = %v, want %v\", got, tt.want)\n                }\n            }()\n            if gotPanic != tt.wantPanic {\n                t.Errorf(\"Span() panicked = %v, want %v\", gotPanic, tt.wantPanic)\n            }\n        })\n    }\n}",
    "79104be89c9c1a79798d2bc6dce60d34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl        float64\n\t\tu        float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"regular span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with +Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with -Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"span with +Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor i := range result {\n\t\t\t\tif math.IsNaN(result[i]) != math.IsNaN(test.expected[i]) || (result[i] != test.expected[i] && !math.IsNaN(result[i]) && !math.IsNaN(test.expected[i])) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ba6c1a9d9cfc826feb1c6cc29a7d1d5": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{3.14},\n\t\t\twant: 3.14,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed positive and negative elements\",\n\t\t\ts:    []float64{1.0, 2.0, -3.0, 4.0, -5.0},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"all elements are NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"mix of finite and NaN elements\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0, 4.0, math.NaN()},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := floats.SumCompensated(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79f3aca3977491f8d5f9776daa658477": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"short dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 7),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, -math.Inf / 2, 0, math.Inf / 2, math.Inf, math.Inf},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(dst, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, dst, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7dbdc50dd0c7ca092a6eb33c2b115cb4": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n    testCases := []struct {\n        name    string\n        slices  [][]float64\n        want    bool\n    }{\n        {\n            name:   \"all slices have equal length\",\n            slices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n            want:   true,\n        },\n        {\n            name:   \"slices have different lengths\",\n            slices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n            want:   false,\n        },\n        {\n            name:   \"no input slices\",\n            slices: [][]float64{},\n            want:   true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := EqualLengths(tc.slices...)\n            if got != tc.want {\n                t.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n            }\n        })\n    }\n}",
    "7ce7e0ff5d5a26e4ace3cfba39e5cd75": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"find all positive elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2, 4},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find first 2 positive elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"find no elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1, 2, 3, -4, 5},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"find 0 elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7ae0b412168e3741e885695e100e10dc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty dst\",\n\t\t\tdst:      []float64{},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      []float64{0},\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -1, 0, 1, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Same(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f6810e613aee48e70477e69512564f4": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"all slices have equal length\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"slices have different lengths\",\n\t\t\tslices: [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}, {7.0, 8.0, 9.0, 10.0}},\n\t\t\twant:   false,\n\t\t},\n\t\t{\n\t\t\tname:   \"no input slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "79ba96a414ec58600a22cf4d6a65c7d9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\twantPc bool\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2 panics\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   0,\n\t\t\twantPc: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not NaN\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   10 + 1,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf, n is odd, v is not Inf\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.5,\n\t\t\twant:   5,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf, n is odd, v is Inf with same sign as l\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf, n is odd, v is Inf with opposite sign as l\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   6,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf, n is even, v is Inf with same sign as l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf, n is even, v is Inf with opposite sign as l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   5,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf, v == l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf, v == u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   9,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   9,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   9,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t\twantPc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   5,\n\t\t\twantPc: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != test.wantPc {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", test.n, test.l, test.u, test.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e0e584ee99bb04f534bf4a061567134": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find first 2 elements satisfying f\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\t\ts:    []float64{-1, 1, 2, -3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements satisfying f\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\t\ts:    []float64{-1, 1, 2, -3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 4, 5},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf:    func(x float64) bool { return x > 10 },\n\t\t\t\ts:    []float64{-1, 1, 2, -3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\t\ts:    []float64{-1, -2, -3, -4, -5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7be2cfa5773f77e57f0b52a902a37906": "package floats_test\n\nimport (\n    \"math\"\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        n        int\n        l        float64\n        u        float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"n less than 2\",\n            n:        1,\n            l:        0,\n            u:        1,\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"v is NaN\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        math.NaN(),\n            expected: 0,\n        },\n        {\n            name:     \"l is NaN, u is not NaN\",\n            n:        10,\n            l:        math.NaN(),\n            u:        1,\n            v:        0.5,\n            expected: 9,\n        },\n        {\n            name:     \"u is NaN\",\n            n:        10,\n            l:        0,\n            u:        math.NaN(),\n            v:        0.5,\n            expected: 0,\n        },\n        {\n            name:     \"l and u are both Inf, n is odd, v is not Inf\",\n            n:        5,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        0.5,\n            expected: 2,\n        },\n        {\n            name:     \"l and u are both Inf, n is odd, v is Inf with the same sign as l\",\n            n:        5,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"l and u are both Inf, n is odd, v is Inf with the opposite sign as l\",\n            n:        5,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 3,\n        },\n        {\n            name:     \"l and u are both Inf, n is even, v has the same sign as l\",\n            n:        4,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"l and u are both Inf, n is even, v has the opposite sign as l\",\n            n:        4,\n            l:        math.Inf(-1),\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 2,\n        },\n        {\n            name:     \"l is Inf, v is equal to l\",\n            n:        10,\n            l:        math.Inf(-1),\n            u:        1,\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"u is Inf, v is equal to u\",\n            n:        10,\n            l:        0,\n            u:        math.Inf(1),\n            v:        math.Inf(1),\n            expected: 9,\n        },\n        {\n            name:     \"v is -Inf, l < u\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"v is Inf, l < u\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        math.Inf(1),\n            expected: 9,\n        },\n        {\n            name:     \"v is -Inf, l > u\",\n            n:        10,\n            l:        1,\n            u:        0,\n            v:        math.Inf(-1),\n            expected: 9,\n        },\n        {\n            name:     \"v is Inf, l > u\",\n            n:        10,\n            l:        1,\n            u:        0,\n            v:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"normal case\",\n            n:        10,\n            l:        0,\n            u:        1,\n            v:        0.5,\n            expected: 5,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            assert.Equal(t, tc.expected, NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v))\n        })\n    }\n}",
    "7dee733e37d1cd403fa43e560561b44b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"equal-length\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single-element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"nan-l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"nan-u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf-l-inf-u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf-l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"inf-u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"short-dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := Span(tc.dst, tc.l, tc.u)\n\t\t\tif len(tc.expected) == 0 {\n\t\t\t\tif dst != nil {\n\t\t\t\t\tt.Errorf(\"expected Span to panic, but got %v\", dst)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !EqualApprox(dst, tc.expected, 1e-10) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, dst, tc.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f3a126a386b9ed26bfb0769fd5122a4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"All positive\",\n\t\t\tinput:    []float64{1, 2, 3, 4, 5},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"All negative\",\n\t\t\tinput:    []float64{-5, -4, -3, -2, -1},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed values\",\n\t\t\tinput:    []float64{-1, 2, -3, 4, -5},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Duplicate maximum values\",\n\t\t\tinput:    []float64{1, 2, 3, 3, 2},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty input\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0, // This will cause a panic\n\t\t},\n\t\t{\n\t\t\tname:     \"Input with NaN\",\n\t\t\tinput:    []float64{1, 2, math.NaN(), 4, 5},\n\t\t\texpected: 3,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.name == \"Empty input\" {\n\t\t\t\t\t\t// Expected panic for empty input\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := MaxIdx(tc.input)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"MaxIdx(%v) = %d, expected %d\", tc.input, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "806936f5d9d784f8306b0ac2a5943872": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tslices  [][]float64\n\t\twant    bool\n\t}{\n\t\t{\n\t\t\tname:    \"all slices have equal length\",\n\t\t\tslices:  [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"slices have different lengths\",\n\t\t\tslices:  [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\twant:    false,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty slices\",\n\t\t\tslices:  [][]float64{},\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single slice\",\n\t\t\tslices:  [][]float64{{1, 2, 3}},\n\t\t\twant:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e338ea1edf5d53d16546d7262adfbf3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, odd n\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u, even n\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v < l\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        10,\n\t\t\tv:        10.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7e067ec2eec8c0ce92a797561684a201": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, odd n\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, even n\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, finite u\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u, finite l\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l < u, v < l\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    -0.1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l < u, v > u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    1.1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v > l\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v < u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f25d22513ef6e04b64a192ed3cfc5b0": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/your-package-name/floats\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"panics for n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l returns n-1\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and Inf u with odd n and v != Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and Inf u with odd n and v == Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and Inf u with even n and v == Inf\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and finite u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u and finite l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v and l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf v and l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tidx := floats.NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "7f69ce5884584bab680bef849c1ae2aa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty dst\",\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf with the same sign\",\n\t\t\tdst:      make([]float64, 7),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic for dst length < 2\n\tt.Run(\"panic for short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for dst length < 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 10.0)\n\t})\n}",
    "809daefdfb910db4c42b0f1b1277fcbe": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"len(dst) < 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "820e22f4df79d99e681e83421197f3ad": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"L2 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-inf norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"L3 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(14, 1.0/3.0),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Norm(tc.s, tc.L)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, expected %f\", tc.s, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "82cfd02b37e335e4d6d30fe85596f5fc": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = 2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname:   \"L = 1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\texpect: 6,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"L = 3\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tL:      3,\n\t\t\texpect: math.Pow(14, 1/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8164f904edbace0e687a6eb1a01a3af5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices, L=2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"different slices, L=1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    1,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices, L=inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tt:    []float64{4, 5, 6},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\ts:    []float64{},\n\t\t\tt:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mismatched lengths\",\n\t\t\ts:    []float64{1, 2},\n\t\t\tt:    []float64{3, 4, 5},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.s, tt.t, tt.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "833b21a0075c577fde94c189898f66a9": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n    // Test cases for the Swap function\n    tests := []struct {\n        name string\n        a    argsort\n        i, j int\n        want argsort\n    }{\n        {\n            name: \"Swap two elements\",\n            a: argsort{\n                s: []float64{1.0, 2.0, 3.0},\n                inds: []int{0, 1, 2},\n            },\n            i: 0,\n            j: 2,\n            want: argsort{\n                s:    []float64{3.0, 2.0, 1.0},\n                inds: []int{2, 1, 0},\n            },\n        },\n        // Add more test cases as needed\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            tt.a.Swap(tt.i, tt.j)\n            if !Equal(tt.a.s, tt.want.s) {\n                t.Errorf(\"Swap() = %v, want %v\", tt.a.s, tt.want.s)\n            }\n            if !Equal(tt.a.inds, tt.want.inds) {\n                t.Errorf(\"Swap() = %v, want %v\", tt.a.inds, tt.want.inds)\n            }\n        })\n    }\n}",
    "80ffe1ef1dc80434c8321ba0d2fb1c7c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      -5,\n\t\t\tu:      5,\n\t\t\twant:   []float64{-5, -2.5, 0, 2.5, 5},\n\t\t},\n\t\t{\n\t\t\tname:   \"single point\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"nan lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"nan upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"inf lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"inf upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"inf both bounds\",\n\t\t\tdst:    make([]float64, 6),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cba209de73be9fc8a65c3115cd478d": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantEr bool\n\t}{\n\t\t{\n\t\t\tname:   \"Find first two elements satisfying the condition\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 1, 2, -3, 4, 5},\n\t\t\tk:      2,\n\t\t\twant:   []int{1, 2},\n\t\t\twantEr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Find all elements satisfying the condition\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 1, 2, -3, 4, 5},\n\t\t\tk:      -1,\n\t\t\twant:   []int{1, 2, 4, 5},\n\t\t\twantEr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"Find no elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 10 },\n\t\t\ts:      []float64{-1, 1, 2, -3, 4, 5},\n\t\t\tk:      2,\n\t\t\twant:   []int{},\n\t\t\twantEr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Zero elements requested\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 1, 2, -3, 4, 5},\n\t\t\tk:      0,\n\t\t\twant:   []int{},\n\t\t\twantEr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantEr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantEr %v\", err, tt.wantEr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8237b765f07159af3926d27949397523": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf with the same sign\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tc.dst, tc.l, tc.c)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.c, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8660c16f640958be268b424125fc3fec": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1.0/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"Norm(%v, %v) = %v, want %v\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8316756719bd266dc16a02ec38ac71fe": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"valid input\",\n\t\t\tn:     10,\n\t\t\tl:     0.0,\n\t\t\tu:     10.0,\n\t\t\tv:     5.0,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"n < 2\",\n\t\t\tn:     1,\n\t\t\tl:     0.0,\n\t\t\tu:     10.0,\n\t\t\tv:     5.0,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN input\",\n\t\t\tn:     10,\n\t\t\tl:     0.0,\n\t\t\tu:     10.0,\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN\",\n\t\t\tn:     10,\n\t\t\tl:     math.NaN(),\n\t\t\tu:     10.0,\n\t\t\tv:     5.0,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tn:     10,\n\t\t\tl:     0.0,\n\t\t\tu:     math.NaN(),\n\t\t\tv:     5.0,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are both Inf with same sign\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     5.0,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are both Inf with opposite signs\",\n\t\t\tn:     9,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0.0,\n\t\t\twant:  4,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is Inf, v == l\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     10.0,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is Inf, v == u\",\n\t\t\tn:     10,\n\t\t\tl:     0.0,\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is -Inf, l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0.0,\n\t\t\tu:     10.0,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is +Inf, l > u\",\n\t\t\tn:     10,\n\t\t\tl:     10.0,\n\t\t\tu:     0.0,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v outside (l, u), l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0.0,\n\t\t\tu:     10.0,\n\t\t\tv:     -1.0,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v outside (l, u), l > u\",\n\t\t\tn:     10,\n\t\t\tl:     10.0,\n\t\t\tu:     0.0,\n\t\t\tv:     11.0,\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t\tif (tt.wantP && recover() == nil) || (!tt.wantP && recover() != nil) {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) unexpected panic\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t}\n\t\t})\n\t}\n}",
    "84cf1db0881ba9374d11a631125e887c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 0, // should panic\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are ±Inf, v is 0\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are ±Inf, v is -Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are ±Inf, v is +Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is Inf, v is l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is Inf, v is u\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l < u, v <= l\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    -1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l < u, v >= u\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    11.0,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v >= l\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    11.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l > u, v <= u\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    -1.0,\n\t\t\twant: 9,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "84fc49945a232770c24f21a053cee5a1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 1\",\n\t\t\tn:        0,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = NaN, u = finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = finite, u = NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = +Inf, u = +Inf, n odd, v = finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = +Inf, u = +Inf, n odd, v = -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = +Inf, u = +Inf, n odd, v = +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = +Inf, u = finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = finite, u = +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        1.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        -0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "88a0193ded84b9e893d23ff426b1843c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(3),\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      1,\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 1,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panics\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif r != badLength {\n\t\t\t\tt.Errorf(\"Distance panicked with unexpected value: %v\", r)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Distance did not panic with mismatched slice lengths\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2}, []float64{1}, 2)\n}",
    "8957cbfb628c000e6a23a0af86dc0e6d": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/gonum/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal Slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different Slices\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 Norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-Inf Norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        float64(+Inf),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty Slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched Lengths\",\n\t\t\ts:        []float64{1, 2},\n\t\t\tt:        []float64{3, 4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) did not panic\", tc.s, tc.t, tc.L)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) panicked: %v\", tc.s, tc.t, tc.L, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8900aa68771056c6d140df5d1c575cfa": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantNil bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid span\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantNil: false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantNil: false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with NaN upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantNil: false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with +Inf lower and upper bounds\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantNil: false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with +Inf lower bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t\twantNil: false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"span with +Inf upper bound\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t\twantNil: false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid span (dst length < 2)\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\twantNil: true,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif tt.wantNil && got != nil {\n\t\t\t\tt.Errorf(\"Span() = %v, want nil\", got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantNil && got == nil {\n\t\t\t\tt.Errorf(\"Span() = nil, want %v\", tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantNil && !EqualApprox(got, tt.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif tt.wantErr && !HasNaN(got) {\n\t\t\t\tt.Errorf(\"Span() did not panic as expected\")\n\t\t\t}\n\t\t})\n\t}\n}",
    "876a136b2371b18a843f206bffeb3c2a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2 panics\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with the same sign\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:    11,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf(-1), v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf(1), v == u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(-1), l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(1), l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is inside (l, u), l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is inside (u, l), l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is outside (l, u), l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is outside (u, l), l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10,\n\t\t\tu:    0,\n\t\t\tv:    11,\n\t\t\twant: 9,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8db84bf8b529bb0fc69aa47c2d3ac7c6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value in the middle\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value at the beginning\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value at the end\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    5.0,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value closest to middle\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    3.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value closest to beginning\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    1.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value closest to end\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    4.5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value is NaN\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value is +Inf\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice, value is -Inf\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v, want %v\", tt.s, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "90eda1a8282de7144480b0cef156e607": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    []float64\n        expected int\n    }{\n        {\n            name:     \"non-empty slice with unique maximum value\",\n            input:    []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n            expected: 2,\n        },\n        {\n            name:     \"non-empty slice with multiple maximum values\",\n            input:    []float64{1.0, 2.0, 3.0, 3.0, 1.0},\n            expected: 2,\n        },\n        {\n            name:     \"non-empty slice with NaN values\",\n            input:    []float64{1.0, math.NaN(), 3.0, 2.0, 1.0},\n            expected: 2,\n        },\n        {\n            name:     \"empty slice\",\n            input:    []float64{},\n            expected: 0,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            if tc.input == nil || len(tc.input) == 0 {\n                defer func() {\n                    if r := recover(); r == nil {\n                        t.Errorf(\"MaxIdx(%v) did not panic\", tc.input)\n                    }\n                }()\n            }\n\n            idx := MaxIdx(tc.input)\n            if idx != tc.expected {\n                t.Errorf(\"MaxIdx(%v) = %d, expected %d\", tc.input, idx, tc.expected)\n            }\n        })\n    }\n}",
    "9012a9920bb033f073d1054b802c5912": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantEr bool\n\t}{\n\t\t{\n\t\t\tname:   \"find all elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      -1,\n\t\t\twant:   []int{2, 3, 4},\n\t\t\twantEr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find first k elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{2, 3},\n\t\t\twantEr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements satisfying f\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 5 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      2,\n\t\t\twant:   []int{},\n\t\t\twantEr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"k == 0\",\n\t\t\tinds:   []int{1, 2, 3},\n\t\t\tf:      func(x float64) bool { return x > 0 },\n\t\t\ts:      []float64{-1, 0, 1, 2, 3},\n\t\t\tk:      0,\n\t\t\twant:   []int{},\n\t\t\twantEr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantEr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantEr %v\", err, tt.wantEr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8d7bf8dcb492c4994dab8bf626b97ed0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"basic case\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 1.0, 5.0\n\t\texpected := []float64{1, 2, 3, 4, 5}\n\t\tresult := Span(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"with NaN l\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tl, u := math.NaN(), 5.0\n\t\texpected := []float64{math.NaN(), math.NaN(), 5}\n\t\tresult := Span(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"with NaN u\", func(t *testing.T) {\n\t\tdst := make([]float64, 3)\n\t\tl, u := 1.0, math.NaN()\n\t\texpected := []float64{1, math.NaN(), math.NaN()}\n\t\tresult := Span(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"with +Inf l and +Inf u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.Inf(1), math.Inf(1)\n\t\texpected := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)}\n\t\tresult := Span(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"with +Inf l\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := math.Inf(1), 5.0\n\t\texpected := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5}\n\t\tresult := Span(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"with +Inf u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 1.0, math.Inf(1)\n\t\texpected := []float64{1, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tresult := Span(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"with length less than 2\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tl, u := 1.0, 5.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", dst, l, u)\n\t\t\t}\n\t\t}()\n\t\tSpan(dst, l, u)\n\t})\n}",
    "93bb65f0c24933e8c6e5822ca34a87d6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: []float64{1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := make([]float64, len(tt.s))\n\t\t\tcopy(s, tt.s)\n\t\t\tReverse(s)\n\t\t\tif !reflect.DeepEqual(s, tt.want) {\n\t\t\t\tt.Errorf(\"Reverse() = %v, want %v\", s, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9303356005fcdaa7752836a212c96a6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(30),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tL:    1,\n\t\t\twant: 10,\n\t\t},\n\t\t{\n\t\t\tname: \"L = inf (max norm)\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative L\",\n\t\t\ts:    []float64{1, 2, 3, 4},\n\t\t\tL:    -2,\n\t\t\twant: math.Sqrt(1.0/30),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8f9e9416d8c0aaecb379aacadcf67c50": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"panic if n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN v returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l NaN, u not NaN returns n-1\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u NaN returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u both Inf, same sign returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l Inf, v == l returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l Inf, v != l returns n-1\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u Inf, v == u returns n-1\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u Inf, v != u returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v Inf, l <= u returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v Inf, l > u returns n-1\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v <= l returns 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        -0.1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v >= u returns n-1\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        1.1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v between l and u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v between l and u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "930bfa10b6dc4b7a361ff5e9c117915b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"single value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.4076, // Computed using a calculator\n\t\t},\n\t\t{\n\t\t\tname: \"with large values\",\n\t\t\ts:    []float64{1000.0, 1001.0, 1002.0},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with small values\",\n\t\t\ts:    []float64{-1000.0, -1001.0, -1002.0},\n\t\t\twant: -1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with mixed values\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 3.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tt.want}, 1e-4) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "8a268a807febdd1589044723d42783f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"panic on n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN input\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd, v is negative Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd, v is positive Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even, v is negative Inf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even, v is positive Inf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite, v equals l\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite, v equals u\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is finite, v equals u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is finite, v equals l\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf, l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf, l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf, l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf, l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l < u\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "98455f52f62b2e50bb908d3d0ed0a1ec": "package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\tinput:    []float64{5.0},\n\t\t\texpected: 5.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple elements slice\",\n\t\t\tinput:    []float64{2.0, 3.0, 4.0},\n\t\t\texpected: 24.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice with zeros\",\n\t\t\tinput:    []float64{2.0, 0.0, 4.0},\n\t\t\texpected: 0.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Prod(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Prod(%v) = %f, expected %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "971cdb9966ab10f3b6a66f22cf666530": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\ttol      float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\ttol:      1e-6,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\ttol:      1e-6,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Within absolute tolerance\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.01, 2.02, 3.03},\n\t\t\ttol:      0.1,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Within relative tolerance\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.01, 2.02, 3.03},\n\t\t\ttol:      0.1,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Outside tolerance\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.1, 2.2, 3.3},\n\t\t\ttol:      0.01,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualApprox(tc.s1, tc.s2, tc.tol)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %t, expected %t\", tc.s1, tc.s2, tc.tol, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "95db695f7002f97cfcc763d5f131bde2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid case 1\",\n\t\t\tn:      5,\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\tv:      3.14,\n\t\t\twant:   1,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 2\",\n\t\t\tn:      10,\n\t\t\tl:      -5.0,\n\t\t\tu:      5.0,\n\t\t\tv:      0.0,\n\t\t\twant:   5,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 3\",\n\t\t\tn:      20,\n\t\t\tl:      -10.0,\n\t\t\tu:      10.0,\n\t\t\tv:      -5.0,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 4\",\n\t\t\tn:      20,\n\t\t\tl:      -10.0,\n\t\t\tu:      10.0,\n\t\t\tv:      10.0,\n\t\t\twant:   19,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 5\",\n\t\t\tn:      20,\n\t\t\tl:      -10.0,\n\t\t\tu:      10.0,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   19,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 6\",\n\t\t\tn:      20,\n\t\t\tl:      -10.0,\n\t\t\tu:      10.0,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 7\",\n\t\t\tn:      20,\n\t\t\tl:      -10.0,\n\t\t\tu:      10.0,\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid case 1\",\n\t\t\tn:         1,\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\tv:         3.14,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v, wantPanic: %t\", tt.n, tt.l, tt.u, tt.v, r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "97f6a508a005bcc949f1573f054387f8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tn:    5,\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\tv:    3.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\tv:    3.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    5.0,\n\t\t\tv:    3.0,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    5.0,\n\t\t\tv:    1.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\tn:    5,\n\t\t\tl:    1.0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    5.0,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    5,\n\t\t\tl:    1.0,\n\t\t\tu:    5.0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l > u\",\n\t\t\tn:    5,\n\t\t\tl:    5.0,\n\t\t\tu:    1.0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9968eecfdf30082706212c97588e7293": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"all positive values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.801150028509206,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative values\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.09501062828176479,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 3.4076985738683676,\n\t\t},\n\t\t{\n\t\t\tname: \"all zero values\",\n\t\t\ts:    []float64{0.0, 0.0, 0.0},\n\t\t\twant: math.Log(3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"single positive value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single negative value\",\n\t\t\ts:    []float64{-1.0},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single zero value\",\n\t\t\ts:    []float64{0.0},\n\t\t\twant: 0.0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tc.s)\n\t\t\tif !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a496ba17ec527d8f006609f6f843ff6": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 4, 6},\n\t\t\twant:   []float64{0.5, 0.5, 0.5},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{2, 4},\n\t\t\twant:   nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Div() unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(tt.dst))\n\t\t\tcopy(dst, tt.dst)\n\t\t\tDiv(dst, tt.s)\n\n\t\t\tif !reflect.DeepEqual(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "99d6db2036d4ac3edc0116983f0e560d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        2.0,\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=2\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\tL:        2.0,\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        1.0,\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=1\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\tL:        1.0,\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=inf\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=inf\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=3\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0, 3.0},\n\t\t\tL:        3.0,\n\t\t\texpected: 0.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal slices, L=3\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tt:        []float64{1.0, 2.0},\n\t\t\tL:        3.0,\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Distance(tt.s, tt.t, tt.L)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", tt.s, tt.t, tt.L, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a6f496faafe107e1f1f8261c46d7bf1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0.0,\n\t\t\texpected: 0, // NearestIdx should panic for empty slice\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is positive infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is negative infinity\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is closest to middle element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.1,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is closest to first element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is closest to last element\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        2.9,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expected == 0 {\n\t\t\t\t\t\t// Expected a panic for empty slice\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := NearestIdx(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, expected %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9b77ccabddafb9d8dc5b4b9224996375": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"basic\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\texpect: []float64{18, 21, 24},\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatch y and s\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatch dst and y\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresult := AddScaledTo(test.dst, test.y, test.alpha, test.s)\n\t\t\tif test.expect == nil {\n\t\t\t\tif len(result) != 0 {\n\t\t\t\t\tt.Errorf(\"expected panic, but got result: %v\", result)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !EqualApprox(result, test.expect, 1e-14) {\n\t\t\t\t\tt.Errorf(\"expected %v, but got %v\", test.expect, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "9cb0d360d85ad376bf2194447eafd178": "package floats\n\nimport \"testing\"\n\nfunc TestHasNaN(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Slice with NaN values\",\n\t\t\tinput:    []float64{1.0, 2.0, float64(0)/float64(0), 4.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Slice without NaN values\",\n\t\t\tinput:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := HasNaN(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"HasNaN(%v) = %v, expected %v\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d291a0a7219e71f1248386c72c4ebdd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2.0,\n\t\t\twant: 0.0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    2.0,\n\t\t\twant: math.Sqrt(14.0),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0},\n\t\t\tL:    1.0,\n\t\t\twant: 6.0,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\ts:    []float64{-1.0, 2.0, -3.0},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Lp norm, p > 1\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    3.0,\n\t\t\twant: math.Pow(14.0, 1.0/3.0),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9ab1d4dcd4e6e4dd07be351879e21a61": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf and v = l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf and v = u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf and v is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf and v is Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u and v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u and v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u and v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u and v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9a98ff29fee4e9f72e766486242fbc11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\tl, u  float64\n\t\twant  []float64\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0,\n\t\t\tu:    10,\n\t\t\twant: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:  \"length less than 2\",\n\t\t\tdst:   make([]float64, 1),\n\t\t\tl:     0,\n\t\t\tu:     10,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.panic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9c55932632ea7107edec31327f638aa7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\ts:        []float64{0.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        1.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v less than s[0]\",\n\t\t\ts:        []float64{0.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        -1.0,\n\t\t\texpected: -0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v greater than or equal to s[len(s)-1]\",\n\t\t\ts:        []float64{0.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        4.0,\n\t\t\texpected: -0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\ts:        []float64{0.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -0,\n\t\t},\n\t\t{\n\t\t\tname:     \"len(s) < 2\",\n\t\t\ts:        []float64{0.0},\n\t\t\tv:        0.5,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"s is not sorted\",\n\t\t\ts:        []float64{2.0, 1.0, 3.0, 0.0, 4.0},\n\t\t\tv:        1.5,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9d4ab18a2d3be262fae27fe7439bf295": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find all elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        -1,\n\t\t\texpected: []int{2, 3, 4},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find first k elements satisfying f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{2, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"No elements satisfy f\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"k = 0 should return empty inds\",\n\t\t\tinds:     []int{1, 2, 3},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1, 0, 1, 2, 3},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif err != nil && !tc.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif err == nil && tc.err {\n\t\t\t\tt.Errorf(\"expected error, but got none\")\n\t\t\t}\n\t\t\tif !Equal(inds, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, inds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "9e6b0f9dd9f49f75a5ba370e3a417163": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\texpect float64\n\t}{\n\t\t{\n\t\t\tname:   \"Equal slices\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Different slices\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\texpect: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:   \"L1 norm\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"L-infinity norm\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Mismatched lengths\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\tL:      2,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.expect == 0 {\n\t\t\t\t\t\t// Expected panic for mismatched lengths\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdist := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(dist-tc.expect) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, dist, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a27f6a53f7ef837c6a2016083242e078": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length < 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, 0.0, 0.0, 0.0, math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a2bf07ba250a0365f9ac0b0f63d41c94": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal Slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal Slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{2, 3, 4},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(3),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal Slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal Slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{2, 3, 4},\n\t\t\tL:        1,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal Slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal Slices, L=inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{2, 3, 4},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty Slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Distance(tc.s, tc.t, tc.L)\n\t\t\tif !EqualApprox([]float64{result}, []float64{tc.expected}, 1e-10) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, expected %f\", tc.s, tc.t, tc.L, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a41f57f74af72aeefcd635aa831db8f0": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"within range\",\n\t\t\ts:      []float64{0, 1, 2, 3, 4, 5},\n\t\t\tv:      2.5,\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"outside range (below)\",\n\t\t\ts:      []float64{0, 1, 2, 3, 4, 5},\n\t\t\tv:      -1,\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"outside range (above)\",\n\t\t\ts:      []float64{0, 1, 2, 3, 4, 5},\n\t\t\tv:      6,\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN value\",\n\t\t\ts:      []float64{0, 1, 2, 3, 4, 5},\n\t\t\tv:      math.NaN(),\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:      \"length less than 2\",\n\t\t\ts:         []float64{0},\n\t\t\tv:         1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"unsorted input\",\n\t\t\ts:         []float64{2, 0, 1, 3, 4, 5},\n\t\t\tv:         2.5,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within() did not panic as expected\")\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within() panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4d1d307540cd4a4d2ac0b2fb9d31721": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n    testCases := []struct {\n        name string\n        s    []float64\n        L    float64\n        want float64\n    }{\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            L:    2,\n            want: 0,\n        },\n        {\n            name: \"L = 2\",\n            s:    []float64{1, 2, 3},\n            L:    2,\n            want: math.Sqrt(14),\n        },\n        {\n            name: \"L = 1\",\n            s:    []float64{1, 2, 3},\n            L:    1,\n            want: 6,\n        },\n        {\n            name: \"L = inf\",\n            s:    []float64{1, 2, 3},\n            L:    math.Inf(1),\n            want: 3,\n        },\n        {\n            name: \"L = 3\",\n            s:    []float64{1, 2, 3},\n            L:    3,\n            want: math.Pow(14, 1/3),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := Norm(tc.s, tc.L)\n            if !EqualApprox([]float64{got}, []float64{tc.want}, 1e-10) {\n                t.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n            }\n        })\n    }\n}",
    "a3fe2ed40acd3b91aacc802c7c7b7333": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty slice\",\n\t\t\ts:     []float64{},\n\t\t\tv:     0,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN value\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"positive infinity\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  2,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative infinity\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nearest value\",\n\t\t\ts:     []float64{1.0, 2.0, 3.0},\n\t\t\tv:     2.1,\n\t\t\twant:  1,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nearest value at beginning\",\n\t\t\ts:     []float64{2.0, 2.1, 3.0},\n\t\t\tv:     2.0,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"nearest value at end\",\n\t\t\ts:     []float64{1.0, 2.0, 2.0},\n\t\t\tv:     2.0,\n\t\t\twant:  1,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"NearestIdx() panicked = %v, wantP %v\", r != nil, tt.wantP)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a016dbc2f0d6caf11e2cb0a3b863ab48": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with the same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tt.n, tt.l, tt.u, tt.v)\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a47dd1cdc3dc83bbdb439193cd64f607": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2 should panic\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with the same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.5,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v is l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v is u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (l, u), l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (u, l), l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    0,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a497dd8b46bc2c813c600319f2b295de": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is less than s[0]\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is greater than or equal to s[len(s)-1]\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"len(s) < 2\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"s is not sorted\",\n\t\t\ts:        []float64{5.0, 2.0, 3.0, 1.0, 4.0},\n\t\t\tv:        2.5,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(test.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tif r != \"floats: input slice not sorted\" {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"expected panic for unsorted slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tif len(test.s) < 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tif r != shortSpan {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected panic: %v\", r)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"expected panic for len(s) < 2\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tresult := Within(test.s, test.v)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, expected %d\", test.s, test.v, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a4b60974e46bfdf6e006c7d82aaa379c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is in (l, u), l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is in (u, l), l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %g, %g, %g) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a7d15f2cc559aa317134a3b5cf5abf3b": "package floats\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n    tests := []struct {\n        name   string\n        dst    []float64\n        s      []float64\n        expect []float64\n    }{\n        {\n            name:   \"equal lengths\",\n            dst:    []float64{1, 2, 3, 4, 5},\n            s:      []float64{5, 4, 3, 2, 1},\n            expect: []float64{-4, -2, 0, 2, 4},\n        },\n        {\n            name:   \"different lengths\",\n            dst:    []float64{1, 2, 3, 4},\n            s:      []float64{5, 4, 3, 2, 1},\n            expect: nil,\n        },\n    }\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil {\n                    if test.expect == nil {\n                        return\n                    } else {\n                        t.Errorf(\"unexpected panic: %v\", r)\n                    }\n                }\n            }()\n\n            Sub(test.dst, test.s)\n            if !reflect.DeepEqual(test.dst, test.expect) {\n                t.Errorf(\"Sub(%v, %v) = %v, want %v\", test.dst, test.s, test.dst, test.expect)\n            }\n        })\n    }\n}",
    "a5e41a7195939f58c03fbd26820a8ba7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"single element slice\", args{[]float64{1.0}, 1.0}, 0},\n\t\t{\"empty slice\", args{[]float64{}, 1.0}, 0}, // Should panic, but testing for 0 index\n\t\t{\"closest value\", args{[]float64{1.0, 2.0, 3.0}, 2.1}, 1},\n\t\t{\"closest value at beginning\", args{[]float64{1.0, 2.0, 3.0}, 0.5}, 0},\n\t\t{\"closest value at end\", args{[]float64{1.0, 2.0, 3.0}, 2.9}, 2},\n\t\t{\"NaN value\", args{[]float64{1.0, 2.0, 3.0}, math.NaN()}, 0},\n\t\t{\"positive infinity\", args{[]float64{1.0, 2.0, 3.0}, math.Inf(1)}, 2},\n\t\t{\"negative infinity\", args{[]float64{1.0, 2.0, 3.0}, math.Inf(-1)}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a521218401b9b8dba09f0819080b73d1": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\twant   float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\twant:   0,\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      2,\n\t\t\twant:   math.Sqrt(3),\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices, L=2\",\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\tL:      2,\n\t\t\twant:   0,\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatched lengths, L=2\",\n\t\t\ts:      []float64{1, 2},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\twant:   0,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\twant:   0,\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      1,\n\t\t\twant:   3,\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\twant:   0,\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      math.Inf(1),\n\t\t\twant:   1,\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=3\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{2, 3, 4},\n\t\t\tL:      3,\n\t\t\twant:   math.Pow(14, 1/3),\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) did not panic\", tc.s, tc.t, tc.L)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) panicked: %v\", tc.s, tc.t, tc.L, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif !nearEqual(got, tc.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", tc.s, tc.t, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc nearEqual(a, b, tol float64) bool {\n\treturn math.Abs(a-b) <= tol\n}",
    "a69b30c54f2b14f26c3f18c8767573b0": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n    testCases := []struct {\n        name     string\n        s        []float64\n        t        []float64\n        L        float64\n        expected float64\n    }{\n        {\n            name:     \"Equal slices, L=2\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{1, 2, 3},\n            L:        2,\n            expected: 0,\n        },\n        {\n            name:     \"Unequal slices, L=2\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{1, 2},\n            L:        2,\n            expected: 0, // This should panic\n        },\n        {\n            name:     \"Equal slices, L=1\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        1,\n            expected: 9,\n        },\n        {\n            name:     \"Equal slices, L=Inf\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        math.Inf(1),\n            expected: 5,\n        },\n        {\n            name:     \"Equal slices, L=3\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        3,\n            expected: math.Pow(78, 1/3),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil {\n                    if tc.expected == 0 {\n                        // Expected a panic, so this is okay\n                        return\n                    }\n                    t.Errorf(\"Unexpected panic: %v\", r)\n                }\n            }()\n\n            dist := Distance(tc.s, tc.t, tc.L)\n            if math.Abs(dist-tc.expected) > 1e-10 {\n                t.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, dist, tc.expected)\n            }\n        })\n    }\n}",
    "a54d54664865f2c31b2989b19aa1f707": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tdst         []float64\n\t\tl, u        float64\n\t\twant        []float64\n\t\twantPanics  bool\n\t\twantErr     bool\n\t\terrorString string\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:        \"dst length is less than 2\",\n\t\t\tdst:         make([]float64, 1),\n\t\t\tl:           0.0,\n\t\t\tu:           10.0,\n\t\t\twantPanics:  true,\n\t\t\terrorString: \"length of dst is less than 2\",\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanics && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic as expected\", tt.dst, tt.l, tt.u)\n\t\t\t\t} else if !tt.wantPanics && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked with: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualFunc(got, tt.want, func(f1, f2 float64) bool {\n\t\t\t\treturn math.IsNaN(f1) && math.IsNaN(f2) || math.Abs(f1-f2) < 1e-14\n\t\t\t}) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ab7dc606c0b084ab5d94a2ed91fc6c4b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\tt.Run(\"equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3, 4, 5}\n\t\ts := []float64{10, 20, 30, 40, 50}\n\t\tt := []float64{2, 4, 6, 8, 10}\n\n\t\texpected := []float64{5, 5, 5, 5, 5}\n\t\tDivTo(dst, s, t)\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"DivTo(dst, s, t) = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"mismatched length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3, 4, 5}\n\t\ts := []float64{10, 20, 30, 40}\n\t\tt := []float64{2, 4, 6, 8, 10}\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"DivTo did not panic with mismatched slice lengths\")\n\t\t\t}\n\t\t}()\n\t\tDivTo(dst, s, t)\n\t})\n\n\tt.Run(\"dst length mismatch\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{10, 20, 30, 40, 50}\n\t\tt := []float64{2, 4, 6, 8, 10}\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"DivTo did not panic with dst length mismatch\")\n\t\t\t}\n\t\t}()\n\t\tDivTo(dst, s, t)\n\t})\n}",
    "adc5acf237e9d9e0b0eaa3cab7609c7a": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\t// Create an instance of argsort\n\ta := argsort{\n\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\tinds: []int{0, 1, 2, 3, 4},\n\t}\n\n\t// Swap the elements at indices 1 and 3\n\ta.Swap(1, 3)\n\n\t// Check if the swap was successful\n\tif a.inds[1] != 3 || a.inds[3] != 1 {\n\t\tt.Errorf(\"Swap function did not work as expected\")\n\t}\n}",
    "abb812288b8de738509d66c3ec95412e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"positive infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"negative infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"nearest value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      2.1,\n\t\t\twant:   1,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal distance\",\n\t\t\ts:      []float64{1.0, 2.0, 2.0},\n\t\t\tv:      2.0,\n\t\t\twant:   1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdx() panic = %v, wantPanic %v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af54b607219a486ffb62bfa2478b3568": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slices\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1, 2, 3}, {4, 5}, {6, 7, 8, 9}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"single slice\",\n\t\t\tslices:   [][]float64{{1, 2, 3}},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "a9d4441a857e403200ecd0cceab9906d": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl       float64\n\t\tu       float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid input\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is NaN\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is NaN\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l and u are Inf\",\n\t\t\tdst:     make([]float64, 7),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       math.Inf(1),\n\t\t\twant:    []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is Inf\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(-1),\n\t\t\tu:       10,\n\t\t\twant:    []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is Inf\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0,\n\t\t\tu:       math.Inf(1),\n\t\t\twant:    []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"dst length less than 2\",\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0,\n\t\t\tu:       10,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif (tt.wantErr && got == nil) || (!tt.wantErr && got != nil) {\n\t\t\t\tt.Errorf(\"Span() error = %v, wantErr %v\", got, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}",
    "aaf32cd17c4604ddafa4458bb47ea3c4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantOK bool\n\t}{\n\t\t{\n\t\t\tname:   \"simple case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\twantOK: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t\twantOK: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantOK: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !tc.wantOK && got != nil {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want panic\", tc.dst, tc.l, tc.u, got)\n\t\t\t}\n\t\t\tif tc.wantOK && !Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "af91ec866fc2f872635e8cfdd90e66fa": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\ts1       []float64\n\t\ts2       []float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 3.0},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal lengths\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal elements\",\n\t\t\ts1:       []float64{1.0, 2.0, 3.0},\n\t\t\ts2:       []float64{1.0, 2.0, 4.0},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts1:       []float64{},\n\t\t\ts2:       []float64{},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Equal(tc.s1, tc.s2)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Equal(%v, %v) = %v, expected %v\", tc.s1, tc.s2, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afc5e1b592f391571a48959e2f9e490f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttype testCase struct {\n\t\tname string\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\twant int\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname: \"all elements pass the test\",\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"no elements pass the test\",\n\t\t\tf:    func(x float64) bool { return x < 0 },\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"some elements pass the test\",\n\t\t\tf:    func(x float64) bool { return x > 2 },\n\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Count(tc.f, tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Count(%v, %v) = %v, want %v\", tc.f, tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "afb6691cc094d2b363d8525e14a19ac8": "package floats\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestCumSum(t *testing.T) {\n    testCases := []struct {\n        name     string\n        dst      []float64\n        s        []float64\n        expected []float64\n    }{\n        {\n            name:     \"empty slices\",\n            dst:      []float64{},\n            s:        []float64{},\n            expected: []float64{},\n        },\n        {\n            name:     \"single element\",\n            dst:      []float64{0},\n            s:        []float64{5},\n            expected: []float64{5},\n        },\n        {\n            name:     \"multiple elements\",\n            dst:      []float64{0, 0, 0, 0, 0},\n            s:        []float64{1, 2, 3, 4, 5},\n            expected: []float64{1, 3, 6, 10, 15},\n        },\n        {\n            name:     \"dst and s have different lengths\",\n            dst:      []float64{0, 0, 0},\n            s:        []float64{1, 2, 3, 4, 5},\n            expected: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := CumSum(tc.dst, tc.s)\n            if !reflect.DeepEqual(result, tc.expected) {\n                t.Errorf(\"CumSum(%v, %v) = %v, expected %v\", tc.dst, tc.s, result, tc.expected)\n            }\n        })\n    }\n}",
    "b023a706762e4bc46743e63893e9d4ca": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\texpect: []float64{4, 10, 18},\n\t\t},\n\t\t{\n\t\t\tname:   \"Mismatch lengths\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5},\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Dst length mismatch\",\n\t\t\tdst:    []float64{0, 0, 0, 0},\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tpanics: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panics && r == nil {\n\t\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) did not panic as expected\", tc.dst, tc.s, tc.t)\n\t\t\t\t} else if !tc.panics && r != nil {\n\t\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) panicked: %v\", tc.dst, tc.s, tc.t, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tc.dst, tc.s, tc.t)\n\t\t\tif !reflect.DeepEqual(got, tc.expect) {\n\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) = %v, want %v\", tc.dst, tc.s, tc.t, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b0f9a3504d61dd97d7d30c129c71d603": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v less than s[0]\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v greater than or equal to s[len(s)-1]\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"len(s) < 2\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"s is not sorted\",\n\t\t\ts:        []float64{3.0, 1.0, 4.0, 2.0, 5.0},\n\t\t\tv:        2.5,\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Within(tc.s, tc.v)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %f) = %d, want %d\", tc.s, tc.v, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b1237c007a154e7551e96e4abef395ac": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n    testCases := []struct {\n        name     string\n        s        []float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"empty slice\",\n            s:        []float64{},\n            v:        0.0,\n            expected: 0, // should panic\n        },\n        {\n            name:     \"NaN value\",\n            s:        []float64{1.0, 2.0, 3.0},\n            v:        math.NaN(),\n            expected: 0,\n        },\n        {\n            name:     \"positive infinity\",\n            s:        []float64{1.0, 2.0, 3.0},\n            v:        math.Inf(1),\n            expected: 2,\n        },\n        {\n            name:     \"negative infinity\",\n            s:        []float64{1.0, 2.0, 3.0},\n            v:        math.Inf(-1),\n            expected: 0,\n        },\n        {\n            name:     \"closest value\",\n            s:        []float64{1.0, 2.0, 3.0},\n            v:        2.5,\n            expected: 1,\n        },\n        {\n            name:     \"multiple closest values\",\n            s:        []float64{1.0, 2.0, 2.0, 3.0},\n            v:        2.0,\n            expected: 1,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil && tc.name == \"empty slice\" {\n                    // Expected panic, ignore it\n                    return\n                } else if r != nil {\n                    t.Errorf(\"Unexpected panic: %v\", r)\n                }\n            }()\n\n            idx := NearestIdx(tc.s, tc.v)\n            if idx != tc.expected {\n                t.Errorf(\"NearestIdx(%v, %f) = %d, expected %d\", tc.s, tc.v, idx, tc.expected)\n            }\n        })\n    }\n}",
    "b057253b10925d31efe70b9b96fdeb78": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        10,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single-element slice\",\n\t\t\ts:        []float64{10},\n\t\t\tv:        10,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{10, 5, 20},\n\t\t\tv:        15,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{10, 20, 30},\n\t\t\tv:        5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{10, 20, 30},\n\t\t\tv:        30,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{10, 20, 30},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value found\",\n\t\t\ts:        []float64{10, 20, 30, 40, 50},\n\t\t\tv:        25,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b247c18384f0d8daf42cbf9e1815e8cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large range\",\n\t\t\ts:    []float64{1e20, 1, -1e20},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b19603c719cd669e4b4e7417b1673a44": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slice\",\n\t\t\ts:        []float64{1.0},\n\t\t\tv:        1.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted slice\",\n\t\t\ts:        []float64{2.0, 1.0},\n\t\t\tv:        1.5,\n\t\t\texpected: -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"v greater than max\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        4.0,\n\t\t\texpected: -1,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v in range\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v at lower bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        1.0,\n\t\t\texpected: 0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"v at upper bound\",\n\t\t\ts:        []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:        4.0,\n\t\t\texpected: 3,\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic as expected\", tc.s, tc.v)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Within(%v, %v) panicked unexpectedly: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, expected %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b171a68a65a0482c47261417a55b4971": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN v\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      math.NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN l\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\tv:      5,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      5,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf l and u, odd n\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0,\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf l and u, even n\",\n\t\t\tn:      6,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0,\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10,\n\t\t\tv:      0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"Inf u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      10,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v <= l\",\n\t\t\tn:      10,\n\t\t\tl:      5,\n\t\t\tu:      10,\n\t\t\tv:      4,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v >= u\",\n\t\t\tn:      10,\n\t\t\tl:      5,\n\t\t\tu:      10,\n\t\t\tv:      11,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      5,\n\t\t\tv:      9,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v <= u\",\n\t\t\tn:      10,\n\t\t\tl:      10,\n\t\t\tu:      5,\n\t\t\tv:      4,\n\t\t\texpect: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\tv:      5,\n\t\t\texpect: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b213bf54d996e0039fda47719746bfab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Empty slice\",\n\t\t\tinput:    []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Single element\",\n\t\t\tinput:    []float64{42.42},\n\t\t\texpected: 42.42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Small positive values\",\n\t\t\tinput:    []float64{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\t\texpected: 1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Small negative values\",\n\t\t\tinput:    []float64{-0.1, -0.2, -0.3, -0.4, -0.5},\n\t\t\texpected: -1.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed positive and negative values\",\n\t\t\tinput:    []float64{1.0, -0.5, 0.25, -0.125, 0.0625},\n\t\t\texpected: 0.6875,\n\t\t},\n\t\t{\n\t\t\tname:     \"Large values\",\n\t\t\tinput:    []float64{1e20, 1e20, 1e20, 1e20, 1e20},\n\t\t\texpected: 5e20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Extremely small values\",\n\t\t\tinput:    []float64{1e-20, 1e-20, 1e-20, 1e-20, 1e-20},\n\t\t\texpected: 5e-20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixture of large and small values\",\n\t\t\tinput:    []float64{1e20, 1e-20, 1e20, 1e-20, 1e20},\n\t\t\texpected: 4.000000000000001e20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Presence of NaN\",\n\t\t\tinput:    []float64{1.0, math.NaN(), 2.0, 3.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := SumCompensated(tc.input)\n\t\t\tif !math.IsNaN(tc.expected) && math.Abs(result-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.input, result, tc.expected)\n\t\t\t} else if math.IsNaN(tc.expected) != math.IsNaN(result) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %f, want %f\", tc.input, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b1c211d15e5b97db52c1164cf02ab259": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0, // expected to panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is less than l\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is greater than u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected == 0 {\n\t\t\t\t\t// Expected a panic, so this is fine\n\t\t\t\t\treturn\n\t\t\t\t} else if r != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b24730c325c23f8e9cf5a440666a54cd": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Length of dst is less than 2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !EqualApprox(got, tt.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b40f3129f28d9f1eeaeb9805d894b2d5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tt     []float64\n\t\tL     float64\n\t\twant  float64\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"equal lengths\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{4, 5, 6},\n\t\t\tL:     2,\n\t\t\twant:  7.0710678118654755,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"different lengths\",\n\t\t\ts:     []float64{1, 2},\n\t\t\tt:     []float64{4, 5, 6},\n\t\t\tL:     2,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"empty slices\",\n\t\t\ts:     []float64{},\n\t\t\tt:     []float64{},\n\t\t\tL:     2,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"L=1\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{4, 5, 6},\n\t\t\tL:     1,\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"L=inf\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tt:     []float64{4, 5, 6},\n\t\t\tL:     math.Inf(1),\n\t\t\twant:  3,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"Distance() = %v, want panic=%v\", r, tt.wantP)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tt.s, tt.t, tt.L)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b517facd54cabc2f4032e18bd4d107cd": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\t// Test case 1: Same length slices\n\tdst := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\texpected := []float64{4, 10, 18}\n\tMul(dst, s)\n\tif !Equal(dst, expected) {\n\t\tt.Errorf(\"Mul() = %v, want %v\", dst, expected)\n\t}\n\n\t// Test case 2: Slices with different lengths\n\tdst = []float64{1, 2, 3}\n\ts = []float64{4, 5}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Mul() did not panic with mismatched slice lengths\")\n\t\t}\n\t}()\n\tMul(dst, s)\n}",
    "b274b8c757536346f03da55ed0a60c98": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v equals l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v equals u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b2b41c0984a6fc130569c29ce9ac8aed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        1.0,\n\t\t\tu:        5.0,\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.MaxFloat64, 0, math.MaxFloat64, math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        5.0,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 5},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        1.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{1, 1, 1, 1, math.Inf(1)},\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif test.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic, but was expected to\", test.dst, test.l, test.u)\n\t\t\t\t} else if !test.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !EqualApprox(result, test.expected, 1e-14) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b4b092207079221ea52e0eecea53fb6f": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal vectors\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different vectors\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:     \"L1 norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"L-infinity norm\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty vectors\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tc.name == \"Mismatched lengths\" {\n\t\t\t\t\t\treturn // Expected panic, test passes\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdist := Distance(tc.s, tc.t, tc.L)\n\t\t\tif math.Abs(dist-tc.expected) > 1e-10 {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, dist, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b39b4e92d68ff04931e1f9c49dce0d52": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tt        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Equal slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"Equal slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Different slices, L=Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5, 6},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty slices\",\n\t\t\ts:        []float64{},\n\t\t\tt:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Mismatched lengths\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tt:        []float64{4, 5},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && tc.expected != 0 {\n\t\t\t\t\t// Expected a panic, so this is fine\n\t\t\t\t} else if r == nil && tc.expected == 0 {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, 0.0, tc.expected)\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, 0.0, tc.expected)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Distance(tc.s, tc.t, tc.L)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b62580acc0fe992fad3b01981ef69e94": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n    // Test cases\n    testCases := []struct {\n        name   string\n        dst    []float64\n        s      []float64\n        t      []float64\n        expect []float64\n    }{\n        {\n            name:   \"Equal lengths\",\n            dst:    []float64{1, 2, 3},\n            s:      []float64{4, 5, 6},\n            t:      []float64{7, 8, 9},\n            expect: []float64{11, 13, 15},\n        },\n        {\n            name:   \"Mismatched lengths\",\n            dst:    []float64{1, 2, 3},\n            s:      []float64{4, 5},\n            t:      []float64{7, 8, 9},\n            expect: nil,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := AddTo(tc.dst, tc.s, tc.t)\n            if len(result) != len(tc.expect) {\n                t.Errorf(\"AddTo(%v, %v, %v) = %v, expected %v\", tc.dst, tc.s, tc.t, result, tc.expect)\n                return\n            }\n\n            for i, v := range result {\n                if v != tc.expect[i] {\n                    t.Errorf(\"AddTo(%v, %v, %v)[%d] = %f, expected %f\", tc.dst, tc.s, tc.t, i, v, tc.expect[i])\n                    return\n                }\n            }\n        })\n    }\n}",
    "b453eeefaf291a83ffcb9e4516aac460": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, v is Inf of the same sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, v is Inf of the opposite sign as l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif idx != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, idx, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b62c0496f8758e4bda8819180b790391": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n    // Test cases\n    type testCase struct {\n        name     string\n        s        []float64\n        t        []float64\n        L        float64\n        expected float64\n    }\n\n    testCases := []testCase{\n        {\n            name:     \"Equal slices, L=2\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{1, 2, 3},\n            L:        2,\n            expected: 0,\n        },\n        {\n            name:     \"Different slices, L=2\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        2,\n            expected: math.Sqrt(9 + 9 + 9),\n        },\n        {\n            name:     \"Empty slices, L=2\",\n            s:        []float64{},\n            t:        []float64{},\n            L:        2,\n            expected: 0,\n        },\n        {\n            name:     \"Different lengths, L=2\",\n            s:        []float64{1, 2},\n            t:        []float64{1, 2, 3},\n            L:        2,\n            expected: 0, // Should panic\n        },\n        {\n            name:     \"L=1\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        1,\n            expected: 9,\n        },\n        {\n            name:     \"L=inf\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        math.Inf(1),\n            expected: 3,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            defer func() {\n                if r := recover(); r != nil {\n                    if tc.expected == 0 {\n                        // Expected a panic\n                        return\n                    }\n                    t.Errorf(\"Unexpected panic: %v\", r)\n                }\n            }()\n\n            result := Distance(tc.s, tc.t, tc.L)\n            if math.Abs(result-tc.expected) > 1e-10 {\n                t.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n            }\n        })\n    }\n}",
    "b90b25d30caac34e602553815fe2c041": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"elements with different magnitudes\",\n\t\t\ts:    []float64{1e20, 1, -1e20},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"floating-point cancellation\",\n\t\t\ts:    []float64{1e20, -1e20, 1, -1},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.s); !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.IsNaN(a) && math.IsNaN(b) || math.Abs(a-b) <= 1e-14*math.Max(math.Abs(a), math.Abs(b))\n}",
    "bdbac0eb9fce9bd1874ee7d0e7ca5d5a": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\tt.Run(\"valid inputs\", func(t *testing.T) {\n\t\tdst := []float64{1.0, 2.0, 3.0}\n\t\talpha := 2.0\n\t\ts := []float64{4.0, 5.0, 6.0}\n\n\t\texpected := []float64{9.0, 12.0, 15.0}\n\t\tAddScaled(dst, alpha, s)\n\n\t\tif !reflect.DeepEqual(dst, expected) {\n\t\t\tt.Errorf(\"expected %v, got %v\", expected, dst)\n\t\t}\n\t})\n\n\tt.Run(\"slices of different lengths\", func(t *testing.T) {\n\t\tdst := []float64{1.0, 2.0, 3.0}\n\t\talpha := 2.0\n\t\ts := []float64{4.0, 5.0}\n\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"AddScaled did not panic with slices of different lengths\")\n\t\t\t}\n\t\t}()\n\n\t\tAddScaled(dst, alpha, s)\n\t})\n}",
    "b8a05ba3a712e311a1d2e9009147f26b": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      10,\n\t\t\twant:   -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element slice\",\n\t\t\ts:      []float64{10},\n\t\t\tv:      10,\n\t\t\twant:   -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"unsorted slice\",\n\t\t\ts:      []float64{10, 5, 15},\n\t\t\tv:      8,\n\t\t\twant:   -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"value less than first element\",\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tv:      5,\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value greater than or equal to last element\",\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tv:      30,\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"value is NaN\",\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tv:      math.NaN(),\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value in range\",\n\t\t\ts:      []float64{10, 20, 30, 40},\n\t\t\tv:      25,\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"value at the end of the range\",\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tv:      20,\n\t\t\twant:   1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value at the beginning of the range\",\n\t\t\ts:      []float64{10, 20, 30},\n\t\t\tv:      10,\n\t\t\twant:   0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tc.s) {\n\t\t\t\tsort.Float64s(tc.s)\n\t\t\t}\n\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Within(%v, %f) panicked unexpectedly: %v\", tc.s, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Within(tc.s, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Within(%v, %f) = %d, want %d\", tc.s, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bf076eed918d7c3223f67e7e25518cf2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tt    []float64\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\ts:    []float64{1.0, 2.0},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tt:    []float64{1.0, 2.0, 4.0},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{1.0, math.NaN(), 3.0},\n\t\t\tt:    []float64{1.0, math.NaN(), 3.0},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1.0, 2.0, math.NaN()},\n\t\t\tt:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Same(tc.s, tc.t)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Same(%v, %v) = %v, want %v\", tc.s, tc.t, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "b89f9f1089868798b9e02bcd5e68794b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"simple case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\texpect: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\texpect: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\texpect: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar got []float64\n\t\t\tif tc.expect == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) did not panic\", tc.dst, tc.l, tc.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tgot = Span(tc.dst, tc.l, tc.u)\n\t\t\t} else {\n\t\t\t\tgot = Span(tc.dst, tc.l, tc.u)\n\t\t\t\tif !Equal(got, tc.expect) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expect)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "b7f2edbdc613f82d19b5b99c215ff5f3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"regular case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ba6c5492461668b1361d8b51e520bf52": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    tests := []struct {\n        name     string\n        dst      []float64\n        l, u     float64\n        expected []float64\n        wantPanic bool\n    }{\n        {\n            name:     \"regular span\",\n            dst:      make([]float64, 5),\n            l:        0,\n            u:        10,\n            expected: []float64{0, 2.5, 5, 7.5, 10},\n        },\n        {\n            name:     \"negative span\",\n            dst:      make([]float64, 5),\n            l:        -5,\n            u:        5,\n            expected: []float64{-5, -2.5, 0, 2.5, 5},\n        },\n        {\n            name:     \"zero span\",\n            dst:      make([]float64, 5),\n            l:        0,\n            u:        0,\n            expected: []float64{0, 0, 0, 0, 0},\n        },\n        {\n            name:     \"infinite span\",\n            dst:      make([]float64, 5),\n            l:        math.Inf(1),\n            u:        math.Inf(1),\n            expected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n        },\n        {\n            name:     \"nan span\",\n            dst:      make([]float64, 5),\n            l:        math.NaN(),\n            u:        math.NaN(),\n            expected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n        },\n        {\n            name:     \"short dst length\",\n            dst:      make([]float64, 1),\n            l:        0,\n            u:        10,\n            wantPanic: true,\n        },\n    }\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            defer func() {\n                r := recover()\n                if test.wantPanic && r == nil {\n                    t.Errorf(\"Span() did not panic\")\n                } else if !test.wantPanic && r != nil {\n                    t.Errorf(\"Span() panicked: %v\", r)\n                }\n            }()\n\n            got := Span(test.dst, test.l, test.u)\n            if !EqualFunc(got, test.expected, func(a, b float64) bool {\n                return math.Abs(a-b) < 1e-10\n            }) {\n                t.Errorf(\"Span() = %v, want %v\", got, test.expected)\n            }\n        })\n    }\n}",
    "bd09c4b3139e4799017cb559fa235589": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative range\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    -5.0,\n\t\t\tu:    5.0,\n\t\t\twant: []float64{-5.0, -2.5, 0.0, 2.5, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Infinite start\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Infinite end\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Infinite both\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(-1), -math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN start\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN end\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:      \"Dst length less than 2\",\n\t\t\tdst:       make([]float64, 1),\n\t\t\tl:         0.0,\n\t\t\tu:         10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c219c9759b2b913ab17a36a30c8a5282": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tslices [][]float64\n\t\twant   bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\tslices: [][]float64{},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"all slices have equal length\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}},\n\t\t\twant:   true,\n\t\t},\n\t\t{\n\t\t\tname:   \"some slices have different lengths\",\n\t\t\tslices: [][]float64{{1.0, 2.0}, {3.0, 4.0, 5.0}, {6.0}},\n\t\t\twant:   false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualLengths(tc.slices...)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, want %v\", tc.slices, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "bfda35f3c18a5baeca503393dbab6526": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"valid input\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, 5.0)\n\t\tassert.Equal(t, []float64{1.0, 2.0, 3.0, 4.0, 5.0}, result)\n\t})\n\n\tt.Run(\"with NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.NaN(), 5.0)\n\t\tassert.True(t, math.IsNaN(result[0]))\n\t\tassert.Equal(t, 5.0, result[len(result)-1])\n\t})\n\n\tt.Run(\"with NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, math.NaN())\n\t\tassert.Equal(t, 1.0, result[0])\n\t\tassert.True(t, math.IsNaN(result[len(result)-1]))\n\t})\n\n\tt.Run(\"with positive Inf lower and upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(1), math.Inf(1))\n\t\tassert.Equal(t, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}, result)\n\t})\n\n\tt.Run(\"with positive Inf lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, math.Inf(1), 5.0)\n\t\tassert.Equal(t, []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0}, result)\n\t})\n\n\tt.Run(\"with positive Inf upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tresult := Span(dst, 1.0, math.Inf(1))\n\t\tassert.Equal(t, []float64{1.0, 1.0, 1.0, 1.0, math.Inf(1)}, result)\n\t})\n\n\tt.Run(\"with length less than 2\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tassert.Panics(t, func() {\n\t\t\tSpan(dst, 1.0, 5.0)\n\t\t})\n\t})\n}",
    "bd0baf941d695935d5dc6dc476aff106": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        3,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        3,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with l == u\",\n\t\t\tn:        3,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with n odd and v not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with n odd and v Inf with opposite sign to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with n even and v Inf with opposite sign to l\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf and v == l\",\n\t\t\tn:        3,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf and v == u\",\n\t\t\tn:        3,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf and l < u\",\n\t\t\tn:        3,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf and l > u\",\n\t\t\tn:        3,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u and v < l\",\n\t\t\tn:        3,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u and v > u\",\n\t\t\tn:        3,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u and v > l\",\n\t\t\tn:        3,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u and v < u\",\n\t\t\tn:        3,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"typical case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0edc28b0bb8ad039cd83dc2899be0c1": "package floats\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\ts        []float64\n\t\tt        []float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"Equal lengths\",\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\tt:        []float64{7, 8, 9},\n\t\t\texpected: []float64{28, 40, 54},\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Unequal lengths\",\n\t\t\tdst:      []float64{1, 2, 3},\n\t\t\ts:        []float64{4, 5},\n\t\t\tt:        []float64{7, 8, 9},\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Dst length mismatch\",\n\t\t\tdst:      []float64{1, 2},\n\t\t\ts:        []float64{4, 5, 6},\n\t\t\tt:        []float64{7, 8, 9},\n\t\t\texpected: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) did not panic as expected\", tc.dst, tc.s, tc.t)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) panicked: %v\", tc.dst, tc.s, tc.t, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tc.dst, tc.s, tc.t)\n\t\t\tif !Equal(got, tc.expected) {\n\t\t\t\tt.Errorf(\"MulTo(%v, %v, %v) = %v, want %v\", tc.dst, tc.s, tc.t, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c245931e3d9384bd8814b85c1d7c28c5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      1.0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"NaN value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"positive infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"negative infinity\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0},\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"nearest value\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:      3.1,\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"nearest value at the end\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:      4.9,\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"nearest value at the beginning\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:      1.1,\n\t\t\texpect: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdx(tc.s, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c0ec03dca8cd07a84c9284fb4860376c": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v equals l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v equals u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c44e095c6325fd9ca41dd7c3957a9234": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tslices   [][]float64\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"all slices have equal length\",\n\t\t\tslices:   [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"slices have different lengths\",\n\t\t\tslices:   [][]float64{{1.0, 2.0, 3.0}, {4.0, 5.0}, {7.0, 8.0, 9.0, 10.0}},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tslices:   [][]float64{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"single slice\",\n\t\t\tslices:   [][]float64{{1.0, 2.0, 3.0}},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := EqualLengths(tc.slices...)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"EqualLengths(%v) = %v, expected %v\", tc.slices, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c4347345bb3b757aabbc440dd959adf5": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"positive values\",\n\t\t\ts:    []float64{1, 3, 2, 4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\ts:    []float64{-1, -3, -2, -4, -5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{1, -3, 2, -4, 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"with NaN\",\n\t\t\ts:    []float64{1, 3, 2, math.NaN(), 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c50cc8843b4580e570dbf84f66a3386f": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinds   []int\n\t\tf      func(float64) bool\n\t\ts      []float64\n\t\tk      int\n\t\twant   []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:   \"find first 2 elements greater than 3\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 3 },\n\t\t\ts:      []float64{1, 2, 4, 5, 6, 7},\n\t\t\tk:      2,\n\t\t\twant:   []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find all elements greater than 3\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 3 },\n\t\t\ts:      []float64{1, 2, 4, 5, 6, 7},\n\t\t\tk:      -1,\n\t\t\twant:   []int{2, 3, 4, 5},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"find no elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 10 },\n\t\t\ts:      []float64{1, 2, 4, 5, 6, 7},\n\t\t\tk:      2,\n\t\t\twant:   []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"find zero elements\",\n\t\t\tinds:   []int{},\n\t\t\tf:      func(x float64) bool { return x > 3 },\n\t\t\ts:      []float64{1, 2, 4, 5, 6, 7},\n\t\t\tk:      0,\n\t\t\twant:   []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c36fad062905512cad6644b00bea6fb9": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        -1,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (l, u)\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is within (u, l)\",\n\t\t\tn:        5,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c63de35547795507c7e26f34c81f2123": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\tt.Run(\"Equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3, 4, 5}\n\t\ts := []float64{0.5, 1, 1.5, 2, 2.5}\n\t\texpected := []float64{0.5, 1, 1.5, 2, 2.5}\n\n\t\tSub(dst, s)\n\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"Mismatched length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3, 4, 5}\n\t\ts := []float64{0.5, 1, 1.5, 2}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Sub() did not panic with mismatched slice lengths\")\n\t\t\t}\n\t\t}()\n\t\tSub(dst, s)\n\t})\n}",
    "c319c9163393d0f1a232cc36990f80f8": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n    tests := []struct {\n        name    string\n        dst     []float64\n        l, u    float64\n        want    []float64\n        wantErr bool\n    }{\n        {\n            name: \"basic case\",\n            dst:  make([]float64, 5),\n            l:    0.0,\n            u:    10.0,\n            want: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n        },\n        {\n            name: \"empty destination\",\n            dst:  make([]float64, 0),\n            l:    0.0,\n            u:    10.0,\n            wantErr: true,\n        },\n        {\n            name: \"single element destination\",\n            dst:  make([]float64, 1),\n            l:    0.0,\n            u:    10.0,\n            wantErr: true,\n        },\n        {\n            name: \"l is NaN\",\n            dst:  make([]float64, 5),\n            l:    math.NaN(),\n            u:    10.0,\n            want: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n        },\n        {\n            name: \"u is NaN\",\n            dst:  make([]float64, 5),\n            l:    0.0,\n            u:    math.NaN(),\n            want: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n        },\n        {\n            name: \"l and u are Inf\",\n            dst:  make([]float64, 5),\n            l:    math.Inf(-1),\n            u:    math.Inf(1),\n            want: []float64{math.Inf(-1), -math.Inf, 0.0, math.Inf, math.Inf(1)},\n        },\n        {\n            name: \"l is Inf\",\n            dst:  make([]float64, 5),\n            l:    math.Inf(-1),\n            u:    10.0,\n            want: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n        },\n        {\n            name: \"u is Inf\",\n            dst:  make([]float64, 5),\n            l:    0.0,\n            u:    math.Inf(1),\n            want: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := Span(tt.dst, tt.l, tt.u)\n            if !Equal(got, tt.want) {\n                t.Errorf(\"Span() = %v, want %v\", got, tt.want)\n            }\n            if (len(got) < 2) != tt.wantErr {\n                t.Errorf(\"Span() error = %v, wantErr %v\", len(got) < 2, tt.wantErr)\n            }\n        })\n    }\n}",
    "c68f0eeab1152e158103052b21dc3f6f": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\tt.Run(\"Equal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5, 6}\n\t\texpected := []float64{4, 10, 18}\n\n\t\tMul(dst, s)\n\n\t\tif !Equal(dst, expected) {\n\t\t\tt.Errorf(\"Mul(%v, %v) = %v, want %v\", dst, s, dst, expected)\n\t\t}\n\t})\n\n\tt.Run(\"Unequal length slices\", func(t *testing.T) {\n\t\tdst := []float64{1, 2, 3}\n\t\ts := []float64{4, 5}\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Mul(%v, %v) did not panic\", dst, s)\n\t\t\t}\n\t\t}()\n\t\tMul(dst, s)\n\t})\n}",
    "c66f332326724bc488067fc1ae2dee45": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tl      float64\n\t\tu      float64\n\t\tdst    []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Basic\",\n\t\t\tl:      1.0,\n\t\t\tu:      100.0,\n\t\t\tdst:    make([]float64, 5),\n\t\t\texpect: []float64{1.0, 4.64, 21.54, 46.42, 100.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"Zero Range\",\n\t\t\tl:      0.0,\n\t\t\tu:      0.0,\n\t\t\tdst:    make([]float64, 5),\n\t\t\texpect: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"Negative Range\",\n\t\t\tl:      -100.0,\n\t\t\tu:      -1.0,\n\t\t\tdst:    make([]float64, 5),\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"Dst Length < 2\",\n\t\t\tl:      1.0,\n\t\t\tu:      100.0,\n\t\t\tdst:    make([]float64, 1),\n\t\t\texpect: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := LogSpan(test.dst, test.l, test.u)\n\t\t\tif !reflect.DeepEqual(got, test.expect) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, expect %v\", got, test.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c5390b0747a0390f595f5a93fd3be797": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"regular case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 9),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 0.0, 0.0, 0.0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(result, tc.expected, 1e-10) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c424d8a35f7c8b05e45733b34ada50f6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2 panics\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not NaN\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf, n is odd, v is not Inf\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.5,\n\t\t\twant:   5,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf, n is odd, v is -Inf\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf, n is odd, v is +Inf\",\n\t\t\tn:      11,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   6,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf, n is even, v is -Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf, n is even, v is +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   5,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, v == l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf, v == u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v <= l\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      -0.1,\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v >= u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      1.1,\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v >= l\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      1.1,\n\t\t\twant:   0,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v <= u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      -0.1,\n\t\t\twant:   9,\n\t\t\twantPanic: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   5,\n\t\t\twantPanic: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked unexpectedly: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c70bd4226e4382659ab756194d226ddb": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid input\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        2.5,\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value less than first element\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        0.5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value greater than or equal to last element\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        5.0,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is NaN\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"input slice length less than 2\",\n\t\t\ts:        []float64{1},\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"input slice not sorted\",\n\t\t\ts:        []float64{5, 2, 4, 1, 3},\n\t\t\tv:        2.5,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tc.s) {\n\t\t\t\t// Sort the input slice if it's not sorted\n\t\t\t\tsort.Float64s(tc.s)\n\t\t\t}\n\n\t\t\tidx := Within(tc.s, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %d, expected %d\", tc.s, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c67238fc1cdc7f32abd6e8a9759afd8f": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantOk bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"with NaN u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf l and u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf l\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"with +Inf u\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t\twantOk: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   nil,\n\t\t\twantOk: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif (got == nil) != !tt.wantOk {\n\t\t\t\tt.Errorf(\"Span() returned %v, want %v\", got == nil, tt.wantOk)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c84004bbf3a69183c622f48e660f5b13": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n    testCases := []struct {\n        name     string\n        s        []float64\n        t        []float64\n        L        float64\n        expected float64\n    }{\n        {\n            name:     \"Equal slices, L=2\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{1, 2, 3},\n            L:        2,\n            expected: 0,\n        },\n        {\n            name:     \"Different slices, L=2\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        2,\n            expected: math.Sqrt(27),\n        },\n        {\n            name:     \"Equal slices, L=1\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{1, 2, 3},\n            L:        1,\n            expected: 0,\n        },\n        {\n            name:     \"Different slices, L=1\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        1,\n            expected: 9,\n        },\n        {\n            name:     \"Equal slices, L=inf\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{1, 2, 3},\n            L:        math.Inf(1),\n            expected: 0,\n        },\n        {\n            name:     \"Different slices, L=inf\",\n            s:        []float64{1, 2, 3},\n            t:        []float64{4, 5, 6},\n            L:        math.Inf(1),\n            expected: 3,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := Distance(tc.s, tc.t, tc.L)\n            if result != tc.expected {\n                t.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, result, tc.expected)\n            }\n        })\n    }\n\n    t.Run(\"Panic on mismatched lengths\", func(t *testing.T) {\n        defer func() {\n            if r := recover(); r == nil {\n                t.Errorf(\"Distance did not panic on mismatched lengths\")\n            }\n        }()\n        Distance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n    })\n}",
    "ca0939efcf7f3a8da4f08dbb68580e05": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n    tests := []struct {\n        name  string\n        s     []float64\n        t     []float64\n        want  bool\n        wantN int\n    }{\n        {\n            name:  \"equal lengths and values\",\n            s:     []float64{1.0, 2.0, 3.0},\n            t:     []float64{1.0, 2.0, 3.0},\n            want:  true,\n            wantN: 3,\n        },\n        {\n            name:  \"different lengths\",\n            s:     []float64{1.0, 2.0, 3.0},\n            t:     []float64{1.0, 2.0},\n            want:  false,\n            wantN: 2,\n        },\n        {\n            name:  \"different values\",\n            s:     []float64{1.0, 2.0, 3.0},\n            t:     []float64{1.0, 2.0, 4.0},\n            want:  false,\n            wantN: 3,\n        },\n        {\n            name:  \"NaN values\",\n            s:     []float64{1.0, math.NaN(), 3.0},\n            t:     []float64{1.0, math.NaN(), 3.0},\n            want:  true,\n            wantN: 3,\n        },\n        {\n            name:  \"empty slices\",\n            s:     []float64{},\n            t:     []float64{},\n            want:  true,\n            wantN: 0,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            if got := Same(tt.s, tt.t); got != tt.want {\n                t.Errorf(\"Same(%v, %v) = %v, want %v\", tt.s, tt.t, got, tt.want)\n            }\n            if len(tt.s) != tt.wantN || len(tt.t) != tt.wantN {\n                t.Errorf(\"Lengths of input slices do not match expected: got %d, %d; want %d, %d\", len(tt.s), len(tt.t), tt.wantN, tt.wantN)\n            }\n        })\n    }\n}",
    "ca5c8d4320f117c218de35798e287ba6": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    tests := []struct {\n        name     string\n        n        int\n        l, u, v  float64\n        expected int\n    }{\n        {\"n < 2 panics\", 1, 0, 1, 0, 0},\n        {\"NaN value\", 10, 0, 1, math.NaN(), 0},\n        {\"l is NaN, u is finite\", 10, math.NaN(), 1, 0.5, 9},\n        {\"u is NaN\", 10, 0, math.NaN(), 0.5, 0},\n        {\"l and u are Inf and equal\", 11, math.Inf(-1), math.Inf(1), 0, 0},\n        {\"l and u are Inf and n is odd\", 11, math.Inf(-1), math.Inf(1), 1, 5},\n        {\"l and u are Inf and n is even\", 10, math.Inf(-1), math.Inf(1), 1, 5},\n        {\"l is Inf\", 10, math.Inf(-1), 1, 0, 0},\n        {\"u is Inf\", 10, 0, math.Inf(1), 1, 9},\n        {\"v is -Inf and l < u\", 10, 0, 1, math.Inf(-1), 0},\n        {\"v is -Inf and l > u\", 10, 1, 0, math.Inf(-1), 9},\n        {\"v is +Inf and l < u\", 10, 0, 1, math.Inf(1), 9},\n        {\"v is +Inf and l > u\", 10, 1, 0, math.Inf(1), 0},\n        {\"v is in the middle\", 10, 0, 1, 0.5, 5},\n    }\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            got := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n            if got != test.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\",\n                    test.n, test.l, test.u, test.v, got, test.expected)\n            }\n        })\n    }\n}",
    "c9072aa3fc2774f4553a579a976d9871": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length < 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want panic=%v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c9a488ed3661683813cdc9acf0983fe4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdst  []float64\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"length 2\",\n\t\t\tdst:  make([]float64, 2),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: []float64{0.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"length 1 (panics)\",\n\t\t\tdst:  make([]float64, 1),\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\tdst:  make([]float64, 6),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(-1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    10.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\tdst:  make([]float64, 5),\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "c6e905e1ad53e35ccd01273d9f1d7878": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"n < 2\",\n\t\t\tn:     1,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN v\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN l\",\n\t\t\tn:     10,\n\t\t\tl:     math.NaN(),\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Inf l and u, odd n\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0,\n\t\t\twant:  2,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Inf l and u, even n\",\n\t\t\tn:     6,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0,\n\t\t\twant:  3,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Inf l\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"Inf u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v < l\",\n\t\t\tn:     10,\n\t\t\tl:     0.5,\n\t\t\tu:     1,\n\t\t\tv:     0.1,\n\t\t\twant:  0,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v > u\",\n\t\t\tn:     10,\n\t\t\tl:     0.5,\n\t\t\tu:     1,\n\t\t\tv:     1.1,\n\t\t\twant:  9,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v between l and u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v between u and l\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tt.n, tt.l, tt.u, tt.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb50929c3d31ad17a3f460bf88000ad7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tinput []float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\tinput: []float64{},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\tinput: []float64{1.0},\n\t\t\texpected: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive elements\",\n\t\t\tinput: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\texpected: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\tinput: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\texpected: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed elements\",\n\t\t\tinput: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\texpected: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\tinput: []float64{1e-20, 1e-20, 1e-20, 1e-20, 1e-20},\n\t\t\texpected: 5e-20,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\tinput: []float64{1e20, 1e20, 1e20, 1e20, 1e20},\n\t\t\texpected: 5e20,\n\t\t},\n\t\t{\n\t\t\tname: \"nan and inf\",\n\t\t\tinput: []float64{math.NaN(), math.Inf(1), math.Inf(-1), 1.0, -1.0},\n\t\t\texpected: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.input)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.input, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb2f4ecce6f8ce30d05a1cb5dedc4149": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n    testCases := []struct {\n        name string\n        s    []float64\n        v    float64\n        want int\n    }{\n        {\n            name: \"basic case\",\n            s:    []float64{1, 2, 3, 4, 5},\n            v:    2.5,\n            want: 1,\n        },\n        {\n            name: \"value at start\",\n            s:    []float64{1, 2, 3, 4, 5},\n            v:    1,\n            want: 0,\n        },\n        {\n            name: \"value at end\",\n            s:    []float64{1, 2, 3, 4, 5},\n            v:    5,\n            want: 4,\n        },\n        {\n            name: \"value above range\",\n            s:    []float64{1, 2, 3, 4, 5},\n            v:    6,\n            want: -1,\n        },\n        {\n            name: \"value below range\",\n            s:    []float64{1, 2, 3, 4, 5},\n            v:    0,\n            want: -1,\n        },\n        {\n            name: \"NaN value\",\n            s:    []float64{1, 2, 3, 4, 5},\n            v:    math.NaN(),\n            want: -1,\n        },\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            v:    2.5,\n            want: -1,\n        },\n        {\n            name: \"unsorted slice\",\n            s:    []float64{5, 2, 4, 1, 3},\n            v:    2.5,\n            want: -1,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := Within(tc.s, tc.v)\n            if got != tc.want {\n                t.Errorf(\"Within(%v, %v) = %d, want %d\", tc.s, tc.v, got, tc.want)\n            }\n        })\n    }\n}",
    "cba9f4ddaeffe47ca5b276cb857f5a91": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2.0,\n\t\t\twant: 0.0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    2.0,\n\t\t\twant: math.Sqrt(14.0),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    1.0,\n\t\t\twant: 6.0,\n\t\t},\n\t\t{\n\t\t\tname: \"max norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"general Lp norm\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\tL:    3.0,\n\t\t\twant: math.Pow(14.0, 1.0/3.0),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := Norm(test.s, test.L)\n\t\t\tif math.Abs(got-test.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", test.s, test.L, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cb535218c3f70cf84aad141358af65fc": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n    testCases := []struct {\n        name   string\n        s      []float64\n        t      []float64\n        L      float64\n        expect float64\n    }{\n        {\n            name:   \"Equal slices\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{1, 2, 3},\n            L:      2,\n            expect: 0,\n        },\n        {\n            name:   \"Unequal slices\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6, 7},\n            L:      2,\n            expect: math.Sqrt(27),\n        },\n        {\n            name:   \"Empty slices\",\n            s:      []float64{},\n            t:      []float64{},\n            L:      2,\n            expect: 1,\n        },\n        {\n            name:   \"L1 norm\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6},\n            L:      1,\n            expect: 9,\n        },\n        {\n            name:   \"L-inf norm\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6},\n            L:      math.Inf(1),\n            expect: 3,\n        },\n        {\n            name:   \"General L-norm\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6},\n            L:      3,\n            expect: math.Pow(14, 1/3),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := Distance(tc.s, tc.t, tc.L)\n            if got != tc.expect {\n                t.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.expect)\n            }\n        })\n    }\n}",
    "cad7b02fd7a43024f9e31aaa000ba4d7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2 should panic\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:        4,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (l, u), l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is inside (u, l), l > u\",\n\t\t\tn:        5,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd2551357bf5a4761b1d93b27199cd8e": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 42.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\ts:    []float64{1e100, 1e100, -1e100, -1e100},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\ts:    []float64{1e-100, 1e-100, -1e-100, -1e-100},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\ts:    []float64{1e100, 1e-100, -1e100, -1e-100},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\ts:    []float64{1.0, math.NaN(), 2.0},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := SumCompensated(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"SumCompensated(%v) = %v, want %v\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cec8ccef0f30afa2aa52c89fdd1aaf3a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tL        float64\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tL:        2,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"L = 1\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        1,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"L = 2\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        2,\n\t\t\texpected: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname:     \"L = Inf\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        math.Inf(1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"L = 3\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tL:        3,\n\t\t\texpected: math.Pow(1+8+27, 1.0/3),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif !floatEqual(got, tc.expected) {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) < 1e-10\n}",
    "cd1af6b4b2cac1a9911a1fa1e5f63565": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"valid input\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\tn:    1,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    10.0,\n\t\t\tv:    5.0,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    5.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with the same sign\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.0,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:    9,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.0,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0.0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    0.0,\n\t\t\tu:    10.0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    10.0,\n\t\t\tu:    0.0,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cbb8d4e698be7f05734f9a6261da1335": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic case\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty dst\",\n\t\t\tdst:      make([]float64, 0),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"single element dst\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: nil, // should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expected == nil {\n\t\t\t\t\t\treturn // expected to panic\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !Equal(result, test.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cd59b1cd0bb3ec2ddb479fb44184b611": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n    testCases := []struct {\n        name   string\n        s      []float64\n        t      []float64\n        L      float64\n        want   float64\n        wantPanic bool\n    }{\n        {\n            name:   \"equal slices, L=2\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{1, 2, 3},\n            L:      2,\n            want:   0,\n        },\n        {\n            name:   \"different slices, L=2\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6},\n            L:      2,\n            want:   5.196152422706632,\n        },\n        {\n            name:   \"L=1\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6},\n            L:      1,\n            want:   9,\n        },\n        {\n            name:   \"L=inf\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5, 6},\n            L:      math.Inf(1),\n            want:   3,\n        },\n        {\n            name:   \"different length slices\",\n            s:      []float64{1, 2, 3},\n            t:      []float64{4, 5},\n            L:      2,\n            wantPanic: true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            var got float64\n            defer func() {\n                if r := recover(); r != nil {\n                    if !tc.wantPanic {\n                        t.Errorf(\"Distance(%v, %v, %v) panicked: %v\", tc.s, tc.t, tc.L, r)\n                    }\n                } else {\n                    if tc.wantPanic {\n                        t.Errorf(\"Distance(%v, %v, %v) did not panic\", tc.s, tc.t, tc.L)\n                    } else if math.Abs(got-tc.want) > 1e-10 {\n                        t.Errorf(\"Distance(%v, %v, %v) = %v, want %v\", tc.s, tc.t, tc.L, got, tc.want)\n                    }\n                }\n            }()\n\n            got = Distance(tc.s, tc.t, tc.L)\n        })\n    }\n}",
    "cf3d2ac834f186c8f0097e850e7bbbbe": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts1      []float64\n\t\ts2      []float64\n\t\tf       func(float64, float64) bool\n\t\twant    bool\n\t}{\n\t\t{\n\t\t\tname:    \"equal slices\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.0},\n\t\t\tf:       func(a, b float64) bool { return a == b },\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"different lengths\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0},\n\t\t\tf:       func(a, b float64) bool { return a == b },\n\t\t\twant:    false,\n\t\t},\n\t\t{\n\t\t\tname:    \"different elements\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.1, 3.0},\n\t\t\tf:       func(a, b float64) bool { return a == b },\n\t\t\twant:    false,\n\t\t},\n\t\t{\n\t\t\tname:    \"equal with tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.01, 3.0},\n\t\t\tf:       func(a, b float64) bool { return a-b < 0.02 },\n\t\t\twant:    true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.s1, tt.s2, tt.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ced77cd244892a4bc6b7d487dd1b6d4a": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tc      float64\n\t\ts      []float64\n\t\twant   []float64\n\t\twantPa bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{8, 10, 12},\n\t\t\twantPa: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   nil,\n\t\t\twantPa: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty dst\",\n\t\t\tdst:    []float64{},\n\t\t\tc:      2,\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{},\n\t\t\twantPa: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty s\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\tc:      2,\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{0, 0, 0},\n\t\t\twantPa: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPa {\n\t\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) panicked: %v\", tt.dst, tt.c, tt.s, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := ScaleTo(tt.dst, tt.c, tt.s)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo(%v, %v, %v) = %v, want %v\", tt.dst, tt.c, tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d00820bb1a4bd89672dcb2c82326bc12": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n    t.Run(\"valid inputs\", func(t *testing.T) {\n        dst := []float64{1, 2, 3}\n        s := []float64{4, 5, 6}\n        expected := []float64{4, 10, 18}\n\n        Mul(dst, s)\n\n        for i, v := range dst {\n            if v != expected[i] {\n                t.Errorf(\"dst[%d] = %v, expected %v\", i, v, expected[i])\n            }\n        }\n    })\n\n    t.Run(\"mismatched lengths\", func(t *testing.T) {\n        dst := []float64{1, 2, 3}\n        s := []float64{4, 5}\n        defer func() {\n            if r := recover(); r == nil {\n                t.Errorf(\"Mul did not panic with mismatched lengths\")\n            }\n        }()\n        Mul(dst, s)\n    })\n}",
    "cee9aea2c702fc18ba210f59a68d56ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"length less than 2\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(-1), -math.Inf, math.Inf, -math.Inf, math.Inf(1)},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.panics {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tt.dst, tt.l, tt.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cdbdf12b54f31cf75f3fe8b5f104b1b6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"dst length less than 2\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(+1),\n\t\t\tu:        math.Inf(+1),\n\t\t\texpected: []float64{math.Inf(+1), math.Inf(+1), 0.0, math.Inf(+1), math.Inf(+1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(+1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(+1), math.Inf(+1), math.Inf(+1), math.Inf(+1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(+1),\n\t\t\texpected: []float64{0.0, math.Inf(+1), math.Inf(+1), math.Inf(+1), math.Inf(+1)},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != test.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked unexpectedly: %v\", test.dst, test.l, test.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(test.dst, test.l, test.u)\n\t\t\tif !EqualFunc(result, test.expected, func(a, b float64) bool {\n\t\t\t\treturn math.IsNaN(a) && math.IsNaN(b) || math.Abs(a-b) < 1e-14\n\t\t\t}) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", test.dst, test.l, test.u, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfc03b5acebd84a7b4d5789bde286391": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find first k elements satisfying f\",\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find no elements satisfying f\",\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find zero elements\",\n\t\t\tinds:    nil,\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{},\n\t\t\tk:       0,\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d03fbbedb07ba59353ee3aa2469554c4": "package floats\n\nimport (\n    \"reflect\"\n    \"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n    tests := []struct {\n        name   string\n        inds   []int\n        f      func(float64) bool\n        s      []float64\n        k      int\n        want   []int\n        wantErr bool\n    }{\n        {\n            name: \"Find all elements satisfying the condition\",\n            inds: []int{},\n            f:    func(x float64) bool { return x > 0 },\n            s:    []float64{-1, 0, 1, 2, 3},\n            k:    -1,\n            want: []int{2, 3, 4},\n        },\n        {\n            name: \"Find the first k elements satisfying the condition\",\n            inds: []int{},\n            f:    func(x float64) bool { return x > 0 },\n            s:    []float64{-1, 0, 1, 2, 3},\n            k:    2,\n            want: []int{2, 3},\n        },\n        {\n            name: \"No elements found\",\n            inds: []int{},\n            f:    func(x float64) bool { return x > 10 },\n            s:    []float64{-1, 0, 1, 2, 3},\n            k:    2,\n            want: []int{},\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := Find(tt.inds, tt.f, tt.s, tt.k)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            if !reflect.DeepEqual(got, tt.want) {\n                t.Errorf(\"Find() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}",
    "d21d94f17836ef34ef6e24fe8f5c1794": "package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tslices  [][]float64\n\t\twant    bool\n\t}{\n\t\t{\n\t\t\tname:    \"all slices have equal length\",\n\t\t\tslices:  [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"slices have different lengths\",\n\t\t\tslices:  [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n\t\t\twant:    false,\n\t\t},\n\t\t{\n\t\t\tname:    \"no input slices\",\n\t\t\tslices:  [][]float64{},\n\t\t\twant:    true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single slice\",\n\t\t\tslices:  [][]float64{{1, 2, 3}},\n\t\t\twant:    true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1e51f3ebef2601345a50316d8222b28": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n    tests := []struct {\n        name string\n        s    []float64\n        want float64\n    }{\n        {\n            name: \"basic case\",\n            s:    []float64{1.0, 2.0, 3.0},\n            want: 3.4076,\n        },\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            want: math.NaN(),\n        },\n        {\n            name: \"all zeros\",\n            s:    []float64{0.0, 0.0, 0.0},\n            want: math.Log(3.0),\n        },\n        {\n            name: \"all negatives\",\n            s:    []float64{-1.0, -2.0, -3.0},\n            want: -0.6931,\n        },\n        {\n            name: \"mix of positives and negatives\",\n            s:    []float64{1.0, -2.0, 3.0},\n            want: 3.4076,\n        },\n        {\n            name: \"all infinities\",\n            s:    []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n            want: math.Inf(1),\n        },\n        {\n            name: \"mix of finites and infinities\",\n            s:    []float64{1.0, math.Inf(1), 3.0},\n            want: math.Inf(1),\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got := LogSumExp(tt.s)\n            if !EqualApprox([]float64{got}, []float64{tt.want}, 1e-4) {\n                t.Errorf(\"LogSumExp(%v) = %v, want %v\", tt.s, got, tt.want)\n            }\n        })\n    }\n}",
    "d3f731fcec5e030b686db890c77b0152": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\ts        []float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\ts:        []float64{},\n\t\t\tv:        0,\n\t\t\texpected: 0, // Should panic\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN input\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"positive infinity input\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative infinity input\",\n\t\t\ts:        []float64{1, 2, 3},\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest index\",\n\t\t\ts:        []float64{1, 2, 3, 4, 5},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nearest index with multiple equal values\",\n\t\t\ts:        []float64{1, 2, 3, 3, 4},\n\t\t\tv:        3.2,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif test.expected == 0 {\n\t\t\t\t\t\t// Expected panic\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := NearestIdx(test.s, test.v)\n\t\t\tif idx != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %f) = %d, expected %d\", test.s, test.v, idx, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d2d4683e15ed6c7820e9cc788de1ae6c": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinds     []int\n\t\tf        func(float64) bool\n\t\ts        []float64\n\t\tk        int\n\t\texpected []int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Find first k elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tk:        2,\n\t\t\texpected: []int{1, 2},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Find all elements\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tk:        -1,\n\t\t\texpected: []int{1, 2, 3, 4},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"No elements found\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 10 },\n\t\t\ts:        []float64{-1.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tk:        2,\n\t\t\texpected: []int{},\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Zero elements requested\",\n\t\t\tinds:     []int{},\n\t\t\tf:        func(x float64) bool { return x > 0 },\n\t\t\ts:        []float64{-1.0, 1.0, 2.0, 3.0, 4.0},\n\t\t\tk:        0,\n\t\t\texpected: []int{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinds, err := Find(tc.inds, tc.f, tc.s, tc.k)\n\t\t\tif (err != nil) != tc.err {\n\t\t\t\tt.Errorf(\"expected error %t, got %v\", tc.err, err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(inds, tc.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tc.expected, inds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "cfbb4651815b01c03980fee9bcea668b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/- Inf, v is 0\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v < l\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v > u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        11.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v > l\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        5.0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v < u\",\n\t\t\tn:        10,\n\t\t\tl:        10.0,\n\t\t\tu:        0.0,\n\t\t\tv:        -1.0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\tv:        5.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d0618cf3772a1cbdb3f414697491934f": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinds        []int\n\t\tf           func(float64) bool\n\t\ts           []float64\n\t\tk           int\n\t\twant        []int\n\t\twantErr     bool\n\t\twantIndsLen int\n\t}{\n\t\t{\n\t\t\tname: \"find first k elements\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:    3,\n\t\t\twant: []int{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:    -1,\n\t\t\twant: []int{2, 3, 4, 5, 6},\n\t\t},\n\t\t{\n\t\t\tname: \"find no elements\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 10 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:    3,\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname:        \"insufficient elements found\",\n\t\t\tinds:        []int{},\n\t\t\tf:           func(x float64) bool { return x > 3 },\n\t\t\ts:           []float64{1, 2, 3, 4, 5},\n\t\t\tk:           6,\n\t\t\twant:        []int{3, 4},\n\t\t\twantErr:     true,\n\t\t\twantIndsLen: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"zero elements requested\",\n\t\t\tinds: []int{},\n\t\t\tf:    func(x float64) bool { return x > 0 },\n\t\t\ts:    []float64{-1, 0, 1, 2, 3, 4, 5},\n\t\t\tk:    0,\n\t\t\twant: []int{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif len(tt.inds) != tt.wantIndsLen {\n\t\t\t\tt.Errorf(\"Find() len(inds) = %v, want %v\", len(tt.inds), tt.wantIndsLen)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d54f36e019297f6ad65085cc8a881991": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\ts1      []float64\n\t\ts2      []float64\n\t\ttol     float64\n\t\twant    bool\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"equal slices\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.0},\n\t\t\ttol:     1e-6,\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"different lengths\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0},\n\t\t\ttol:     1e-6,\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"within absolute tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.001},\n\t\t\ttol:     1e-3,\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"within relative tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.01},\n\t\t\ttol:     0.01,\n\t\t\twant:    true,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"not within tolerance\",\n\t\t\ts1:      []float64{1.0, 2.0, 3.0},\n\t\t\ts2:      []float64{1.0, 2.0, 3.1},\n\t\t\ttol:     1e-3,\n\t\t\twant:    false,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualApprox(tc.s1, tc.s2, tc.tol)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %v, want %v\", tc.s1, tc.s2, tc.tol, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d1ae84045c77da5ac561a7f186238cb5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\tn:    5,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    5,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with same sign\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with different signs, n is odd\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with different signs, n is even\",\n\t\t\tn:    6,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf(-1), v is equal to l\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf(1), v is equal to u\",\n\t\t\tn:    5,\n\t\t\tl:    -1,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(-1), l < u\",\n\t\t\tn:    5,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(1), l < u\",\n\t\t\tn:    5,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(-1), l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(1), l > u\",\n\t\t\tn:    5,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is within (l, u)\",\n\t\t\tn:    5,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is at the boundary (l, u)\",\n\t\t\tn:    5,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    -1,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is at the boundary (l, u)\",\n\t\t\tn:    5,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    1,\n\t\t\twant: 4,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d7391925b9ae35074c2ad1cdf8cee8b0": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\twant   bool\n\t\terrMsg string\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 3.0},\n\t\t\twant:   true,\n\t\t\terrMsg: \"Equal(%v, %v) = %v, want %v\",\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal length\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0},\n\t\t\twant:   false,\n\t\t\terrMsg: \"Equal(%v, %v) = %v, want %v\",\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal elements\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.0, 2.0, 4.0},\n\t\t\twant:   false,\n\t\t\terrMsg: \"Equal(%v, %v) = %v, want %v\",\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts1:     []float64{},\n\t\t\ts2:     []float64{},\n\t\t\twant:   true,\n\t\t\terrMsg: \"Equal(%v, %v) = %v, want %v\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Equal(tt.s1, tt.s2)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(tt.errMsg, tt.s1, tt.s2, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d472e2d93552a6c0dda8754ae8121fc6": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:      \"empty destination\",\n\t\t\tdst:       []float64{},\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"single element destination\",\n\t\t\tdst:       []float64{0},\n\t\t\tl:         0,\n\t\t\tu:         10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"two element destination\",\n\t\t\tdst:    []float64{0, 0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple element destination\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked unexpectedly: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d7b6ea6bd6829ec9f86229042aa6cc5b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n < 2\", args{1, 0, 1, 0.5}, 0},\n\t\t{\"v is NaN\", args{10, 0, 1, math.NaN()}, 0},\n\t\t{\"l is NaN\", args{10, math.NaN(), 1, 0.5}, 9},\n\t\t{\"u is NaN\", args{10, 0, math.NaN(), 0.5}, 1},\n\t\t{\"l and u are Inf, v is Inf\", args{11, math.Inf(-1), math.Inf(1), math.Inf(1)}, 10},\n\t\t{\"l and u are Inf, v is -Inf\", args{11, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"l is Inf, v is l\", args{10, math.Inf(-1), 1, math.Inf(-1)}, 0},\n\t\t{\"u is Inf, v is u\", args{10, 0, math.Inf(1), math.Inf(1)}, 9},\n\t\t{\"v is -Inf, l < u\", args{10, 0, 1, math.Inf(-1)}, 0},\n\t\t{\"v is Inf, l < u\", args{10, 0, 1, math.Inf(1)}, 9},\n\t\t{\"v is -Inf, l > u\", args{10, 1, 0, math.Inf(-1)}, 9},\n\t\t{\"v is Inf, l > u\", args{10, 1, 0, math.Inf(1)}, 0},\n\t\t{\"normal case\", args{10, 0, 1, 0.5}, 5},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d54d5f470d5f7010a1f68fb43aacbcd4": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, n is even, v is +Inf\",\n\t\t\tn:        6,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, v is l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is -Inf, v is u\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is -Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is +Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "db0efa97eac5aa38beace3d862c72995": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n    testCases := []struct {\n        name     string\n        n        int\n        l        float64\n        u        float64\n        v        float64\n        expected int\n    }{\n        {\"n < 2\", 1, 0, 1, 0.5, 0},\n        {\"v is NaN\", 10, 0, 1, math.NaN(), 0},\n        {\"l is NaN, u is not\", 10, math.NaN(), 1, 0.5, 9},\n        {\"u is NaN\", 10, 0, math.NaN(), 0.5, 0},\n        {\"l and u are Inf and equal\", 5, math.Inf(1), math.Inf(1), 0.5, 0},\n        {\"l and u are Inf and different, n is odd\", 5, math.Inf(-1), math.Inf(1), 0, 2},\n        {\"l and u are Inf and different, n is even\", 6, math.Inf(-1), math.Inf(1), 0, 3},\n        {\"l is Inf\", 5, math.Inf(-1), 1, 0, 0},\n        {\"u is Inf\", 5, 0, math.Inf(1), 1, 4},\n        {\"v is -Inf, l < u\", 5, 0, 1, math.Inf(-1), 0},\n        {\"v is Inf, l < u\", 5, 0, 1, math.Inf(1), 4},\n        {\"v is -Inf, l > u\", 5, 1, 0, math.Inf(-1), 4},\n        {\"v is Inf, l > u\", 5, 1, 0, math.Inf(1), 0},\n        {\"normal case\", 5, 0, 1, 0.5, 2},\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n            if got != tc.expected {\n                t.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n            }\n        })\n    }\n}",
    "dc352efe1934cd3627e87fc74681474a": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    []float64\n        expected int\n    }{\n        {\n            name:     \"empty slice\",\n            input:    []float64{},\n            expected: 0,\n        },\n        {\n            name:     \"single element slice\",\n            input:    []float64{42.0},\n            expected: 0,\n        },\n        {\n            name:     \"multiple elements, maximum at beginning\",\n            input:    []float64{100.0, 50.0, 75.0},\n            expected: 0,\n        },\n        {\n            name:     \"multiple elements, maximum at end\",\n            input:    []float64{50.0, 75.0, 100.0},\n            expected: 2,\n        },\n        {\n            name:     \"multiple elements, maximum in middle\",\n            input:    []float64{50.0, 100.0, 75.0},\n            expected: 1,\n        },\n        {\n            name:     \"multiple elements, with NaNs\",\n            input:    []float64{50.0, math.NaN(), 100.0, 75.0},\n            expected: 2,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := MaxIdx(tc.input)\n            if result != tc.expected {\n                t.Errorf(\"MaxIdx(%v) = %d, expected %d\", tc.input, result, tc.expected)\n            }\n        })\n    }\n\n    // Test that MaxIdx panics on an empty slice\n    defer func() {\n        if r := recover(); r == nil {\n            t.Errorf(\"MaxIdx([]float64{}) did not panic\")\n        }\n    }()\n    MaxIdx([]float64{})\n}",
    "d8099fc547bc3e0cba409e34e0be5d49": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid range\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"negative range\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      -10,\n\t\t\tu:      0,\n\t\t\twant:   []float64{-10, -7.5, -5, -2.5, 0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"zero length dst\",\n\t\t\tdst:    make([]float64, 0),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.panics {\n\t\t\t\t\tt.Errorf(\"Span(%v, %f, %f) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d91536c4291955fa1cb968ab179e0f7a": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tn            int\n\t\tl, u, v      float64\n\t\texpectedIdx  int\n\t\tshouldPanic  bool\n\t}{\n\t\t{\n\t\t\tname:         \"n < 2\",\n\t\t\tn:            1,\n\t\t\tl:            0,\n\t\t\tu:            1,\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"v is NaN\",\n\t\t\tn:            10,\n\t\t\tl:            0,\n\t\t\tu:            1,\n\t\t\tv:            math.NaN(),\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"l is NaN, u is not NaN\",\n\t\t\tn:            10,\n\t\t\tl:            math.NaN(),\n\t\t\tu:            1,\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  9,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"u is NaN\",\n\t\t\tn:            10,\n\t\t\tl:            0,\n\t\t\tu:            math.NaN(),\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"l and u are both Inf with same sign\",\n\t\t\tn:            7,\n\t\t\tl:            math.Inf(1),\n\t\t\tu:            math.Inf(1),\n\t\t\tv:            1,\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"l and u are both Inf with different signs\",\n\t\t\tn:            10,\n\t\t\tl:            math.Inf(1),\n\t\t\tu:            math.Inf(-1),\n\t\t\tv:            0,\n\t\t\texpectedIdx:  5,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"l is Inf, u is finite\",\n\t\t\tn:            10,\n\t\t\tl:            math.Inf(1),\n\t\t\tu:            1,\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  9,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"u is Inf, l is finite\",\n\t\t\tn:            10,\n\t\t\tl:            0,\n\t\t\tu:            math.Inf(1),\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"v is -Inf, l < u\",\n\t\t\tn:            10,\n\t\t\tl:            0,\n\t\t\tu:            1,\n\t\t\tv:            math.Inf(-1),\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"v is Inf, l > u\",\n\t\t\tn:            10,\n\t\t\tl:            1,\n\t\t\tu:            0,\n\t\t\tv:            math.Inf(1),\n\t\t\texpectedIdx:  0,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"v is within (l, u)\",\n\t\t\tn:            10,\n\t\t\tl:            0,\n\t\t\tu:            1,\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  5,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"v is within (u, l)\",\n\t\t\tn:            10,\n\t\t\tl:            1,\n\t\t\tu:            0,\n\t\t\tv:            0.5,\n\t\t\texpectedIdx:  5,\n\t\t\tshouldPanic:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.shouldPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Expected panic, but none occurred\")\n\t\t\t\t} else if !tc.shouldPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected panic: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expectedIdx {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expectedIdx)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d9c055ec104c56718a9f735546ef9f34": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN value\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is less than l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is greater than u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is greater than l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is less than u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dcfe3ecfae6fa288d7bcd0d33508722c": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-package/floats\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element slice\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      float64(0)/float64(0),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      float64(0)/float64(0),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      -math.Inf,\n\t\t\tu:      math.Inf,\n\t\t\twant:   []float64{-math.Inf, -math.Inf / 2, 0.0, math.Inf / 2, math.Inf},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      -math.Inf,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{-math.Inf, -math.Inf, -math.Inf, -math.Inf, 10.0},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panics {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want panics = %v\", r, tt.panics)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.Span(tt.dst, tt.l, tt.u)\n\t\t\tif !floats.Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dc0c51f114dd31f4e8df118530ca14e5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v = NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = NaN, u = finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = NaN, u = NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = Inf, n odd, v = finite\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = Inf, n odd, v = -Inf\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = Inf, n odd, v = +Inf\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = Inf, u = finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = finite, u = Inf\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        -1,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        11,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        11,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        -1,\n\t\t\texpected: 8,\n\t\t},\n\t\t{\n\t\t\tname:     \"l = u\",\n\t\t\tn:        10,\n\t\t\tl:        5,\n\t\t\tu:        5,\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", test.n, test.l, test.u, test.v, got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "dcd2c202fca790496c6f66029cca00a0": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\tdst     []float64\n\t\tl, u    float64\n\t\twant    []float64\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid case, length 5\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0.0,\n\t\t\tu:       10.0,\n\t\t\twant:    []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid case, length 3\",\n\t\t\tdst:     make([]float64, 3),\n\t\t\tl:       -5.0,\n\t\t\tu:       5.0,\n\t\t\twant:    []float64{-5.0, 0.0, 5.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is NaN\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.NaN(),\n\t\t\tu:       10.0,\n\t\t\twant:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is NaN\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0.0,\n\t\t\tu:       math.NaN(),\n\t\t\twant:    []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l and u are both Inf\",\n\t\t\tdst:     make([]float64, 7),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       math.Inf(1),\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is Inf\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       math.Inf(1),\n\t\t\tu:       10.0,\n\t\t\twant:    []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"u is Inf\",\n\t\t\tdst:     make([]float64, 5),\n\t\t\tl:       0.0,\n\t\t\tu:       math.Inf(1),\n\t\t\twant:    []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"dst length less than 2\",\n\t\t\tdst:     make([]float64, 1),\n\t\t\tl:       0.0,\n\t\t\tu:       10.0,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif tc.wantErr {\n\t\t\t\tif got != nil {\n\t\t\t\t\tt.Errorf(\"Span() = %v, want error\", got)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !EqualApprox(got, tc.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0511d81fad1093714fcf21a2a02a933": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\targs []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: []float64{},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: []float64{3.14},\n\t\t\twant: 3.14,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice\",\n\t\t\targs: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\twant: 24.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements slice\",\n\t\t\targs: []float64{-1.0, 2.0, -3.0, 4.0},\n\t\t\twant: -24.0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v, want %v\", tt.args, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "d799b91a3bd21a0eb9863753a3943661": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"n less than 2, panics\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not NaN, returns n-1\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf and same sign, n is odd, v is not Inf, returns n/2\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.5,\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf and same sign, n is odd, v is Inf with same sign as l, returns 0\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf and same sign, n is odd, v is Inf with opposite sign as l, returns n/2+1\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   3,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf and same sign, n is even, v has same sign as l, returns 0\",\n\t\t\tn:      4,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf and same sign, n is even, v has opposite sign as l, returns n/2\",\n\t\t\tn:      4,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf, v is equal to l, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf, v is equal to u, returns n-1\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l < u, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l < u, returns n-1\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l > u, returns n-1\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l > u, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v is less than l, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      -0.1,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l < u, v is greater than u, returns n-1\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      1.1,\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v is greater than l, returns 0\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      1.1,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l > u, v is less than u, returns n-1\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      -0.1,\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twant:   5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.panics {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "de0f41c026a90025ceeee7a8b47d9b51": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twanted int\n\t}{\n\t\t{\n\t\t\tname:   \"n < 2 panics\",\n\t\t\tn:      1,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.NaN(),\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN, u is not\",\n\t\t\tn:      10,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twanted: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      0.5,\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, n is odd, v is +Inf\",\n\t\t\tn:      9,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(1),\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, n is odd, v is -Inf\",\n\t\t\tn:      9,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twanted: 4,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, n is even, v is +Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(1),\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, n is even, v is -Inf\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(-1),\n\t\t\twanted: 5,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, v == l\",\n\t\t\tn:      10,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf, v == u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twanted: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(-1),\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l < u\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      math.Inf(1),\n\t\t\twanted: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(-1),\n\t\t\twanted: 9,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is +Inf, l > u\",\n\t\t\tn:      10,\n\t\t\tl:      1,\n\t\t\tu:      0,\n\t\t\tv:      math.Inf(1),\n\t\t\twanted: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"normal case\",\n\t\t\tn:      10,\n\t\t\tl:      0,\n\t\t\tu:      1,\n\t\t\tv:      0.5,\n\t\t\twanted: 5,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\tif got != test.wanted {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, wanted %d\", test.n, test.l, test.u, test.v, got, test.wanted)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e0de08f91bb8621093aea8a6f6895828": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tinds   []int\n\t\twant   []float64\n\t\twantInds []int\n\t}{\n\t\t{\n\t\t\tname:   \"simple\",\n\t\t\tdst:    []float64{5.0, 2.0, 3.0, 1.0, 4.0},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twantInds: []int{3, 1, 2, 4, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"already sorted\",\n\t\t\tdst:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tinds:   make([]int, 5),\n\t\t\twant:   []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twantInds: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:   \"empty\",\n\t\t\tdst:    []float64{},\n\t\t\tinds:   make([]int, 0),\n\t\t\twant:   []float64{},\n\t\t\twantInds: []int{},\n\t\t},\n\t\t{\n\t\t\tname:   \"mismatch length\",\n\t\t\tdst:    []float64{1.0, 2.0, 3.0},\n\t\t\tinds:   make([]int, 4),\n\t\t\twant:   nil,\n\t\t\twantInds: nil,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Argsort() panic = %v, wantPanic = %v\", r, tc.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tArgsort(tc.dst, tc.inds)\n\n\t\t\tif !reflect.DeepEqual(tc.dst, tc.want) {\n\t\t\t\tt.Errorf(\"Argsort() dst = %v, want %v\", tc.dst, tc.want)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tc.inds, tc.wantInds) {\n\t\t\t\tt.Errorf(\"Argsort() inds = %v, want %v\", tc.inds, tc.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "df7fb887ea18e4ff6789fa276836ed07": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t}{\n\t\t{\n\t\t\tname:     \"basic\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{},\n\t\t},\n\t\t{\n\t\t\tname:     \"negative range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        -10.0,\n\t\t\tu:        0.0,\n\t\t\texpected: []float64{-10.0, -7.5, -5.0, -2.5, 0.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"NaN u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l and u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf l\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"Inf u\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %f, %f) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test panic\n\tt.Run(\"short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan(make([]float64, 1), 0.0, 10.0)\n\t})\n}",
    "e3d4b6f7a4af707bc819ae7f7d99fff2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ts    []float64\n\t\tL    float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\tL:    2,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 2\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    2,\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L = 1\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    1,\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L = Inf\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L = 3\",\n\t\t\ts:    []float64{1, 2, 3},\n\t\t\tL:    3,\n\t\t\twant: math.Pow(14, 1.0/3.0),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Norm(tc.s, tc.L)\n\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\tt.Errorf(\"Norm(%v, %f) = %f, want %f\", tc.s, tc.L, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e36e2d6500656f6ab7d05eebfb5207f7": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\ts     []float64\n\t\tv     float64\n\t\twant  int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"empty slice\",\n\t\t\ts:     []float64{},\n\t\t\tv:     0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     math.NaN(),\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"positive infinity\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  2,\n\t\t},\n\t\t{\n\t\t\tname:  \"negative infinity\",\n\t\t\ts:     []float64{1, 2, 3},\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t},\n\t\t{\n\t\t\tname:  \"closest value\",\n\t\t\ts:     []float64{1, 2, 3, 4, 5},\n\t\t\tv:     3.2,\n\t\t\twant:  2,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple closest values\",\n\t\t\ts:     []float64{1, 2, 3, 3, 4, 5},\n\t\t\tv:     3,\n\t\t\twant:  2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); (r != nil) != tt.wantP {\n\t\t\t\t\tt.Errorf(\"NearestIdx() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdx(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e3debfe533834eb7a925993f5da8abed": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tinput  []float64\n\t\twant   []float64\n\t\twantIn []int\n\t}{\n\t\t{\n\t\t\tname:   \"sorted slice\",\n\t\t\tinput:  []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twant:   []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twantIn: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsorted slice\",\n\t\t\tinput:  []float64{3.0, 1.0, 4.0, 5.0, 2.0},\n\t\t\twant:   []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twantIn: []int{1, 4, 0, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\tinput:  []float64{},\n\t\t\twant:   []float64{},\n\t\t\twantIn: []int{},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element slice\",\n\t\t\tinput:  []float64{1.0},\n\t\t\twant:   []float64{1.0},\n\t\t\twantIn: []int{0},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.input))\n\t\t\tcopy(dst, tt.input)\n\t\t\tinds := make([]int, len(tt.input))\n\t\t\tArgsort(dst, inds)\n\n\t\t\tif !reflect.DeepEqual(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(inds, tt.wantIn) {\n\t\t\t\tt.Errorf(\"Argsort() indices = %v, want %v\", inds, tt.wantIn)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e46741c04a2ae3e8fb5d63a0dfcf1389": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n    testCases := []struct {\n        name     string\n        s        []float64\n        v        float64\n        expected int\n    }{\n        {\n            name:     \"valid input\",\n            s:        []float64{0, 1, 2, 3, 4, 5},\n            v:        2.5,\n            expected: 2,\n        },\n        {\n            name:     \"value less than first element\",\n            s:        []float64{0, 1, 2, 3, 4, 5},\n            v:        -1,\n            expected: -1,\n        },\n        {\n            name:     \"value greater than last element\",\n            s:        []float64{0, 1, 2, 3, 4, 5},\n            v:        6,\n            expected: -1,\n        },\n        {\n            name:     \"NaN value\",\n            s:        []float64{0, 1, 2, 3, 4, 5},\n            v:        math.NaN(),\n            expected: -1,\n        },\n        {\n            name:     \"slice length less than 2\",\n            s:        []float64{0},\n            v:        0.5,\n            expected: -1,\n        },\n        {\n            name:     \"unsorted slice\",\n            s:        []float64{5, 1, 3, 2, 4, 0},\n            v:        2.5,\n            expected: -1,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := Within(tc.s, tc.v)\n            if result != tc.expected {\n                t.Errorf(\"Within(%v, %v) = %d, expected %d\", tc.s, tc.v, result, tc.expected)\n            }\n        })\n    }\n}",
    "e23f0499b54dde9b7d452678e119f319": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2 should panic\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN, return 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, return n-1\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN, return 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is finite, return n/2\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is -Inf, return 0\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is +Inf, return n/2 + 1\",\n\t\t\tn:        11,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v == l, return 0\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v == u, return n-1\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u, return 0\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u, return n-1\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u, return n-1\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u, return 0\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e25ace83e9153cf53faa9bc86e8579de": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n < 2\",\n\t\t\tn:    1,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    1,\n\t\t\tv:    math.NaN(),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\tn:    10,\n\t\t\tl:    math.NaN(),\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\tn:    10,\n\t\t\tl:    0,\n\t\t\tu:    math.NaN(),\n\t\t\tv:    0.5,\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd, v is finite\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd, v is -Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd, v is Inf\",\n\t\t\tn:    5,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even, v is -Inf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even, v is Inf\",\n\t\t\tn:    4,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\tn:    10,\n\t\t\tl:    math.Inf(-1),\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    math.Inf(1),\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    math.Inf(-1),\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    math.Inf(1),\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l < u\",\n\t\t\tn:    10,\n\t\t\tl:    -1,\n\t\t\tu:    1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, l > u\",\n\t\t\tn:    10,\n\t\t\tl:    1,\n\t\t\tu:    -1,\n\t\t\tv:    0.5,\n\t\t\twant: 5,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e551b450b466d5af6639a408ad6d1cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tl, u     float64\n\t\texpected []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid range\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\texpected: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid length\",\n\t\t\tdst:      make([]float64, 1),\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{math.Inf(-1), -math.Inf, 0, math.Inf, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        10,\n\t\t\texpected: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !reflect.DeepEqual(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7908f6ba9246e52947f0c450542ee07": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{5},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements slice\",\n\t\t\ts:    []float64{2, 3, 4},\n\t\t\twant: 24,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements slice\",\n\t\t\ts:    []float64{-1, 2, -3},\n\t\t\twant: -6,\n\t\t},\n\t\t{\n\t\t\tname: \"zero element slice\",\n\t\t\ts:    []float64{0, 2, 3},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e4b1a35bdcaef67e0246950a70f8a28b": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n less than 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is +Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tidx := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif idx != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tc.n, tc.l, tc.u, tc.v, idx, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e7de2bec59d8d297fc181da6f481f74b": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ty      []float64\n\t\talpha  float64\n\t\ts      []float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"Basic case\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5, 6},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{1, 1, 1},\n\t\t\texpect: []float64{6, 7, 8},\n\t\t},\n\t\t{\n\t\t\tname:   \"Unequal slice lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ty:      []float64{4, 5},\n\t\t\talpha:  2.0,\n\t\t\ts:      []float64{1, 1, 1},\n\t\t\texpect: nil, // Should panic\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Call the function and check the result\n\t\t\tvar panicked bool\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tpanicked = true\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := AddScaledTo(tc.dst, tc.y, tc.alpha, tc.s)\n\t\t\tif panicked {\n\t\t\t\tif tc.expect != nil {\n\t\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) panicked, but was expected to succeed\", tc.dst, tc.y, tc.alpha, tc.s)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !EqualApprox(result, tc.expect, 1e-10) {\n\t\t\t\t\tt.Errorf(\"AddScaledTo(%v, %v, %v, %v) = %v, want %v\", tc.dst, tc.y, tc.alpha, tc.s, result, tc.expect)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "e56decab21bda765dea786add27026fb": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, v is not Inf\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, v is Inf of the same sign as l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, v is Inf of the opposite sign as l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v is equal to l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v is equal to u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1,\n\t\t\tu:        0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eaffafaa2e0ca1f7561e224cb9d3208c": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n    testCases := []struct {\n        name string\n        s    []float64\n        want float64\n    }{\n        {\n            name: \"empty slice\",\n            s:    []float64{},\n            want: 1,\n        },\n        {\n            name: \"single element slice\",\n            s:    []float64{3.14},\n            want: 3.14,\n        },\n        {\n            name: \"multiple elements slice\",\n            s:    []float64{1, 2, 3, 4, 5},\n            want: 120,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            got := Prod(tc.s)\n            if got != tc.want {\n                t.Errorf(\"Prod(%v) = %v, want %v\", tc.s, got, tc.want)\n            }\n        })\n    }\n}",
    "e5e9fa216268e609baeb416605b77cd2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        5,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are positive Inf, v is not Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are positive Inf, v is positive Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are positive Inf, v is negative Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is positive Inf, v is equal to l\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is positive Inf, v is equal to u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is negative Inf, l < u\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is positive Inf, l > u\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v is within the range\",\n\t\t\tn:        5,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v is within the range\",\n\t\t\tn:        5,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 2,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ed4c3249384c384098afcc70d1b2cbca": "package floats\n\nimport (\n    \"math\"\n    \"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n    testCases := []struct {\n        name     string\n        input    []float64\n        expected float64\n    }{\n        {\n            name:     \"empty slice\",\n            input:    []float64{},\n            expected: 0,\n        },\n        {\n            name:     \"single element\",\n            input:    []float64{1.0},\n            expected: 1.0,\n        },\n        {\n            name:     \"multiple elements\",\n            input:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n            expected: 15.0,\n        },\n        {\n            name:     \"large dynamic range\",\n            input:    []float64{1e100, 1e-100, 1e100, 1e-100, 1e100},\n            expected: 3.0e100,\n        },\n        {\n            name:     \"NaN value\",\n            input:    []float64{1.0, math.NaN(), 2.0},\n            expected: math.NaN(),\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            result := SumCompensated(tc.input)\n            if !Same([]float64{result}, []float64{tc.expected}) {\n                t.Errorf(\"SumCompensated(%v) = %f, expected %f\", tc.input, result, tc.expected)\n            }\n        })\n    }\n}",
    "e846085b6c4d3e90047c324e42424143": "package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       0.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       0.0,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0, 3.0},\n\t\t\tv:       1.5,\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than first element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.0,\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than last element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       4.0,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value in the middle\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.5,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value equal to an element\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       3.0,\n\t\t\twant:    2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"NaN value\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -1,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot, err := Within(tc.s, tc.v)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Within(%v, %v) error = %v, wantErr %v\", tc.s, tc.v, err, tc.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", tc.s, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e8244b76a457320d0ab3b95b58a6c2da": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname       string\n\t\tdst        []float64\n\t\tl, u       float64\n\t\texpected   []float64\n\t\tpanicsWhen bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid span\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:       \"Dst length less than 2\",\n\t\t\tdst:        make([]float64, 1),\n\t\t\tl:          0.0,\n\t\t\tu:          10.0,\n\t\t\tpanicsWhen: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\texpected: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(-1),\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10.0,\n\t\t\texpected: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf\",\n\t\t\tdst:      make([]float64, 5),\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\texpected: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panicsWhen && r == nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic as expected\", tc.dst, tc.l, tc.u)\n\t\t\t\t} else if !tc.panicsWhen && r != nil {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked: %v\", tc.dst, tc.l, tc.u, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tresult := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Equal(result, tc.expected) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, expected %v\", tc.dst, tc.l, tc.u, result, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eb2979221b37e0bc94da0f2b22cd5473": "package floats_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/gonum/floats\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tt      []float64\n\t\tL      float64\n\t\twant   float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      2,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=2\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      2,\n\t\t\twant:   5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      1,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=1\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      1,\n\t\t\twant:   9,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{1, 2, 3},\n\t\t\tL:      math.Inf(1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"different slices, L=inf\",\n\t\t\ts:      []float64{1, 2, 3},\n\t\t\tt:      []float64{4, 5, 6},\n\t\t\tL:      math.Inf(1),\n\t\t\twant:   3,\n\t\t},\n\t\t{\n\t\t\tname:      \"slices with different lengths\",\n\t\t\ts:         []float64{1, 2, 3},\n\t\t\tt:         []float64{4, 5},\n\t\t\tL:         2,\n\t\t\twantPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.wantPanic {\n\t\t\t\tt.Run(\"panics\", func(t *testing.T) {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\t\tt.Errorf(\"Distance did not panic\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\tfloats.Distance(tc.s, tc.t, tc.L)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tgot := floats.Distance(tc.s, tc.t, tc.L)\n\t\t\t\tif math.Abs(got-tc.want) > 1e-10 {\n\t\t\t\t\tt.Errorf(\"Distance(%v, %v, %f) = %f, want %f\", tc.s, tc.t, tc.L, got, tc.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "ee11c775a2b30640658618f6276f10f9": "package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\ts1     []float64\n\t\ts2     []float64\n\t\ttol    float64\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths, all within tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.01, 2.02, 3.03},\n\t\t\ttol:    0.1,\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal lengths, one outside tolerance\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.01, 2.02, 4.0},\n\t\t\ttol:    0.1,\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal lengths\",\n\t\t\ts1:     []float64{1.0, 2.0, 3.0},\n\t\t\ts2:     []float64{1.01, 2.02},\n\t\t\ttol:    0.1,\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\ts1:     []float64{},\n\t\t\ts2:     []float64{},\n\t\t\ttol:    0.1,\n\t\t\texpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := EqualApprox(tc.s1, tc.s2, tc.tol)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"EqualApprox(%v, %v, %f) = %t, want %t\", tc.s1, tc.s2, tc.tol, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "edd6222fcf0881ddecd2e6230084c628": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"basic case\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are +/- Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is +Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0.0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0.0, 2.5, 5.0, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "e84c735c076f2f8bd8d768404cfa6161": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/-Inf, n is odd, v is finite\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/-Inf, n is odd, v is +Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are +/-Inf, n is odd, v is -Inf\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is +Inf, v != l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is -Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is -Inf, v != u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.Inf(-1),\n\t\t\tv:        5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is +Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v <= l\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l < u, v >= u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v >= l\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        10,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u, v <= u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        0,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal case\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "eee73366a6b12e52db5a164b7574ac06": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinds    []int\n\t\tf       func(float64) bool\n\t\ts       []float64\n\t\tk       int\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"Find first 2 elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Find all elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       -1,\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"No elements satisfying f\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 10 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       2,\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Zero elements requested\",\n\t\t\tinds:    []int{},\n\t\t\tf:       func(x float64) bool { return x > 0 },\n\t\t\ts:       []float64{-1, 0, 1, 2, 3},\n\t\t\tk:       0,\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.inds, tt.f, tt.s, tt.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ef173baae917f51659bbeea6f5a88278": "package floats\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\ts      []float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty slice\",\n\t\t\ts:      []float64{},\n\t\t\tv:      1.0,\n\t\t\twant:   -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element slice\",\n\t\t\ts:      []float64{1.0},\n\t\t\tv:      1.0,\n\t\t\twant:   -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"unsorted slice\",\n\t\t\ts:      []float64{2.0, 1.0, 3.0},\n\t\t\tv:      1.5,\n\t\t\twant:   -1,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"value less than first element\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:      0.5,\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value greater than or equal to last element\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:      4.0,\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value is NaN\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:      float64(0)/float64(0),\n\t\t\twant:   -1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value is found\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:      2.5,\n\t\t\twant:   1,\n\t\t},\n\t\t{\n\t\t\tname:   \"value is last index\",\n\t\t\ts:      []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\tv:      4.0,\n\t\t\twant:   3,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tsort.Float64s(tt.s)\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.wantPanic {\n\t\t\t\t\tt.Errorf(\"Within() = %v, want panic=%v\", r, tt.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Within(tt.s, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "ede839d8aa21a2a990793caf464a7fa3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tn      int\n\t\tl      float64\n\t\tu      float64\n\t\tv      float64\n\t\twant   int\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"valid case 1\",\n\t\t\tn:      5,\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\tv:      5.0,\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 2\",\n\t\t\tn:      10,\n\t\t\tl:      -5.0,\n\t\t\tu:      5.0,\n\t\t\tv:      0.0,\n\t\t\twant:   5,\n\t\t},\n\t\t{\n\t\t\tname:   \"valid case 3\",\n\t\t\tn:      7,\n\t\t\tl:      -10.0,\n\t\t\tu:      10.0,\n\t\t\tv:      -5.0,\n\t\t\twant:   1,\n\t\t},\n\t\t{\n\t\t\tname:   \"n less than 2\",\n\t\t\tn:      1,\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\tv:      5.0,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tn:      5,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10.0,\n\t\t\tv:      5.0,\n\t\t\twant:   4,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tn:      5,\n\t\t\tl:      0.0,\n\t\t\tu:      math.NaN(),\n\t\t\tv:      5.0,\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      0.0,\n\t\t\twant:   2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf and v is Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10.0,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   4,\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf and v is Inf\",\n\t\t\tn:      5,\n\t\t\tl:      -10.0,\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   4,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is -Inf and l < u\",\n\t\t\tn:      5,\n\t\t\tl:      0.0,\n\t\t\tu:      10.0,\n\t\t\tv:      math.Inf(-1),\n\t\t\twant:   0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is Inf and l > u\",\n\t\t\tn:      5,\n\t\t\tl:      10.0,\n\t\t\tu:      0.0,\n\t\t\tv:      math.Inf(1),\n\t\t\twant:   0,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.wantPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan did not panic as expected\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t} else {\n\t\t\t\tgot := NearestIdxForSpan(test.n, test.l, test.u, test.v)\n\t\t\t\tif got != test.want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", test.n, test.l, test.u, test.v, got, test.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2c99ede0b70b8c7222aa22af27455ed": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0, // This should panic\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{5.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min at start\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min at end\",\n\t\t\ts:    []float64{4.0, 3.0, 2.0, 1.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min in middle\",\n\t\t\ts:    []float64{4.0, 1.0, 3.0, 2.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, min repeated\",\n\t\t\ts:    []float64{1.0, 1.0, 2.0, 3.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\ts:    []float64{math.NaN(), 2.0, 3.0, 1.0},\n\t\t\twant: 3,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := MinIdx(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2d0a4e0607696b81d0f7831b78f1a69": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"Equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twant:   []float64{28, 40, 54},\n\t\t},\n\t\t{\n\t\t\tname:   \"Mismatched lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Dst length mismatch\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8},\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ts:      []float64{},\n\t\t\tt:      []float64{},\n\t\t\twant:   []float64{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tt.wantPanic && r == nil {\n\t\t\t\t\tt.Errorf(\"MulTo did not panic as expected\")\n\t\t\t\t} else if !tt.wantPanic && r != nil {\n\t\t\t\t\tt.Errorf(\"MulTo panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := MulTo(tt.dst, tt.s, tt.t)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f2f791bd017a2c0391ee414f8e34deb6": "package floats\n\nimport (\n    \"testing\"\n)\n\nfunc TestLess(t *testing.T) {\n    testCases := []struct {\n        name      string\n        a         argsort\n        i, j      int\n        expected  bool\n    }{\n        {\n            name: \"i less than j\",\n            a: argsort{\n                s: []float64{1.0, 2.0, 3.0},\n            },\n            i:        0,\n            j:        1,\n            expected: true,\n        },\n        {\n            name: \"i greater than j\",\n            a: argsort{\n                s: []float64{3.0, 2.0, 1.0},\n            },\n            i:        1,\n            j:        0,\n            expected: false,\n        },\n        {\n            name: \"i equal to j\",\n            a: argsort{\n                s: []float64{1.0, 2.0, 2.0},\n            },\n            i:        1,\n            j:        2,\n            expected: true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            if got := tc.a.Less(tc.i, tc.j); got != tc.expected {\n                t.Errorf(\"argsort.Less(%d, %d) = %v, expected %v\", tc.i, tc.j, got, tc.expected)\n            }\n        })\n    }\n}",
    "f000ba2650b7d541450f4670b4290607": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tdst   []float64\n\t\tl     float64\n\t\tu     float64\n\t\twant  []float64\n\t\twantN int\n\t\twantP bool\n\t}{\n\t\t{\n\t\t\tname:  \"basic\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     1.0,\n\t\t\tu:     5.0,\n\t\t\twant:  []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\twantN: 5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"less than 2 elements\",\n\t\t\tdst:   make([]float64, 1),\n\t\t\tl:     1.0,\n\t\t\tu:     5.0,\n\t\t\twant:  nil,\n\t\t\twantN: 0,\n\t\t\twantP: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.NaN(),\n\t\t\tu:     5.0,\n\t\t\twant:  []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t\twantN: 5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     1.0,\n\t\t\tu:     math.NaN(),\n\t\t\twant:  []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twantN: 5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are both Inf\",\n\t\t\tdst:   make([]float64, 6),\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     math.Inf(-1),\n\t\t\twant:  []float64{math.Inf(1), math.Inf(1), 0, 0, math.Inf(-1), math.Inf(-1)},\n\t\t\twantN: 6,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is Inf\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     5.0,\n\t\t\twant:  []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t\twantN: 5,\n\t\t\twantP: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is Inf\",\n\t\t\tdst:   make([]float64, 5),\n\t\t\tl:     1.0,\n\t\t\tu:     math.Inf(1),\n\t\t\twant:  []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\twantN: 5,\n\t\t\twantP: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := Span(tt.dst, tt.l, tt.u)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.dst, tt.l, tt.u, got, tt.want)\n\t\t\t}\n\t\t\tif len(got) != tt.wantN {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) returned a slice of length %d, want %d\", tt.dst, tt.l, tt.u, len(got), tt.wantN)\n\t\t\t}\n\t\t\tif (tt.wantP && recover() == nil) || (!tt.wantP && recover() != nil) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked when it %v expected to\", tt.dst, tt.l, tt.u, map[bool]string{true: \"was\", false: \"was not\"}[tt.wantP])\n\t\t\t}\n\t\t})\n\t}\n}",
    "f5730e5037fa3baa3a7797e3cf5e3a11": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype testCase struct {\n\t\tname string\n\t\ts    []float64\n\t\twant int\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\ts:    []float64{42.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all positive values\",\n\t\t\ts:    []float64{10.0, 5.0, 20.0, 15.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative values\",\n\t\t\ts:    []float64{-10.0, -5.0, -20.0, -15.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed values\",\n\t\t\ts:    []float64{10.0, -5.0, 20.0, -15.0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"with NaN values\",\n\t\t\ts:    []float64{10.0, math.NaN(), 20.0, -15.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\ts:    []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := MinIdx(tc.s)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %d, want %d\", tc.s, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f15c3362d300b641bf4f7188dbe271b2": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl      float64\n\t\tu      float64\n\t\twant   []float64\n\t\twantPanic bool\n\t}{\n\t\t{\n\t\t\tname:   \"empty dst\",\n\t\t\tdst:    []float64{},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"single element dst\",\n\t\t\tdst:    []float64{0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twantPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"positive l and u\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"negative l and u\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      -10,\n\t\t\tu:      0,\n\t\t\twant:   []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\twant:   []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\twant:   []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    []float64{0, 0, 0, 0, 0},\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\twant:   []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.wantPanic {\n\t\t\t\t\tt.Errorf(\"Span() panic = %v, wantPanic = %v\", r, tc.wantPanic)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !EqualApprox(got, tc.want, 1e-14) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f0b30df2d6d93e47dff67646e0ce6c10": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname  string\n\t\tn     int\n\t\tl     float64\n\t\tu     float64\n\t\tv     float64\n\t\twant  int\n\t\tpanic bool\n\t}{\n\t\t{\n\t\t\tname:  \"n < 2\",\n\t\t\tn:     1,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\tpanic: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"NaN input\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.NaN(),\n\t\t\twant:  -1,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is NaN, u is finite\",\n\t\t\tn:     10,\n\t\t\tl:     math.NaN(),\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  9,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is NaN\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.NaN(),\n\t\t\tv:     0.5,\n\t\t\twant:  0,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +/- Inf, v is +Inf\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  2,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +/- Inf, v is -Inf\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  2,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l and u are +/- Inf, v is 0\",\n\t\t\tn:     5,\n\t\t\tl:     math.Inf(-1),\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     0,\n\t\t\twant:  2,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"l is +Inf, v is equal to l\",\n\t\t\tn:     10,\n\t\t\tl:     math.Inf(1),\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"u is +Inf, v is equal to u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     math.Inf(1),\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  9,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is -Inf, l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     math.Inf(-1),\n\t\t\twant:  0,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is +Inf, l > u\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     math.Inf(1),\n\t\t\twant:  0,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is in the middle, l < u\",\n\t\t\tn:     10,\n\t\t\tl:     0,\n\t\t\tu:     1,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\tpanic: false,\n\t\t},\n\t\t{\n\t\t\tname:  \"v is in the middle, l > u\",\n\t\t\tn:     10,\n\t\t\tl:     1,\n\t\t\tu:     0,\n\t\t\tv:     0.5,\n\t\t\twant:  5,\n\t\t\tpanic: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif tc.panic && r == nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) did not panic\", tc.n, tc.l, tc.u, tc.v)\n\t\t\t\t} else if !tc.panic && r != nil {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) panicked: %v\", tc.n, tc.l, tc.u, tc.v, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tc.n, tc.l, tc.u, tc.v, got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f51a1aaeae1dd7bf0c8e26f89b8b78ab": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\tt.Run(\"valid input\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 1.0, 100.0\n\t\texpected := []float64{1, 3.1622776601683795, 10, 31.622776601683795, 100}\n\t\tresult := LogSpan(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"negative input\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := -1.0, 100.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) did not panic\", dst, l, u)\n\t\t\t}\n\t\t}()\n\t\tLogSpan(dst, l, u)\n\t})\n\n\tt.Run(\"zero input\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tl, u := 0.0, 100.0\n\t\texpected := []float64{0, 0, 0, 0, 0}\n\t\tresult := LogSpan(dst, l, u)\n\t\tif !Equal(result, expected) {\n\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) = %v, want %v\", dst, l, u, result, expected)\n\t\t}\n\t})\n\n\tt.Run(\"dst length less than 2\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tl, u := 1.0, 100.0\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"LogSpan(%v, %v, %v) did not panic\", dst, l, u)\n\t\t\t}\n\t\t}()\n\t\tLogSpan(dst, l, u)\n\t})\n}",
    "f5bab763ada8fe7c36081efa09724629": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\twant   []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal lengths\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   []float64{5, 7, 9},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"different lengths\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\twant:   nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"empty slices\",\n\t\t\tdst:    []float64{},\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"one empty slice\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{},\n\t\t\twant:   []float64{1, 2, 3},\n\t\t\tpanics: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tt.panics {\n\t\t\t\t\tt.Errorf(\"Add() panicked: %v, want panic: %t\", r, tt.panics)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tdst := make([]float64, len(tt.dst))\n\t\t\tcopy(dst, tt.dst)\n\t\t\tAdd(dst, tt.s)\n\n\t\t\tif !reflect.DeepEqual(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f4050e94ad42ab51bda296b51cea2843": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\tl, u   float64\n\t\texpect []float64\n\t}{\n\t\t{\n\t\t\tname:   \"basic\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\texpect: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 2\",\n\t\t\tdst:    make([]float64, 2),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\texpect: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"length 1\",\n\t\t\tdst:    make([]float64, 1),\n\t\t\tl:      0,\n\t\t\tu:      10,\n\t\t\texpect: func() []float64 {\n\t\t\t\tvar dst []float64\n\t\t\t\trequire.Panics(t, func() { dst = Span(dst, 0, 10) })\n\t\t\t\treturn dst\n\t\t\t}(),\n\t\t},\n\t\t{\n\t\t\tname:   \"l is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.NaN(),\n\t\t\tu:      10,\n\t\t\texpect: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is NaN\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.NaN(),\n\t\t\texpect: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname:   \"l is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      10,\n\t\t\texpect: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname:   \"u is Inf\",\n\t\t\tdst:    make([]float64, 5),\n\t\t\tl:      0,\n\t\t\tu:      math.Inf(1),\n\t\t\texpect: []float64{0, 2.5, 5, 7.5, math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := Span(tc.dst, tc.l, tc.u)\n\t\t\tif !Same(got, tc.expect) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tc.dst, tc.l, tc.u, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8164ef3c4d50b252e6a8135c40a0ab5": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ts    []float64\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\ts:    []float64{},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single value\",\n\t\t\ts:    []float64{1.0},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple values\",\n\t\t\ts:    []float64{1.0, 2.0, 3.0},\n\t\t\twant: 3.407605893806644,\n\t\t},\n\t\t{\n\t\t\tname: \"all values are negative\",\n\t\t\ts:    []float64{-1.0, -2.0, -3.0},\n\t\t\twant: -0.0067737985012833,\n\t\t},\n\t\t{\n\t\t\tname: \"some values are negative\",\n\t\t\ts:    []float64{1.0, -2.0, 3.0},\n\t\t\twant: 3.3068936414879193,\n\t\t},\n\t\t{\n\t\t\tname: \"all values are zero\",\n\t\t\ts:    []float64{0.0, 0.0, 0.0},\n\t\t\twant: math.Log(3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"some values are infinity\",\n\t\t\ts:    []float64{1.0, math.Inf(1), 3.0},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"some values are negative infinity\",\n\t\t\ts:    []float64{1.0, math.Inf(-1), 3.0},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := LogSumExp(tt.s)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tt.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f6c14f0baeb9d56eb54d29effcc34ad0": "package floats\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       []float64\n\t\tv       float64\n\t\twant    int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"empty slice\",\n\t\t\ts:       []float64{},\n\t\t\tv:       1.0,\n\t\t\twant:    -2,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"single element slice\",\n\t\t\ts:       []float64{1.0},\n\t\t\tv:       1.0,\n\t\t\twant:    -2,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"unsorted slice\",\n\t\t\ts:       []float64{2.0, 1.0},\n\t\t\tv:       1.5,\n\t\t\twant:    0,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"value less than min\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       0.5,\n\t\t\twant:    -2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value greater than max\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       3.5,\n\t\t\twant:    -2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value is NaN\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0},\n\t\t\tv:       math.NaN(),\n\t\t\twant:    -2,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value in range\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       2.5,\n\t\t\twant:    1,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value at upper bound\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       5.0,\n\t\t\twant:    4,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"value at lower bound\",\n\t\t\ts:       []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\tv:       1.0,\n\t\t\twant:    0,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := func() (int, error) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\treturn -1, r.(error)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\treturn Within(tt.s, tt.v), nil\n\t\t\t}()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Within() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fdddd85e91abddc251b9da767bee01fa": "package floats_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/your-username/your-project/floats\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\t// Test cases\n\ttestCases := []struct {\n\t\tname   string\n\t\tdst    []float64\n\t\ts      []float64\n\t\tt      []float64\n\t\texpect []float64\n\t\tpanics bool\n\t}{\n\t\t{\n\t\t\tname:   \"equal length slices\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: []float64{12, 15, 18},\n\t\t\tpanics: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"unequal length slices\",\n\t\t\tdst:    []float64{1, 2, 3},\n\t\t\ts:      []float64{4, 5},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t\tpanics: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"dst length different from s and t\",\n\t\t\tdst:    []float64{1, 2},\n\t\t\ts:      []float64{4, 5, 6},\n\t\t\tt:      []float64{7, 8, 9},\n\t\t\texpect: nil,\n\t\t\tpanics: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif (r != nil) != tc.panics {\n\t\t\t\t\tt.Errorf(\"unexpected panic state: got %v, want %v\", r, tc.panics)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := floats.AddTo(tc.dst, tc.s, tc.t)\n\t\t\tif !floats.Equal(got, tc.expect) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f609d4620b7ad1d4e4f0ba7a78ef6ae8": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl        float64\n\t\tu        float64\n\t\tv        float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2\",\n\t\t\tn:        1,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is not NaN\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0.0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is Inf, v == l\",\n\t\t\tn:        10,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is Inf, v == u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between l and u, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0.0,\n\t\t\tu:        1.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is between u and l, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        1.0,\n\t\t\tu:        0.0,\n\t\t\tv:        0.5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, expected %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}",
    "f8a59234d5fba12b9c07d35cf59640d8": "package floats\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tdst      []float64\n\t\tinds     []int\n\t\texpected []float64\n\t\texpInds  []int\n\t}{\n\t\t{\n\t\t\tname:     \"sorted input\",\n\t\t\tdst:      []float64{1, 2, 3, 4, 5},\n\t\t\tinds:     []int{0, 1, 2, 3, 4},\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t\texpInds:  []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"unsorted input\",\n\t\t\tdst:      []float64{5, 2, 4, 1, 3},\n\t\t\tinds:     []int{0, 1, 2, 3, 4},\n\t\t\texpected: []float64{1, 2, 3, 4, 5},\n\t\t\texpInds:  []int{3, 1, 4, 0, 2},\n\t\t},\n\t\t{\n\t\t\tname:     \"equal input\",\n\t\t\tdst:      []float64{1, 1, 1, 1, 1},\n\t\t\tinds:     []int{0, 1, 2, 3, 4},\n\t\t\texpected: []float64{1, 1, 1, 1, 1},\n\t\t\texpInds:  []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"zero length input\",\n\t\t\tdst:      []float64{},\n\t\t\tinds:     []int{},\n\t\t\texpected: []float64{},\n\t\t\texpInds:  []int{},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tc.dst))\n\t\t\tcopy(dst, tc.dst)\n\t\t\tinds := make([]int, len(tc.inds))\n\t\t\tcopy(inds, tc.inds)\n\n\t\t\tArgsort(dst, inds)\n\n\t\t\tif !reflect.DeepEqual(dst, tc.expected) {\n\t\t\t\tt.Errorf(\"Argsort() dst = %v, want %v\", dst, tc.expected)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(inds, tc.expInds) {\n\t\t\t\tt.Errorf(\"Argsort() inds = %v, want %v\", inds, tc.expInds)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fbcec84a399d16e857a04dd4101ba926": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"basic case\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tresult := Span(dst, 0, 1)\n\t\tassert.Equal(t, expected, result)\n\t})\n\n\tt.Run(\"reversed range\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tresult := Span(dst, 1, 0)\n\t\tassert.Equal(t, expected, result)\n\t})\n\n\tt.Run(\"length less than 2\", func(t *testing.T) {\n\t\tdst := make([]float64, 1)\n\t\tassert.Panics(t, func() {\n\t\t\tSpan(dst, 0, 1)\n\t\t})\n\t})\n\n\tt.Run(\"NaN lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tresult := Span(dst, math.NaN(), 1)\n\t\tassert.Equal(t, expected, result)\n\t})\n\n\tt.Run(\"NaN upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tresult := Span(dst, 0, math.NaN())\n\t\tassert.Equal(t, expected, result)\n\t})\n\n\tt.Run(\"Inf lower and upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)}\n\t\tresult := Span(dst, math.Inf(-1), math.Inf(1))\n\t\tassert.Equal(t, expected, result)\n\t})\n\n\tt.Run(\"Inf lower bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 1}\n\t\tresult := Span(dst, math.Inf(-1), 1)\n\t\tassert.Equal(t, expected, result)\n\t})\n\n\tt.Run(\"Inf upper bound\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\texpected := []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tresult := Span(dst, 0, math.Inf(1))\n\t\tassert.Equal(t, expected, result)\n\t})\n}",
    "fe478ab38e642e30157bc134e5ad80b3": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"n < 2\", 1, 0, 1, 0, 0},\n\t\t{\"NaN v\", 10, 0, 1, math.NaN(), 0},\n\t\t{\"NaN l\", 10, math.NaN(), 1, 0.5, 9},\n\t\t{\"NaN u\", 10, 0, math.NaN(), 0.5, 0},\n\t\t{\"Inf l and u, odd n\", 5, math.Inf(-1), math.Inf(1), 0, 2},\n\t\t{\"Inf l and u, odd n, v < l\", 5, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"Inf l and u, odd n, v > l\", 5, math.Inf(-1), math.Inf(1), math.Inf(1), 4},\n\t\t{\"Inf l and u, even n\", 6, math.Inf(-1), math.Inf(1), 0, 3},\n\t\t{\"Inf l and u, even n, v < l\", 6, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"Inf l and u, even n, v > l\", 6, math.Inf(-1), math.Inf(1), math.Inf(1), 5},\n\t\t{\"Inf l\", 10, math.Inf(-1), 1, 0, 0},\n\t\t{\"Inf l, v == l\", 10, math.Inf(-1), 1, math.Inf(-1), 0},\n\t\t{\"Inf u\", 10, 0, math.Inf(1), 1, 9},\n\t\t{\"Inf u, v == u\", 10, 0, math.Inf(1), math.Inf(1), 9},\n\t\t{\"Inf v, l < u\", 10, 0, 1, math.Inf(-1), 1},\n\t\t{\"Inf v, l > u\", 10, 1, 0, math.Inf(-1), 9},\n\t\t{\"Inf v, l == u\", 10, 0, 0, math.Inf(-1), 0},\n\t\t{\"Inf v, l == u\", 10, 0, 0, math.Inf(1), 0},\n\t\t{\"l < u\", 10, 0, 1, 0.5, 5},\n\t\t{\"l > u\", 10, 1, 0, 0.5, 5},\n\t\t{\"l == u\", 10, 0, 0, 0.5, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}",
    "fffbfad0db7ae393fa0704ea9b316d33": "package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tn        int\n\t\tl, u, v  float64\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"n < 2 should panic\",\n\t\t\tn:        1,\n\t\t\tl:        0,\n\t\t\tu:        1,\n\t\t\tv:        0.5,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.NaN(),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l is NaN, u is finite\",\n\t\t\tn:        10,\n\t\t\tl:        math.NaN(),\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"u is NaN\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        math.NaN(),\n\t\t\tv:        5,\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with the same sign\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is odd\",\n\t\t\tn:        5,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"l and u are both Inf with opposite signs, n is even\",\n\t\t\tn:        6,\n\t\t\tl:        math.Inf(-1),\n\t\t\tu:        math.Inf(1),\n\t\t\tv:        0,\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l < u\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is -Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(-1),\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is Inf, l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        math.Inf(1),\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is in the middle of the range\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is at the lower bound\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"v is at the upper bound\",\n\t\t\tn:        10,\n\t\t\tl:        0,\n\t\t\tu:        10,\n\t\t\tv:        10,\n\t\t\texpected: 9,\n\t\t},\n\t\t{\n\t\t\tname:     \"l > u\",\n\t\t\tn:        10,\n\t\t\tl:        10,\n\t\t\tu:        0,\n\t\t\tv:        5,\n\t\t\texpected: 5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %f, %f, %f) = %d, want %d\", tt.n, tt.l, tt.u, tt.v, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}"
}