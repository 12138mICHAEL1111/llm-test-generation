{"0026966f482687b357882089f4e9ee0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u and v is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u and v is greater than l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","00ff8da04f0e838382a81a82fbe07efe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(1 + 8 + 27, 1.0/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","013e5ee407fb258d6a8c3fda98af7c6a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Test cases for various combinations of l and u\n\t\t{\n\t\t\tname: \"Simple Span\",\n\t\t\targs: args{dst: make([]float64, 5), l: 0, u: 10},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Span\",\n\t\t\targs: args{dst: make([]float64, 5), l: -10, u: 0},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Infinity\",\n\t\t\targs: args{dst: make([]float64, 5), l: 0, u: math.Inf(1)},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Infinity\",\n\t\t\targs: args{dst: make([]float64, 5), l: math.Inf(-1), u: 0},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{dst: make([]float64, 5), l: 0, u: math.NaN()},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN and Infinity\",\n\t\t\targs: args{dst: make([]float64, 5), l: math.NaN(), u: math.Inf(1)},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.Inf(1)},\n\t\t},\n\t\t// Test cases for invalid input lengths\n\t\t{\n\t\t\tname: \"Invalid Length\",\n\t\t\targs: args{dst: make([]float64, 1), l: 0, u: 10},\n\t\t\twant: nil, // Panics, so want is nil\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Expect panic for invalid length\n\t\t\t\t\tif tt.name == \"Invalid Length\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0215348bb87bbfbf266f19937ec2247e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Subtracts elements of two slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{10, 20, 30},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: []float64{9, 18, 27},\n\t\t},\n\t\t{\n\t\t\tname: \"Subtracts elements of two slices with negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{10, 20, 30},\n\t\t\t\ts:   []float64{-1, -2, -3},\n\t\t\t},\n\t\t\twant: []float64{11, 22, 33},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !equalFloat64Slices(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloat64Slices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","028e90cbce778d1961c87aa647c65dad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\n\t\t// Edge cases\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 0},\n\n\t\t// NaN cases\n\t\t{\"n=2, l=NaN, u=0, v=0\", args{2, math.NaN(), 0, 0}, 1},\n\t\t{\"n=2, l=0, u=NaN, v=0\", args{2, 0, math.NaN(), 0}, 0},\n\t\t{\"n=2, l=NaN, u=NaN, v=0\", args{2, math.NaN(), math.NaN(), 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=NaN\", args{2, 0, 1, math.NaN()}, 0},\n\n\t\t// Inf cases\n\t\t{\"n=2, l=Inf, u=Inf, v=Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=Inf, u=Inf, v=-Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=3, l=Inf, u=Inf, v=Inf\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=Inf, u=Inf, v=-Inf\", args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"n=2, l=-Inf, u=Inf, v=Inf\", args{2, math.Inf(-1), math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=-Inf, u=Inf, v=-Inf\", args{2, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 0},\n\n\t\t// Out of bounds cases\n\t\t{\"n=2, l=0, u=1, v=-1\", args{2, 0, 1, -1}, 0},\n\t\t{\"n=2, l=0, u=1, v=2\", args{2, 0, 1, 2}, 1},\n\t\t{\"n=2, l=1, u=0, v=-1\", args{2, 1, 0, -1}, 1},\n\t\t{\"n=2, l=1, u=0, v=2\", args{2, 1, 0, 2}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02c76544e44aa50c3890e81b07f8e90f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element slice, nearest element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element slice, nearest element, multiple candidates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element slice, nearest element, negative value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t\tv: -3.2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02d05743532d1daecf41e66d43e30cae":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside the span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside the span (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v closer to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v closer to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 8,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02dace20380755f8b679152b01cb1c37":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"nan2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"short span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02fbbeaf9207bbe077f089b5539b257d":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"Empty\", args{[]float64{}, 1}, 0},\n\t\t{\"L1\", args{[]float64{1, 2, 3}, 1}, 6},\n\t\t{\"L2\", args{[]float64{1, 2, 3}, 2}, math.Sqrt(14)},\n\t\t{\"LInf\", args{[]float64{1, 2, 3}, math.Inf(1)}, 3},\n\t\t{\"Negative\", args{[]float64{-1, -2, -3}, 1}, 6},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !float64Equals(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc float64Equals(a, b float64) bool {\n\tconst tolerance = 1e-6\n\treturn math.Abs(a-b) \u003c tolerance\n}\n","0448c285f2fcbc79b86a5077593f1471":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with two elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"slice with multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.3333333333333333, 0.6666666666666666, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !equalFloatSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloatSlices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !math.IsEqual(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","0481378a1b09214b71ea7267f94d33e1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0, // should panic\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at first index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at middle index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at last index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple minima, first minimum returned\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 1.0, 3.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 2.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"MinIdx(%v) panicked: %v\", tt.args.s, r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx(%v) = %v, want %v\", tt.args.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","049bf5e147c76a4cefac4edd03539ef1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic Cases\n\t\t{\"Basic1\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"Basic2\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"Basic3\", args{5, -1, 1, 0.25}, 1},\n\t\t{\"Basic4\", args{5, -1, 1, 0.75}, 3},\n\n\t\t// Edge Cases\n\t\t{\"Edge1\", args{2, 0, 1, 0}, 0},\n\t\t{\"Edge2\", args{2, 0, 1, 1}, 1},\n\t\t{\"Edge3\", args{2, 0, 1, 0.5}, 0},\n\n\t\t// NaN Cases\n\t\t{\"NaN1\", args{3, 0, 1, math.NaN()}, 0},\n\t\t{\"NaN2\", args{3, math.NaN(), 1, 0.5}, 2},\n\t\t{\"NaN3\", args{3, 0, math.NaN(), 0.5}, 0},\n\n\t\t// Inf Cases\n\t\t{\"Inf1\", args{3, math.Inf(1), 1, 0.5}, 2},\n\t\t{\"Inf2\", args{3, 0, math.Inf(1), 0.5}, 0},\n\t\t{\"Inf3\", args{3, -math.Inf(1), math.Inf(1), 0}, 1},\n\t\t{\"Inf4\", args{3, -math.Inf(1), math.Inf(1), 1}, 1},\n\t\t{\"Inf5\", args{3, -math.Inf(1), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"Inf6\", args{3, -math.Inf(1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"Inf7\", args{4, -math.Inf(1), math.Inf(1), 0}, 2},\n\t\t{\"Inf8\", args{4, -math.Inf(1), math.Inf(1), 1}, 2},\n\t\t{\"Inf9\", args{4, -math.Inf(1), math.Inf(1), math.Inf(1)}, 3},\n\t\t{\"Inf10\", args{4, -math.Inf(1), math.Inf(1), -math.Inf(1)}, 1},\n\n\t\t// Negative Span Cases\n\t\t{\"Neg1\", args{3, 1, 0, 0.5}, 1},\n\t\t{\"Neg2\", args{3, 1, 0, 0.25}, 2},\n\n\t\t// Special Halfway Cases\n\t\t{\"Halfway1\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"Halfway2\", args{4, 0, 1, 0.5}, 2},\n\t\t{\"Halfway3\", args{5, 0, 1, 0.5}, 2},\n\n\t\t// Panics\n\t\t{\"Panic1\", args{1, 0, 1, 0.5}, -1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.name == \"Panic1\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0509e0638a4b45d441f01d4ba3e331eb":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttype args struct {\n\t\tc   float64\n\t\tdst []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tScale(tt.args.c, tt.args.dst)\n\t\t\tif !Equal(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Scale() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","078c692d78e6f34adcf892727898b8a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Large Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN at the end\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf at both ends\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf at the start\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf at the end\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf at the end with different values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf at both ends with different values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), 0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 1)\n}","07a3669a4df39454690361c55d14ee12":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = 1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = -1\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 0, v = 0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.NaN(), v = 0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = 0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 0, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t} else if r != shortSpan {\n\t\t\tt.Errorf(\"NearestIdxForSpan() panicked with %v, want %v\", r, shortSpan)\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\nfunc ExampleNearestIdxForSpan() {\n\tfmt.Println(NearestIdxForSpan(3, 0, 1, 0.25))\n\tfmt.Println(NearestIdxForSpan(3, 0, 1, 0.75))\n\tfmt.Println(NearestIdxForSpan(3, 1, 0, 0.25))\n\tfmt.Println(NearestIdxForSpan(3, 1, 0, 0.75))\n\t// Output:\n\t// 1\n\t// 2\n\t// 2\n\t// 1\n}","082fe751a23930a68a019f44025e09cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNegativeInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{-10, -10, -10, -10, math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithBothInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithBothInfEqual\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","08367c21374f71c8896f648b0805835b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"short_dst\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0843ef585b873a1a79ee4ad7a8360783":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=1\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=1\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","08d82e43185b5ac68d847ab24ea6f61b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 2},\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n=3, l=1, u=0, v=0.5\", args{3, 1, 0, 0.5}, 1},\n\t\t{\"n=4, l=1, u=0, v=0.5\", args{4, 1, 0, 0.5}, 2},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 0},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=0, u=0, v=0\", args{2, 0, 0, 0}, 0},\n\t\t{\"n=2, l=1, u=1, v=1\", args{2, 1, 1, 1}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=0}, args{2, math.Inf(1), math.Inf(1), 0}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=0}, args{2, math.Inf(-1), math.Inf(-1), 0}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=0}, args{2, math.Inf(1), math.Inf(-1), 0}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=0}, args{2, math.Inf(-1), math.Inf(1), 0}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=0}, args{2, math.NaN(), 0, 0}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=0}, args{2, 0, math.NaN(), 0}, 1},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()}, args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()}, args{2, 0, math.NaN(), math.NaN()}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","092d969bdc8d331e1383b09ae960574d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}","0a4296a1d29592be5b3cbae3eddad4e4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"SimpleSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInfAndNaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInfAndInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0a81dba7d0fdfeb9b2ee90d5fffab1ef":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 0},\n\t\t{\"n=3, l=0, u=1, v=0\", args{3, 0, 1, 0}, 0},\n\t\t{\"n=3, l=0, u=1, v=1\", args{3, 0, 1, 1}, 2},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=4, l=0, u=1, v=0\", args{4, 0, 1, 0}, 0},\n\t\t{\"n=4, l=0, u=1, v=1\", args{4, 0, 1, 1}, 3},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 1},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 0},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 1},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n=3, l=1, u=0, v=0\", args{3, 1, 0, 0}, 0},\n\t\t{\"n=3, l=1, u=0, v=1\", args{3, 1, 0, 1}, 2},\n\t\t{\"n=3, l=1, u=0, v=0.5\", args{3, 1, 0, 0.5}, 1},\n\t\t{\"n=4, l=1, u=0, v=0\", args{4, 1, 0, 0}, 0},\n\t\t{\"n=4, l=1, u=0, v=1\", args{4, 1, 0, 1}, 3},\n\t\t{\"n=4, l=1, u=0, v=0.5\", args{4, 1, 0, 0.5}, 1},\n\t\t{\"n=2, l=0, u=0, v=0\", args{2, 0, 0, 0}, 0},\n\t\t{\"n=2, l=1, u=1, v=1\", args{2, 1, 1, 1}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=0}, args{2, math.Inf(1), math.Inf(1), 0}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=0}, args{2, math.Inf(-1), math.Inf(-1), 0}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=0}, args{3, math.Inf(1), math.Inf(1), 0}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=0}, args{3, math.Inf(-1), math.Inf(-1), 0}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(-1), v=0}, args{3, math.Inf(1), math.Inf(-1), 0}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=0}, args{3, math.Inf(-1), math.Inf(1), 0}, 1},\n\t\t{\"n=2, l=math.NaN(), u=1, v=math.NaN()}, args{2, math.NaN(), 1, math.NaN()}, 0},\n\t\t{\"n=2, l=1, u=math.NaN(), v=math.NaN()}, args{2, 1, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=2, l=1, u=math.NaN(), v=1}, args{2, 1, math.NaN(), 1}, 1},\n\t\t{\"n=2, l=math.NaN(), u=1, v=1}, args{2, math.NaN(), 1, 1}, 1},\n\t\t{\"n=2, l=math.NaN(), u=1, v=0}, args{2, math.NaN(), 1, 0}, 0},\n\t\t{\"n=2, l=1, u=math.NaN(), v=0}, args{2, 1, math.NaN(), 0}, 0},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=0}, args{2, math.NaN(), math.NaN(), 0}, 0},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=1}, args{2, math.NaN(), math.NaN(), 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_ShortSpan(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\nfunc ExampleNearestIdxForSpan() {\n\t// Create a span with 10 equally spaced points from 0 to 1\n\tn := 10\n\tl := 0.0\n\tu := 1.0\n\n\t// Find the index of the element closest to 0.25\n\tv := 0.25\n\tidx := NearestIdxForSpan(n, l, u, v)\n\tfmt.Println(idx)\n\t// Output: 2\n}","0b097e9900feb8b9e641c792209cf25f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0, // Should panic, but we'll test that separately\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at start\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple minima, return first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, NaN, ignore NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, math.NaN(), 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) == 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"MinIdx() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tMinIdx(tt.args.s)\n\t\t\t\treturn // Panic should occur\n\t\t\t}\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0b471cefc5359254a2f629459fb3aade":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"large range\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 10),\n\t\t\t\tl:   0,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{0, 11.11111111111111, 22.22222222222222, 33.33333333333333, 44.44444444444444, 55.55555555555556, 66.66666666666666, 77.77777777777777, 88.88888888888889, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input and output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input and output (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input and output (even length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf output negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"short span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) should have panicked\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0c3582a382574f253a9d3e2de6f04b2e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"same_length_and_values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different_lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different_values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_values_same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_values_different\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 4, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0cbfee12334c61b215b68e7039d3e04c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Both NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0d144bb389e3e2f7fce75bb9ab4c36ba":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal, v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even and v is halfway between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd and v is halfway between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0d37d4ebe8ea732945906d799178ed91":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all positive\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all negative\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{-1, -2, -3},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{1, -2, 3, -4},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"zero\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x == 0 },\n\t\t\t\ts: []float64{1, 0, 3, 0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","0d38cf851eedbeb3bf60880a2ff1cb98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1.0/3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slice\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","0e04172c6c2d5d231457bf49bbcc2001":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Basic Cases\n\t\t{\n\t\t\tname: \"Span 0 to 10\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span 10 to 0\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{10, 7.5, 5, 2.5, 0},\n\t\t},\n\t\t// Edge Cases\n\t\t{\n\t\t\tname: \"Span with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil, // Should panic\n\t\t},\n\t\t// NaN Cases\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN lower and upper bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t// Inf Cases\n\t\t{\n\t\t\tname: \"Span with Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower and upper bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower and upper bounds (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t// Other cases\n\t\t{\n\t\t\tname: \"Span with negative lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{-10, -5, 0, 5, 10},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0e9561493f6229f9472a0d33b0425509":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic_case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative_values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), 0, 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\n\tdst := make([]float64, 1)\n\tSpan(dst, 0, 10)\n}\n\nfunc TestSpan_Range(t *testing.T) {\n\tdst := make([]float64, 5)\n\tfor i, x := range Span(dst, 0, 10) {\n\t\tif x != float64(i)*2.5 {\n\t\t\tt.Errorf(\"Span() returned unexpected value: got %v, want %v\", x, float64(i)*2.5)\n\t\t}\n\t}\n}\n\nfunc EqualApprox(s1, s2 []float64, tol float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif !math.IsNaN(s1[i]) \u0026\u0026 !math.IsNaN(s2[i]) {\n\t\t\tif math.Abs(s1[i]-s2[i]) \u003e tol {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if math.IsNaN(s1[i]) != math.IsNaN(s2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","0f3a51095de34ca23f6513dd63718b5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"test1\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   100.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 10.0, 100.0, 1000.0, 10000.0},\n\t\t},\n\t\t{\n\t\t\tname: \"test2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   0.1,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.1, 1.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"test3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   0.001,\n\t\t\t\tu:   1000.0,\n\t\t\t},\n\t\t\twant: []float64{0.001, 0.1, 10.0, 1000.0},\n\t\t},\n\t\t{\n\t\t\tname: \"test4\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   -1.0,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"test5\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0fd11dba8dbc082251b5cc7acfffe5cd":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t\tt:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"OneElement\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\ts:   []float64{1},\n\t\t\t\tt:   []float64{2},\n\t\t\t},\n\t\t\twant: []float64{3},\n\t\t},\n\t\t{\n\t\t\tname: \"MultipleElements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{5, 7, 9},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAddTo_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddTo() did not panic\")\n\t\t}\n\t}()\n\tAddTo([]float64{0}, []float64{1}, []float64{2, 3})\n}\n\nfunc TestAddTo_PanicDst(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddTo() did not panic\")\n\t\t}\n\t}()\n\tAddTo([]float64{0, 1}, []float64{1, 2, 3}, []float64{1, 2, 3})\n}","10520592a0f56f200f0a6b8fc4e6f903":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"EqualSlices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t\tf:  func(x, y float64) bool { return x == y },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"DifferentLengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t\tf:  func(x, y float64) bool { return x == y },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"DifferentValues\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t\tf:  func(x, y float64) bool { return x == y },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualWithTolerance\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.01, 2.01, 3.01},\n\t\t\t\tf:  func(x, y float64) bool { return abs(x-y) \u003c 0.1 },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc abs(x float64) float64 {\n\tif x \u003c 0 {\n\t\treturn -x\n\t}\n\treturn x\n}","11f572eb365996ad3a7cf07e62825761":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L0 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 0,\n\t\t\t},\n\t\t\t// This is incorrect, but the function does not handle L=0.\n\t\t\twant: math.Pow(14, 0),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1233b208bd7b9681685f0e7a71169e0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Two element span\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, v is u\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 1},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, v is l\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, v is NaN\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l is NaN\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, u is NaN\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l and u are NaN\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l is Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, u is Inf\",\n\t\t\targs: args{n: 3, l: 0, u: math.Inf(1), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l and u are Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l and u are Inf, v is Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l and u are Inf, v is -Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l and u are Inf, v is 0\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l is Inf, u is -Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l is Inf, u is -Inf, v is Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l is Inf, u is -Inf, v is -Inf\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Three element span, l is Inf, u is -Inf, v is 0\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(-1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","128299297328105251c94c426bd401ac":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN, l is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0, // should panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name == \"n is less than 2\" {\n\t\t\t\t\t\tif fmt.Sprint(r) != shortSpan {\n\t\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan() panic: got %v, want %v\", fmt.Sprint(r), shortSpan)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan() panicked: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","156e9026367d2431fbba36241809755c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   -2,\n\t\t\t},\n\t\t\twant: []float64{-1, -1.5, -2},\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","16389cca552661e959b771ae10933bd1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest to the left\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest to the right\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, equal distance, lowest index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","16b961141bad023dbcab537e8956f070":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.25, 0.5, 0.75, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 2.0)\n}","175bec1e74ac88c0ebf6618319ad2aea":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"panic on short dst\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic for short dst\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{}, 0, 1)\n\t})\n\n\tt.Run(\"one NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"one NaN, reversed\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tSpan(dst, 0, math.NaN())\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"two Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), Inf(-1)) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"two Inf, even dst\", func(t *testing.T) {\n\t\tdst := make([]float64, 6)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tSpan(dst, math.Inf(1), math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), Inf(-1)) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"two Inf, equal\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)}\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), Inf(1)) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"one Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1}\n\t\tSpan(dst, math.Inf(1), 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, Inf(1), 1) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"one Inf, reversed\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tSpan(dst, 0, math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, Inf(-1)) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"regular case\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tSpan(dst, 0, 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"regular case, reversed\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{1, 0.75, 0.5, 0.25, 0}\n\t\tSpan(dst, 1, 0)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 1, 0) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"regular case, large dst\", func(t *testing.T) {\n\t\tdst := make([]float64, 100)\n\t\twant := make([]float64, 100)\n\t\tfor i := range dst {\n\t\t\twant[i] = float64(i) / 99\n\t\t}\n\t\tSpan(dst, 0, 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v; want %v\", dst, dst, want)\n\t\t\t}\n\t\t}\n\t})\n}","178631791ebe40ac3e37a083dbafcaf0":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","17b48362ee126933a53c1a193c164509":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{},\n\t\t\t\ty:     []float64{},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{0, 0, 0},\n\t\t\t\ty:     []float64{1, 2, 3},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{9, 12, 15},\n\t\t},\n\t\t{\n\t\t\tname: \"negative alpha\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{0, 0, 0},\n\t\t\t\ty:     []float64{1, 2, 3},\n\t\t\t\talpha: -2.0,\n\t\t\t\ts:     []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{-7, -8, -9},\n\t\t},\n\t\t{\n\t\t\tname: \"dst is not same length as y\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{0, 0},\n\t\t\t\ty:     []float64{1, 2, 3},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"s is not same length as y\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{0, 0, 0},\n\t\t\t\ty:     []float64{1, 2, 3},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{4, 5},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","1830f8f917008a5af3ab25c87b2ae2dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=0, v=0\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=1, v=1\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=0\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=0\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=-1, u=1, v=-2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: -1,\n\t\t\t\tu: 1,\n\t\t\t\tv: -2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=-1, u=1, v=2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: -1,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","18f63684bb35c6121ee813332812b6fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t\t// Add more test cases here...\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","1968ed211494d5115fccc7fbe0d9b841":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic_case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative_values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   -5.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -8.75, -7.5, -6.25, -5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"large_values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000.0,\n\t\t\t\tu:   1010.0,\n\t\t\t},\n\t\t\twant: []float64{1000.0, 1002.5, 1005.0, 1007.5, 1010.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_finite_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"finite_l_inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l_finite_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"finite_l_nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l_nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 10.0)\n}","19b2aa9741f579897b5c9a00dec4d507":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ad9c3bf09c1a9d8050c0ee5abf9560b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1c4cb9f8a7e88f9578abe483cfc61f88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 2.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -2.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"max at the end\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"repeated max\",\n\t\t\targs: args{s: []float64{1.0, 3.0, 3.0, 2.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 3.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1c5f72f2d5979de07ba7baa8000ca229":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"one length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u different\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ca3cc76bc3280f4036eb5e02262113a":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Test cases for valid inputs.\n\t\t{\n\t\t\tname: \"Span with positive values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   -5.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -8.75, -7.5, -6.25, -5.0},\n\t\t},\n\t\t// Test cases for NaN and Inf inputs.\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with both Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t// Test cases for invalid inputs.\n\t\t{\n\t\t\tname: \"Span with dst length less than 2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil, // Should panic, so no expected value.\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic for short dst\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpan_Range(t *testing.T) {\n\tdst := make([]float64, 5)\n\tfor i, x := range Span(dst, 0.0, 10.0) {\n\t\tif x != float64(i)*2.5 {\n\t\t\tt.Errorf(\"Span() returned incorrect value at index %d: got %v, want %v\", i, x, float64(i)*2.5)\n\t\t}\n\t}\n}\n\nfunc TestSpan_NaN(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, math.NaN(), 10.0)\n\tfor i := 0; i \u003c 4; i++ {\n\t\tif !math.IsNaN(dst[i]) {\n\t\t\tt.Errorf(\"Span() did not return NaN at index %d\", i)\n\t\t}\n\t}\n\tif dst[4] != 10.0 {\n\t\tt.Errorf(\"Span() did not return correct value at index 4: got %v, want %v\", dst[4], 10.0)\n\t}\n}\n\nfunc TestSpan_Inf(t *testing.T) {\n\tdst := make([]float64, 5)\n\tSpan(dst, math.Inf(1), 10.0)\n\tfor i := 0; i \u003c 4; i++ {\n\t\tif !math.IsInf(dst[i], 1) {\n\t\t\tt.Errorf(\"Span() did not return Inf at index %d\", i)\n\t\t}\n\t}\n\tif dst[4] != 10.0 {\n\t\tt.Errorf(\"Span() did not return correct value at index 4: got %v, want %v\", dst[4], 10.0)\n\t}\n}","1d6ce67971a15d6b9f8427cb2884ae20":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"floating point precision\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 1e-16, 1e-16, 1e-16, 1e-16},\n\t\t\t},\n\t\t\twant: 1.0000000000000002,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); math.Abs(got-tt.want) \u003e 1e-12 {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1fdd45a9c18c7c68f389281bb34338b8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple Case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Less Than Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Greater Than Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower Bound Equal to Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower Bound and Inf Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower Bound and Inf Upper Bound, Different Signs\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower Bound and Finite Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Finite Lower Bound and Inf Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf Value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse Span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1fe92cb8cfb822ebbb0cb855c24a048d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 3.2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Closest to the left\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Closest to the right\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 3.1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 3.2,\n\t\t\t},\n\t\t\twant: 0, // Panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","200507033a4953d93b579d69ed390e88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5.0, 1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max in middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 5.0, 3.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple max, first max returned\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 5.0, 2.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs in slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 3.0, math.NaN(), 5.0},\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","20b1c7750ca546302f3faea997b5b38d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and v is equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and v is not equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and v is equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and v is not equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf and l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf and l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf and u \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf and u \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","210f3b2cc25d3852c35a761e34477c91":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"large range\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   1000,\n\t\t\t},\n\t\t\twant: []float64{0, 250, 500, 750, 1000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"both Inf, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"both Inf, odd length, different\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   -math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, -math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !equalFloatSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloatSlices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif !math.IsNaN(s1[i]) \u0026\u0026 !math.IsNaN(s2[i]) \u0026\u0026 s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","213b596d12483bcacb7cf3ba03419666":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"within\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"below lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"above upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 5.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN input\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5, 2, 3, 1, 4},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","226111ab2928dc905e44814f6f9015be":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"Empty slice\", args{[]float64{}, 2}, 1},\n\t\t{\"L2 norm\", args{[]float64{1, 2, 3}, 2}, math.Sqrt(14)},\n\t\t{\"L1 norm\", args{[]float64{1, 2, 3}, 1}, 6},\n\t\t{\"L inf norm\", args{[]float64{1, 2, 3}, math.Inf(1)}, 3},\n\t\t{\"L 3 norm\", args{[]float64{1, 2, 3}, 3}, math.Pow(14, 1/3)},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","22bd207af381f87686834da5d600c1ad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, equal distance, return lowest index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","252ed22fd9f5304c94adacddc06a1137":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with no NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with one NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with multiple NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3, math.NaN()},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","253f0b1f1c4b549501d40eca15d5eced":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside range, negative\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge cases\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge cases 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds, Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds, negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Short span\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Short span 2\",\n\t\t\targs: args{\n\t\t\t\tn: 0,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, Inf l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, Inf l and u, even n\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, Inf l and u, negative v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, Inf l and u, positive v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, NaN l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, NaN l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case, NaN u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n}\n\nfunc ExampleNearestIdxForSpan() {\n\tn := 5\n\tl := 0.0\n\tu := 10.0\n\tv := 5.0\n\tfmt.Println(NearestIdxForSpan(n, l, u, v))\n\t// Output: 2\n}","25ce682804023f9a12509c8ac3f9216a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN L\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN U\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf U\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, 0, 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L and Inf U\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L and Inf U (even)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L and Inf U (equal)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L and Inf U (even, equal)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","26a35a13561a9794e4226386d82986f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // This test should panic, but we're just checking for no crash here\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","273f0a878b8e6f3562e9f28f044dc394":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-09,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\t},\n\t\t\twant: 0.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","275967bd3d165d6f5e107ac14d6101cc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside of bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN, u not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN, l not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","27980de3e3145bbf91a6bce006ce4d0c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicate minimum\",\n\t\t\targs: args{s: []float64{2.0, 1.0, 1.0, 3.0, 4.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed positive and negative values\",\n\t\t\targs: args{s: []float64{1.0, -2.0, 3.0, -4.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN as minimum\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, 2.0, 3.0, 4.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple NaN values\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, math.NaN(), 3.0, 4.0}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2799b7f6d5b93f89992e821705bebff0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Test cases for different n, l, u, and v values\n\t\t{\n\t\t\tname: \"PositiveSpan\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\targs: args{n: 5, l: 10, u: 0, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"VOutsideSpan\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 15},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"VEqualLowerBound\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"VEqualUpperBound\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 10},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"VNaN\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"LNaN\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 10, v: 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"UNan\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: 5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"LInf\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: 10, v: 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"UInf\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: 5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"VInf\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"LInfUInf\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"LInfUInfOddN\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: 5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"LInfUInfOddNNegV\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -5},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","28520fc1a5692c9c87d9da5daba3a32d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"minimum at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate minimums\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","288f617c62576d3f1a88038094c17195":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{s: []float64{2.0, 1.0, 3.0, 4.0, 1.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple minimums\",\n\t\t\targs: args{s: []float64{1.0, 1.0, 2.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, 2.0, math.NaN()}},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","28ebcdc9ba99fb1af3edf4495a630a68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0, // This will panic, but we'll test for that specifically\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, minimum at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, minimum at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, minimum in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, multiple minima, first one returned\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs are ignored\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, math.NaN(), 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"All NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) == 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tt.Logf(\"Panic as expected: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","28f9800a7a4182bbc7af30b587ca4260":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 3.7416573867739413,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Arbitrary L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: 4.140818223697058,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 !math.IsInf(got, 1) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","29038392105c5bc234f760656fcb22e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN with duplicates\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, math.NaN(), 2.0}},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2912766f5fa08aadae1282284cedee38":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1e6,\n\t\t\t\tu:   1e7,\n\t\t\t},\n\t\t\twant: []float64{1e6, 2.25e6, 3.5e6, 4.75e6, 1e7},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf output\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanRange(t *testing.T) {\n\tdst := make([]float64, 5)\n\tfor i, x := range Span(dst, 0, 10) {\n\t\tif x != float64(i)*2.5 {\n\t\t\tt.Errorf(\"Span(dst, 0, 10) generated unexpected value: got %v, want %v\", x, float64(i)*2.5)\n\t\t}\n\t}\n\tfor i, x := range Span(dst, 10, 0) {\n\t\tif x != float64(4-i)*2.5 {\n\t\t\tt.Errorf(\"Span(dst, 10, 0) generated unexpected value: got %v, want %v\", x, float64(4-i)*2.5)\n\t\t}\n\t}\n}\n\nfunc TestSpanErrors(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", dst, 0.0, 10.0)\n\t\t} else if fmt.Sprint(r) != shortSpan {\n\t\t\tt.Errorf(\"Span(%v, %v, %v) panicked with %v, want %v\", dst, 0.0, 10.0, r, shortSpan)\n\t\t}\n\t}()\n\tSpan(dst, 0.0, 10.0)\n}\n","29321ecf0482984dd39ea3b7ce875e3b":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span_basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_both\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_short\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t} else if _, ok := r.(error); !ok {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic with error\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t} else {\n\t\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\tif !Equal(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t\t}\n\t\t\t\tfor i, v := range got {\n\t\t\t\t\tif math.IsNaN(v) {\n\t\t\t\t\t\tif !math.IsNaN(tt.want[i]) {\n\t\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if !math.IsNaN(v) \u0026\u0026 math.IsNaN(tt.want[i]) {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","29360998acd13b342952710bb8afacf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0, 7.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"single_element\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -7.0, -4.0, -1.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both_even\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","295ed50fd8578a673bb2e3fcc8350d9c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"cancellation\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, -1e10, 1e-10, -1e-10},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","29b9b1c0f0123acdc4bd5a5dcb577350":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 2.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with same max\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 3.0, 3.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at start\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 1.0, 3.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","2a86c48c0b34e51f7e81c07ad226cfc8":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !equalFloat64Slices(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloat64Slices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2adf7865b18d991dea53dc6df7a87df3":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 4.0, 6.0},\n\t\t\t},\n\t\t\twant: 12.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-2.0, 4.0, -6.0},\n\t\t\t},\n\t\t\twant: 48.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2c01766532bd63aa2abc38cc94eb14e6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span_Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Span_One\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Simple\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_NaN_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_NaN_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_Inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equal(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !math.IsNaN(a[i]) \u0026\u0026 !math.IsNaN(b[i]) {\n\t\t\tif a[i] != b[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if math.IsNaN(a[i]) \u0026\u0026 !math.IsNaN(b[i]) || !math.IsNaN(a[i]) \u0026\u0026 math.IsNaN(b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","2c0b11a375fc921998c1c9c945a1e821":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside range (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v at lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v at upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v halfway between bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (opposite signs)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf, l and u finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf (negative), l and u finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0, // Should panic, but we are checking for the panic in a separate test\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","2d185405319948d8cbedc6a6a50ab7fc":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := DivTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2d9592ac59a1a355ee03def9ab0094c3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside the range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside the range (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN (l)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN (u)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (l)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (l) - equal\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (l) - odd n\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (u)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (v) - negative\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (v) - positive\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (v) - negative (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (v) - positive (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2e64769798a5cc94d729f8d90e29adfd":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tc   float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := ScaleTo(tt.args.dst, tt.args.c, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2e8f04b46a7cc612ea38ffd806e2eb04":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"short span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2f1a12d46d26c88d281ab17f5d43f813":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, tie, lowest index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 2.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3089a094a99d51ef78034874e78c9a53":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: 2.126928011817216,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 5.012542275205544,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -0.9999546021337495,\n\t\t},\n\t\t{\n\t\t\tname: \"Large elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10},\n\t\t\t},\n\t\t\twant: 3e10,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), 1.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), 1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsClose(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","30dee26f57fa90a8a53794231ce2c69e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","310cb20bedefcc5ffc221258026fc89f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithBothInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithBothNaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNegativeInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 5},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{1}, 1, 2)\n}","315d479ff232fd65956f9b3da7e0e12b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","31da813b746c7eabd381b135198484d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u finite, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u finite, n = 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","32bb0402b219e3687bbce36b83414407":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to the last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between the first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to the second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between the second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","345c9a3be0ead2a6bb443889e1480273":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   -10,\n\t\t\t\tu:   -5,\n\t\t\t},\n\t\t\twant: []float64{-10, -8.75, -7.5, -6.25, -5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34830695dc149b4a5cc409e9b2a8f053":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"floating point precision\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 0.1, 0.01, 0.001, 0.0001},\n\t\t\t},\n\t\t\twant: 1.11111,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}","34c0d99226cdf4b4227be15a1f145e68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with opposite signs\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same signs, odd n, v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same signs, odd n, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same signs, even n, v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same signs, even n, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf(0)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf(0), v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf(0)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf(0), v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(-1)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf(1)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v in (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v in (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34ff38c1847746783a7293319ecf85f8":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 1 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find insufficient elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 2 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","356d6aedd0b043c46f7fcf7e3ff1cbc9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","358cb99636fbb9e701ee9e0d5a0edac1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: -5,\n\t\t\t\tv: -7.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"ReversedBounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"ValueLessThanLowerBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ValueGreaterThanUpperBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNValue\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"InfValue\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"InfValueNegative\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBoundsOddN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBoundsEvenN\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBoundsEvenNNegative\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBoundsEvenNNegative\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBoundsEvenNPositive\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","35e4e0a40afe6a5e168783bb39d5cb1d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nearest elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","36b46310cb1e47d0cbd345cbb5e97feb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside span 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 11.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v at lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v at upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 10.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2, v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is finite, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is finite, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3777da618e67948fe1f0988381d359df":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{s: []float64{1e10, 2e10, 3e10, 4e10, 5e10}},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{s: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10}},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{s: []float64{1.0, -2.0, 3.0, -4.0, 5.0}},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"cancellation\",\n\t\t\targs: args{s: []float64{1e10, -1e10, 1e-10}},\n\t\t\twant: 1e-10,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 !math.IsInf(got, -1) \u0026\u0026 !math.IsInf(got, 1) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","382421897ddac293a7eaf5803663f8ba":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5},\n\t\t\t},\n\t\t\twant: []float64{}, // Panic expected, want should be irrelevant\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Panic expected in the unequal length case.\n\t\t\t\t\tif tt.name == \"Unequal length slices\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Sub() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3843bad289f379e1a739b632988424fb":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find 0 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 5\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements (k \u003c 0)\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 2\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: -1,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 2\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find more elements than available\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 2\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: 4,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 2\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","39db05dc4a24eb9227f51017d3d973fe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: -5,\n\t\t\t\tv: -7.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nan bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"nan value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"short span\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\t// Panic expected.\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) didn't panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3a76d4dd149871d67008d88252023be3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum at last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, minimum in middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple minimums\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, math.NaN(), 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 3.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, math.NaN(), 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3adb71339e22f88f256492a10f5ad403":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic Cases\n\t\t{\n\t\t\tname: \"Simple Span, Value within\",\n\t\t\targs: args{n: 10, l: 0.0, u: 10.0, v: 5.0},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Span, Value at Lower Bound\",\n\t\t\targs: args{n: 10, l: 0.0, u: 10.0, v: 0.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Span, Value at Upper Bound\",\n\t\t\targs: args{n: 10, l: 0.0, u: 10.0, v: 10.0},\n\t\t\twant: 9,\n\t\t},\n\t\t// Edge Cases\n\t\t{\n\t\t\tname: \"Span with NaN Lower Bound\",\n\t\t\targs: args{n: 10, l: math.NaN(), u: 10.0, v: 5.0},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN Upper Bound\",\n\t\t\targs: args{n: 10, l: 0.0, u: math.NaN(), v: 5.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf Bounds\",\n\t\t\targs: args{n: 10, l: math.Inf(1), u: math.Inf(1), v: 5.0},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf Bounds, Odd Length\",\n\t\t\targs: args{n: 11, l: math.Inf(1), u: math.Inf(1), v: 5.0},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf Bounds, Even Length\",\n\t\t\targs: args{n: 10, l: math.Inf(1), u: math.Inf(1), v: 5.0},\n\t\t\twant: 5,\n\t\t},\n\t\t// Value Outside Span\n\t\t{\n\t\t\tname: \"Value Below Lower Bound\",\n\t\t\targs: args{n: 10, l: 0.0, u: 10.0, v: -5.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Above Upper Bound\",\n\t\t\targs: args{n: 10, l: 0.0, u: 10.0, v: 15.0},\n\t\t\twant: 9,\n\t\t},\n\t\t// Reversed Span\n\t\t{\n\t\t\tname: \"Reversed Span, Value within\",\n\t\t\targs: args{n: 10, l: 10.0, u: 0.0, v: 5.0},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed Span, Value at Lower Bound\",\n\t\t\targs: args{n: 10, l: 10.0, u: 0.0, v: 10.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed Span, Value at Upper Bound\",\n\t\t\targs: args{n: 10, l: 10.0, u: 0.0, v: 0.0},\n\t\t\twant: 9,\n\t\t},\n\t\t// NaN Value\n\t\t{\n\t\t\tname: \"NaN Value\",\n\t\t\targs: args{n: 10, l: 0.0, u: 10.0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3bddc91a49dd0c307d9de0e1281590c7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Span 2 elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span 3 elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 3, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span 4 elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 2.5, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","3d239a05153f127756cc4206cf13ce2f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3f1fcb2afc428a0210f30e3b742123c1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside range (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to middle\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v slightly above middle\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5.1,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v slightly below middle\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l = NaN, u = not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u = NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l = Inf, u = Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = Inf, u = Inf (even n)\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = Inf, u = Inf (v = Inf)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l = Inf, u = Inf (v = -Inf)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l = Inf, u = finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l = finite, u = Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v = Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v = -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3fa7e3b95f5c707b1cf62da5c1bdb6f4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\ttype args struct {\n\t\tc   float64\n\t\tdst []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]float64, len(tt.args.dst))\n\t\t\tcopy(got, tt.args.dst)\n\t\t\tAddConst(tt.args.c, got)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddConst() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","402da2b0239a95cd0ad9382497c83698":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t// Special cases\n\t\t{\n\t\t\tname: \"NaN Lower\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Upper\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Upper\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Both\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Both Equal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t// Error cases\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.want == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","408bf5d6763678341e7519c97944b765":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"Basic 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Basic 2\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 5},\n\t\t},\n\t\t// Special cases for NaN\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t// Special cases for Inf\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t// Panic cases\n\t\t{\n\t\t\tname: \"Panic: Short dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.want == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4171fcb628d4c71d3830d56fe113e994":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds negative\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf and nan\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","425513ae8a69a98a714e8b3f95e333d2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Case with NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Case with Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Case with Inf, reversed\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 10.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Case with v outside (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Case with v outside (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Case with n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4255a92f176f4d91698166bcd5e8c176":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","427a068f7b9d98292d45ba8f0298d820":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"infinite values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"short dst\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic when dst length is less than 2\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","437c902372f0d98605b3971c25a238e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds low\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds high\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"reversed bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"even number of elements\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"odd number of elements\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"zero length\",\n\t\t\targs: args{\n\t\t\t\tn: 0,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0, // Should panic, but the panic is not tested here\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","43b37766db5973e6b66d2f8e975f0b50":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find 1 element\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find 3 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find more than k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    4,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 5 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements with initial inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{4, 5, 6},\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find 1 element with initial inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{4, 5, 6},\n\t\t\t\tf:    func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{0},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","43da2b9b629e14fe67c3831d7c5be202":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 2.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 2.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 3.2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","448e96e64dc8a814b9196333c8e74a69":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside the range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside the range (reverse)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN, l is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, n is even, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not, v is equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not, v is equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","44b252eb7d64662d0890dd69335bcff7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"FindFirst2Elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindFirst3Elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{3, 4, 5},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindMoreThanKElements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{3},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"FindZeroElements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindNegativeK\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{3, 4, 5, 6, 7, 8, 9},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindWithExistingInds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 3, 4, 5},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindNoMatch\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 12\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 6, 7, 8, 9, 10, 11, 12},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4511cbb301b7d8bfcf0b0dedbc359aa4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic_case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"negative_values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5,\n\t\t\t\tu:   -1,\n\t\t\t},\n\t\t\twant: []float64{-5, -4, -3, -2, -1},\n\t\t},\n\t\t{\n\t\t\tname: \"zero_value\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), 0, 0, 0, math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_inf_u_odd_length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), 0, 0, 0, 0, 0, math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 5},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{1, math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","453441fed479c6b931c95d8e6a2dc624":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same sign and v is Inf with same sign as l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same sign and v is Inf with same sign as u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with opposite signs and v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf and l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf and l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf and u \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf and u \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","45a30c5828885a89ba83eb56d93bcb68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf, v neg Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf, odd n\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf, odd n, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf, odd n, v neg Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf, v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v neg Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v pos Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0, // Should panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4627622097568676db1c4bb86f0f6c45":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"outside bounds reversed\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l equals u\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l equals u, v equals u\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, v equals l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, v equals u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, v outside bounds reversed\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, v equals inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, v equals -inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, n even, v negative inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, n even, v positive inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, n odd, v negative inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf bounds, n odd, v positive inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is nan\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"u is nan\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is nan\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4779c1536b5e5170e27ec9a3d10c39ae":"","47f60ea89af4f421e1d95c0dab96a75e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with same maximum\",\n\t\t\targs: args{s: []float64{1.0, 3.0, 3.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","485f3f9430a5c1ee9fe363f2c8c5ca6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: -1, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, minimum at beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, minimum at end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, minimum in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, multiple minimums\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 1.0, 3.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"All NaN values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name == \"Empty slice\" {\n\t\t\t\t\t\t// Expected panic for empty slice\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"MinIdx() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","4902acfcc99189c581fc8a8766675600":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 0},\n\n\t\t// Cases with NaN\n\t\t{\"n=2, l=NaN, u=1, v=0\", args{2, math.NaN(), 1, 0}, 1},\n\t\t{\"n=2, l=0, u=NaN, v=1\", args{2, 0, math.NaN(), 1}, 0},\n\t\t{\"n=2, l=NaN, u=NaN, v=0\", args{2, math.NaN(), math.NaN(), 0}, 0},\n\n\t\t// Cases with Inf\n\t\t{\"n=2, l=Inf, u=Inf, v=Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=Inf, u=Inf, v=-Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=2, l=Inf, u=Inf, v=0\", args{2, math.Inf(1), math.Inf(1), 0}, 1},\n\t\t{\"n=2, l=Inf, u=0, v=Inf\", args{2, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=2, l=Inf, u=0, v=-Inf\", args{2, math.Inf(1), 0, math.Inf(-1)}, 1},\n\t\t{\"n=2, l=0, u=Inf, v=Inf\", args{2, 0, math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=0, u=Inf, v=-Inf\", args{2, 0, math.Inf(1), math.Inf(-1)}, 0},\n\n\t\t// Odd n cases\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 0},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\n\t\t// Even n cases\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 0},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 2},\n\n\t\t// Edge cases\n\t\t{\"n=2, l=0, u=0, v=0\", args{2, 0, 0, 0}, 0},\n\t\t{\"n=2, l=1, u=1, v=1\", args{2, 1, 1, 1}, 1},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=0, u=1, v=NaN\", args{2, 0, 1, math.NaN()}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","498646d911c3405408999849c323ca03":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1.0/3),\n\t\t},\n\t\t// Add more test cases here...\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","49ba2faa968d0b16296a65774ac0301a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"SimpleCase\", args{5, 1.0, 5.0, 3.0}, 2},\n\t\t{\"EdgeCase1\", args{5, 1.0, 5.0, 1.0}, 0},\n\t\t{\"EdgeCase2\", args{5, 1.0, 5.0, 5.0}, 4},\n\t\t{\"EdgeCase3\", args{5, 5.0, 1.0, 3.0}, 2},\n\t\t{\"EdgeCase4\", args{5, 5.0, 1.0, 5.0}, 0},\n\t\t{\"EdgeCase5\", args{5, 5.0, 1.0, 1.0}, 4},\n\t\t{\"InfL\", args{5, math.Inf(1), 5.0, 3.0}, 4},\n\t\t{\"InfU\", args{5, 1.0, math.Inf(1), 3.0}, 0},\n\t\t{\"InfBoth\", args{5, math.Inf(1), math.Inf(1), 3.0}, 2},\n\t\t{\"NaNL\", args{5, math.NaN(), 5.0, 3.0}, 4},\n\t\t{\"NaNU\", args{5, 1.0, math.NaN(), 3.0}, 0},\n\t\t{\"NaNV\", args{5, 1.0, 5.0, math.NaN()}, 0},\n\t\t{\"InfVNeg\", args{5, 1.0, 5.0, math.Inf(-1)}, 0},\n\t\t{\"InfVPos\", args{5, 1.0, 5.0, math.Inf(1)}, 4},\n\t\t{\"ShortSpan\", args{1, 1.0, 5.0, 3.0}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","49f1f6060a6fe1ef71ebca94b2d03f19":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=5, l=0, u=1, v=0.2\", args{5, 0, 1, 0.2}, 1},\n\t\t{\"n=5, l=0, u=1, v=0.8\", args{5, 0, 1, 0.8}, 4},\n\t\t{\"n=5, l=0, u=1, v=0.5\", args{5, 0, 1, 0.5}, 3},\n\t\t{\"n=10, l=0, u=10, v=5\", args{10, 0, 10, 5}, 5},\n\t\t{\"n=10, l=0, u=10, v=2.5\", args{10, 0, 10, 2.5}, 3},\n\t\t{\"n=10, l=0, u=10, v=7.5\", args{10, 0, 10, 7.5}, 8},\n\t\t{\"n=10, l=10, u=0, v=5\", args{10, 10, 0, 5}, 5},\n\t\t{\"n=10, l=10, u=0, v=2.5\", args{10, 10, 0, 2.5}, 8},\n\t\t{\"n=10, l=10, u=0, v=7.5\", args{10, 10, 0, 7.5}, 3},\n\t\t{\"n=2, l=0, u=1, v=1.5\", args{2, 0, 1, 1.5}, 1},\n\t\t{\"n=2, l=0, u=1, v=-0.5\", args{2, 0, 1, -0.5}, 0},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 0},\n\t\t{\"n=2, l=1, u=0, v=1.5\", args{2, 1, 0, 1.5}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=0, v=math.Inf(1)}, args{2, math.Inf(1), 0, math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=0, v=math.Inf(-1)}, args{2, math.Inf(-1), 0, math.Inf(-1)}, 0},\n\t\t{\"n=2, l=0, u=math.Inf(1), v=math.Inf(1)}, args{2, 0, math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=0, u=math.Inf(-1), v=math.Inf(-1)}, args{2, 0, math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()}, args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()}, args{2, 0, math.NaN(), math.NaN()}, 1},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()}, args{2, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}\n\nfunc TestNearestIdxForSpan_NaN(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=math.NaN()\", 2, 0, 1, 0},\n\t\t{\"n=2, l=math.NaN(), u=1, v=math.NaN()\", 2, math.NaN(), 1, 1},\n\t\t{\"n=2, l=1, u=math.NaN(), v=math.NaN()\", 2, 1, math.NaN(), 0},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\", 2, math.NaN(), math.NaN(), 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, math.NaN())\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Inf(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", 2, math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\", 2, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\", 2, math.Inf(1), math.Inf(-1), math.Inf(1), 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\", 2, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"n=2, l=math.Inf(1), u=0, v=math.Inf(1)\", 2, math.Inf(1), 0, math.Inf(1), 1},\n\t\t{\"n=2, l=math.Inf(-1), u=0, v=math.Inf(-1)\", 2, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{\"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\", 2, 0, math.Inf(1), math.Inf(1), 1},\n\t\t{\"n=2, l=0, u=math.Inf(-1), v=math.Inf(-1)\", 2, 0, math.Inf(-1), math.Inf(-1), 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", 3, math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\", 3, math.Inf(-1), math.Inf(-1), math.Inf(-1), 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\", 3, math.Inf(1), math.Inf(-1), math.Inf(1), 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\", 3, math.Inf(-1), math.Inf(1), math.Inf(-1), 0},\n\t\t{\"n=3, l=math.Inf(1), u=0, v=math.Inf(1)\", 3, math.Inf(1), 0, math.Inf(1), 2},\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=math.Inf(-1)\", 3, math.Inf(-1), 0, math.Inf(-1), 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=math.Inf(1)\", 3, 0, math.Inf(1), math.Inf(1), 2},\n\t\t{\"n=3, l=0, u=math.Inf(-1), v=math.Inf(-1)\", 3, 0, math.Inf(-1), math.Inf(-1), 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_EdgeCases(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0\", 2, 0, 1, 0, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", 2, 0, 1, 1, 1},\n\t\t{\"n=2, l=1, u=0, v=0\", 2, 1, 0, 0, 0},\n\t\t{\"n=2, l=1, u=0, v=1\", 2, 1, 0, 1, 1},\n\t\t{\"n=2, l=0, u=0, v=0\", 2, 0, 0, 0, 0},\n\t\t{\"n=2, l=1, u=1, v=1\", 2, 1, 1, 1, 0},\n\t\t{\"n=3, l=0, u=1, v=0\", 3, 0, 1, 0, 0},\n\t\t{\"n=3, l=0, u=1, v=1\", 3, 0, 1, 1, 2},\n\t\t{\"n=3, l=1, u=0, v=0\", 3, 1, 0, 0, 0},\n\t\t{\"n=3, l=1, u=0, v=1\", 3, 1, 0, 1, 2},\n\t\t{\"n=3, l=0, u=0, v=0\", 3, 0, 0, 0, 0},\n\t\t{\"n=3, l=1, u=1, v=1\", 3, 1, 1, 1, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_EqualBounds(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=0, v=0\", 2, 0, 0, 0, 0},\n\t\t{\"n=2, l=1, u=1, v=1\", 2, 1, 1, 1, 0},\n\t\t{\"n=3, l=0, u=0, v=0\", 3, 0, 0, 0, 0},\n\t\t{\"n=3, l=1, u=1, v=1\", 3, 1, 1, 1, 0},\n\t\t{\"n=4, l=0, u=0, v=0\", 4, 0, 0, 0, 0},\n\t\t{\"n=4, l=1, u=1, v=1\", 4, 1, 1, 1, 0},\n\t\t{\"n=5, l=0, u=0, v=0\", 5, 0, 0, 0, 0},\n\t\t{\"n=5, l=1, u=1, v=1\", 5, 1, 1, 1, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tt.n, tt.l, tt.u, tt.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExampleNearestIdxForSpan() {\n\t// Find the index of the element in a hypothetical vector of\n\t// 10 elements, evenly spaced between 0 and 10, whose value\n\t// is closest to 5.\n\tidx := NearestIdxForSpan(10, 0, 10, 5)\n\tfmt.Println(idx) // Output: 5\n}","4a76c915a614c1a32e928870371d7c11":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinities\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinities2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 5,\n\t\t\t\tu: 5,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t} else if fmt.Sprintf(\"%v\", r) != \"shortSpan\" {\n\t\t\tt.Errorf(\"NearestIdxForSpan() panicked with %v, want %v\", r, \"shortSpan\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","4b1a23c141eedc527eec4c3fbbbf89e3":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4ba005c9cdfe22faa8fc506e95a25089":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4c6cdb436525f21ceeedad76790926b9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slice lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4cbcd075e4543798c309fb6ee26e85d1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"even span, v in span\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"even span, v outside span\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 6.0,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"odd span, v in span\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"odd span, v outside span\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 6.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v at l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v at u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is 0\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is NaN, l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 5.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is NaN, u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with Inf bounds, v is NaN, l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4e1af0d7b8ed5d716b99fd19e75c5557":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4eb979ccf40b8e4948c951fe71f3192c":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4ee2b8620a8d952f91ac91175e990d11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"LowerBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"UpperBound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"OutsideBounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"ReverseBounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 100,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"InfNegative\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 0,\n\t\t\t\tv: -100,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoth\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothEqual\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothEqualOdd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothOdd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 100,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","50a644966ebeb9b5f9f075ffe29701a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with positive bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and finite u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with finite l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","50bf89e11cdfc6a5f67944e93b69ded7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first 2 elements with existing inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 20},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first 5 elements - insufficient elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find 0 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find 1 element\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{0},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5100393d9c20179d1f466df07560df26":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAddScaled(dst, tt.args.alpha, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","513e0f7a072d293d0d8efdd905153883":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51de97e964a1fffb9b422eb59da5400d":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tDiv(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51e62d3003c1cef2b289488bb49642bc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.33\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.33},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.66\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.66},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.4\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.4},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.6\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.6},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.33\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.33},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.66\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.66},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.4\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.4},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.6\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.6},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 0, v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: 0, v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 0, v: math.Inf(-1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: 0, u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51e6755e7f508768bca93b584325caa1":"```go\npackage floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty span\",\n\t\t\targs: args{\n\t\t\t\tn: 0,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one element\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"span with three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"span with four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"span with five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 6,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 7,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 8,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"span with nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 9,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ten elements\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eleven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 11,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twelve elements\",\n\t\t\targs: args{\n\t\t\t\tn: 12,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 13,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fourteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 14,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 15,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 7,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 16,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 7,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventeen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 17,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 18,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 8,\n\t\t},\n\t\t{\n\t\t\tname: \"span with nineteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 19,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 20,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 21,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 10,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 22,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 10,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 23,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 11,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 24,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 11,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 25,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 12,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 26,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 12,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 27,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 13,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 28,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 13,\n\t\t},\n\t\t{\n\t\t\tname: \"span with twenty-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 29,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 14,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 30,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 14,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 31,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 15,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 32,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 15,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 33,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 34,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 16,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 35,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 17,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 36,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 17,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 37,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 18,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 38,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 18,\n\t\t},\n\t\t{\n\t\t\tname: \"span with thirty-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 39,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 19,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 40,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 19,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 41,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 20,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 42,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 20,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 43,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 21,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 44,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 21,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 45,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 22,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 46,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 22,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 47,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 23,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 48,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 23,\n\t\t},\n\t\t{\n\t\t\tname: \"span with forty-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 49,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 24,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 50,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 24,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 51,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 25,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 52,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 25,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 53,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 26,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 54,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 26,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 55,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 27,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 56,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 27,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 57,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 28,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 58,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 28,\n\t\t},\n\t\t{\n\t\t\tname: \"span with fifty-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 59,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 29,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 60,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 29,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 61,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 30,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 62,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 30,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 63,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 31,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 64,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 31,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 65,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 32,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 66,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 32,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 67,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 33,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 68,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 33,\n\t\t},\n\t\t{\n\t\t\tname: \"span with sixty-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 69,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 34,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy elements\",\n\t\t\targs: args{\n\t\t\t\tn: 70,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 34,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 71,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 35,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 72,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 35,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 73,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 36,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 74,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 36,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 75,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 37,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 76,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 37,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 77,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 38,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 78,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 38,\n\t\t},\n\t\t{\n\t\t\tname: \"span with seventy-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 79,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 39,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 80,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 39,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 81,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 40,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 82,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 40,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 83,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 41,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 84,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 41,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 85,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 86,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 42,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 87,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 43,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 88,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 43,\n\t\t},\n\t\t{\n\t\t\tname: \"span with eighty-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 89,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 44,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety elements\",\n\t\t\targs: args{\n\t\t\t\tn: 90,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 44,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 91,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 45,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 92,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 45,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 93,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 46,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 94,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 46,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 95,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 47,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 96,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 47,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 97,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 48,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 98,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 48,\n\t\t},\n\t\t{\n\t\t\tname: \"span with ninety-nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 99,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 49,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred elements\",\n\t\t\targs: args{\n\t\t\t\tn: 100,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 49,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 101,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 50,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 102,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 50,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 103,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 51,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 104,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 51,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 105,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 52,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and six elements\",\n\t\t\targs: args{\n\t\t\t\tn: 106,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 52,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and seven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 107,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 53,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and eight elements\",\n\t\t\targs: args{\n\t\t\t\tn: 108,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 53,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and nine elements\",\n\t\t\targs: args{\n\t\t\t\tn: 109,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 54,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and ten elements\",\n\t\t\targs: args{\n\t\t\t\tn: 110,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 54,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and eleven elements\",\n\t\t\targs: args{\n\t\t\t\tn: 111,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 55,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and twelve elements\",\n\t\t\targs: args{\n\t\t\t\tn: 112,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 55,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and thirteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 113,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 56,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and fourteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 114,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 56,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and fifteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 115,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 57,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and sixteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 116,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 57,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and seventeen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 117,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 58,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and eighteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 118,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 58,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and nineteen elements\",\n\t\t\targs: args{\n\t\t\t\tn: 119,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 59,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and twenty elements\",\n\t\t\targs: args{\n\t\t\t\tn: 120,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 59,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and twenty-one elements\",\n\t\t\targs: args{\n\t\t\t\tn: 121,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 60,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and twenty-two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 122,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 60,\n\t\t},\n\t\t{\n\t\t\tname: \"span with one hundred and twenty-three elements\",\n\t\t\targs: args{\n\t\t\t\tn","51f37ea8b340d88b86dd6365594f823f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: 2.1269280118172213,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 4.1269280118172213,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0},\n\t\t\t},\n\t\t\twant: -0.8730719881827787,\n\t\t},\n\t\t{\n\t\t\tname: \"large positive elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1000.0, 1001.0, 1002.0},\n\t\t\t},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1000.0, -1001.0, -1002.0},\n\t\t\t},\n\t\t\twant: -1000.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(tt.want) \u0026\u0026 !math.IsNaN(got) \u0026\u0026 math.Abs(got-tt.want) \u003e 1e-12 {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","535e683dd7462e2c87fae6b37215e513":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slice lengths\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","54cf5f7fc12931717650aaf61a9e1990":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 0},\n\t\t{\"n=3, l=0, u=1, v=0\", args{3, 0, 1, 0}, 0},\n\t\t{\"n=3, l=0, u=1, v=1\", args{3, 0, 1, 1}, 2},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 0},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 0},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=5, l=0, u=1, v=0.2\", args{5, 0, 1, 0.2}, 0},\n\t\t{\"n=5, l=0, u=1, v=0.8\", args{5, 0, 1, 0.8}, 4},\n\t\t{\"n=5, l=0, u=1, v=0.4\", args{5, 0, 1, 0.4}, 1},\n\t\t{\"n=5, l=0, u=1, v=0.6\", args{5, 0, 1, 0.6}, 3},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 0},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n=3, l=1, u=0, v=1\", args{3, 1, 0, 1}, 0},\n\t\t{\"n=3, l=1, u=0, v=0\", args{3, 1, 0, 0}, 2},\n\t\t{\"n=3, l=1, u=0, v=0.5\", args{3, 1, 0, 0.5}, 1},\n\t\t{\"n=3, l=1, u=0, v=0.25\", args{3, 1, 0, 0.25}, 2},\n\t\t{\"n=3, l=1, u=0, v=0.75\", args{3, 1, 0, 0.75}, 0},\n\t\t{\"n=4, l=1, u=0, v=0.25\", args{4, 1, 0, 0.25}, 3},\n\t\t{\"n=4, l=1, u=0, v=0.75\", args{4, 1, 0, 0.75}, 0},\n\t\t{\"n=5, l=1, u=0, v=0.2\", args{5, 1, 0, 0.2}, 4},\n\t\t{\"n=5, l=1, u=0, v=0.8\", args{5, 1, 0, 0.8}, 0},\n\t\t{\"n=5, l=1, u=0, v=0.4\", args{5, 1, 0, 0.4}, 3},\n\t\t{\"n=5, l=1, u=0, v=0.6\", args{5, 1, 0, 0.6}, 1},\n\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), -math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=1\", args{2, math.Inf(1), math.Inf(1), 1}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=-1\", args{2, math.Inf(1), math.Inf(1), -1}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), -math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=1\", args{3, math.Inf(1), math.Inf(1), 1}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=-1\", args{3, math.Inf(1), math.Inf(1), -1}, 2},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{4, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{4, math.Inf(1), math.Inf(1), -math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=1\", args{4, math.Inf(1), math.Inf(1), 1}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=-1\", args{4, math.Inf(1), math.Inf(1), -1}, 2},\n\t\t{\"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{5, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{5, math.Inf(1), math.Inf(1), -math.Inf(1)}, 3},\n\t\t{\"n=5, l=math.Inf(1), u=math.Inf(1), v=1\", args{5, math.Inf(1), math.Inf(1), 1}, 0},\n\t\t{\"n=5, l=math.Inf(1), u=math.Inf(1), v=-1\", args{5, math.Inf(1), math.Inf(1), -1}, 3},\n\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{2, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{2, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=1\", args{2, math.Inf(-1), math.Inf(-1), 1}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-1\", args{2, math.Inf(-1), math.Inf(-1), -1}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=1\", args{3, math.Inf(-1), math.Inf(-1), 1}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-1\", args{3, math.Inf(-1), math.Inf(-1), -1}, 2},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{4, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{4, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=1\", args{4, math.Inf(-1), math.Inf(-1), 1}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-1\", args{4, math.Inf(-1), math.Inf(-1), -1}, 2},\n\t\t{\"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{5, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{5, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 3},\n\t\t{\"n=5, l=math.Inf(-1), u=math.Inf(-1), v=1\", args{5, math.Inf(-1), math.Inf(-1), 1}, 0},\n\t\t{\"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-1\", args{5, math.Inf(-1), math.Inf(-1), -1}, 3},\n\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()\", args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=1\", args{2, math.NaN(), 0, 1}, 1},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()\", args{2, 0, math.NaN(), math.NaN()}, 1},\n\t\t{\"n=2, l=0, u=math.NaN(), v=1\", args{2, 0, math.NaN(), 1}, 0},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\", args{2, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=1\", args{2, math.NaN(), math.NaN(), 1}, 0},\n\t\t{\"n=3, l=math.NaN(), u=0, v=math.NaN()\", args{3, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=3, l=math.NaN(), u=0, v=1\", args{3, math.NaN(), 0, 1}, 2},\n\t\t{\"n=3, l=0, u=math.NaN(), v=math.NaN()\", args{3, 0, math.NaN(), math.NaN()}, 2},\n\t\t{\"n=3, l=0, u=math.NaN(), v=1\", args{3, 0, math.NaN(), 1}, 0},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\", args{3, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=1\", args{3, math.NaN(), math.NaN(), 1}, 0},\n\t\t{\"n=4, l=math.NaN(), u=0, v=math.NaN()\", args{4, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=4, l=math.NaN(), u=0, v=1\", args{4, math.NaN(), 0, 1}, 3},\n\t\t{\"n=4, l=0, u=math.NaN(), v=math.NaN()\", args{4, 0, math.NaN(), math.NaN()}, 3},\n\t\t{\"n=4, l=0, u=math.NaN(), v=1\", args{4, 0, math.NaN(), 1}, 0},\n\t\t{\"n=4, l=math.NaN(), u=math.NaN(), v=math.NaN()\", args{4, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t\t{\"n=4, l=math.NaN(), u=math.NaN(), v=1\", args{4, math.NaN(), math.NaN(), 1}, 0},\n\t\t{\"n=5, l=math.NaN(), u=0, v=math.NaN()\", args{5, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=5, l=math.NaN(), u=0, v=1\", args{5, math.NaN(), 0, 1}, 4},\n\t\t{\"n=5, l=0, u=math.NaN(), v=math.NaN()\", args{5, 0, math.NaN(), math.NaN()}, 4},\n\t\t{\"n=5, l=0, u=math.NaN(), v=1\", args{5, 0, math.NaN(), 1}, 0},\n\t\t{\"n=5, l=math.NaN(), u=math.NaN(), v=math.NaN()\", args{5, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t\t{\"n=5, l=math.NaN(), u=math.NaN(), v=1\", args{5, math.NaN(), math.NaN(), 1}, 0},\n\n\t\t{\"n=2, l=0, u=1, v=math.NaN()\", args{2, 0, 1, math.NaN()}, 0},\n\t\t{\"n=3, l=0, u=1, v=math.NaN()\", args{3, 0, 1, math.NaN()}, 0},\n\t\t{\"n=4, l=0, u=1, v=math.NaN()\", args{4, 0, 1, math.NaN()}, 0},\n\t\t{\"n=5, l=0, u=1, v=math.NaN()\", args{5, 0, 1, math.NaN()}, 0},\n\n\t\t{\"n=2, l=1, u=0, v=math.NaN()\", args{2, 1, 0, math.NaN()}, 0},\n\t\t{\"n=3, l=1, u=0, v=math.NaN()\", args{3, 1, 0, math.NaN()}, 0},\n\t\t{\"n=4, l=1, u=0, v=math.NaN()\", args{4, 1, 0, math.NaN()}, 0},\n\t\t{\"n=5, l=1, u=0, v=math.NaN()\", args{5, 1, 0, math.NaN()}, 0},\n\n\t\t{\"n=2, l=0, u=0, v=0\", args{2, 0, 0, 0}, 0},\n\t\t{\"n=3, l=0, u=0, v=0\", args{3, 0, 0, 0}, 0},\n\t\t{\"n=4, l=0, u=0, v=0\", args{4, 0, 0, 0}, 0},\n\t\t{\"n=5, l=0, u=0, v=0\", args{5, 0, 0, 0}, 0},\n\n\t\t{\"n=2, l=1, u=1, v=1\", args{2, 1, 1, 1}, 0},\n\t\t{\"n=3, l=1, u=1, v=1\", args{3, 1, 1, 1}, 0},\n\t\t{\"n=4, l=1, u=1, v=1\", args{4, 1, 1, 1}, 0},\n\t\t{\"n=5, l=1, u=1, v=1\", args{5, 1, 1, 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5510c4a37a65894d6414bbbb693794cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is finite, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is less than u, v is halfway\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u, v is halfway\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","553492048d9a895e0c7a6480f8a52aa9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic Case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero Bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and finite u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Finite l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Dst less than 2\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","557c377cf77cfee5862a9c9ac824624d":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"zeroes\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 0.0, 3.0, 0.0, 5.0},\n\t\t\t},\n\t\t\twant: 9.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// almostEqual checks if two floats are equal within a small tolerance.\nfunc almostEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}","566741d6f8a87aed21ab7e8ff5149d73":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple Case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Outside Range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Equal to Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value Equal to Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf Value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse Range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse Range with Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse Range with Negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both Bounds NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both Bounds Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Both Bounds Inf - Different Signs\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even Number of Points\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even Number of Points - Closer to Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","585b7ac09a3b8d7ae48ddfa3fb2ed341":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1e10,\n\t\t\t\tu:   1e12,\n\t\t\t},\n\t\t\twant: []float64{1e10, 3.25e11, 6.5e11, 9.75e11, 1e12},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf4\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","58c241954b2664727c41d7721efab838":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","596038e104a8cfd0669b4e0ae9d834d2":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"FindFirstK\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindFirstK_LessThanK\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 4.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"FindFirstK_NegativeK\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindFirstK_ZeroK\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FindFirstK_WithIndices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","59cfb0df3d116931d8ef233f5c4d4ba1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_diff\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   -math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, 0, -math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","59e9807e410b3b1e42476d1626350de1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (even length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 10)\n}","5a067b714f12586ffcf7e6ed3a76e094":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single Element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Elements with Negative Values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Elements with Duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Elements with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Elements with NaN and Min Value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0, 1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5aa15949cd7c6551c734080cf1d8b245":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value less than the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value greater than or equal to the last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value equal to the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value between the first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value equal to the second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value between the second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Value equal to the third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5cab14684e3236374aff22310a463d29":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0, // Should panic, but for this test we'll assume it returns 0\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5.0, 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 5.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple maxes, first one returned\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 5.0, 5.0, 2.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"contains NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","5cfd5efc057e14d6f915e2f0e3a7a4e1":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices - different length\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices - different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5db0ca7cc9e199b358e4086356bd249f":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// L = 1\n\t\t{\"Norm L1 empty\", args{[]float64{}, 1}, 0},\n\t\t{\"Norm L1 one element\", args{[]float64{2}, 1}, 2},\n\t\t{\"Norm L1 two elements\", args{[]float64{2, 3}, 1}, 5},\n\t\t{\"Norm L1 multiple elements\", args{[]float64{1, 2, 3, 4, 5}, 1}, 15},\n\t\t// L = 2\n\t\t{\"Norm L2 empty\", args{[]float64{}, 2}, 0},\n\t\t{\"Norm L2 one element\", args{[]float64{2}, 2}, 2},\n\t\t{\"Norm L2 two elements\", args{[]float64{2, 3}, 2}, math.Sqrt(13)},\n\t\t{\"Norm L2 multiple elements\", args{[]float64{1, 2, 3, 4, 5}, 2}, math.Sqrt(55)},\n\t\t// L \u003e 2\n\t\t{\"Norm L3 empty\", args{[]float64{}, 3}, 0},\n\t\t{\"Norm L3 one element\", args{[]float64{2}, 3}, 2},\n\t\t{\"Norm L3 two elements\", args{[]float64{2, 3}, 3}, math.Pow(17, 1/3)},\n\t\t{\"Norm L3 multiple elements\", args{[]float64{1, 2, 3, 4, 5}, 3}, math.Pow(155, 1/3)},\n\t\t// L = Inf\n\t\t{\"Norm LInf empty\", args{[]float64{}, math.Inf(1)}, 0},\n\t\t{\"Norm LInf one element\", args{[]float64{2}, math.Inf(1)}, 2},\n\t\t{\"Norm LInf two elements\", args{[]float64{2, 3}, math.Inf(1)}, 3},\n\t\t{\"Norm LInf multiple elements\", args{[]float64{1, 2, 3, 4, 5}, math.Inf(1)}, 5},\n\t\t// Negative L\n\t\t{\"Norm negative L\", args{[]float64{1, 2, 3}, -1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}","5e5b494cf15f876e881c448b70eb2381":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Equal lengths\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{4, 5},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) != len(tt.args.t) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != badLength {\n\t\t\t\t\t\tt.Errorf(\"SubTo() did not panic with badLength, got %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSubTo(tt.args.dst, tt.args.s, tt.args.t)\n\t\t\t} else if len(tt.args.dst) != len(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != badDstLength {\n\t\t\t\t\t\tt.Errorf(\"SubTo() did not panic with badDstLength, got %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSubTo(tt.args.dst, tt.args.s, tt.args.t)\n\t\t\t} else {\n\t\t\t\tgot := SubTo(tt.args.dst, tt.args.s, tt.args.t)\n\t\t\t\tif !Equal(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","5ec0328f90a34d616e3b204f7b27312c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// n is less than 2\n\t\t{\"n less than 2 panic\", args{1, 0, 1, 0}, 0},\n\t\t// Special cases for Inf and NaN.\n\t\t{\"l is NaN and u is not NaN\", args{3, math.NaN(), 1, 0}, 2},\n\t\t{\"u is NaN\", args{3, 0, math.NaN(), 0}, 0},\n\t\t{\"l and u are both Inf and equal\", args{3, math.Inf(0), math.Inf(0), 0}, 0},\n\t\t{\"l and u are both Inf, n is odd, and v is not Inf\", args{3, math.Inf(0), math.Inf(0), 0}, 1},\n\t\t{\"l and u are both Inf, n is odd, and v is Inf\", args{3, math.Inf(0), math.Inf(0), math.Inf(0)}, 0},\n\t\t{\"l and u are both Inf, n is even, and v is Inf\", args{4, math.Inf(0), math.Inf(0), math.Inf(0)}, 0},\n\t\t{\"l and u are both Inf, n is even, and v is not Inf\", args{4, math.Inf(0), math.Inf(0), 0}, 2},\n\t\t{\"l is Inf, u is not Inf, and v is equal to l\", args{3, math.Inf(0), 1, math.Inf(0)}, 0},\n\t\t{\"l is Inf, u is not Inf, and v is not equal to l\", args{3, math.Inf(0), 1, 0}, 2},\n\t\t{\"u is Inf, l is not Inf, and v is equal to u\", args{3, 0, math.Inf(0), math.Inf(0)}, 2},\n\t\t{\"u is Inf, l is not Inf, and v is not equal to u\", args{3, 0, math.Inf(0), 0}, 0},\n\t\t// Special cases for v outside (l, u) and (u, l).\n\t\t{\"l \u003c u, v \u003c= l\", args{3, 0, 1, 0}, 0},\n\t\t{\"l \u003c u, v \u003e= u\", args{3, 0, 1, 1}, 2},\n\t\t{\"l \u003e u, v \u003e= l\", args{3, 1, 0, 1}, 0},\n\t\t{\"l \u003e u, v \u003c= u\", args{3, 1, 0, 0}, 2},\n\t\t// General case.\n\t\t{\"general case 1\", args{5, 0, 1, 0.25}, 1},\n\t\t{\"general case 2\", args{5, 0, 1, 0.75}, 3},\n\t\t{\"general case 3\", args{5, 1, 0, 0.25}, 3},\n\t\t{\"general case 4\", args{5, 1, 0, 0.75}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","61372161edf3c9defd238b1135cd48bc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Test cases for valid inputs\n\t\t{\n\t\t\tname: \"Span_Valid_Case1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Valid_Case2\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -2.0,\n\t\t\t\tu:   2.0,\n\t\t\t},\n\t\t\twant: []float64{-2.0, 0.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Valid_Case3\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   -1.5,\n\t\t\t\tu:   1.5,\n\t\t\t},\n\t\t\twant: []float64{-1.5, -0.5, 0.5, 1.5},\n\t\t},\n\t\t// Test cases for NaN inputs\n\t\t{\n\t\t\tname: \"Span_NaN_l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_NaN_u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t// Test cases for Inf inputs\n\t\t{\n\t\t\tname: \"Span_Inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t// Test cases for short dst slice\n\t\t{\n\t\t\tname: \"Span_Short_Dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want == nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Span() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","619b5b88adc14dd5e12b4896a2e60292":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","63eb0a38dfc2724cfeb1f978ccfde92a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"zero length\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v outside\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","63fa0b8a84228ec317cfed7688363a0a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf l and inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","6413829de65ffe830657a47656e35ce0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is 1\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, odd n\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, even n\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v is in the middle\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v is close to l\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.01,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v is close to u\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.99,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","656d8243e7ab61dd1b5d5d4c0a1c2a51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero Length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"One Element\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Lower\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Upper\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Upper\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Both\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), -1, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Both Even Length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","65a07e02fcce872028436f8a915909a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Value less than minimum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value greater than maximum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Value equal to minimum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value equal to maximum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","65fd8ad4512dfef4102fe3bfb9270a4f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf and Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","6614f0f640bed3219f6edca88d44dd37":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"ZeroLength\", args{0, 0, 1, 0.5}, 0},\n\t\t{\"OneLength\", args{1, 0, 1, 0.5}, 0},\n\t\t{\"TwoLength\", args{2, 0, 1, 0.5}, 0},\n\t\t{\"TwoLength\", args{2, 0, 1, 0.75}, 1},\n\t\t{\"EvenLength\", args{4, 0, 1, 0.25}, 0},\n\t\t{\"EvenLength\", args{4, 0, 1, 0.5}, 1},\n\t\t{\"EvenLength\", args{4, 0, 1, 0.75}, 2},\n\t\t{\"OddLength\", args{5, 0, 1, 0.25}, 0},\n\t\t{\"OddLength\", args{5, 0, 1, 0.5}, 2},\n\t\t{\"OddLength\", args{5, 0, 1, 0.75}, 3},\n\t\t{\"OddLength\", args{5, -1, 1, 0}, 1},\n\t\t{\"OddLength\", args{5, -1, 1, 0.5}, 2},\n\t\t{\"OddLength\", args{5, -1, 1, 1}, 4},\n\t\t{\"EvenLength\", args{4, 1, 0, 0.75}, 0},\n\t\t{\"EvenLength\", args{4, 1, 0, 0.5}, 1},\n\t\t{\"EvenLength\", args{4, 1, 0, 0.25}, 2},\n\t\t{\"OddLength\", args{5, 1, 0, 1}, 0},\n\t\t{\"OddLength\", args{5, 1, 0, 0.5}, 2},\n\t\t{\"OddLength\", args{5, 1, 0, 0}, 4},\n\t\t{\"NaNLower\", args{2, math.NaN(), 1, 0.5}, 1},\n\t\t{\"NaNUpper\", args{2, 0, math.NaN(), 0.5}, 0},\n\t\t{\"InfLower\", args{2, math.Inf(-1), 1, 0.5}, 1},\n\t\t{\"InfUpper\", args{2, 0, math.Inf(1), 0.5}, 0},\n\t\t{\"InfBoth\", args{2, math.Inf(-1), math.Inf(1), 0.5}, 0},\n\t\t{\"InfBothSame\", args{2, math.Inf(1), math.Inf(1), 0.5}, 0},\n\t\t{\"InfBothSame\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"InfBothSame\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"InfBothSame\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"InfBothSame\", args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"InfBothSame\", args{4, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"InfBothSame\", args{4, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t} else if fmt.Sprintf(\"%v\", r) != shortSpan {\n\t\t\tt.Errorf(\"NearestIdxForSpan() panicked with %v, want %v\", r, shortSpan)\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}","662f2e407358b89be4281a5a18880939":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L-norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slice lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Panic is expected here\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","66d292c1ce226e5c8864cc13fe05bc21":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case 1\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case 3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than l, l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than u, l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","67dd6295b47259e6fb279f0555c34da2":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices different lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","68474e5a72e61670a6cb46b5ac1305bf":"package floats\n\nimport \"testing\"\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","68899a430ddf4f6f239e756b66bbbffb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Identical slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","68e0afb435fbddde65eef21993523abe":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"edge case\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN input\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5, 2, 3, 1, 4},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","690866bf0f92f2e1f2a6c438c10bc8eb":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=3, l=0, u=10, v=5\", args{3, 0, 10, 5}, 1},\n\t\t{\"n=3, l=10, u=0, v=5\", args{3, 10, 0, 5}, 2},\n\t\t{\"n=4, l=0, u=10, v=5\", args{4, 0, 10, 5}, 2},\n\t\t{\"n=4, l=10, u=0, v=5\", args{4, 10, 0, 5}, 1},\n\t\t{\"n=3, l=0, u=10, v=0\", args{3, 0, 10, 0}, 0},\n\t\t{\"n=3, l=0, u=10, v=10\", args{3, 0, 10, 10}, 2},\n\t\t{\"n=3, l=10, u=0, v=10\", args{3, 10, 0, 10}, 0},\n\t\t{\"n=3, l=10, u=0, v=0\", args{3, 10, 0, 0}, 2},\n\t\t{\"n=2, l=0, u=10, v=5\", args{2, 0, 10, 5}, 1},\n\t\t{\"n=2, l=10, u=0, v=5\", args{2, 10, 0, 5}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\", args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=0\", args{3, math.Inf(1), math.Inf(1), 0}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=0\", args{3, math.Inf(-1), math.Inf(1), 0}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\", args{3, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=0\", args{3, math.Inf(-1), math.Inf(-1), 0}, 1},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=0\", args{3, 0, math.Inf(1), 0}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=math.Inf(1)\", args{3, 0, math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=math.Inf(-1)\", args{3, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.NaN(), u=10, v=0\", args{3, math.NaN(), 10, 0}, 0},\n\t\t{\"n=3, l=math.NaN(), u=10, v=10\", args{3, math.NaN(), 10, 10}, 2},\n\t\t{\"n=3, l=math.NaN(), u=10, v=math.NaN(), v=math.NaN()\", args{3, math.NaN(), 10, math.NaN()}, 0},\n\t\t{\"n=3, l=10, u=math.NaN(), v=0\", args{3, 10, math.NaN(), 0}, 2},\n\t\t{\"n=3, l=10, u=math.NaN(), v=10\", args{3, 10, math.NaN(), 10}, 0},\n\t\t{\"n=3, l=10, u=math.NaN(), v=math.NaN(), v=math.NaN()\", args{3, 10, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=0\", args{3, 0, math.NaN(), 0}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=10\", args{3, 0, math.NaN(), 10}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=math.NaN(), v=math.NaN()\", args{3, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=0\", args{3, math.NaN(), math.NaN(), 0}, 0},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=10\", args{3, math.NaN(), math.NaN(), 10}, 0},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\", args{3, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","6930d616072f2ca90b31519426117788":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: 2.1269280118172214,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 4.161539316206239,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0},\n\t\t\t},\n\t\t\twant: -0.838460683793761,\n\t\t},\n\t\t{\n\t\t\tname: \"positive and negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0},\n\t\t\t},\n\t\t\twant: 3.161539316206239,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1000.0, 2000.0, 3000.0, 4000.0},\n\t\t\t},\n\t\t\twant: 4000.0,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.0001, 0.0002, 0.0003, 0.0004},\n\t\t\t},\n\t\t\twant: -8.517192563259897,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(tt.want) \u0026\u0026 !math.IsNaN(got) \u0026\u0026 math.Abs(got-tt.want) \u003e 1e-10 {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","69897caeb65fe72f7aa78c474973b3a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase1\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 3.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"BasicCase2\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 1.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"BasicCase3\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NegInf\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ReverseOrder\",\n\t\t\targs: args{n: 5, l: 5.0, u: 1.0, v: 2.5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualBounds\",\n\t\t\targs: args{n: 5, l: 2.0, u: 2.0, v: 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"OddN\",\n\t\t\targs: args{n: 7, l: 1.0, u: 7.0, v: 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"OddNInf\",\n\t\t\targs: args{n: 7, l: math.Inf(-1), u: math.Inf(1), v: 4.0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"OddNInfL\",\n\t\t\targs: args{n: 7, l: math.Inf(-1), u: 7.0, v: 1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"OddNInfU\",\n\t\t\targs: args{n: 7, l: 1.0, u: math.Inf(1), v: 7.0},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"OddNInfBoth\",\n\t\t\targs: args{n: 7, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"OddNInfBothNeg\",\n\t\t\targs: args{n: 7, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBounds1\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 5.0, v: 3.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNBounds2\",\n\t\t\targs: args{n: 5, l: 1.0, u: math.NaN(), v: 3.0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","6aede9c09c69006b852dd6e16ffad905":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"TestSpan_Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan_Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan_NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan_Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan_Inf_Different\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6af629ddd937cab703589d0bb7a8abe6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.3,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6bfc7b9f97ba65b7653d66b1e69f0b80":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t\tf:  func(x, y float64) bool { return x == y },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t\tf:  func(x, y float64) bool { return x == y },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t\tf:  func(x, y float64) bool { return x == y },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with custom function\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.1, 2.1, 3.1},\n\t\t\t\tf:  func(x, y float64) bool { return x \u003c= y \u0026\u0026 y \u003c= x+0.2 },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","6c7c9566e0529939e343a754e38af8a8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Panics_for_length_less_than_2\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span() did not panic for length less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{}, 0, 1)\n\t})\n\n\tt.Run(\"Handles_NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Handles_Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tgot := Span(dst, math.Inf(1), math.Inf(-1))\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf, -Inf) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Returns_correctly_spaced_values\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{1, 2, 3, 4, 5}\n\t\tgot := Span(dst, 1, 5)\n\t\tif !Equal(got, want) {\n\t\t\tt.Errorf(\"Span(%v, 1, 5) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n}\n","6d06d0759e4be25c7b630ad5ceb5bc13":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic_case\",\n\t\t\targs: args{n: 5, l: 1, u: 5, v: 3},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"outside_lower_bound\",\n\t\t\targs: args{n: 5, l: 1, u: 5, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"outside_upper_bound\",\n\t\t\targs: args{n: 5, l: 1, u: 5, v: 6},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative_bounds\",\n\t\t\targs: args{n: 5, l: -5, u: -1, v: -3},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_lower_bound\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: 5, v: 3},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_upper_bound\",\n\t\t\targs: args{n: 5, l: 1, u: math.Inf(1), v: 3},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both_bounds\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: 3},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both_bounds_odd_length\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 3},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both_bounds_odd_length_negative_v\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: -3},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_lower_bound\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 5, v: 3},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_upper_bound\",\n\t\t\targs: args{n: 5, l: 1, u: math.NaN(), v: 3},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_v\",\n\t\t\targs: args{n: 5, l: 1, u: 5, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6d21515f8125323eb177cf800f931b07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   -5,\n\t\t\t},\n\t\t\twant: []float64{-10, -8.75, -7.5, -6.25, -5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6deba74db0b90460246258ff700fb465":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Normal Case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{}, 0, 1)\n}","6f60e11c27d167cc98a6c777b2ed309f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"simple\", args{5, 0, 10, 5}, 2},\n\t\t{\"outside_lower\", args{5, 0, 10, -1}, 0},\n\t\t{\"outside_upper\", args{5, 0, 10, 11}, 4},\n\t\t{\"nan_lower\", args{5, math.NaN(), 10, 5}, 4},\n\t\t{\"nan_upper\", args{5, 0, math.NaN(), 5}, 0},\n\t\t{\"nan_v\", args{5, 0, 10, math.NaN()}, 0},\n\t\t{\"inf_lower\", args{5, math.Inf(1), 10, 5}, 4},\n\t\t{\"inf_upper\", args{5, 0, math.Inf(1), 5}, 0},\n\t\t{\"inf_v_pos\", args{5, 0, 10, math.Inf(1)}, 4},\n\t\t{\"inf_v_neg\", args{5, 0, 10, math.Inf(-1)}, 0},\n\t\t{\"inf_both\", args{5, math.Inf(1), math.Inf(1), 5}, 2},\n\t\t{\"inf_both_even\", args{4, math.Inf(1), math.Inf(1), 5}, 2},\n\t\t{\"inf_both_neg\", args{5, math.Inf(-1), math.Inf(-1), -5}, 2},\n\t\t{\"inf_both_neg_even\", args{4, math.Inf(-1), math.Inf(-1), -5}, 2},\n\t\t{\"edge_lower\", args{5, 0, 10, 0}, 0},\n\t\t{\"edge_upper\", args{5, 0, 10, 10}, 4},\n\t\t{\"zero_length\", args{1, 0, 10, 5}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6f8f0cf089b9296b93c93e650fdcf0f6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest to middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","705779804a0d6e416d989d33e5d71d2c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"Basic1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\n\t\t// Edge cases\n\t\t{\n\t\t\tname: \"Edge1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\n\t\t// Inf cases\n\t\t{\n\t\t\tname: \"Inf1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: -math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf6\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: -math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf7\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf8\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\n\t\t// NaN cases\n\t\t{\n\t\t\tname: \"NaN1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\n\t\t// Reverse cases\n\t\t{\n\t\t\tname: \"Reverse1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\n\t\t// Odd length cases\n\t\t{\n\t\t\tname: \"Odd1\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd2\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\n\t\t// Even length cases\n\t\t{\n\t\t\tname: \"Even1\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even2\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Even3\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\n\t\t// Panics\n\t\t{\n\t\t\tname: \"Panic\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: -1, // Indicates that it's expected to panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.want == -1 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","70ef5cf162ccbbbeaffa61109d9d5327":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"SimpleCase\", args{n: 5, l: 0, u: 10, v: 5}, 2},\n\t\t{\"NearLowerBound\", args{n: 5, l: 0, u: 10, v: 1}, 0},\n\t\t{\"NearUpperBound\", args{n: 5, l: 0, u: 10, v: 9}, 4},\n\t\t{\"LowerBound\", args{n: 5, l: 0, u: 10, v: 0}, 0},\n\t\t{\"UpperBound\", args{n: 5, l: 0, u: 10, v: 10}, 4},\n\t\t{\"OddLength\", args{n: 3, l: 0, u: 10, v: 5}, 1},\n\t\t{\"EvenLength\", args{n: 4, l: 0, u: 10, v: 5}, 2},\n\t\t{\"NaNValue\", args{n: 5, l: 0, u: 10, v: math.NaN()}, 0},\n\t\t{\"NaNLowerBound\", args{n: 5, l: math.NaN(), u: 10, v: 5}, 4},\n\t\t{\"NaNUpperBound\", args{n: 5, l: 0, u: math.NaN(), v: 5}, 0},\n\t\t{\"InfLowerBound\", args{n: 5, l: math.Inf(-1), u: 10, v: 5}, 4},\n\t\t{\"InfUpperBound\", args{n: 5, l: 0, u: math.Inf(1), v: 5}, 0},\n\t\t{\"InfBothBounds\", args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: 5}, 2},\n\t\t{\"InfBothBoundsEqual\", args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: 5}, 0},\n\t\t{\"InfBothBoundsEqualOddLength\", args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: 5}, 1},\n\t\t{\"InfValueNegative\", args{n: 5, l: 0, u: 10, v: math.Inf(-1)}, 0},\n\t\t{\"InfValuePositive\", args{n: 5, l: 0, u: 10, v: math.Inf(1)}, 4},\n\t\t{\"ReversedBounds\", args{n: 5, l: 10, u: 0, v: 5}, 0},\n\t\t{\"ReversedBoundsNearLowerBound\", args{n: 5, l: 10, u: 0, v: 9}, 4},\n\t\t{\"ReversedBoundsNearUpperBound\", args{n: 5, l: 10, u: 0, v: 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","719fbaed10eb9f84af07d905fd6dc8b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, -3.0, 4.0, -5.0},\n\t\t\t},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","72080191d1a0f6a037ea1ba79b729034":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"equal length slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: 32,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{4, 5},\n\t\t\t},\n\t\t\twant: math.NaN(), // Expect panic, so want is NaN\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Panics are expected in the unequal length case\n\t\t\t\t\tif tt.name == \"unequal length slices\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Dot() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Dot(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Dot() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","731ef9c1650a0835b8d91c3e5645ea3d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0, 7.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -8.0, -6.0, -4.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ZeroLength\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"OneLength\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN_2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf_2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf_3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf_4\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7342be149dca4d93bbc1c7058fc4b165":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"same length and same value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same length and different value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"same length and same NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same length and different NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","735adf687a18e301fe773c3aa12dfa6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2 panic\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN returns 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN u not NaN returns n - 1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN returns 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf returns 0 for n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf returns 0 for n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf returns n/2 for v == 0\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf returns n/2+1 for v == 0 and n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf returns n/2 for v \u003e 0 and n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf returns n/2+1 for v \u003e 0 and n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf returns n-1 for v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf returns 0 for v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf returns 0 for v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf returns n-1 for v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf -1 returns 0 for l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf -1 returns n-1 for l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf 1 returns 0 for u \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf 1 returns n-1 for u \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v inside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v inside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u returns 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.want == -1 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","742c3a0e60b52275548045f9937128ed":"package floats\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 0, 0},\n\t\t\t},\n\t\t\twant: []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 0, 0},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{2.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 0, 0},\n\t\t\t},\n\t\t\twant: []int{1, 0, 2},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]int, len(tt.args.dst))\n\t\t\tcopy(got, tt.args.inds)\n\t\t\tArgsortStable(tt.args.dst, got)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"ArgsortStable() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestArgsortStablePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ArgsortStable() did not panic\")\n\t\t}\n\t}()\n\tdst := []float64{1.0, 2.0, 3.0}\n\tinds := []int{0, 1}\n\tArgsortStable(dst, inds)\n\tt.Errorf(\"ArgsortStable() should have panicked but didn't\")\n}\n\nfunc Equal(s1, s2 []int) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","74b6c2682cd0091c2b1d38011061c6ec":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7531e22078872885620137b8f10e36fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","75568582d0db1dd3b3d9aaadf9b871d7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice - NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != shortSpan {\n\t\t\t\t\t\tt.Errorf(\"Within() should have panicked with %v, but panicked with %v\", shortSpan, r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() should have panicked, but did not\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","764003bc0b16664630dab25d0a7361f9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L-norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","7775eae90044d2b83c4ba237a18e6524":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0, // Panics\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest is first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest is last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest is in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","77b93326ee7c291bfa127d16988aa7d8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   -2,\n\t\t\t},\n\t\t\twant: []float64{-1, -1.5, -2},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","79104be89c9c1a79798d2bc6dce60d34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"one element slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.5, 0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, 0, 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","79ba96a414ec58600a22cf4d6a65c7d9":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"Basic case 1\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 2.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case 2\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 4.0},\n\t\t\twant: 4,\n\t\t},\n\t\t// Edge cases\n\t\t{\n\t\t\tname: \"Edge case 1: v equal to l\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case 2: v equal to u\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 5.0},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case 3: v outside (l, u)\",\n\t\t\targs: args{n: 5, l: 1.0, u: 5.0, v: 0.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case 4: v outside (u, l)\",\n\t\t\targs: args{n: 5, l: 5.0, u: 1.0, v: 6.0},\n\t\t\twant: 0,\n\t\t},\n\t\t// Special cases\n\t\t{\n\t\t\tname: \"Special case 1: l = u\",\n\t\t\targs: args{n: 5, l: 1.0, u: 1.0, v: 1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 2: l is NaN\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 5.0, v: 2.0},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 3: u is NaN\",\n\t\t\targs: args{n: 5, l: 1.0, u: math.NaN(), v: 2.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 4: l and u are both Inf\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 5: l and u are both Inf with different signs\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(-1), v: 1.0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 6: l and u are both Inf with different signs and odd n\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 7: l is Inf\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: 5.0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Special case 8: u is Inf\",\n\t\t\targs: args{n: 5, l: 1.0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t// Panic cases\n\t\t{\n\t\t\tname: \"Panic case: n \u003c 2\",\n\t\t\targs: args{n: 1, l: 1.0, u: 5.0, v: 2.5},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) didn't panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_SpecialCases(t *testing.T) {\n\t// Test cases for v outside (l, u) and (u, l).\n\tfor _, tc := range []struct {\n\t\tname   string\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"v less than l, l \u003c u\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\tv:      0.0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v greater than u, l \u003c u\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\tv:      6.0,\n\t\t\texpect: 4,\n\t\t},\n\t\t{\n\t\t\tname:   \"v greater than l, l \u003e u\",\n\t\t\tn:      5,\n\t\t\tl:      5.0,\n\t\t\tu:      1.0,\n\t\t\tv:      6.0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v less than u, l \u003e u\",\n\t\t\tn:      5,\n\t\t\tl:      5.0,\n\t\t\tu:      1.0,\n\t\t\tv:      0.0,\n\t\t\texpect: 4,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n\t// Test cases for v being NaN.\n\tfor _, tc := range []struct {\n\t\tname   string\n\t\tn      int\n\t\tl, u   float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"v is NaN, l and u are not NaN\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN, l is NaN\",\n\t\t\tn:      5,\n\t\t\tl:      math.NaN(),\n\t\t\tu:      5.0,\n\t\t\texpect: 6,\n\t\t},\n\t\t{\n\t\t\tname:   \"v is NaN, u is NaN\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      math.NaN(),\n\t\t\texpect: 0,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, math.NaN())\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, NaN) = %v, want %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n\t// Test cases for l and u being Inf.\n\tfor _, tc := range []struct {\n\t\tname   string\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"l and u are both +Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l and u are both -Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(-1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 4,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, v is +Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(1),\n\t\t\texpect: 0,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, v is -Inf\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      math.Inf(-1),\n\t\t\texpect: 4,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, v is 0\",\n\t\t\tn:      5,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      0,\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"l is +Inf, u is -Inf, v is 0, odd n\",\n\t\t\tn:      7,\n\t\t\tl:      math.Inf(1),\n\t\t\tu:      math.Inf(-1),\n\t\t\tv:      0,\n\t\t\texpect: 3,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_NearHalfway(t *testing.T) {\n\t// Test cases near the halfway point.\n\tfor _, tc := range []struct {\n\t\tname   string\n\t\tn      int\n\t\tl, u   float64\n\t\tv      float64\n\t\texpect int\n\t}{\n\t\t{\n\t\t\tname:   \"v slightly less than halfway\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\tv:      2.9999999999,\n\t\t\texpect: 2,\n\t\t},\n\t\t{\n\t\t\tname:   \"v slightly more than halfway\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\tv:      3.0000000001,\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"v exactly halfway, odd n\",\n\t\t\tn:      5,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\tv:      3.0,\n\t\t\texpect: 3,\n\t\t},\n\t\t{\n\t\t\tname:   \"v exactly halfway, even n\",\n\t\t\tn:      6,\n\t\t\tl:      1.0,\n\t\t\tu:      5.0,\n\t\t\tv:      3.0,\n\t\t\texpect: 3,\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := NearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\t\t\tif got != tc.expect {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\",\n\t\t\t\t\ttc.n, tc.l, tc.u, tc.v, got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}","79f3aca3977491f8d5f9776daa658477":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple Case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower Bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, 10, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower and Upper Bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Lower and Upper Bound (unequal)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","7ae0b412168e3741e885695e100e10dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with valid input\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound and Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7ba6c1a9d9cfc826feb1c6cc29a7d1d5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3, 4e-5, 5e15},\n\t\t\t},\n\t\t\twant: 5.000000000000001e+15,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7be2cfa5773f77e57f0b52a902a37906":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Two elements, value in between\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Two elements, value outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Two elements, value outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, value in between\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, value near lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, value near upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 9.9,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, value outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, value outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound NaN, upper bound not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound NaN, lower bound not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower and upper bound infinite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower and upper bound infinite (different signs)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower and upper bound infinite (odd number of elements)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower and upper bound infinite (even number of elements)\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound infinite, upper bound finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound infinite, upper bound finite (value \u003c upper bound)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound finite, upper bound infinite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound finite, upper bound infinite (value \u003e lower bound)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value negative infinity\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Value positive infinity\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Value NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7ce7e0ff5d5a26e4ace3cfba39e5cd75":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Zero elements requested\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(float64) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"All elements requested\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(float64) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 1\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Not enough elements found\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 2 elements (with initial inds)\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 1\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7dbdc50dd0c7ca092a6eb33c2b115cb4":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7dee733e37d1cd403fa43e560561b44b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   3,\n\t\t\t},\n\t\t\twant: []float64{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"negative case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{-1, 0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"inf case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"nan case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"short dst panic\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   3,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","7e067ec2eec8c0ce92a797561684a201":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n = 2, l = 0, u = 1, v = 0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n = 3, l = 0, u = 1, v = 0.25\", args{3, 0, 1, 0.25}, 1},\n\t\t{\"n = 3, l = 0, u = 1, v = 0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n = 4, l = 0, u = 1, v = 0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n = 4, l = 0, u = 1, v = 0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n = 5, l = 0, u = 1, v = 0.25\", args{5, 0, 1, 0.25}, 1},\n\t\t{\"n = 5, l = 0, u = 1, v = 0.75\", args{5, 0, 1, 0.75}, 4},\n\t\t{\"n = 10, l = 0, u = 1, v = 0.1\", args{10, 0, 1, 0.1}, 1},\n\t\t{\"n = 10, l = 0, u = 1, v = 0.9\", args{10, 0, 1, 0.9}, 9},\n\t\t{\"n = 10, l = 0, u = 1, v = 0.5\", args{10, 0, 1, 0.5}, 5},\n\t\t{\"n = 10, l = 0, u = 1, v = 0.49\", args{10, 0, 1, 0.49}, 5},\n\t\t{\"n = 10, l = 0, u = 1, v = 0.51\", args{10, 0, 1, 0.51}, 5},\n\t\t{\"n = 10, l = -1, u = 1, v = 0\", args{10, -1, 1, 0}, 5},\n\t\t{\"n = 10, l = 1, u = -1, v = 0\", args{10, 1, -1, 0}, 5},\n\t\t{\"n = 10, l = -1, u = 1, v = -1\", args{10, -1, 1, -1}, 0},\n\t\t{\"n = 10, l = 1, u = -1, v = 1\", args{10, 1, -1, 1}, 0},\n\t\t{\"n = 10, l = -1, u = 1, v = 1\", args{10, -1, 1, 1}, 9},\n\t\t{\"n = 10, l = 1, u = -1, v = -1\", args{10, 1, -1, -1}, 9},\n\t\t{\"n = 10, l = -1, u = 1, v = math.Inf(1)\", args{10, -1, 1, math.Inf(1)}, 9},\n\t\t{\"n = 10, l = 1, u = -1, v = math.Inf(1)\", args{10, 1, -1, math.Inf(1)}, 0},\n\t\t{\"n = 10, l = -1, u = 1, v = math.Inf(-1)\", args{10, -1, 1, math.Inf(-1)}, 0},\n\t\t{\"n = 10, l = 1, u = -1, v = math.Inf(-1)\", args{10, 1, -1, math.Inf(-1)}, 9},\n\t\t{\"n = 10, l = math.NaN(), u = 1, v = 0\", args{10, math.NaN(), 1, 0}, 9},\n\t\t{\"n = 10, l = 1, u = math.NaN(), v = 0\", args{10, 1, math.NaN(), 0}, 0},\n\t\t{\"n = 10, l = math.NaN(), u = math.NaN(), v = 0\", args{10, math.NaN(), math.NaN(), 0}, 0},\n\t\t{\"n = 10, l = math.Inf(1), u = math.Inf(1), v = 0\", args{10, math.Inf(1), math.Inf(1), 0}, 0},\n\t\t{\"n = 10, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\", args{10, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n = 10, l = math.Inf(1), u = math.Inf(1), v = math.Inf(-1)\", args{10, math.Inf(1), math.Inf(1), math.Inf(-1)}, 5},\n\t\t{\"n = 10, l = math.Inf(-1), u = math.Inf(-1), v = 0\", args{10, math.Inf(-1), math.Inf(-1), 0}, 9},\n\t\t{\"n = 10, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\", args{10, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 5},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7e0e584ee99bb04f534bf4a061567134":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find_k_0_empty\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 0\n\t\t\t\t},\n\t\t\t\ts: []float64{},\n\t\t\t\tk: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_0_non_empty\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2, 3},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 0\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_neg_all_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 0\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_neg_some_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 1\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: -1,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_neg_none_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 3\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: -1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_all_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 0\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: 3,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_some_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 1\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_not_enough_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 2\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    []int{2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_none_found\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 3\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","7e338ea1edf5d53d16546d7262adfbf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are infinities, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are infinities, l == u, v is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are infinities, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are infinities, l != u, n is odd, v is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are infinities, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are infinities, l != u, n is even, v is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is inf, u is finite, v is l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is inf, v is u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f25d22513ef6e04b64a192ed3cfc5b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=5, l=0, u=1, v=0.2\", args{5, 0, 1, 0.2}, 1},\n\t\t{\"n=5, l=0, u=1, v=0.8\", args{5, 0, 1, 0.8}, 4},\n\t\t{\"n=5, l=0, u=1, v=0.5\", args{5, 0, 1, 0.5}, 3},\n\t\t{\"n=2, l=0, u=1, v=-1\", args{2, 0, 1, -1}, 0},\n\t\t{\"n=2, l=0, u=1, v=2\", args{2, 0, 1, 2}, 1},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n=2, l=1, u=0, v=-0.5\", args{2, 1, 0, -0.5}, 0},\n\t\t{\"n=2, l=0, u=0, v=0\", args{2, 0, 0, 0}, 0},\n\t\t{\"n=2, l=1, u=1, v=1\", args{2, 1, 1, 1}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(-1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)}, args{3, math.Inf(-1), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)}, args{3, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"n=3, l=math.NaN(), u=0, v=math.NaN()}, args{3, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=math.NaN()}, args{3, 0, math.NaN(), math.NaN()}, 2},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()}, args{3, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t\t{\"n=3, l=math.NaN(), u=1, v=1}, args{3, math.NaN(), 1, 1}, 2},\n\t\t{\"n=3, l=1, u=math.NaN(), v=1}, args{3, 1, math.NaN(), 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f3a126a386b9ed26bfb0769fd5122a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 2.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple max values\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -2.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 3.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f6810e613aee48e70477e69512564f4":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Single slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f69ce5884584bab680bef849c1ae2aa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0, 7.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -8.0, -6.0, -4.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !equalSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","806936f5d9d784f8306b0ac2a5943872":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"single slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices with equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices with different lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","809daefdfb910db4c42b0f1b1277fcbe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   -5,\n\t\t\t},\n\t\t\twant: []float64{-10, -8.75, -7.5, -6.25, -5},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Large Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000000,\n\t\t\t\tu:   1000005,\n\t\t\t},\n\t\t\twant: []float64{1000000, 1000001.25, 1000002.5, 1000003.75, 1000005},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN (reverse)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   10,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf (reverse)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   10,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{10, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf (unequal)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-12) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","80ffe1ef1dc80434c8321ba0d2fb1c7c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic span\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0, 7.0, 9.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8164f904edbace0e687a6eb1a01a3af5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"L1\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname: \"LInf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","820e22f4df79d99e681e83421197f3ad":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExampleNorm() {\n\ts := []float64{1, 2, 3}\n\tfmt.Println(Norm(s, 1)) // Output: 6\n\tfmt.Println(Norm(s, 2)) // Output: 3.7416573867739413\n\tfmt.Println(Norm(s, math.Inf(1))) // Output: 3\n}","8237b765f07159af3926d27949397523":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"negative case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"inf case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","82cfd02b37e335e4d6d30fe85596f5fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8316756719bd266dc16a02ec38ac71fe":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -1.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd Length\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Even Length\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0.0, 1.0, 0.5)\n}\n\nfunc TestNearestIdxForSpanEdgeCases(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Zero Length\",\n\t\t\targs: args{\n\t\t\t\tn: 0,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"One Length\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal Bounds Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Halfway Point\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_EdgeCases_Inf(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Inf Bounds, Inf V, Even Length\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds, Inf V, Odd Length\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds, Neg Inf V, Even Length\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds, Neg Inf V, Odd Length\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds, Finite V, Even Length\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds, Finite V, Odd Length\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L, Finite U, V Between L and U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0.0,\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L, Finite U, V Greater Than U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Finite L, Inf U, V Between L and U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Finite L, Inf U, V Less Than L\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L, Inf U, V Equal L\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf L, Inf U, V Equal U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_SpecialCases(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"V Less Than L, L Less Than U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"V Greater Than U, L Less Than U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"V Greater Than L, L Greater Than U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"V Less Than U, L Greater Than U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_EdgeCases_NaN(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"NaN L, Finite U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Finite L, NaN U\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExampleNearestIdxForSpan() {\n\t// Find the index of the element closest to 0.5 in a hypothetical\n\t// span of 5 elements from 0 to 1.\n\tidx := NearestIdxForSpan(5, 0.0, 1.0, 0.5)\n\tfmt.Println(idx)\n\t// Output: 2\n}","833b21a0075c577fde94c189898f66a9":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant argsort\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.a.Swap(tt.args.i, tt.args.j); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Swap() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","84cba209de73be9fc8a65c3115cd478d":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements that are not in the slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with non-nil inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf:    func(f float64) bool { return f \u003e 0 },\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","84cf1db0881ba9374d11a631125e887c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=10, v=5\",\n\t\t\targs: args{n: 2, l: 0, u: 10, v: 5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=10, v=5\",\n\t\t\targs: args{n: 3, l: 0, u: 10, v: 5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=10, v=5\",\n\t\t\targs: args{n: 4, l: 0, u: 10, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=10, v=5\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=10, u=0, v=5\",\n\t\t\targs: args{n: 2, l: 10, u: 0, v: 5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=10, u=0, v=5\",\n\t\t\targs: args{n: 3, l: 10, u: 0, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=10, u=0, v=5\",\n\t\t\targs: args{n: 4, l: 10, u: 0, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=10, u=0, v=5\",\n\t\t\targs: args{n: 5, l: 10, u: 0, v: 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","84fc49945a232770c24f21a053cee5a1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v below bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf (opposite signs)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8660c16f640958be268b424125fc3fec":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1, -2, -3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !floatEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEqual(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}","876a136b2371b18a843f206bffeb3c2a":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\"Simple\", args{n: 5, l: 0, u: 10, v: 5}, 2},\n\t\t{\"NearLowerBound\", args{n: 5, l: 0, u: 10, v: 1}, 0},\n\t\t{\"NearUpperBound\", args{n: 5, l: 0, u: 10, v: 9}, 4},\n\t\t{\"OutsideBounds\", args{n: 5, l: 0, u: 10, v: -1}, 0},\n\t\t{\"OutsideBounds2\", args{n: 5, l: 0, u: 10, v: 11}, 4},\n\n\t\t// Special cases for NaN\n\t\t{\"LowerBoundNaN\", args{n: 5, l: math.NaN(), u: 10, v: 5}, 4},\n\t\t{\"UpperBoundNaN\", args{n: 5, l: 0, u: math.NaN(), v: 5}, 0},\n\t\t{\"BothBoundsNaN\", args{n: 5, l: math.NaN(), u: math.NaN(), v: 5}, 0},\n\t\t{\"ValueNaN\", args{n: 5, l: 0, u: 10, v: math.NaN()}, 0},\n\n\t\t// Special cases for Inf\n\t\t{\"LowerBoundInf\", args{n: 5, l: math.Inf(0), u: 10, v: 5}, 4},\n\t\t{\"UpperBoundInf\", args{n: 5, l: 0, u: math.Inf(0), v: 5}, 0},\n\t\t{\"BothBoundsInf\", args{n: 5, l: math.Inf(0), u: math.Inf(0), v: 5}, 2},\n\t\t{\"BothBoundsInfEqual\", args{n: 5, l: math.Inf(0), u: math.Inf(0), v: math.Inf(0)}, 0},\n\t\t{\"ValueInfPositive\", args{n: 5, l: 0, u: 10, v: math.Inf(1)}, 4},\n\t\t{\"ValueInfNegative\", args{n: 5, l: 0, u: 10, v: math.Inf(-1)}, 0},\n\t\t{\"ValueInfPositiveBoundInf\", args{n: 5, l: math.Inf(0), u: math.Inf(0), v: math.Inf(1)}, 4},\n\t\t{\"ValueInfNegativeBoundInf\", args{n: 5, l: math.Inf(0), u: math.Inf(0), v: math.Inf(-1)}, 0},\n\t\t{\"ValueInfEqualLowerBound\", args{n: 5, l: math.Inf(0), u: 10, v: math.Inf(0)}, -1},\n\t\t{\"ValueInfEqualUpperBound\", args{n: 5, l: 0, u: math.Inf(0), v: math.Inf(0)}, 4},\n\n\t\t// Edge cases\n\t\t{\"LowerBoundEqualsUpperBound\", args{n: 5, l: 0, u: 0, v: 0}, 0},\n\t\t{\"EvenNumberOfElements\", args{n: 4, l: 0, u: 10, v: 5}, 2},\n\t\t{\"OddNumberOfElements\", args{n: 3, l: 0, u: 10, v: 5}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic with short span\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}\n\nfunc TestNearestIdxForSpanInfBounds(t *testing.T) {\n\t// Check that NearestIdxForSpan works correctly with infinite bounds\n\tn := 5\n\tl := math.Inf(0)\n\tu := math.Inf(0)\n\n\t// Test cases with different values for v\n\ttestCases := []struct {\n\t\tv   float64\n\t\twant int\n\t}{\n\t\t{math.Inf(0), 0},\n\t\t{math.Inf(1), 4},\n\t\t{math.Inf(-1), 0},\n\t\t{5, 2},\n\t\t{-5, 2},\n\t\t{0, 2},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(n=%d, l=Inf, u=Inf, v=%f) = %d, want %d\", n, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanZeroBounds(t *testing.T) {\n\t// Check that NearestIdxForSpan works correctly with zero bounds\n\tn := 5\n\tl := 0.0\n\tu := 0.0\n\n\t// Test cases with different values for v\n\ttestCases := []struct {\n\t\tv   float64\n\t\twant int\n\t}{\n\t\t{0.0, 0},\n\t\t{1.0, 4},\n\t\t{-1.0, 0},\n\t\t{0.5, 0},\n\t\t{-0.5, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tgot := NearestIdxForSpan(n, l, u, tc.v)\n\t\tif got != tc.want {\n\t\t\tt.Errorf(\"NearestIdxForSpan(n=%d, l=0, u=0, v=%f) = %d, want %d\", n, tc.v, got, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestNearestIdxForSpanInvalidInput(t *testing.T) {\n\t// Test cases with invalid input\n\ttestCases := []struct {\n\t\tn    int\n\t\tl    float64\n\t\tu    float64\n\t\tv    float64\n\t\terr  error\n\t\tmsg string\n\t}{\n\t\t{1, 0, 10, 5, fmt.Errorf(\"floats: span too short\"), \"NearestIdxForSpan() panicked with a short span\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tif r != tc.err {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan() panicked with unexpected error: got %v, want %v\", r, tc.err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tNearestIdxForSpan(tc.n, tc.l, tc.u, tc.v)\n\n\t\t// Check if the expected error was thrown\n\t\tif tc.err == nil {\n\t\t\tt.Errorf(\"%s: NearestIdxForSpan() did not panic as expected\", tc.msg)\n\t\t}\n\t}\n}\n","88a0193ded84b9e893d23ff426b1843c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slice\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Should panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8900aa68771056c6d140df5d1c575cfa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf - Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) should have panicked\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8957cbfb628c000e6a23a0af86dc0e6d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8a268a807febdd1589044723d42783f7":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic Case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge Case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge Case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Input\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: -10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_ShortSpan(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic for short span\")\n\t\t} else {\n\t\t\tif fmt.Sprintf(\"%v\", r) != shortSpan {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() panicked with wrong message: %v, want %v\", r, shortSpan)\n\t\t\t}\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","8d7bf8dcb492c4994dab8bf626b97ed0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds, even length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}","8db84bf8b529bb0fc69aa47c2d3ac7c6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8f9e9416d8c0aaecb379aacadcf67c50":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case 1\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9012a9920bb033f073d1054b802c5912":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"find 0 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: 0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tk: -1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts: []float64{6, 7, 8, 9, 10},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first 3 elements, but only 2 exist\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts: []float64{6, 7, 4, 5, 10},\n\t\t\t\tk: 3,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find elements with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts: []float64{6, 7, 8, 9, 10},\n\t\t\t\tk: 2,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","90eda1a8282de7144480b0cef156e607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at beginning\",\n\t\t\targs: args{s: []float64{5.0, 2.0, 3.0, 1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max at end\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, max in the middle\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 5.0, 3.0, 4.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple max values\",\n\t\t\targs: args{s: []float64{1.0, 5.0, 5.0, 3.0, 4.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all elements are NaN\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"some elements are NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 2.0, math.NaN(), 3.0}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9303356005fcdaa7752836a212c96a6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\"Zero length slice\", args{[]float64{}, 1}, 0},\n\t\t{\"L1 norm\", args{[]float64{1, 2, 3}, 1}, 6},\n\t\t{\"L2 norm\", args{[]float64{1, 2, 3}, 2}, math.Sqrt(14)},\n\t\t{\"L infinity norm\", args{[]float64{1, 2, 3}, math.Inf(1)}, 3},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","930bfa10b6dc4b7a361ff5e9c117915b":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.4076059679126216,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -0.04978706836786394,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{100.0, 200.0, 300.0},\n\t\t\t},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinite numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), 1.0, 2.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinite numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), 1.0, 2.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) == 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"LogSumExp(%v) did not panic\", tt.args.s)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp(%v) = %v, want %v\", tt.args.s, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLogSumExp_NaN(t *testing.T) {\n\ts := []float64{1.0, math.NaN(), 2.0}\n\tgot := LogSumExp(s)\n\tif !math.IsNaN(got) {\n\t\tt.Errorf(\"LogSumExp(%v) = %v, want NaN\", s, got)\n\t}\n}\n\nfunc TestLogSumExp_Zero(t *testing.T) {\n\ts := []float64{0.0, 0.0, 0.0}\n\tgot := LogSumExp(s)\n\tif !math.IsNaN(got) {\n\t\tt.Errorf(\"LogSumExp(%v) = %v, want NaN\", s, got)\n\t}\n}\n\nfunc TestLogSumExp_Overflow(t *testing.T) {\n\ts := []float64{math.MaxFloat64, math.MaxFloat64}\n\tgot := LogSumExp(s)\n\tif !math.IsInf(got, 0) {\n\t\tt.Errorf(\"LogSumExp(%v) = %v, want Inf(0)\", s, got)\n\t}\n}\n\nfunc TestLogSumExp_Underflow(t *testing.T) {\n\ts := []float64{-math.MaxFloat64, -math.MaxFloat64}\n\tgot := LogSumExp(s)\n\tif !math.IsInf(got, -1) {\n\t\tt.Errorf(\"LogSumExp(%v) = %v, want Inf(-1)\", s, got)\n\t}\n}\n","93bb65f0c24933e8c6e5822ca34a87d6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]float64, len(tt.args.s))\n\t\t\tcopy(got, tt.args.s)\n\t\t\tReverse(got)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Reverse() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","95db695f7002f97cfcc763d5f131bde2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than two\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","971cdb9966ab10f3b6a66f22cf666530":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttype args struct {\n\t\ts1  []float64\n\t\ts2  []float64\n\t\ttol float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 4.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.000001, 2.000002, 3.000003},\n\t\t\t\ttol: 1e-5,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.000001, 2.000002, 3.1},\n\t\t\t\ttol: 1e-5,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different length slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, math.NaN(), 3.0},\n\t\t\t\ts2:  []float64{1.0, math.NaN(), 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values with different tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, math.NaN(), 3.0},\n\t\t\t\ts2:  []float64{1.0, 3.0, 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualApprox(tt.args.s1, tt.args.s2, tt.args.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t\tfmt.Printf(\"s1: %v\\n\", tt.args.s1)\n\t\t\t\tfmt.Printf(\"s2: %v\\n\", tt.args.s2)\n\t\t\t}\n\t\t})\n\t}\n}\n","97f6a508a005bcc949f1573f054387f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n = 2, l = 0, u = 1, v = 0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n = 3, l = 0, u = 1, v = 0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n = 3, l = 0, u = 1, v = 0.25\", args{3, 0, 1, 0.25}, 0},\n\t\t{\"n = 3, l = 0, u = 1, v = 0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n = 4, l = 0, u = 1, v = 0.5\", args{4, 0, 1, 0.5}, 2},\n\t\t{\"n = 4, l = 0, u = 1, v = 0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n = 4, l = 0, u = 1, v = 0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n = 2, l = 1, u = 0, v = 0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n = 3, l = 1, u = 0, v = 0.5\", args{3, 1, 0, 0.5}, 2},\n\t\t{\"n = 3, l = 1, u = 0, v = 0.25\", args{3, 1, 0, 0.25}, 0},\n\t\t{\"n = 3, l = 1, u = 0, v = 0.75\", args{3, 1, 0, 0.75}, 1},\n\t\t{\"n = 4, l = 1, u = 0, v = 0.5\", args{4, 1, 0, 0.5}, 3},\n\t\t{\"n = 4, l = 1, u = 0, v = 0.25\", args{4, 1, 0, 0.25}, 2},\n\t\t{\"n = 4, l = 1, u = 0, v = 0.75\", args{4, 1, 0, 0.75}, 0},\n\n\t\t{\"n = 3, l = 0, u = 1, v = math.Inf(1)\", args{3, 0, 1, math.Inf(1)}, 2},\n\t\t{\"n = 3, l = 0, u = 1, v = math.Inf(-1)\", args{3, 0, 1, math.Inf(-1)}, 0},\n\t\t{\"n = 3, l = 1, u = 0, v = math.Inf(1)\", args{3, 1, 0, math.Inf(1)}, 0},\n\t\t{\"n = 3, l = 1, u = 0, v = math.Inf(-1)\", args{3, 1, 0, math.Inf(-1)}, 2},\n\n\t\t{\"n = 3, l = math.NaN(), u = 1, v = 0.5\", args{3, math.NaN(), 1, 0.5}, 2},\n\t\t{\"n = 3, l = 0, u = math.NaN(), v = 0.5\", args{3, 0, math.NaN(), 0.5}, 0},\n\t\t{\"n = 3, l = math.NaN(), u = 1, v = math.NaN(), args{3, math.NaN(), 1, math.NaN()}, 2},\n\t\t{\"n = 3, l = 0, u = math.NaN(), v = math.NaN(), args{3, 0, math.NaN(), math.NaN()}, 0},\n\n\t\t{\"n = 3, l = math.Inf(1), u = math.Inf(1), v = 0.5\", args{3, math.Inf(1), math.Inf(1), 0.5}, 1},\n\t\t{\"n = 3, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1), args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n = 3, l = math.Inf(1), u = math.Inf(1), v = math.Inf(-1), args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\n\t\t{\"n = 3, l = math.Inf(1), u = 0, v = math.Inf(1), args{3, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n = 3, l = math.Inf(1), u = 0, v = math.Inf(-1), args{3, math.Inf(1), 0, math.Inf(-1)}, 2},\n\n\t\t{\"n = 3, l = 0, u = math.Inf(1), v = math.Inf(1), args{3, 0, math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n = 3, l = 0, u = math.Inf(1), v = math.Inf(-1), args{3, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","98455f52f62b2e50bb908d3d0ed0a1ec":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9968eecfdf30082706212c97588e7293":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0}},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0}},\n\t\t\twant: -0.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{s: []float64{1000.0, 1001.0, 1002.0}},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{s: []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","99d6db2036d4ac3edc0116983f0e560d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L-norm distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: 4.326748710935853,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistance_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","9a496ba17ec527d8f006609f6f843ff6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tDiv(dst, tt.args.s)\n\t\t\tif !Same(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9a6f496faafe107e1f1f8261c46d7bf1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value closer to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value closer to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9a98ff29fee4e9f72e766486242fbc11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   -5,\n\t\t\t},\n\t\t\twant: []float64{-10, -8.75, -7.5, -6.25, -5},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   100000,\n\t\t\t\tu:   100005,\n\t\t\t},\n\t\t\twant: []float64{100000, 100001.25, 100002.5, 100003.75, 100005},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), 0, math.Inf(1), math.Inf(0), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), 0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound, equal values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","9ab1d4dcd4e6e4dd07be351879e21a61":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Two elements\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 2,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Three elements\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 3,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Four elements\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 4,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Five elements\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 5,\n\t\t\t\tv: 3,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even elements, v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 4,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Even elements, v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1,\n\t\t\t\tu: 4,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd elements, v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 5,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd elements, v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 5,\n\t\t\t\tv: 6,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 5,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 5,\n\t\t\t\tv: 3,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 3,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite, v is l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite, v is not l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 5,\n\t\t\t\tv: 3,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf, v is u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf, v is not u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 3,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 5,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 5,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 5,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 5,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9b77ccabddafb9d8dc5b4b9224996375":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9c55932632ea7107edec31327f638aa7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9cb0d360d85ad376bf2194447eafd178":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"No NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"One NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 2.0, math.NaN(), 4.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9d291a0a7219e71f1248386c72c4ebdd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(1 + 8 + 27, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsClose(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9d4ab18a2d3be262fae27fe7439bf295":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t// Test cases for k = 0\n\t\t{\n\t\t\tname: \"Find_k_0_empty_slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_0_non_empty_slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t// Test cases for k \u003c 0\n\t\t{\n\t\t\tname: \"Find_k_neg_empty_slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_neg_non_empty_slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_neg_non_empty_slice_with_condition\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 1.5 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t// Test cases for k \u003e 0\n\t\t{\n\t\t\tname: \"Find_k_pos_empty_slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_non_empty_slice_enough_elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_non_empty_slice_not_enough_elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    4,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_pos_non_empty_slice_with_condition\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 1.5 },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t// Test cases with non-nil inds\n\t\t{\n\t\t\tname: \"Find_with_non_nil_inds_k_0\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 20},\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_with_non_nil_inds_k_neg\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 20},\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_with_non_nil_inds_k_pos\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 20},\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9e6b0f9dd9f49f75a5ba370e3a417163":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","a016dbc2f0d6caf11e2cb0a3b863ab48":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v below l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v above u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == l == u, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == l == u, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v \u003e 0, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v \u003e 0, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v \u003c 0, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v \u003c 0, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == +Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == +Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == -Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u, v == -Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == +Inf, v == +Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == +Inf, v == +Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == +Inf, v == -Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == +Inf, v == -Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == +Inf, v == 0, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == +Inf, v == 0, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == -Inf, v == +Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == -Inf, v == +Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == -Inf, v == -Inf, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == -Inf, v == -Inf, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == -Inf, v == 0, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == -Inf, v == 0, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == +Inf, v == +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == +Inf, v == 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == +Inf, v == -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == +Inf, v == NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == -Inf, v == +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == -Inf, v == 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == -Inf, v == -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == -Inf, v == NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == NaN, v == +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == NaN, v == 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == NaN, v == -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == +Inf, u == NaN, v == NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == -Inf, u == NaN, v == +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == -Inf, u == NaN, v == 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == -Inf, u == NaN, v == -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == -Inf, u == NaN, v == NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == NaN, v == +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == NaN, v == 0\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == NaN, v == -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l == NaN, u == NaN, v == NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a27f6a53f7ef837c6a2016083242e078":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with both Inf and different values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t} else {\n\t\t\tif fmt.Sprint(r) != \"short span\" {\n\t\t\t\tt.Errorf(\"Span() panicked with %v, want %v\", fmt.Sprint(r), \"short span\")\n\t\t\t}\n\t\t}\n\t}()\n\n\tSpan(make([]float64, 1), 0, 10)\n}","a2bf07ba250a0365f9ac0b0f63d41c94":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","a3fe2ed40acd3b91aacc802c7c7b7333":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, closest to middle element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, equidistant to two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a41f57f74af72aeefcd635aa831db8f0":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"one element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"two element slice, v less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"two element slice, v greater than or equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"two element slice, v within range\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, v less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, v greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, v within range\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, v equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 3.0, 2.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 || !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a47dd1cdc3dc83bbdb439193cd64f607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds lower\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds upper\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"reversed bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, odd n\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a497dd8b46bc2c813c600319f2b295de":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to the last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value within the first two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value within the last two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != shortSpan {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t} else if !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != \"floats: input slice not sorted\" {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a4b60974e46bfdf6e006c7d82aaa379c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and not equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and not equal and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf and not equal and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a4d1d307540cd4a4d2ac0b2fb9d31721":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a521218401b9b8dba09f0819080b73d1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 Norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 Norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-Infinity Norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 Norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(math.Pow(3, 3)+math.Pow(3, 3)+math.Pow(3, 3), 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Empty Slices\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a54d54664865f2c31b2989b19aa1f707":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicCase\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeValues\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"LargeSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 10),\n\t\t\t\tl:   0,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{0, 11.11111111111111, 22.22222222222222, 33.33333333333333, 44.44444444444444, 55.55555555555556, 66.66666666666666, 77.77777777777777, 88.88888888888889, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfOddLength\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-12) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","a5e41a7195939f58c03fbd26820a8ba7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest is first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest is last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest is in the middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, multiple nearest, lowest index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"-Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdx() did not panic\")\n\t\t}\n\t}()\n\tNearestIdx([]float64{}, 1.0)\n}","a69b30c54f2b14f26c3f18c8767573b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","a7d15f2cc559aa317134a3b5cf5abf3b":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{-3, -3, -3},\n\t\t},\n\t\t{\n\t\t\tname: \"different length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5},\n\t\t\t},\n\t\t\twant: nil, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.want == nil {\n\t\t\t\t\t\t// Panic expected\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Sub() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !equalFloat64Slices(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloat64Slices(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif math.Abs(a[i]-b[i]) \u003e 1e-6 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc ExampleSub() {\n\tdst := []float64{1, 2, 3}\n\ts := []float64{4, 5, 6}\n\tSub(dst, s)\n\tfmt.Println(dst)\n\t// Output: [-3 -3 -3]\n}","a9d4441a857e403200ecd0cceab9906d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"PanicShortSpan\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{}, 0, 1)\n\t})\n\n\tt.Run(\"SingleNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, NaN, 1) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"DoubleNaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tgot := Span(dst, 0, math.NaN())\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, 0, NaN) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"DoubleInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)}\n\t\tgot := Span(dst, math.Inf(0), math.Inf(0))\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf, Inf) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"DoubleInfOdd\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)}\n\t\tgot := Span(dst, math.Inf(0), math.Inf(0))\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf, Inf) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"DoubleInfOddDifferent\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)}\n\t\tgot := Span(dst, math.Inf(0), math.Inf(1))\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf, Inf) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"SingleInf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 1}\n\t\tgot := Span(dst, math.Inf(0), 1)\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, Inf, 1) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n\n\tt.Run(\"SpanBasic\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, 0.25, 0.5, 0.75, 1}\n\t\tgot := Span(dst, 0, 1)\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span(%v, 0, 1) = %v, want %v\", dst, got, want)\n\t\t}\n\t})\n}","aaf32cd17c4604ddafa4458bb47ea3c4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t// Special cases with NaN\n\t\t{\n\t\t\tname: \"SpanWithNaN_L\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNaN_U\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t// Special cases with Inf\n\t\t{\n\t\t\tname: \"SpanWithInf_L\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInf_U\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInf_Both\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t// Panic cases\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.want == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) should have panicked\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t} else {\n\t\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\tif !Equal(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","ab7dc606c0b084ab5d94a2ed91fc6c4b":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{2, 4, 6},\n\t\t\t},\n\t\t\twant: []float64{0.5, 0.5, 0.5},\n\t\t},\n\t\t{\n\t\t\tname: \"zero denominator\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{2, 0, 6},\n\t\t\t},\n\t\t\twant: []float64{0.5, math.Inf(1), 0.5},\n\t\t},\n\t\t{\n\t\t\tname: \"negative denominator\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\ts:   []float64{1, 2, 3},\n\t\t\t\tt:   []float64{-2, -4, -6},\n\t\t\t},\n\t\t\twant: []float64{-0.5, -0.5, -0.5},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := DivTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDivToPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DivTo() did not panic\")\n\t\t}\n\t}()\n\tDivTo([]float64{1, 2, 3}, []float64{1, 2}, []float64{1, 2})\n}\n\nfunc TestDivToPanicDst(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != badDstLength {\n\t\t\tt.Errorf(\"DivTo() did not panic with badDstLength: %v\", r)\n\t\t}\n\t}()\n\tDivTo([]float64{1, 2}, []float64{1, 2, 3}, []float64{1, 2, 3})\n}\n\nfunc TestDivToPanicDst2(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != badDstLength {\n\t\t\tt.Errorf(\"DivTo() did not panic with badDstLength: %v\", r)\n\t\t}\n\t}()\n\tDivTo([]float64{1}, []float64{1, 2, 3}, []float64{1, 2, 3})\n}","abb812288b8de738509d66c3ec95412e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"closest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"closest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","adc5acf237e9d9e0b0eaa3cab7609c7a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant argsort\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.a\n\t\t\tgot.Swap(tt.args.i, tt.args.j)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Swap() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","af54b607219a486ffb62bfa2478b3568":"package floats\n\nimport \"testing\"\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","af91ec866fc2f872635e8cfdd90e66fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","afb6691cc094d2b363d8525e14a19ac8":"","afc5e1b592f391571a48959e2f9e490f":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tf: func(float64) bool { return true },\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all elements true\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"some elements true\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 1 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"no elements true\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 3 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b023a706762e4bc46743e63893e9d4ca":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b057253b10925d31efe70b9b96fdeb78":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value within the first span\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value within the second span\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b0f9a3504d61dd97d7d30c129c71d603":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to the last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between the first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to the second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between the second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b1237c007a154e7551e96e4abef395ac":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element slice, closest element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element slice, closest element, multiple matches\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 2.0, 4.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple element slice, closest element, negative value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0},\n\t\t\t\tv: -2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","b171a68a65a0482c47261417a55b4971":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic Case\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside Range\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 15},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Values\",\n\t\t\targs: args{n: 5, l: -10, u: 0, v: -5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{n: 5, l: -math.Inf(1), u: math.Inf(1), v: 5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Nan Boundaries\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 10, v: 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{n: 5, l: -math.Inf(1), u: 10, v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive Inf\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal Boundaries\",\n\t\t\targs: args{n: 5, l: 10, u: 10, v: 10},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd Number of Elements\",\n\t\t\targs: args{n: 3, l: 0, u: 10, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic when n \u003c 2\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","b19603c719cd669e4b4e7417b1673a44":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b1c211d15e5b97db52c1164cf02ab259":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 0},\n\t\t{\"n=3, l=0, u=1, v=0\", args{3, 0, 1, 0}, 0},\n\t\t{\"n=3, l=0, u=1, v=1\", args{3, 0, 1, 1}, 2},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=4, l=0, u=1, v=0\", args{4, 0, 1, 0}, 0},\n\t\t{\"n=4, l=0, u=1, v=1\", args{4, 0, 1, 1}, 3},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 1},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 0},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n=3, l=1, u=0, v=1\", args{3, 1, 0, 1}, 0},\n\t\t{\"n=3, l=1, u=0, v=0\", args{3, 1, 0, 0}, 2},\n\t\t{\"n=3, l=1, u=0, v=0.5\", args{3, 1, 0, 0.5}, 1},\n\t\t{\"n=4, l=1, u=0, v=1\", args{4, 1, 0, 1}, 0},\n\t\t{\"n=4, l=1, u=0, v=0\", args{4, 1, 0, 0}, 3},\n\t\t{\"n=4, l=1, u=0, v=0.5\", args{4, 1, 0, 0.5}, 1},\n\t\t{\"n=2, l=0, u=0, v=0\", args{2, 0, 0, 0}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{3, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(-1)}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)}, args{3, math.Inf(1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)}, args{3, math.Inf(1), math.Inf(-1), math.Inf(-1)}, 2},\n\t\t{\"n=2, l=math.Inf(1), u=0, v=math.Inf(1)}, args{2, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=0, v=0}, args{2, math.Inf(1), 0, 0}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=0, v=math.Inf(1)}, args{3, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=0, v=0}, args{3, math.Inf(1), 0, 0}, 2},\n\t\t{\"n=2, l=0, u=math.Inf(1), v=math.Inf(1)}, args{2, 0, math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=0, u=math.Inf(1), v=0}, args{2, 0, math.Inf(1), 0}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=math.Inf(1)}, args{3, 0, math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=0}, args{3, 0, math.Inf(1), 0}, 0},\n\t\t{\"n=2, l=0, u=math.Inf(-1), v=math.Inf(-1)}, args{2, 0, math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=0, u=math.Inf(-1), v=0}, args{2, 0, math.Inf(-1), 0}, 1},\n\t\t{\"n=3, l=0, u=math.Inf(-1), v=math.Inf(-1)}, args{3, 0, math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(-1), v=0}, args{3, 0, math.Inf(-1), 0}, 2},\n\t\t{\"n=2, l=math.Inf(-1), u=0, v=math.Inf(-1)}, args{2, math.Inf(-1), 0, math.Inf(-1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=0, v=0}, args{2, math.Inf(-1), 0, 0}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=math.Inf(-1)}, args{3, math.Inf(-1), 0, math.Inf(-1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=0}, args{3, math.Inf(-1), 0, 0}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()}, args{2, math.NaN(), 0, math.NaN()}, 1},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()}, args{2, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=0}, args{2, math.NaN(), 0, 0}, 1},\n\t\t{\"n=2, l=0, u=math.NaN(), v=0}, args{2, 0, math.NaN(), 0}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","b213bf54d996e0039fda47719746bfab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large and small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 1e-10, 1e10, 1e-10},\n\t\t\t},\n\t\t\twant: 2e10,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"-Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b24730c325c23f8e9cf5a440666a54cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Span with 2 elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with 3 elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 1.0, 5.0)\n}","b247c18384f0d8daf42cbf9e1815e8cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{s: []float64{1e10, 2e10, 3e10, 4e10, 5e10}},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{s: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10}},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative numbers\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed signs\",\n\t\t\targs: args{s: []float64{1.0, -2.0, 3.0, -4.0, 5.0}},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Floating point precision\",\n\t\t\targs: args{s: []float64{1.0, 0.1, 0.01, 0.001, 0.0001}},\n\t\t\twant: 1.11111,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0}},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{s: []float64{1.0, math.Inf(1), 3.0}},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","b274b8c757536346f03da55ed0a60c98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0\", args{3, 0, 1, 0}, 0},\n\t\t{\"n=3, l=0, u=1, v=1\", args{3, 0, 1, 1}, 2},\n\t\t// Cases with Inf\n\t\t{\"n=3, l=-math.Inf(1), u=1, v=-1\", args{3, -math.Inf(1), 1, -1}, 0},\n\t\t{\"n=3, l=-math.Inf(1), u=1, v=0\", args{3, -math.Inf(1), 1, 0}, 1},\n\t\t{\"n=3, l=-math.Inf(1), u=1, v=1\", args{3, -math.Inf(1), 1, 1}, 2},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=0\", args{3, 0, math.Inf(1), 0}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=1\", args{3, 0, math.Inf(1), 1}, 1},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=100\", args{3, 0, math.Inf(1), 100}, 2},\n\t\t// Cases with NaN\n\t\t{\"n=3, l=math.NaN(), u=1, v=0\", args{3, math.NaN(), 1, 0}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=0\", args{3, 0, math.NaN(), 0}, 2},\n\t\t// Cases with even n\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 0},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 2},\n\t\t{\"n=4, l=0, u=1, v=1\", args{4, 0, 1, 1}, 3},\n\t\t// Cases with odd n\n\t\t{\"n=5, l=0, u=1, v=0.2\", args{5, 0, 1, 0.2}, 0},\n\t\t{\"n=5, l=0, u=1, v=0.4\", args{5, 0, 1, 0.4}, 1},\n\t\t{\"n=5, l=0, u=1, v=0.6\", args{5, 0, 1, 0.6}, 2},\n\t\t{\"n=5, l=0, u=1, v=0.8\", args{5, 0, 1, 0.8}, 3},\n\t\t{\"n=5, l=0, u=1, v=1\", args{5, 0, 1, 1}, 4},\n\t\t// Cases with negative bounds\n\t\t{\"n=3, l=-1, u=0, v=-0.5\", args{3, -1, 0, -0.5}, 1},\n\t\t// Cases with reversed bounds\n\t\t{\"n=3, l=1, u=0, v=0.5\", args{3, 1, 0, 0.5}, 1},\n\t\t// Cases with edge cases for halfway\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=2, v=1\", args{3, 0, 2, 1}, 1},\n\t\t// Cases with n \u003c 2\n\t\t{\"n=1, l=0, u=1, v=0.5\", args{1, 0, 1, 0.5}, 0}, // This should panic\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b2b41c0984a6fc130569c29ce9ac8aed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"ShortSlice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span() did not panic with short slice\")\n\t\t\t}\n\t\t}()\n\t\tdst := make([]float64, 1)\n\t\tSpan(dst, 0, 1)\n\t})\n\n\tt.Run(\"NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.NaN(), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif !math.IsNaN(got[i]) {\n\t\t\t\tt.Errorf(\"Span() failed to fill slice with NaN when l is NaN: got %v, want NaN\", got[i])\n\t\t\t}\n\t\t}\n\t\tif got[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Span() failed to set last element to u when l is NaN: got %v, want 1\", got[len(dst)-1])\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tgot = Span(dst, 0, math.NaN())\n\t\tif got[0] != 0 {\n\t\t\tt.Errorf(\"Span() failed to set first element to l when u is NaN: got %v, want 0\", got[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif !math.IsNaN(got[i+1]) {\n\t\t\t\tt.Errorf(\"Span() failed to fill slice with NaN when u is NaN: got %v, want NaN\", got[i+1])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Inf\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, math.Inf(0), math.Inf(0))\n\t\tfor i := range dst[:len(dst)/2] {\n\t\t\tif got[i] != math.Inf(0) {\n\t\t\t\tt.Errorf(\"Span() failed to fill first half of slice with l when l and u are Inf: got %v, want Inf\", got[i])\n\t\t\t}\n\t\t\tif got[len(dst)-i-1] != math.Inf(0) {\n\t\t\t\tt.Errorf(\"Span() failed to fill last half of slice with u when l and u are Inf: got %v, want Inf\", got[len(dst)-i-1])\n\t\t\t}\n\t\t}\n\t\tif len(dst)%2 == 1 {\n\t\t\tif got[len(dst)/2] != 0 {\n\t\t\t\tt.Errorf(\"Span() failed to set middle element to 0 when l and u are Inf and dst has odd length: got %v, want 0\", got[len(dst)/2])\n\t\t\t}\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tgot = Span(dst, math.Inf(0), 1)\n\t\tfor i := range dst[:len(dst)-1] {\n\t\t\tif got[i] != math.Inf(0) {\n\t\t\t\tt.Errorf(\"Span() failed to fill slice with l when l is Inf: got %v, want Inf\", got[i])\n\t\t\t}\n\t\t}\n\t\tif got[len(dst)-1] != 1 {\n\t\t\tt.Errorf(\"Span() failed to set last element to u when l is Inf: got %v, want 1\", got[len(dst)-1])\n\t\t}\n\n\t\tdst = make([]float64, 5)\n\t\tgot = Span(dst, 0, math.Inf(0))\n\t\tif got[0] != 0 {\n\t\t\tt.Errorf(\"Span() failed to set first element to l when u is Inf: got %v, want 0\", got[0])\n\t\t}\n\t\tfor i := range dst[1:] {\n\t\t\tif got[i+1] != math.Inf(0) {\n\t\t\t\tt.Errorf(\"Span() failed to fill slice with u when u is Inf: got %v, want Inf\", got[i+1])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Normal\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\tgot := Span(dst, 0, 1)\n\t\tfor i := range dst {\n\t\t\tif got[i] != float64(i)/4 {\n\t\t\t\tt.Errorf(\"Span() failed to generate correct values: got %v, want %v\", got[i], float64(i)/4)\n\t\t\t}\n\t\t}\n\t})\n}","b39b4e92d68ff04931e1f9c49dce0d52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 distance\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) != len(tt.args.t) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tt.Logf(\"Distance panicked as expected: %v\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tDistance(tt.args.s, tt.args.t, tt.args.L)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b40f3129f28d9f1eeaeb9805d894b2d5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b453eeefaf291a83ffcb9e4516aac460":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n \u003c 2\", args{1, 0, 1, 0.5}, 0},\n\t\t{\"v is NaN\", args{3, 0, 1, math.NaN()}, 0},\n\t\t{\"l is NaN and u is not\", args{3, math.NaN(), 1, 0.5}, 2},\n\t\t{\"u is NaN\", args{3, 0, math.NaN(), 0.5}, 0},\n\t\t{\"l and u are Inf and equal\", args{3, math.Inf(0), math.Inf(0), 0.5}, 0},\n\t\t{\"l and u are Inf and not equal, n is odd\", args{3, math.Inf(0), math.Inf(1), 0.5}, 1},\n\t\t{\"l and u are Inf and not equal, n is even\", args{4, math.Inf(0), math.Inf(1), 0.5}, 1},\n\t\t{\"l and u are Inf and not equal, v is Inf with same sign as l\", args{3, math.Inf(0), math.Inf(1), math.Inf(0)}, 0},\n\t\t{\"l and u are Inf and not equal, v is Inf with opposite sign as l\", args{3, math.Inf(0), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"l is Inf\", args{3, math.Inf(0), 1, 0.5}, 2},\n\t\t{\"u is Inf\", args{3, 0, math.Inf(0), 0.5}, 0},\n\t\t{\"v is -Inf\", args{3, 0, 1, math.Inf(-1)}, 0},\n\t\t{\"v is Inf\", args{3, 0, 1, math.Inf(1)}, 2},\n\t\t{\"l \u003c u, v \u003c= l\", args{3, 0, 1, -0.5}, 0},\n\t\t{\"l \u003c u, v \u003e= u\", args{3, 0, 1, 1.5}, 2},\n\t\t{\"l \u003e u, v \u003e= l\", args{3, 1, 0, 1.5}, 0},\n\t\t{\"l \u003e u, v \u003c= u\", args{3, 1, 0, -0.5}, 2},\n\t\t{\"l = u\", args{3, 0, 0, 0.5}, 0},\n\t\t{\"l \u003c u, v within bounds\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"l \u003e u, v within bounds\", args{3, 1, 0, 0.5}, 1},\n\t\t{\"general case\", args{10, 0, 10, 5.5}, 5},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\tt.Errorf(\"NearestIdxForSpan() should have panicked\")\n}","b4b092207079221ea52e0eecea53fb6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 Norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 Norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L Infinity Norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 Norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1.0/3.0),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","b517facd54cabc2f4032e18bd4d107cd":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Same(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b62580acc0fe992fad3b01981ef69e94":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b62c0496f8758e4bda8819180b790391":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L inf norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L 3 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // This should panic, but we're testing for the panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b7f2edbdc613f82d19b5b99c215ff5f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Two elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Three elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Five elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tdst := make([]float64, 1)\n\tSpan(dst, 1.0, 5.0)\n}","b89f9f1089868798b9e02bcd5e68794b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1,\n\t\t\t\tu:   5,\n\t\t\t},\n\t\t\twant: []float64{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5,\n\t\t\t\tu:   -1,\n\t\t\t},\n\t\t\twant: []float64{-5, -4, -3, -2, -1},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed Inf and NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1, 5)\n}","b8a05ba3a712e311a1d2e9009147f26b":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic_case\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value_at_boundary\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value_greater_than_max\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 6,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value_less_than_min\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty_slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted_slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5, 2, 3, 4, 1},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value_is_nan\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic\", tt.args.s, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic\", tt.args.s, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Within(tt.args.s, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", tt.args.s, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","b90b25d30caac34e602553815fe2c041":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large positive values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Large negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1e10, -2e10, -3e10, -4e10, -5e10},\n\t\t\t},\n\t\t\twant: -1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed positive and negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, -2e10, 3e10, -4e10, 5e10},\n\t\t\t},\n\t\t\twant: 3e10,\n\t\t},\n\t\t{\n\t\t\tname: \"Floating point precision test\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ba6c5492461668b1361d8b51e520bf52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Test cases for different input values\n\t\t{\n\t\t\tname: \"Span with positive bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with zero bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with mixed bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t// Test cases for different slice lengths\n\t\t{\n\t\t\tname: \"Span with small slice length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with large slice length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 10),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.0},\n\t\t},\n\t\t// Test cases for panics\n\t\t{\n\t\t\tname: \"Span with slice length less than 2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bd09c4b3139e4799017cb559fa235589":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"Span_2\",\n\t\t\targs: args{dst: make([]float64, 2), l: 1.0, u: 2.0},\n\t\t\twant: []float64{1.0, 2.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_3\",\n\t\t\targs: args{dst: make([]float64, 3), l: 0.0, u: 1.0},\n\t\t\twant: []float64{0.0, 0.5, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_4\",\n\t\t\targs: args{dst: make([]float64, 4), l: -1.0, u: 1.0},\n\t\t\twant: []float64{-1.0, -0.5, 0.0, 1.0},\n\t\t},\n\t\t// Special cases for Inf and NaN\n\t\t{\n\t\t\tname: \"Span_NaN_l\",\n\t\t\targs: args{dst: make([]float64, 4), l: math.NaN(), u: 1.0},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_NaN_u\",\n\t\t\targs: args{dst: make([]float64, 4), l: 0.0, u: math.NaN()},\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_Inf_u\",\n\t\t\targs: args{dst: make([]float64, 4), l: math.Inf(1), u: math.Inf(1)},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_u\",\n\t\t\targs: args{dst: make([]float64, 4), l: math.Inf(1), u: 1.0},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_l_Inf_u\",\n\t\t\targs: args{dst: make([]float64, 4), l: 0.0, u: math.Inf(1)},\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\n\tdst := make([]float64, 1)\n\tSpan(dst, 0.0, 1.0)\n}\n\nfunc TestSpan_Range(t *testing.T) {\n\tdst := make([]float64, 5)\n\tfor i, x := range Span(dst, 0.0, 1.0) {\n\t\tif x != float64(i)/4.0 {\n\t\t\tt.Errorf(\"Span() range value at index %d = %f, want %f\", i, x, float64(i)/4.0)\n\t\t}\n\t}\n\t// Check that dst is mutated correctly\n\tfor i := range dst {\n\t\tif dst[i] != float64(i)/4.0 {\n\t\t\tt.Errorf(\"Span() dst value at index %d = %f, want %f\", i, dst[i], float64(i)/4.0)\n\t\t}\n\t}\n}\n\nfunc TestSpan_OddLength(t *testing.T) {\n\tdst := make([]float64, 3)\n\tSpan(dst, 0.0, 1.0)\n\tif dst[0] != 0.0 || dst[1] != 0.5 || dst[2] != 1.0 {\n\t\tt.Errorf(\"Span() dst values are incorrect: %v\", dst)\n\t}\n}\n\nfunc TestSpan_InfNaN(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tl    float64\n\t\tu    float64\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span_NaN_l_u\",\n\t\t\tl:    math.NaN(),\n\t\t\tu:    math.NaN(),\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_Inf_u_odd\",\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_Inf_u_even\",\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_u_odd\",\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_Inf_l_u_even\",\n\t\t\tl:    math.Inf(1),\n\t\t\tu:    1.0,\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_l_Inf_u_odd\",\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span_l_Inf_u_even\",\n\t\t\tl:    0.0,\n\t\t\tu:    math.Inf(1),\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, 4)\n\t\t\tgot := Span(dst, tt.l, tt.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function for comparing float64 slices\nfunc Equal(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif !math.IsNaN(s1[i]) \u0026\u0026 !math.IsNaN(s2[i]) \u0026\u0026 s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t\tif math.IsNaN(s1[i]) != math.IsNaN(s2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","bd0baf941d695935d5dc6dc476aff106":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Special cases for Inf and NaN\n\t\t{\"n = 2, l = NaN, u = 1, v = 0.5\", args{2, math.NaN(), 1, 0.5}, 1},\n\t\t{\"n = 2, l = 1, u = NaN, v = 0.5\", args{2, 1, math.NaN(), 0.5}, 0},\n\t\t{\"n = 3, l = Inf, u = Inf, v = 0\", args{3, math.Inf(0), math.Inf(0), 0}, 1},\n\t\t{\"n = 3, l = Inf, u = Inf, v = Inf\", args{3, math.Inf(0), math.Inf(0), math.Inf(0)}, 0},\n\t\t{\"n = 4, l = Inf, u = Inf, v = Inf\", args{4, math.Inf(0), math.Inf(0), math.Inf(0)}, 0},\n\t\t{\"n = 4, l = Inf, u = Inf, v = -Inf\", args{4, math.Inf(0), math.Inf(0), math.Inf(-1)}, 3},\n\t\t{\"n = 3, l = -Inf, u = -Inf, v = -Inf\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 2},\n\t\t{\"n = 3, l = -Inf, u = -Inf, v = Inf\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n = 2, l = Inf, u = 1, v = Inf\", args{2, math.Inf(0), 1, math.Inf(0)}, 0},\n\t\t{\"n = 2, l = 1, u = -Inf, v = -Inf\", args{2, 1, math.Inf(-1), math.Inf(-1)}, 1},\n\t\t// Special cases for v outside (l, u) and (u, l).\n\t\t{\"n = 3, l = 1, u = 5, v = 0\", args{3, 1, 5, 0}, 0},\n\t\t{\"n = 3, l = 1, u = 5, v = 6\", args{3, 1, 5, 6}, 2},\n\t\t{\"n = 3, l = 5, u = 1, v = 6\", args{3, 5, 1, 6}, 0},\n\t\t{\"n = 3, l = 5, u = 1, v = 0\", args{3, 5, 1, 0}, 2},\n\t\t// General cases\n\t\t{\"n = 3, l = 1, u = 5, v = 2\", args{3, 1, 5, 2}, 0},\n\t\t{\"n = 3, l = 1, u = 5, v = 3\", args{3, 1, 5, 3}, 1},\n\t\t{\"n = 3, l = 1, u = 5, v = 4\", args{3, 1, 5, 4}, 2},\n\t\t{\"n = 5, l = 1, u = 10, v = 3\", args{5, 1, 10, 3}, 0},\n\t\t{\"n = 5, l = 1, u = 10, v = 5\", args{5, 1, 10, 5}, 1},\n\t\t{\"n = 5, l = 1, u = 10, v = 8\", args{5, 1, 10, 8}, 3},\n\t\t{\"n = 4, l = 1, u = 4, v = 2.5\", args{4, 1, 4, 2.5}, 1},\n\t\t{\"n = 4, l = 1, u = 4, v = 1.5\", args{4, 1, 4, 1.5}, 0},\n\t\t{\"n = 5, l = -10, u = -5, v = -8\", args{5, -10, -5, -8}, 0},\n\t\t{\"n = 5, l = -10, u = -5, v = -7\", args{5, -10, -5, -7}, 1},\n\t\t{\"n = 5, l = -10, u = -5, v = -6\", args{5, -10, -5, -6}, 2},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 1, 2, 1.5)\n}","bdbac0eb9fce9bd1874ee7d0e7ca5d5a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAddScaled(dst, tt.args.alpha, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bf076eed918d7c3223f67e7e25518cf2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN not treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfda35f3c18a5baeca503393dbab6526":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"TestSpan1\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -5.0, 0.0, 5.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan4\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan5\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan6\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestSpan7\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   10.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{10.0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !floatArraysEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 10.0)\n}\n\nfunc floatArraysEqual(a, b []float64) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !math.IsNaN(a[i]) \u0026\u0026 !math.IsNaN(b[i]) \u0026\u0026 math.Abs(a[i]-b[i]) \u003e 1e-6 {\n\t\t\tfmt.Printf(\"a[%d] = %f, b[%d] = %f\\n\", i, a[i], i, b[i])\n\t\t\treturn false\n\t\t} else if math.IsNaN(a[i]) != math.IsNaN(b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","c0ec03dca8cd07a84c9284fb4860376c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n \u003c 2\", args{1, 1, 2, 1.5}, -1},\n\t\t{\"l = u\", args{2, 1, 1, 1}, 0},\n\t\t{\"l = u, n odd\", args{3, 1, 1, 1}, 1},\n\t\t{\"v = l\", args{2, 1, 2, 1}, 0},\n\t\t{\"v = u\", args{2, 1, 2, 2}, 1},\n\t\t{\"v \u003c l\", args{2, 1, 2, 0}, 0},\n\t\t{\"v \u003e u\", args{2, 1, 2, 3}, 1},\n\t\t{\"l \u003c u, v \u003c l\", args{3, 1, 3, 0}, 0},\n\t\t{\"l \u003c u, v \u003e u\", args{3, 1, 3, 4}, 2},\n\t\t{\"l \u003c u, v in range\", args{3, 1, 3, 2}, 1},\n\t\t{\"l \u003e u, v \u003e l\", args{3, 3, 1, 4}, 0},\n\t\t{\"l \u003e u, v \u003c u\", args{3, 3, 1, 0}, 2},\n\t\t{\"l \u003e u, v in range\", args{3, 3, 1, 2}, 1},\n\t\t{\"l = NaN, u = 1\", args{2, math.NaN(), 1, 1}, 1},\n\t\t{\"l = 1, u = NaN\", args{2, 1, math.NaN(), 1}, 0},\n\t\t{\"l = Inf, u = Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, -1},\n\t\t{\"l = Inf, u = Inf, n odd\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, -1},\n\t\t{\"l = Inf, u = Inf, v = -Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"l = Inf, u = Inf, v = Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"l = Inf, u = Inf, v = 0\", args{2, math.Inf(1), math.Inf(1), 0}, 0},\n\t\t{\"l = Inf, u = Inf, v = 1\", args{3, math.Inf(1), math.Inf(1), 1}, 1},\n\t\t{\"l = Inf, u = 1\", args{2, math.Inf(1), 1, 1}, 1},\n\t\t{\"l = Inf, u = 1, v = Inf\", args{2, math.Inf(1), 1, math.Inf(1)}, 0},\n\t\t{\"l = 1, u = Inf\", args{2, 1, math.Inf(1), 1}, 0},\n\t\t{\"l = 1, u = Inf, v = Inf\", args{2, 1, math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"l = NaN, u = NaN\", args{2, math.NaN(), math.NaN(), 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c0edc28b0bb8ad039cd83dc2899be0c1":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c219c9759b2b913ab17a36a30c8a5282":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"OneSlice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"EqualLengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"DifferentLengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c245931e3d9384bd8814b85c1d7c28c5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c319c9163393d0f1a232cc36990f80f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Panic on short slice\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span() did not panic when length was less than 2\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{}, 1.0, 2.0)\n\t})\n\n\tt.Run(\"Span with NaN l\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 2.0}\n\t\tgot := Span(dst, math.NaN(), 2.0)\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span() with NaN l = %v, want %v, got %v\", math.NaN(), want, got)\n\t\t}\n\t})\n\n\tt.Run(\"Span with NaN u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()}\n\t\tgot := Span(dst, 1.0, math.NaN())\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span() with NaN u = %v, want %v, got %v\", math.NaN(), want, got)\n\t\t}\n\t})\n\n\tt.Run(\"Span with Inf l and Inf u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tgot := Span(dst, math.Inf(1), math.Inf(-1))\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span() with Inf l and Inf u = %v, want %v, got %v\", math.Inf(1), want, got)\n\t\t}\n\t})\n\n\tt.Run(\"Span with Inf l\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 2.0}\n\t\tgot := Span(dst, math.Inf(1), 2.0)\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span() with Inf l = %v, want %v, got %v\", math.Inf(1), want, got)\n\t\t}\n\t})\n\n\tt.Run(\"Span with Inf u\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{1.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)}\n\t\tgot := Span(dst, 1.0, math.Inf(-1))\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span() with Inf u = %v, want %v, got %v\", math.Inf(-1), want, got)\n\t\t}\n\t})\n\n\tt.Run(\"Span with regular values\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{1.0, 1.5, 2.0, 2.5, 3.0}\n\t\tgot := Span(dst, 1.0, 3.0)\n\t\tif !Same(got, want) {\n\t\t\tt.Errorf(\"Span() = %v, want %v\", got, want)\n\t\t}\n\t})\n}","c36fad062905512cad6644b00bea6fb9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n \u003c 2\", args{1, 0, 1, 0.5}, 0},\n\t\t{\"v NaN\", args{2, 0, 1, math.NaN()}, 0},\n\t\t{\"l NaN, u not NaN\", args{2, math.NaN(), 1, 0.5}, 1},\n\t\t{\"u NaN\", args{2, 0, math.NaN(), 0.5}, 0},\n\t\t{\"l and u Inf\", args{3, math.Inf(0), math.Inf(0), math.Inf(0)}, 0},\n\t\t{\"l and u Inf, n odd\", args{3, math.Inf(0), math.Inf(0), 1}, 1},\n\t\t{\"l and u Inf, n even\", args{4, math.Inf(0), math.Inf(0), 1}, 0},\n\t\t{\"l and u Inf, n even, v negative\", args{4, math.Inf(0), math.Inf(0), -1}, 2},\n\t\t{\"l Inf, u finite\", args{2, math.Inf(0), 1, 0.5}, 1},\n\t\t{\"l Inf, u finite, v equal to l\", args{2, math.Inf(0), 1, math.Inf(0)}, 0},\n\t\t{\"u Inf, l finite\", args{2, 0, math.Inf(0), 0.5}, 0},\n\t\t{\"u Inf, l finite, v equal to u\", args{2, 0, math.Inf(0), math.Inf(0)}, 1},\n\t\t{\"v negative Inf, l \u003c u\", args{2, 0, 1, math.Inf(-1)}, 0},\n\t\t{\"v negative Inf, l \u003e u\", args{2, 1, 0, math.Inf(-1)}, 1},\n\t\t{\"v positive Inf, l \u003c u\", args{2, 0, 1, math.Inf(1)}, 1},\n\t\t{\"v positive Inf, l \u003e u\", args{2, 1, 0, math.Inf(1)}, 0},\n\t\t{\"l \u003c u, v \u003c= l\", args{3, 0, 1, 0}, 0},\n\t\t{\"l \u003c u, v \u003e= u\", args{3, 0, 1, 1}, 2},\n\t\t{\"l \u003e u, v \u003e= l\", args{3, 1, 0, 1}, 0},\n\t\t{\"l \u003e u, v \u003c= u\", args{3, 1, 0, 0}, 2},\n\t\t{\"basic case\", args{3, 0, 1, 0.5}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c424d8a35f7c8b05e45733b34ada50f6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=1\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 1},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=1\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=1\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 1},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=1\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(-1), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(-1), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(-1), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(-1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=1\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=1\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(-1), v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(-1), v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(-1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(-1), v=1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(-1), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.NaN(), v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.NaN(), v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c4347345bb3b757aabbc440dd959adf5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0, // Should panic\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"all equal\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 1.0, 1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -2.0, -1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at start\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 1.0, 3.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 3.0, math.NaN()},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 1.0, math.NaN(), 3.0, math.NaN()},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tif tt.name == \"empty slice\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"MaxIdx() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c44e095c6325fd9ca41dd7c3957a9234":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{\n\t\t\t\t\t{1, 2, 3},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{\n\t\t\t\t\t{1, 2, 3},\n\t\t\t\t\t{4, 5, 6},\n\t\t\t\t\t{7, 8, 9},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unequal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{\n\t\t\t\t\t{1, 2, 3},\n\t\t\t\t\t{4, 5, 6},\n\t\t\t\t\t{7, 8},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c50cc8843b4580e570dbf84f66a3386f":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(float64) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements, k negative\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(float64) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements, k zero\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(float64) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find some elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 3\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find too many elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 3\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find none\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find multiple with pre-populated inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(v float64) bool {\n\t\t\t\t\treturn v \u003e 3\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c5390b0747a0390f595f5a93fd3be797":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","c63de35547795507c7e26f34c81f2123":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c66f332326724bc488067fc1ae2dee45":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"test1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{1, 1.5848931924611136, 2.5118864315095794, 3.9810717055349734, 6.309573444801933, 10, 15.848931924611136, 25.118864315095794, 39.810717055349734, 63.09573444801933},\n\t\t},\n\t\t{\n\t\t\tname: \"test2\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   10,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{10, 17.782794100389228, 31.622776601683793, 56.23413251903491, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"test3\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{1, 1.7782794100389228, 3.1622776601683793, 5.623413251903491, 10, 17.782794100389228, 31.622776601683793, 56.23413251903491, 100, 177.82794100389228},\n\t\t},\n\t\t{\n\t\t\tname: \"test4\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{1, 10, 100},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-10) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c67238fc1cdc7f32abd6e8a9759afd8f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\tt.Run(\"Panic on short span\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Span did not panic on a short slice\")\n\t\t\t}\n\t\t}()\n\t\tSpan([]float64{}, 0, 1)\n\t})\n\n\tt.Run(\"Span with NaN\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1}\n\t\tSpan(dst, math.NaN(), 1)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span with NaN failed at index %d, got %f, want %f\", i, dst[i], want[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Span with positive infinities\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)}\n\t\tSpan(dst, math.Inf(1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span with Inf failed at index %d, got %f, want %f\", i, dst[i], want[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Span with negative infinities\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(-1), math.Inf(-1)}\n\t\tSpan(dst, math.Inf(-1), math.Inf(-1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span with Inf failed at index %d, got %f, want %f\", i, dst[i], want[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Span with mixed infinities\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{math.Inf(-1), 0, 0, 0, math.Inf(1)}\n\t\tSpan(dst, math.Inf(-1), math.Inf(1))\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span with Inf failed at index %d, got %f, want %f\", i, dst[i], want[i])\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Span with normal values\", func(t *testing.T) {\n\t\tdst := make([]float64, 5)\n\t\twant := []float64{0, 1, 2, 3, 4}\n\t\tSpan(dst, 0, 4)\n\t\tfor i := range dst {\n\t\t\tif dst[i] != want[i] {\n\t\t\t\tt.Errorf(\"Span with normal values failed at index %d, got %f, want %f\", i, dst[i], want[i])\n\t\t\t}\n\t\t}\n\t})\n}","c68f0eeab1152e158103052b21dc3f6f":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c6e905e1ad53e35ccd01273d9f1d7878":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to middle\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v slightly less than middle\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v slightly greater than middle\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5.1,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd, v is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n is odd, v is -inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even, v is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n is even, v is -inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is inf, u is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is inf, u is inf, v is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is inf, u is inf, v is -inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c70bd4226e4382659ab756194d226ddb":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"within\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5, 6},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"below\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5, 6},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"above\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5, 6},\n\t\t\t\tv: 7,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"nan\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5, 6},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3, 1, 2, 4, 5, 6},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"short span\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"edge case\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2},\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c84004bbf3a69183c622f48e660f5b13":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 5.196152422706632,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L-inf norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: 11.180339887498949,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slice lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Should panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","c9072aa3fc2774f4553a579a976d9871":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with valid input\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound and Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c9a488ed3661683813cdc9acf0983fe4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large range\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 10),\n\t\t\t\tl:   0,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{0, 11.11111111111111, 22.22222222222222, 33.33333333333333, 44.44444444444444, 55.55555555555556, 66.66666666666666, 77.77777777777777, 88.88888888888889, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf (even)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 10)\n}","ca0939efcf7f3a8da4f08dbb68580e05":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Same slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tt: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tt: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tt: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 0.0 / 0.0},\n\t\t\t\tt: []float64{1.0, 2.0, 3.0, 0.0 / 0.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","ca5c8d4320f117c218de35798e287ba6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cad7b02fd7a43024f9e31aaa000ba4d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf with same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is +Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cb2f4ecce6f8ce30d05a1cb5dedc4149":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value in range\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value at lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value at upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value below lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value above upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{4.0, 2.0, 3.0, 1.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic for short slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic for unsorted slice\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cb50929c3d31ad17a3f460bf88000ad7":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSumCompensatedAccuracy(t *testing.T) {\n\t// Test cases where SumCompensated provides more accurate results than Sum\n\ttype testCase struct {\n\t\ts     []float64\n\t\twant  float64\n\t\tdelta float64\n\t}\n\ttestCases := []testCase{\n\t\t{\n\t\t\ts:     []float64{1e20, 1e-20, 1e20, -1e-20, 1e20, 1e-20},\n\t\t\twant:  3e20,\n\t\t\tdelta: 1e-15, // Expected delta for SumCompensated\n\t\t},\n\t\t{\n\t\t\ts:     []float64{1e10, 1e-10, 1e10, -1e-10, 1e10, 1e-10},\n\t\t\twant:  3e10,\n\t\t\tdelta: 1e-9,  // Expected delta for SumCompensated\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"AccuracyTest-%v\", tc.s), func(t *testing.T) {\n\t\t\tgotCompensated := SumCompensated(tc.s)\n\t\t\tgotSum := Sum(tc.s)\n\t\t\t// Check if SumCompensated is more accurate than Sum\n\t\t\tif math.Abs(gotCompensated-tc.want) \u003e tc.delta {\n\t\t\t\tt.Errorf(\"SumCompensated accuracy failed: got %v, want %v with delta %v\", gotCompensated, tc.want, tc.delta)\n\t\t\t}\n\t\t\tif math.Abs(gotSum-tc.want) \u003c tc.delta {\n\t\t\t\tt.Errorf(\"Sum accuracy unexpectedly good: got %v, want %v with delta %v\", gotSum, tc.want, tc.delta)\n\t\t\t}\n\t\t})\n\t}\n}\n","cb535218c3f70cf84aad141358af65fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cba9f4ddaeffe47ca5b276cb857f5a91":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\"Empty\", args{[]float64{}, 1}, 0},\n\t\t{\"Zero\", args{[]float64{0, 0, 0}, 1}, 0},\n\t\t{\"One\", args{[]float64{1, 1, 1}, 1}, 3},\n\t\t{\"L1\", args{[]float64{1, 2, 3}, 1}, 6},\n\t\t{\"L2\", args{[]float64{1, 2, 3}, 2}, math.Sqrt(14)},\n\t\t{\"LInf\", args{[]float64{1, 2, 3}, math.Inf(1)}, 3},\n\t\t{\"Negative\", args{[]float64{-1, -2, -3}, 1}, 6},\n\t\t{\"Mixed\", args{[]float64{-1, 2, -3}, 1}, 6},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !floatEquals(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEquals(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}\n","cbb8d4e698be7f05734f9a6261da1335":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with one element\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.75, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large values\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cd1af6b4b2cac1a9911a1fa1e5f63565":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.Inf(1), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.Inf(1), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.Inf(1), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.Inf(1), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cd2551357bf5a4761b1d93b27199cd8e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 1e10, 1e10, 1e10, 1e10},\n\t\t\t},\n\t\t\twant: 5e10,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 1e-10, 1e-10, 1e-10, 1e-10},\n\t\t\t},\n\t\t\twant: 5e-10,\n\t\t},\n\t\t{\n\t\t\tname: \"Alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cd59b1cd0bb3ec2ddb479fb44184b611":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L inf norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1.0/3.0),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cdbdf12b54f31cf75f3fe8b5f104b1b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 0.75, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.75, -0.5, -0.25, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"large\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   100,\n\t\t\t\tu:   200,\n\t\t\t},\n\t\t\twant: []float64{100, 125, 150, 175, 200},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and finite u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"finite l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cec8ccef0f30afa2aa52c89fdd1aaf3a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !almostEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc almostEqual(a, b float64) bool {\n\tconst epsilon = 1e-8\n\treturn math.Abs(a-b) \u003c epsilon\n}","ced77cd244892a4bc6b7d487dd1b6d4a":"package floats\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tc   float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tc:   2.0,\n\t\t\t\ts:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0, 3.0},\n\t\t\t\tc:   2.0,\n\t\t\t\ts:   []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: []float64{2.0, 4.0, 6.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1.0, 2.0},\n\t\t\t\tc:   2.0,\n\t\t\t\ts:   []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := ScaleTo(tt.args.dst, tt.args.c, tt.args.s); !equalFloatSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloatSlices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestScaleToPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ScaleTo() did not panic\")\n\t\t}\n\t}()\n\tScaleTo([]float64{1.0, 2.0}, 2.0, []float64{1.0, 2.0, 3.0})\n\tt.Errorf(\"ScaleTo() should have panicked\")\n}","cee9aea2c702fc18ba210f59a68d56ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"one element dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"two element dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"three element dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"four element dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 3.3333333333333335, 6.666666666666667, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"five element dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cf3d2ac834f186c8f0097e850e7bbbbe":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Custom comparison function\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.1, 2.1, 3.1},\n\t\t\t\tf:  func(a, b float64) bool { return (a - b) \u003c 0.1 },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","cfbb4651815b01c03980fee9bcea668b":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal, v is Inf and same sign as l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and not equal, v is Inf and same sign as u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u, v = l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, v is in the middle\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, v is close to l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, v is close to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n}\n\nfunc TestNearestIdxForSpan_Comparison(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t\t{\n\t\t\tname: \"n = 3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"n = 10\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"n = 100\",\n\t\t\targs: args{\n\t\t\t\tn: 100,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := Span(make([]float64, tt.args.n), tt.args.l, tt.args.u)\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\twant := NearestIdx(s, tt.args.v)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExampleNearestIdxForSpan() {\n\tn := 10\n\tl := 0.0\n\tu := 1.0\n\tv := 0.5\n\n\tidx := NearestIdxForSpan(n, l, u, v)\n\tfmt.Println(idx) // output: 5\n}","cfc03b5acebd84a7b4d5789bde286391":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements with k \u003c 0\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 1.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements with k \u003e 0\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 1.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements with k \u003e 0 and not enough elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 1.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find no elements with k == 0\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 10.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 1.0},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d00820bb1a4bd89672dcb2c82326bc12":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d03fbbedb07ba59353ee3aa2469554c4":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements with k \u003c 0\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements with insufficient elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{1},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with k = 0\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d0618cf3772a1cbdb3f414697491934f":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d1ae84045c77da5ac561a7f186238cb5":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=10, l=-1, u=1, v=0\", args{10, -1, 1, 0}, 5},\n\t\t{\"n=10, l=-1, u=1, v=0.5\", args{10, -1, 1, 0.5}, 7},\n\t\t{\"n=10, l=-1, u=1, v=-0.5\", args{10, -1, 1, -0.5}, 3},\n\t\t{\"n=10, l=-1, u=1, v=1.5\", args{10, -1, 1, 1.5}, 9},\n\t\t{\"n=10, l=-1, u=1, v=-1.5\", args{10, -1, 1, -1.5}, 0},\n\t\t{\"n=2, l=0, u=1, v=NaN\", args{2, 0, 1, math.NaN()}, 0},\n\t\t{\"n=2, l=NaN, u=1, v=0.5\", args{2, math.NaN(), 1, 0.5}, 1},\n\t\t{\"n=2, l=0, u=NaN, v=0.5\", args{2, 0, math.NaN(), 0.5}, 0},\n\t\t{\"n=2, l=Inf, u=Inf, v=Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=Inf, u=Inf, v=-Inf\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=3, l=Inf, u=Inf, v=Inf\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=Inf, u=Inf, v=-Inf\", args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"n=2, l=Inf, u=0, v=Inf\", args{2, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=2, l=Inf, u=0, v=-Inf\", args{2, math.Inf(1), 0, math.Inf(-1)}, 1},\n\t\t{\"n=2, l=0, u=Inf, v=Inf\", args{2, 0, math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=0, u=Inf, v=-Inf\", args{2, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=-Inf, u=0, v=Inf\", args{2, math.Inf(-1), 0, math.Inf(1)}, 1},\n\t\t{\"n=2, l=-Inf, u=0, v=-Inf\", args{2, math.Inf(-1), 0, math.Inf(-1)}, 0},\n\t\t{\"n=2, l=0, u=-Inf, v=Inf\", args{2, 0, math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=0, u=-Inf, v=-Inf\", args{2, 0, math.Inf(-1), math.Inf(-1)}, 1},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t} else {\n\t\t\tfmt.Println(\"NearestIdxForSpan() panicked as expected:\", r)\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}","d1e51f3ebef2601345a50316d8222b28":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.401197381662153,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -0.9999999999999999,\n\t\t},\n\t\t{\n\t\t\tname: \"Infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), 1.0, 2.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), 1.0, 2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 !math.IsInf(tt.want, 0) \u0026\u0026 math.Abs(got-tt.want) \u003e 1e-12 {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t} else if got := LogSumExp(tt.args.s); math.IsNaN(got) || math.IsInf(got, 0) || math.IsNaN(tt.want) || math.IsInf(tt.want, 0) {\n\t\t\t\t// check if both got and want are NaN or Inf\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"Panic test\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"LogSumExp() did not panic\")\n\t\t\t} else if fmt.Sprint(r) != \"s is an empty slice\" {\n\t\t\t\tt.Errorf(\"LogSumExp() panicked with %v, want 's is an empty slice'\", r)\n\t\t\t}\n\t\t}()\n\t\tLogSumExp([]float64{})\n\t})\n}","d21d94f17836ef34ef6e24fe8f5c1794":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d2d4683e15ed6c7820e9cc788de1ae6c":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find less than k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 3\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 0},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003c 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d3f731fcec5e030b686db890c77b0152":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element with multiple matches\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 2.0, 4.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element with positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element with negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","d472e2d93552a6c0dda8754ae8121fc6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_diff\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   -math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, -math.Inf(1), -math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 1.0, 5.0)\n}","d54d5f470d5f7010a1f68fb43aacbcd4":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v halfway between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n even, v halfway between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN, l is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is not Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is not Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is not Inf, v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is Inf, v is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: -1, // expect panic\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan(1, 0, 10, 5) did not panic\")\n\t\t} else {\n\t\t\tfmt.Printf(\"Recovered panic: %v\\n\", r)\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","d54f36e019297f6ad65085cc8a881991":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttype args struct {\n\t\ts1  []float64\n\t\ts2  []float64\n\t\ttol float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.000001, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-5,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 4.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t// Add more test cases here\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualApprox(tt.args.s1, tt.args.s2, tt.args.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d7391925b9ae35074c2ad1cdf8cee8b0":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"EqualSlices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"DifferentLengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"DifferentValues\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"EmptySlices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d799b91a3bd21a0eb9863753a3943661":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// Basic cases\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 0},\n\t\t{\"n=3, l=0, u=1, v=0.5\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\n\t\t// Cases with infinities\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=-10\", args{3, math.Inf(-1), 0, -10}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=-1\", args{3, math.Inf(-1), 0, -1}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=0\", args{3, math.Inf(-1), 0, 0}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=0, v=1\", args{3, math.Inf(-1), 0, 1}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=-10\", args{3, 0, math.Inf(1), -10}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=-1\", args{3, 0, math.Inf(1), -1}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=0\", args{3, 0, math.Inf(1), 0}, 0},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=1\", args{3, 0, math.Inf(1), 1}, 2},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 0},\n\n\t\t// Cases with NaN\n\t\t{\"n=3, l=math.NaN(), u=0, v=0\", args{3, math.NaN(), 0, 0}, 0},\n\t\t{\"n=3, l=math.NaN(), u=0, v=1\", args{3, math.NaN(), 0, 1}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=0\", args{3, 0, math.NaN(), 0}, 2},\n\t\t{\"n=3, l=0, u=math.NaN(), v=1\", args{3, 0, math.NaN(), 1}, 2},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=0\", args{3, math.NaN(), math.NaN(), 0}, 0},\n\t\t{\"n=3, l=math.NaN(), u=math.NaN(), v=1\", args{3, math.NaN(), math.NaN(), 1}, 2},\n\n\t\t// Cases with v outside of (l, u)\n\t\t{\"n=3, l=0, u=1, v=-1\", args{3, 0, 1, -1}, 0},\n\t\t{\"n=3, l=0, u=1, v=2\", args{3, 0, 1, 2}, 2},\n\t\t{\"n=3, l=1, u=0, v=-1\", args{3, 1, 0, -1}, 0},\n\t\t{\"n=3, l=1, u=0, v=2\", args{3, 1, 0, 2}, 2},\n\n\t\t// Cases with even n\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 0},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 2},\n\n\t\t// Cases with odd n\n\t\t{\"n=5, l=0, u=1, v=0.25\", args{5, 0, 1, 0.25}, 0},\n\t\t{\"n=5, l=0, u=1, v=0.5\", args{5, 0, 1, 0.5}, 2},\n\t\t{\"n=5, l=0, u=1, v=0.75\", args{5, 0, 1, 0.75}, 3},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d7b6ea6bd6829ec9f86229042aa6cc5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, opposite sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v not equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v not equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u, v = l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u, v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 10,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d8099fc547bc3e0cba409e34e0be5d49":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{-10.0, -7.5, -5.0, -2.5, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLower\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpper\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLower\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpper\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoth\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothEqual\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0.0, 10.0)\n}","d91536c4291955fa1cb968ab179e0f7a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple_case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"outside_span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative_span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_and_u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_v_negative\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf_v_positive\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n_less_than_2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0, // Should panic, but we're testing for the panic later\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t} else {\n\t\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","d9c055ec104c56718a9f735546ef9f34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"edge case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"edge case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: -10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nan case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"inf case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"inf case 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"inf case 4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"short span\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","db0efa97eac5aa38beace3d862c72995":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0, // should panic\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dc0c51f114dd31f4e8df118530ca14e5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 10.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: -1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 11.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse span (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 10.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse span (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (4)\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (5)\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10.0,\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v (1)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0.0,\n\t\t\t\tu: 10.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v (4)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10.0,\n\t\t\t\tu: 0.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dc352efe1934cd3627e87fc74681474a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all elements are the same\",\n\t\t\targs: args{s: []float64{1.0, 1.0, 1.0, 1.0, 1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dcd2c202fca790496c6f66029cca00a0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"TwoElements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"FiveElements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeBounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNLowerBound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaNUpperBound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"InfLowerBound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfUpperBound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfBounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"BothInfBoundsSame\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !equalSlice(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalSlice(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif !math.IsEqual(s1[i], s2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","dcfe3ecfae6fa288d7bcd0d33508722c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"One element slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Two elements slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{1, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Three elements slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{1, 5.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, even length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1, 1},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l, Inf u, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1, 1, 1},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 1, 1},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","de0f41c026a90025ceeee7a8b47d9b51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside of span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside of span, reversed\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v at the lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v at the upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is -Inf, odd n\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is -Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is -Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is -Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","df7fb887ea18e4ff6789fa276836ed07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","e0511d81fad1093714fcf21a2a02a933":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-2.0, -3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e0de08f91bb8621093aea8a6f6895828":"package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{1, 2, 3, 0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tArgsort(tt.args.dst, tt.args.inds)\n\t\t\tif !Equal(tt.args.inds, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", tt.args.inds, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e23f0499b54dde9b7d452678e119f319":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is 1\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 4\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 2.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than l and less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1.0,\n\t\t\t\tu: 2.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u and less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 2.0,\n\t\t\t\tu: 1.0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e25ace83e9153cf53faa9bc86e8579de":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is 1\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 4\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN, l is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is less than u, v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is less than u, v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u, v is greater than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u, v is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e36e2d6500656f6ab7d05eebfb5207f7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","e3d4b6f7a4af707bc819ae7f7d99fff2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !float64Eq(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// float64Eq checks if two float64 values are equal within a small tolerance.\nfunc float64Eq(a, b float64) bool {\n\tconst tolerance = 1e-6\n\treturn math.Abs(a-b) \u003c tolerance\n}","e3debfe533834eb7a925993f5da8abed":"package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0, 4.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0, 3},\n\t\t},\n\t\t{\n\t\t\tname: \"Duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0, 1.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{1, 3, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{-3.0, -1.0, -2.0, -4.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0, 3},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]int, len(tt.args.inds))\n\t\t\tcopy(got, tt.args.inds)\n\t\t\tArgsort(tt.args.dst, got)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e46741c04a2ae3e8fb5d63a0dfcf1389":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e4b1a35bdcaef67e0246950a70f8a28b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-1\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=1\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e551b450b466d5af6639a408ad6d1cd2":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large range\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   1000,\n\t\t\t},\n\t\t\twant: []float64{0, 250, 500, 750, 1000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 1)\n}\n\nfunc TestSpanRange(t *testing.T) {\n\tdst := make([]float64, 5)\n\tfor i, x := range Span(dst, 0, 10) {\n\t\tif x != float64(i)*2.5 {\n\t\t\tt.Errorf(\"Span() range value mismatch: got %v, want %v\", x, float64(i)*2.5)\n\t\t}\n\t}\n}\n\nfunc Equal(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif !math.IsNaN(s1[i]) \u0026\u0026 !math.IsNaN(s2[i]) \u0026\u0026 s1[i] != s2[i] {\n\t\t\treturn false\n\t\t} else if math.IsNaN(s1[i]) != math.IsNaN(s2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","e56decab21bda765dea786add27026fb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside the range\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: -1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside the range (other side)\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 11},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal to lower bound\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal to upper bound\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: 10},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 10, v: 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: 5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: 10, v: 5},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: 5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound and upper bound\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound and upper bound (different signs)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: 5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf value\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf value\",\n\t\t\targs: args{n: 5, l: 0, u: 10, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds\",\n\t\t\targs: args{n: 5, l: 10, u: 0, v: 5},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","e5e9fa216268e609baeb416605b77cd2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=10, v=5\", args{2, 0, 10, 5}, 1},\n\t\t{\"n=3, l=0, u=10, v=5\", args{3, 0, 10, 5}, 1},\n\t\t{\"n=4, l=0, u=10, v=5\", args{4, 0, 10, 5}, 2},\n\t\t{\"n=5, l=0, u=10, v=5\", args{5, 0, 10, 5}, 2},\n\t\t{\"n=2, l=10, u=0, v=5\", args{2, 10, 0, 5}, 1},\n\t\t{\"n=3, l=10, u=0, v=5\", args{3, 10, 0, 5}, 1},\n\t\t{\"n=4, l=10, u=0, v=5\", args{4, 10, 0, 5}, 2},\n\t\t{\"n=5, l=10, u=0, v=5\", args{5, 10, 0, 5}, 2},\n\t\t{\"n=2, l=0, u=10, v=0\", args{2, 0, 10, 0}, 0},\n\t\t{\"n=2, l=0, u=10, v=10\", args{2, 0, 10, 10}, 1},\n\t\t{\"n=2, l=10, u=0, v=10\", args{2, 10, 0, 10}, 0},\n\t\t{\"n=2, l=10, u=0, v=0\", args{2, 10, 0, 0}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()}, args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()}, args{2, 0, math.NaN(), math.NaN()}, 1},\n\t\t{\"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()}, args{2, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7908f6ba9246e52947f0c450542ee07":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 0.0, 4.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7de2bec59d8d297fc181da6f481f74b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e8244b76a457320d0ab3b95b58a6c2da":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Two element slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Three element slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e846085b6c4d3e90047c324e42424143":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Within sorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Within sorted slice, value at start\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Within sorted slice, value at end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Within sorted slice, value outside\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within sorted slice, value outside 2\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 6,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within sorted slice, duplicate values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 2, 4, 5},\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5, 2, 3, 1, 4},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within slice with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, math.NaN(), 4, 5},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within slice with NaN, value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within slice with length less than 2\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1},\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tt.Errorf(\"input slice is not sorted\")\n\t\t\t}\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tt.Errorf(\"input slice length is less than 2\")\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e84c735c076f2f8bd8d768404cfa6161":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside range 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Both bounds are Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 6,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse range\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse range 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse range 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 10, 5)\n}","eaffafaa2e0ca1f7561e224cb9d3208c":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Single Element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple Elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2, 3, 4},\n\t\t\t},\n\t\t\twant: 24,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb2979221b37e0bc94da0f2b22cd5473":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Arbitrary L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","ed4c3249384c384098afcc70d1b2cbca":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","edd6222fcf0881ddecd2e6230084c628":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic_case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative_values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"large_values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l_inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), 0, 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdst := make([]float64, 1)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(dst, 0, 10)\n}","ede839d8aa21a2a990793caf464a7fa3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Reversed bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 6\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_ShortSpan(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != shortSpan {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic with short span, got %v\", r)\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0.5)\n}","ee11c775a2b30640658618f6276f10f9":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttype args struct {\n\t\ts1  []float64\n\t\ts2  []float64\n\t\ttol float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 0.0001,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.00001, 2.00002, 3.00003},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 0.0001,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0},\n\t\t\t\ttol: 0.0001,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.1},\n\t\t\t\ttol: 0.0001,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{},\n\t\t\t\ts2:  []float64{},\n\t\t\t\ttol: 0.0001,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualApprox(tt.args.s1, tt.args.s2, tt.args.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eee73366a6b12e52db5a164b7574ac06":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 10\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 10\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find insufficient elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 5\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ef173baae917f51659bbeea6f5a88278":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with three elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than the first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to the last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 || !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\t// Expected panic, no need to check the actual panic message\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t} else {\n\t\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","f000ba2650b7d541450f4670b4290607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// Basic cases\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   3.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   -3.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-3.0, -2.0, -1.0},\n\t\t},\n\t\t// Edge cases\n\t\t{\n\t\t\tname: \"Zero length dst\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   3.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Length 1 dst\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   3.0,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   3.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   3.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 3.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !sameFloat64Slice(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc sameFloat64Slice(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif !math.IsNaN(s1[i]) \u0026\u0026 !math.IsNaN(s2[i]) \u0026\u0026 s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t\tif math.IsNaN(s1[i]) != math.IsNaN(s2[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","f0b30df2d6d93e47dff67646e0ce6c10":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=1\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=1\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f15c3362d300b641bf4f7188dbe271b2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   10,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{10, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds (mixed)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds (mixed reversed)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   10,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{10, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-10) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f2c99ede0b70b8c7222aa22af27455ed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple element slice with unique minimum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 0.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple element slice with multiple minimums\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 0.0, 0.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 0.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with NaN as minimum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 0.0, 4.0, 5.0, math.NaN()},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f2d0a4e0607696b81d0f7831b78f1a69":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f2f791bd017a2c0391ee414f8e34deb6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLess(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.a.Less(tt.args.i, tt.args.j); got != tt.want {\n\t\t\t\tt.Errorf(\"Less() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f4050e94ad42ab51bda296b51cea2843":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty Slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with Length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic Span\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Span\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{10, 7.5, 5, 2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN at end\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf at end\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f51a1aaeae1dd7bf0c8e26f89b8b78ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"TestLogSpan 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{1, 10, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan 2\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10000,\n\t\t\t},\n\t\t\twant: []float64{1, 10, 100, 10000},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan 3\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10000,\n\t\t\t},\n\t\t\twant: []float64{1, 10000},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan 4\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   100000,\n\t\t\t},\n\t\t\twant: []float64{1, 10, 100, 1000, 100000},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f5730e5037fa3baa3a7797e3cf5e3a11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple element slice with multiple minimums\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 1.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple element slice with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple element slice with minimum NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f5bab763ada8fe7c36081efa09724629":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f609d4620b7ad1d4e4f0ba7a78ef6ae8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"ZeroLengthSpan\", args{0, 0, 0, 0}, 0},\n\t\t{\"OneLengthSpan\", args{1, 0, 0, 0}, 0},\n\t\t{\"TwoLengthSpan\", args{2, 0, 1, 0}, 0},\n\t\t{\"TwoLengthSpan\", args{2, 0, 1, 1}, 1},\n\t\t{\"TwoLengthSpan\", args{2, 0, 1, 0.5}, 0},\n\t\t{\"ThreeLengthSpan\", args{3, 0, 1, 0}, 0},\n\t\t{\"ThreeLengthSpan\", args{3, 0, 1, 1}, 2},\n\t\t{\"ThreeLengthSpan\", args{3, 0, 1, 0.5}, 1},\n\t\t{\"FourLengthSpan\", args{4, 0, 1, 0}, 0},\n\t\t{\"FourLengthSpan\", args{4, 0, 1, 1}, 3},\n\t\t{\"FourLengthSpan\", args{4, 0, 1, 0.25}, 0},\n\t\t{\"FourLengthSpan\", args{4, 0, 1, 0.5}, 1},\n\t\t{\"FourLengthSpan\", args{4, 0, 1, 0.75}, 2},\n\t\t{\"InfSpan\", args{2, math.Inf(1), math.Inf(1), 0}, 0},\n\t\t{\"InfSpan\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"InfSpan\", args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"InfSpan\", args{2, math.Inf(-1), math.Inf(-1), 0}, 1},\n\t\t{\"InfSpan\", args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 1},\n\t\t{\"InfSpan\", args{2, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"InfSpan\", args{3, math.Inf(1), math.Inf(1), 0}, 1},\n\t\t{\"InfSpan\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"InfSpan\", args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"InfSpan\", args{3, math.Inf(-1), math.Inf(-1), 0}, 1},\n\t\t{\"InfSpan\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 2},\n\t\t{\"InfSpan\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"NanSpan\", args{2, math.NaN(), math.NaN(), 0}, 0},\n\t\t{\"NanSpan\", args{2, math.NaN(), math.NaN(), math.NaN()}, 0},\n\t\t{\"NanSpan\", args{2, math.NaN(), 0, 0}, 1},\n\t\t{\"NanSpan\", args{2, 0, math.NaN(), 0}, 0},\n\t\t{\"NanSpan\", args{3, math.NaN(), math.NaN(), 0}, 1},\n\t\t{\"NanSpan\", args{3, math.NaN(), math.NaN(), math.NaN()}, 1},\n\t\t{\"NanSpan\", args{3, math.NaN(), 0, 0}, 2},\n\t\t{\"NanSpan\", args{3, 0, math.NaN(), 0}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f6c14f0baeb9d56eb54d29effcc34ad0":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Within_SortedSlice_ValueWithinBounds\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Within_SortedSlice_ValueAtLowerBound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Within_SortedSlice_ValueAtUpperBound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 4,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Within_SortedSlice_ValueBelowLowerBound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"Within_SortedSlice_ValueAboveUpperBound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 6,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"Within_SortedSlice_ValueNaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"Within_UnsortedSlice_Panics\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3, 2, 1, 4, 5},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1, // Want: Panic\n\t\t},\n\t\t{\n\t\t\tname: \"Within_ShortSlice_Panics\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: -1, // Want: Panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 || !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within(%v, %v) did not panic\", tt.args.s, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","f8164ef3c4d50b252e6a8135c40a0ab5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1000.0, 2000.0, 3000.0},\n\t\t\t},\n\t\t\twant: 3000.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), 2.0, 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f8a59234d5fba12b9c07d35cf59640d8":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twantDst  []float64\n\t\twantInds []int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twantDst:  []float64{},\n\t\t\twantInds: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twantDst:  []float64{1.0},\n\t\t\twantInds: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twantDst:  []float64{1.0, 2.0, 3.0},\n\t\t\twantInds: []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twantDst:  []float64{1.0, 2.0, 3.0},\n\t\t\twantInds: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twantDst:  []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\twantInds: []int{1, 2, 3, 0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tinds := make([]int, len(tt.args.inds))\n\t\t\tcopy(inds, tt.args.inds)\n\t\t\tArgsort(dst, inds)\n\t\t\tif !Equal(dst, tt.wantDst) {\n\t\t\t\tt.Errorf(\"Argsort() dst = %v, want %v\", dst, tt.wantDst)\n\t\t\t}\n\t\t\tif !Equal(inds, tt.wantInds) {\n\t\t\t\tt.Errorf(\"Argsort() inds = %v, want %v\", inds, tt.wantInds)\n\t\t\t}\n\t\t})\n\t}\n}","fbcec84a399d16e857a04dd4101ba926":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty dst\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"dst with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Span\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Span\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{1, 0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and finite u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with finite l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","fdddd85e91abddc251b9da767bee01fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t\tt:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5, 6},\n\t\t\t\tt:   []float64{7, 8, 9},\n\t\t\t},\n\t\t\twant: []float64{12, 15, 18},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !equalFloatSlices(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalFloatSlices(s1, s2 []float64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","fe478ab38e642e30157bc134e5ad80b3":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=3, l=0, u=1, v=0\", args{3, 0, 1, 0}, 0},\n\t\t{\"n=3, l=0, u=1, v=0.333\", args{3, 0, 1, 0.333}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.666\", args{3, 0, 1, 0.666}, 2},\n\t\t{\"n=3, l=0, u=1, v=1\", args{3, 0, 1, 1}, 2},\n\t\t{\"n=4, l=0, u=1, v=0\", args{4, 0, 1, 0}, 0},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=4, l=0, u=1, v=1\", args{4, 0, 1, 1}, 3},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 0},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 0},\n\t\t{\"n=3, l=1, u=0, v=0\", args{3, 1, 0, 0}, 2},\n\t\t{\"n=3, l=1, u=0, v=0.333\", args{3, 1, 0, 0.333}, 1},\n\t\t{\"n=3, l=1, u=0, v=0.666\", args{3, 1, 0, 0.666}, 0},\n\t\t{\"n=3, l=1, u=0, v=1\", args{3, 1, 0, 1}, 0},\n\t\t{\"n=4, l=1, u=0, v=0\", args{4, 1, 0, 0}, 3},\n\t\t{\"n=4, l=1, u=0, v=0.25\", args{4, 1, 0, 0.25}, 2},\n\t\t{\"n=4, l=1, u=0, v=0.5\", args{4, 1, 0, 0.5}, 1},\n\t\t{\"n=4, l=1, u=0, v=0.75\", args{4, 1, 0, 0.75}, 0},\n\t\t{\"n=4, l=1, u=0, v=1\", args{4, 1, 0, 1}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), -math.Inf(1)}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), -math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{4, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{4, math.Inf(1), math.Inf(1), -math.Inf(1)}, 3},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{2, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{2, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{4, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{4, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 3},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{2, math.Inf(-1), math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\", args{2, math.Inf(-1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\", args{3, math.Inf(-1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{4, math.Inf(-1), math.Inf(1), math.Inf(1)}, 3},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\", args{4, math.Inf(-1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()\", args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=0\", args{2, math.NaN(), 0, 0}, 1},\n\t\t{\"n=2, l=math.NaN(), u=0, v=1\", args{2, math.NaN(), 0, 1}, 1},\n\t\t{\"n=3, l=math.NaN(), u=0, v=math.NaN()\", args{3, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=3, l=math.NaN(), u=0, v=0\", args{3, math.NaN(), 0, 0}, 2},\n\t\t{\"n=3, l=math.NaN(), u=0, v=1\", args{3, math.NaN(), 0, 1}, 2},\n\t\t{\"n=4, l=math.NaN(), u=0, v=math.NaN()\", args{4, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=4, l=math.NaN(), u=0, v=0\", args{4, math.NaN(), 0, 0}, 3},\n\t\t{\"n=4, l=math.NaN(), u=0, v=1\", args{4, math.NaN(), 0, 1}, 3},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()\", args{2, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=0\", args{2, 0, math.NaN(), 0}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=1\", args{2, 0, math.NaN(), 1}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=math.NaN()\", args{3, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=0\", args{3, 0, math.NaN(), 0}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=1\", args{3, 0, math.NaN(), 1}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=math.NaN()\", args{4, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=0\", args{4, 0, math.NaN(), 0}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=1\", args{4, 0, math.NaN(), 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}\n\nfunc TestNearestIdxForSpan_nLess2(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"NearestIdxForSpan() did not panic\")\n\t\t}\n\t}()\n\tNearestIdxForSpan(1, 0, 1, 0)\n}\n\nfunc TestNearestIdxForSpan_vNaN(t *testing.T) {\n\tgot := NearestIdxForSpan(2, 0, 1, math.NaN())\n\tif got != 0 {\n\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, 0)\n\t}\n}\n\nfunc TestNearestIdxForSpan_specialCases(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{2, math.Inf(1), math.Inf(1), -math.Inf(1)}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{3, math.Inf(1), math.Inf(1), -math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\", args{4, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\", args{4, math.Inf(1), math.Inf(1), -math.Inf(1)}, 3},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{2, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{2, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 1},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{3, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\", args{4, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\", args{4, math.Inf(-1), math.Inf(-1), -math.Inf(1)}, 3},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{2, math.Inf(-1), math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\", args{2, math.Inf(-1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{3, math.Inf(-1), math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\", args{3, math.Inf(-1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\", args{4, math.Inf(-1), math.Inf(1), math.Inf(1)}, 3},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\", args{4, math.Inf(-1), math.Inf(1), -math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()\", args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=0\", args{2, math.NaN(), 0, 0}, 1},\n\t\t{\"n=2, l=math.NaN(), u=0, v=1\", args{2, math.NaN(), 0, 1}, 1},\n\t\t{\"n=3, l=math.NaN(), u=0, v=math.NaN()\", args{3, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=3, l=math.NaN(), u=0, v=0\", args{3, math.NaN(), 0, 0}, 2},\n\t\t{\"n=3, l=math.NaN(), u=0, v=1\", args{3, math.NaN(), 0, 1}, 2},\n\t\t{\"n=4, l=math.NaN(), u=0, v=math.NaN()\", args{4, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=4, l=math.NaN(), u=0, v=0\", args{4, math.NaN(), 0, 0}, 3},\n\t\t{\"n=4, l=math.NaN(), u=0, v=1\", args{4, math.NaN(), 0, 1}, 3},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()\", args{2, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=0\", args{2, 0, math.NaN(), 0}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=1\", args{2, 0, math.NaN(), 1}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=math.NaN()\", args{3, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=0\", args{3, 0, math.NaN(), 0}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=1\", args{3, 0, math.NaN(), 1}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=math.NaN()\", args{4, 0, math.NaN(), math.NaN()}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=0\", args{4, 0, math.NaN(), 0}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=1\", args{4, 0, math.NaN(), 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_generalCases(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.333\", args{3, 0, 1, 0.333}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.666\", args{3, 0, 1, 0.666}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.5\", args{4, 0, 1, 0.5}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 0},\n\t\t{\"n=3, l=1, u=0, v=0.333\", args{3, 1, 0, 0.333}, 1},\n\t\t{\"n=3, l=1, u=0, v=0.666\", args{3, 1, 0, 0.666}, 0},\n\t\t{\"n=4, l=1, u=0, v=0.25\", args{4, 1, 0, 0.25}, 2},\n\t\t{\"n=4, l=1, u=0, v=0.5\", args{4, 1, 0, 0.5}, 1},\n\t\t{\"n=4, l=1, u=0, v=0.75\", args{4, 1, 0, 0.75}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_edgeCases(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0\", args{2, 0, 1, 0}, 0},\n\t\t{\"n=2, l=0, u=1, v=1\", args{2, 0, 1, 1}, 1},\n\t\t{\"n=3, l=0, u=1, v=0\", args{3, 0, 1, 0}, 0},\n\t\t{\"n=3, l=0, u=1, v=1\", args{3, 0, 1, 1}, 2},\n\t\t{\"n=4, l=0, u=1, v=0\", args{4, 0, 1, 0}, 0},\n\t\t{\"n=4, l=0, u=1, v=1\", args{4, 0, 1, 1}, 3},\n\t\t{\"n=2, l=1, u=0, v=0\", args{2, 1, 0, 0}, 1},\n\t\t{\"n=2, l=1, u=0, v=1\", args{2, 1, 0, 1}, 0},\n\t\t{\"n=3, l=1, u=0, v=0\", args{3, 1, 0, 0}, 2},\n\t\t{\"n=3, l=1, u=0, v=1\", args{3, 1, 0, 1}, 0},\n\t\t{\"n=4, l=1, u=0, v=0\", args{4, 1, 0, 0}, 3},\n\t\t{\"n=4, l=1, u=0, v=1\", args{4, 1, 0, 1}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNearestIdxForSpan_compareWithNearest(t *testing.T) {\n\tfor n := 2; n \u003c= 10; n++ {\n\t\tfor i := 0; i \u003c 100; i++ {\n\t\t\tl := float64(i)\n\t\t\tu := float64(i+1)\n\t\t\tfor j := 0; j \u003c 100; j++ {\n\t\t\t\tv := float64(j)/100 + l\n\t\t\t\tgot := NearestIdxForSpan(n, l, u, v)\n\t\t\t\twant := Nearest(Span(make([]float64, n), l, u), v)\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\", n, l, u, v, got, want)\n\t\t\t\t\tfmt.Printf(\"NearestIdxForSpan(%d, %v, %v, %v) = %v, want %v\\n\", n, l, u, v, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","fffbfad0db7ae393fa0704ea9b316d33":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"ZeroLength\", args{0, 1, 2, 1.5}, 0},\n\t\t{\"OneLength\", args{1, 1, 2, 1.5}, 0},\n\t\t{\"TwoLength\", args{2, 1, 2, 1.5}, 0},\n\t\t{\"TwoLengthUlt\", args{2, 1, 2, 2}, 1},\n\t\t{\"TwoLengthGrt\", args{2, 1, 2, 1}, 0},\n\t\t{\"TwoLengthMid\", args{2, 1, 2, 1.5}, 0},\n\t\t{\"FourLength\", args{4, 1, 2, 1.5}, 0},\n\t\t{\"FourLengthMid\", args{4, 1, 2, 1.75}, 1},\n\t\t{\"FourLengthMid\", args{4, 1, 2, 1.25}, 0},\n\t\t{\"FourLengthUlt\", args{4, 1, 2, 2}, 3},\n\t\t{\"FourLengthGrt\", args{4, 1, 2, 1}, 0},\n\t\t{\"NaNL\", args{4, math.NaN(), 2, 1}, 3},\n\t\t{\"NaNU\", args{4, 1, math.NaN(), 1}, 0},\n\t\t{\"InfLInfU\", args{4, math.Inf(1), math.Inf(1), 1}, 0},\n\t\t{\"InfLInfUOdd\", args{5, math.Inf(1), math.Inf(1), 1}, 2},\n\t\t{\"InfLInfUOddNeg\", args{5, math.Inf(-1), math.Inf(-1), 1}, 2},\n\t\t{\"InfLInfUEven\", args{4, math.Inf(1), math.Inf(1), 1}, 0},\n\t\t{\"InfL\", args{4, math.Inf(1), 2, 1}, 0},\n\t\t{\"InfU\", args{4, 1, math.Inf(1), 1}, 3},\n\t\t{\"NegInfV\", args{4, 1, 2, math.Inf(-1)}, 0},\n\t\t{\"PosInfV\", args{4, 1, 2, math.Inf(1)}, 3},\n\t\t{\"ULessThanL\", args{4, 2, 1, 1.5}, 3},\n\t\t{\"ULessThanL\", args{4, 2, 1, 2.5}, 0},\n\t\t{\"NaNV\", args{4, 1, 2, math.NaN()}, 0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"}