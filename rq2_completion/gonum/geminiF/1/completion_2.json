{"0026966f482687b357882089f4e9ee0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","00ff8da04f0e838382a81a82fbe07efe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(1 + 8 + 27, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","013e5ee407fb258d6a8c3fda98af7c6a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0215348bb87bbfbf266f19937ec2247e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","028e90cbce778d1961c87aa647c65dad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, negative\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, positive\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02c76544e44aa50c3890e81b07f8e90f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, nearest to middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, equal distance, return lowest index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02d05743532d1daecf41e66d43e30cae":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","02dace20380755f8b679152b01cb1c37":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Odd\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","02fbbeaf9207bbe077f089b5539b257d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0448c285f2fcbc79b86a5077593f1471":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","0481378a1b09214b71ea7267f94d33e1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","049bf5e147c76a4cefac4edd03539ef1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (different signs)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (different signs, odd n)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf (negative)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0509e0638a4b45d441f01d4ba3e331eb":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScale(t *testing.T) {\n\ttype args struct {\n\t\tc   float64\n\t\tdst []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tScale(tt.args.c, tt.args.dst)\n\t\t\tif !Equal(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Scale() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","078c692d78e6f34adcf892727898b8a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","07a3669a4df39454690361c55d14ee12":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","082fe751a23930a68a019f44025e09cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Equal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","08367c21374f71c8896f648b0805835b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0843ef585b873a1a79ee4ad7a8360783":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.5},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.5},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 0, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = 0, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = 0, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = 1, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 1, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = 1, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","08d82e43185b5ac68d847ab24ea6f61b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","092d969bdc8d331e1383b09ae960574d":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !floatEquals(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc floatEquals(a, b float64) bool {\n\treturn math.Abs(a-b) \u003c 1e-6\n}","0a4296a1d29592be5b3cbae3eddad4e4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0a81dba7d0fdfeb9b2ee90d5fffab1ef":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0b097e9900feb8b9e641c792209cf25f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values at the beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values at the end\",\n\t\t\targs: args{s: []float64{1.0, 3.0, 4.0, 5.0, math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0b471cefc5359254a2f629459fb3aade":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large range\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -1000,\n\t\t\t\tu:   1000,\n\t\t\t},\n\t\t\twant: []float64{-1000, -500, 0, 500, 1000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and finite u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Finite l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","0c3582a382574f253a9d3e2de6f04b2e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN not treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0cbfee12334c61b215b68e7039d3e04c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0), math.Inf(0)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0d144bb389e3e2f7fce75bb9ab4c36ba":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0d37d4ebe8ea732945906d799178ed91":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0d38cf851eedbeb3bf60880a2ff1cb98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","0e04172c6c2d5d231457bf49bbcc2001":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","0e9561493f6229f9472a0d33b0425509":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","0f3a51095de34ca23f6513dd63718b5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t\t{\n\t\t\tname: \"TestLogSpan1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.154434690031884, 4.641588833612779, 10.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan2\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   10.0,\n\t\t\t\tu:   100.0,\n\t\t\t},\n\t\t\twant: []float64{10.0, 21.54434690031884, 46.41588833612779, 100.0, 100.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan3\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0.1,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{0.1, 0.2154434690031884, 0.4641588833612779, 1.0, 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan4\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   -1.0,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"TestLogSpan5\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","0fd11dba8dbc082251b5cc7acfffe5cd":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","10520592a0f56f200f0a6b8fc4e6f903":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn a == b\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn a == b\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn a == b\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0001, 2.0001, 3.0001},\n\t\t\t\tf: func(a, b float64) bool {\n\t\t\t\t\treturn abs(a-b) \u003c 0.001\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc abs(x float64) float64 {\n\tif x \u003c 0 {\n\t\treturn -x\n\t}\n\treturn x\n}","11f572eb365996ad3a7cf07e62825761":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L norm with negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1, -2, -3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1233b208bd7b9681685f0e7a71169e0f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","128299297328105251c94c426bd401ac":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","156e9026367d2431fbba36241809755c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","16389cca552661e959b771ae10933bd1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","16b961141bad023dbcab537e8956f070":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"nan_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"inf_both_even\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","175bec1e74ac88c0ebf6618319ad2aea":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","178631791ebe40ac3e37a083dbafcaf0":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","17b48362ee126933a53c1a193c164509":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1830f8f917008a5af3ab25c87b2ae2dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","18f63684bb35c6121ee813332812b6fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(1 + 8 + 27, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1968ed211494d5115fccc7fbe0d9b841":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","19b2aa9741f579897b5c9a00dec4d507":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1ad9c3bf09c1a9d8050c0ee5abf9560b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1c4cb9f8a7e88f9578abe483cfc61f88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1c5f72f2d5979de07ba7baa8000ca229":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfNegative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{-10.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfEqual\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","1ca3cc76bc3280f4036eb5e02262113a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","1d6ce67971a15d6b9f8427cb2884ae20":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed positive and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1fdd45a9c18c7c68f389281bb34338b8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.NaN(), v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = 0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1fe92cb8cfb822ebbb0cb855c24a048d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","200507033a4953d93b579d69ed390e88":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, math.NaN(), 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","20b1c7750ca546302f3faea997b5b38d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","210f3b2cc25d3852c35a761e34477c91":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","213b596d12483bcacb7cf3ba03419666":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","226111ab2928dc905e44814f6f9015be":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","22bd207af381f87686834da5d600c1ad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value closer to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value closer to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.8,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","252ed22fd9f5304c94adacddc06a1137":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"one NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, math.NaN()},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 2, math.NaN()},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","253f0b1f1c4b549501d40eca15d5eced":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is between u and l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","25ce682804023f9a12509c8ac3f9216a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), 0, 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), 0, 0, 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","26a35a13561a9794e4226386d82986f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","273f0a878b8e6f3562e9f28f044dc394":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"zero and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.0, -1.0, -2.0, -3.0, -4.0},\n\t\t\t},\n\t\t\twant: -10.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","275967bd3d165d6f5e107ac14d6101cc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","27980de3e3145bbf91a6bce006ce4d0c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 1.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 3.0, 4.0, 5.0, math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2799b7f6d5b93f89992e821705bebff0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","28520fc1a5692c9c87d9da5daba3a32d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), -1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","288f617c62576d3f1a88038094c17195":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), -1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","28ebcdc9ba99fb1af3edf4495a630a68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values with duplicates\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0, math.NaN(), 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","28f9800a7a4182bbc7af30b587ca4260":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L norm with negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1, -2, -3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","29038392105c5bc234f760656fcb22e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), math.NaN(), math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2912766f5fa08aadae1282284cedee38":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with positive bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with zero bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower and upper bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower and upper bounds (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","29321ecf0482984dd39ea3b7ce875e3b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","29360998acd13b342952710bb8afacf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","295ed50fd8578a673bb2e3fcc8350d9c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"zero and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.0, -1.0, -2.0, -3.0, -4.0},\n\t\t\t},\n\t\t\twant: -10.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","29b9b1c0f0123acdc4bd5a5dcb577350":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN element with other NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), math.NaN(), 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2a86c48c0b34e51f7e81c07ad226cfc8":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2adf7865b18d991dea53dc6df7a87df3":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 0.0, 4.0},\n\t\t\t},\n\t\t\twant: 0.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2c01766532bd63aa2abc38cc94eb14e6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Two elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Three elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 3.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Five elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower and upper bound, odd length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2c0b11a375fc921998c1c9c945a1e821":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, negative\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, positive\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2d185405319948d8cbedc6a6a50ab7fc":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := DivTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2d9592ac59a1a355ee03def9ab0094c3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u Inf, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u finite, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf, u finite, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u Inf, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l -Inf, u finite, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l -Inf, u finite, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u -Inf, v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l finite, u -Inf, v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2e64769798a5cc94d729f8d90e29adfd":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tc   float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := ScaleTo(tt.args.dst, tt.args.c, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","2e8f04b46a7cc612ea38ffd806e2eb04":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"large\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 10),\n\t\t\t\tl:   0,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{0, 11.11111111111111, 22.22222222222222, 33.33333333333333, 44.44444444444444, 55.55555555555556, 66.66666666666666, 77.77777777777777, 88.88888888888889, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","2f1a12d46d26c88d281ab17f5d43f813":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3089a094a99d51ef78034874e78c9a53":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.4076059679126216,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -0.04978706836786394,\n\t\t},\n\t\t{\n\t\t\tname: \"large positive elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10},\n\t\t\t},\n\t\t\twant: 3e+10,\n\t\t},\n\t\t{\n\t\t\tname: \"large negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1e10, -2e10, -3e10},\n\t\t\t},\n\t\t\twant: -1e+10,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), 1.0, math.Inf(1)},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(tt.want) \u0026\u0026 !math.IsNaN(got) \u0026\u0026 math.Abs(got-tt.want) \u003e 1e-6 {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","30dee26f57fa90a8a53794231ce2c69e":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Two slices with equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Two slices with different lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple slices with equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple slices with different lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","310cb20bedefcc5ffc221258026fc89f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","315d479ff232fd65956f9b3da7e0e12b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","31da813b746c7eabd381b135198484d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.NaN(), v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = 0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","32bb0402b219e3687bbce36b83414407":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 || !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","345c9a3be0ead2a6bb443889e1480273":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34830695dc149b4a5cc409e9b2a8f053":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{s: []float64{1e10, 2e10, 3e10, 4e10, 5e10}},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{s: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10}},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Alternating signs\",\n\t\t\targs: args{s: []float64{1.0, -2.0, 3.0, -4.0, 5.0}},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Near zero\",\n\t\t\targs: args{s: []float64{1e-15, 2e-15, 3e-15, 4e-15, 5e-15}},\n\t\t\twant: 1.5e-14,\n\t\t},\n\t\t{\n\t\t\tname: \"Near infinity\",\n\t\t\targs: args{s: []float64{1e15, 2e15, 3e15, 4e15, 5e15}},\n\t\t\twant: 1.5e16,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0}},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{s: []float64{1.0, math.Inf(1), 3.0}},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{s: []float64{1.0, math.Inf(-1), 3.0}},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34c0d99226cdf4b4227be15a1f145e68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with opposite signs\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same signs and n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf with same signs and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.3,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","34ff38c1847746783a7293319ecf85f8":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements with k \u003c 0\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements, not enough elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    4,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0, 1},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2.0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","356d6aedd0b043c46f7fcf7e3ff1cbc9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","358cb99636fbb9e701ee9e0d5a0edac1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","35e4e0a40afe6a5e168783bb39d5cb1d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","36b46310cb1e47d0cbd345cbb5e97feb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3777da618e67948fe1f0988381d359df":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","382421897ddac293a7eaf5803663f8ba":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3843bad289f379e1a739b632988424fb":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find insufficient elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 11},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{10, 11, 0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","39db05dc4a24eb9227f51017d3d973fe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds (4)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds (5)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Reverse bounds (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3a76d4dd149871d67008d88252023be3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values at the beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values at the end\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3adb71339e22f88f256492a10f5ad403":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3bddc91a49dd0c307d9de0e1281590c7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (even)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","3d239a05153f127756cc4206cf13ce2f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3f1fcb2afc428a0210f30e3b742123c1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","3fa7e3b95f5c707b1cf62da5c1bdb6f4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddConst(t *testing.T) {\n\ttype args struct {\n\t\tc   float64\n\t\tdst []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tAddConst(tt.args.c, tt.args.dst)\n\t\t\tif !Equal(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"AddConst() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","402da2b0239a95cd0ad9382497c83698":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","408bf5d6763678341e7519c97944b765":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4171fcb628d4c71d3830d56fe113e994":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","425513ae8a69a98a714e8b3f95e333d2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Odd length\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 2\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 3\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 4\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 5\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 6\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 100,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 7\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -100,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4255a92f176f4d91698166bcd5e8c176":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","427a068f7b9d98292d45ba8f0298d820":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.75, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","437c902372f0d98605b3971c25a238e2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","43b37766db5973e6b66d2f8e975f0b50":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(float64) bool { return true },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find first element\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 3 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find multiple elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 3 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find more elements than exist\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 3 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf:    func(x float64) bool { return x \u003e 5 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf:    func(x float64) bool { return x \u003e 3 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"find with existing indices and no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf:    func(x float64) bool { return x \u003e 5 },\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","43da2b9b629e14fe67c3831d7c5be202":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","448e96e64dc8a814b9196333c8e74a69":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (different signs)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (different signs, even n)\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf (negative)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.args.n \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) did not panic\", tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tNearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v)\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan(%v, %v, %v, %v) = %v, want %v\", tt.args.n, tt.args.l, tt.args.u, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","44b252eb7d64662d0890dd69335bcff7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 5 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 11},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4511cbb301b7d8bfcf0b0dedbc359aa4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","453441fed479c6b931c95d8e6a2dc624":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","45a30c5828885a89ba83eb56d93bcb68":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4627622097568676db1c4bb86f0f6c45":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4779c1536b5e5170e27ec9a3d10c39ae":"","47f60ea89af4f421e1d95c0dab96a75e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, math.NaN(), 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","485f3f9430a5c1ee9fe363f2c8c5ca6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with NaN\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with NaN at the beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, 2.0, 3.0, 4.0}},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4902acfcc99189c581fc8a8766675600":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","498646d911c3405408999849c323ca03":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","49ba2faa968d0b16296a65774ac0301a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"general case, v is halfway\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","49f1f6060a6fe1ef71ebca94b2d03f19":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4a76c915a614c1a32e928870371d7c11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4b1a23c141eedc527eec4c3fbbbf89e3":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4ba005c9cdfe22faa8fc506e95a25089":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case - v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case - v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside of span\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside of span (other direction)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN v\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (even n)\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (v == l)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (v == u)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (v == -Inf)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and u (v == Inf)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v (negative)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf v (positive)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u (v outside of span)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u (v outside of span)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4c6cdb436525f21ceeedad76790926b9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slice lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4cbcd075e4543798c309fb6ee26e85d1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4e1af0d7b8ed5d716b99fd19e75c5557":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4eb979ccf40b8e4948c951fe71f3192c":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","4ee2b8620a8d952f91ac91175e990d11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","50a644966ebeb9b5f9f075ffe29701a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","50bf89e11cdfc6a5f67944e93b69ded7":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find fewer than k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find one element\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3, 1},\n\t\t\t\tk:    1,\n\t\t\t},\n\t\t\twant:    []int{3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5100393d9c20179d1f466df07560df26":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tAddScaled(tt.args.dst, tt.args.alpha, tt.args.s)\n\t\t\tif !Equal(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","513e0f7a072d293d0d8efdd905153883":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51de97e964a1fffb9b422eb59da5400d":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tDiv(tt.args.dst, tt.args.s)\n\t\t\tif !Equal(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51e62d3003c1cef2b289488bb49642bc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51e6755e7f508768bca93b584325caa1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and equal\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","51f37ea8b340d88b86dd6365594f823f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0}},\n\t\t\twant: 3.4076059679126216,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0}},\n\t\t\twant: -0.04978706836786394,\n\t\t},\n\t\t{\n\t\t\tname: \"large positive elements\",\n\t\t\targs: args{s: []float64{100.0, 200.0, 300.0}},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large negative elements\",\n\t\t\targs: args{s: []float64{-100.0, -200.0, -300.0}},\n\t\t\twant: -100.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{s: []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinities\",\n\t\t\targs: args{s: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","535e683dd7462e2c87fae6b37215e513":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // This test should panic, but we're just checking for a non-zero result\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","54cf5f7fc12931717650aaf61a9e1990":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5510c4a37a65894d6414bbbb693794cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is finite, u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","553492048d9a895e0c7a6480f8a52aa9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","557c377cf77cfee5862a9c9ac824624d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"cancellation\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, -1e10, 1e-10, -1e-10},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","566741d6f8a87aed21ab7e8ff5149d73":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","585b7ac09a3b8d7ae48ddfa3fb2ed341":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 4\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","58c241954b2664727c41d7721efab838":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAdd(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","596038e104a8cfd0669b4e0ae9d834d2":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find_k_0\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_negative\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_positive_found\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_positive_not_found\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 4\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_positive_empty_slice\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","59cfb0df3d116931d8ef233f5c4d4ba1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","59e9807e410b3b1e42476d1626350de1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with two elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with three elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with both Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 3),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","5a067b714f12586ffcf7e6ed3a76e094":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at end\",\n\t\t\targs: args{s: []float64{1.0, 3.0, 4.0, 5.0, math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5aa15949cd7c6551c734080cf1d8b245":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value within first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value within second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5cab14684e3236374aff22310a463d29":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 2.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with same max\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 1.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -2.0, -1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 3.0, 1.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN as max\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 1.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5cfd5efc057e14d6f915e2f0e3a7a4e1":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5db0ca7cc9e199b358e4086356bd249f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5e5b494cf15f876e881c448b70eb2381":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSubTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SubTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"SubTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","5ec0328f90a34d616e3b204f7b27312c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","61372161edf3c9defd238b1135cd48bc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Unequal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","619b5b88adc14dd5e12b4896a2e60292":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), math.NaN(), 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN as maximum\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, math.NaN()}},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","63eb0a38dfc2724cfeb1f978ccfde92a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 0, v = 0\",\n\t\t\targs: args{n: 2, l: 0, u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 1, v = 1\",\n\t\t\targs: args{n: 2, l: 1, u: 1, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 1, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 1, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(-1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","63fa0b8a84228ec317cfed7688363a0a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"InfNegative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{-10.0, math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBoth\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfBothEqual\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","6413829de65ffe830657a47656e35ce0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is 1\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 4\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","656d8243e7ab61dd1b5d5d4c0a1c2a51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), -1, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (even)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","65a07e02fcce872028436f8a915909a7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, equal distance, return lowest index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","65fd8ad4512dfef4102fe3bfb9270a4f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf-Neg\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf-Pos-Neg\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, 0.0, math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf-Neg-Pos\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), 0.0, 0.0, 0.0, math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","6614f0f640bed3219f6edca88d44dd37":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","662f2e407358b89be4281a5a18880939":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","66d292c1ce226e5c8864cc13fe05bc21":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is finite\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, negative\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, positive\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, n odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","67dd6295b47259e6fb279f0555c34da2":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n","68474e5a72e61670a6cb46b5ac1305bf":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","68899a430ddf4f6f239e756b66bbbffb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN not treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","68e0afb435fbddde65eef21993523abe":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","690866bf0f92f2e1f2a6c438c10bc8eb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: 0, v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=1\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6930d616072f2ca90b31519426117788":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{100.0, 200.0, 300.0},\n\t\t\t},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","69897caeb65fe72f7aa78c474973b3a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6aede9c09c69006b852dd6e16ffad905":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{-10, -10, -10, -10, math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","6af629ddd937cab703589d0bb7a8abe6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6bfc7b9f97ba65b7653d66b1e69f0b80":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2, 3},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1, 2, 4},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal with custom function\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1, 2, 3},\n\t\t\t\ts2: []float64{1.1, 2.1, 3.1},\n\t\t\t\tf:  func(a, b float64) bool { return abs(a-b) \u003c 0.1 },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc abs(x float64) float64 {\n\tif x \u003c 0 {\n\t\treturn -x\n\t}\n\treturn x\n}","6c7c9566e0529939e343a754e38af8a8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Different\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","6d06d0759e4be25c7b630ad5ceb5bc13":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6d21515f8125323eb177cf800f931b07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf-Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6deba74db0b90460246258ff700fb465":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Different\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0.0, 0.0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","6f60e11c27d167cc98a6c777b2ed309f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","6f8f0cf089b9296b93c93e650fdcf0f6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","705779804a0d6e416d989d33e5d71d2c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, n even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v in (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v in (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","70ef5cf162ccbbbeaffa61109d9d5327":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","719fbaed10eb9f84af07d905fd6dc8b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{s: []float64{1e10, 2e10, 3e10, 4e10, 5e10}},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{s: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10}},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Alternating signs\",\n\t\t\targs: args{s: []float64{1.0, -2.0, 3.0, -4.0, 5.0}},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, math.NaN(), 3.0}},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{s: []float64{1.0, math.Inf(1), 3.0}},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{s: []float64{1.0, math.Inf(-1), 3.0}},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","72080191d1a0f6a037ea1ba79b729034":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDot(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Dot(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Dot() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","731ef9c1650a0835b8d91c3e5645ea3d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7342be149dca4d93bbc1c7058fc4b165":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN not treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","735adf687a18e301fe773c3aa12dfa6b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is outside (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is outside (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is outside (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is outside (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is inside (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is inside (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","742c3a0e60b52275548045f9937128ed":"package floats\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsortStable(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"slice with duplicates\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0, 1.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{1, 3, 2, 0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]int, len(tt.args.dst))\n\t\t\tcopy(got, tt.args.inds)\n\t\t\tArgsortStable(tt.args.dst, got)\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"ArgsortStable() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestArgsortStable_Panic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ArgsortStable() did not panic\")\n\t\t}\n\t}()\n\tArgsortStable([]float64{1.0, 2.0}, []int{1})\n}","74b6c2682cd0091c2b1d38011061c6ec":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7531e22078872885620137b8f10e36fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","75568582d0db1dd3b3d9aaadf9b871d7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tt.Errorf(\"Slice is not sorted: %v\", tt.args.s)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","764003bc0b16664630dab25d0a7361f9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7775eae90044d2b83c4ba237a18e6524":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element is at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element is at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","77b93326ee7c291bfa127d16988aa7d8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","79104be89c9c1a79798d2bc6dce60d34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"InfNegative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(-1),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1), math.Inf(-1), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   10.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{10.0, 10.0, 10.0, 10.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"ShortSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","79ba96a414ec58600a22cf4d6a65c7d9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","79f3aca3977491f8d5f9776daa658477":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{-10.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","7ae0b412168e3741e885695e100e10dc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 1.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (even)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","7ba6c1a9d9cfc826feb1c6cc29a7d1d5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"-Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7be2cfa5773f77e57f0b52a902a37906":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7ce7e0ff5d5a26e4ace3cfba39e5cd75":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7dbdc50dd0c7ca092a6eb33c2b115cb4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Two slices with equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Two slices with different lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple slices with equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple slices with different lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}, {7, 8, 9, 10}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7dee733e37d1cd403fa43e560561b44b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","7e067ec2eec8c0ce92a797561684a201":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7e0e584ee99bb04f534bf4a061567134":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7e338ea1edf5d53d16546d7262adfbf3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is positive\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is negative\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.3,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f25d22513ef6e04b64a192ed3cfc5b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f3a126a386b9ed26bfb0769fd5122a4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f6810e613aee48e70477e69512564f4":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices with equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices with different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices with equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices with different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","7f69ce5884584bab680bef849c1ae2aa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","806936f5d9d784f8306b0ac2a5943872":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","809daefdfb910db4c42b0f1b1277fcbe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","80ffe1ef1dc80434c8321ba0d2fb1c7c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 10, 10, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, 0, 0, 0, math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","8164f904edbace0e687a6eb1a01a3af5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","820e22f4df79d99e681e83421197f3ad":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8237b765f07159af3926d27949397523":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","82cfd02b37e335e4d6d30fe85596f5fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8316756719bd266dc16a02ec38ac71fe":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","833b21a0075c577fde94c189898f66a9":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant argsort\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.a.Swap(tt.args.i, tt.args.j); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Swap() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","84cba209de73be9fc8a65c3115cd478d":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 5 elements, but only 3 exist\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find 0 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with non-nil inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{10, 11},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","84cf1db0881ba9374d11a631125e887c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","84fc49945a232770c24f21a053cee5a1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is 1\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 2\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 3\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 4\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n is 5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf and u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8660c16f640958be268b424125fc3fec":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","876a136b2371b18a843f206bffeb3c2a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","88a0193ded84b9e893d23ff426b1843c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","8900aa68771056c6d140df5d1c575cfa":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Simple case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   -10,\n\t\t\t\tu:   -5,\n\t\t\t},\n\t\t\twant: []float64{-10, -8.75, -7.5, -6.25, -5},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8957cbfb628c000e6a23a0af86dc0e6d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts  []float64\n\t\tt  []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{},\n\t\t\t\tt:  []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts:  []float64{1, 2, 3},\n\t\t\t\tt:  []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","8a268a807febdd1589044723d42783f7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8d7bf8dcb492c4994dab8bf626b97ed0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","8db84bf8b529bb0fc69aa47c2d3ac7c6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","8f9e9416d8c0aaecb379aacadcf67c50":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 15,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: -5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9012a9920bb033f073d1054b802c5912":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 1\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements not enough\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{0},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 1\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","90eda1a8282de7144480b0cef156e607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative values\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values at the beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values at the end\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, math.NaN()}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN values\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9303356005fcdaa7752836a212c96a6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L norm with negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1, -2, -3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","930bfa10b6dc4b7a361ff5e9c117915b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{100.0, 200.0, 300.0},\n\t\t\t},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","93bb65f0c24933e8c6e5822ca34a87d6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tReverse(tt.args.s)\n\t\t\tif !Equal(tt.args.s, tt.want) {\n\t\t\t\tt.Errorf(\"Reverse() = %v, want %v\", tt.args.s, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","95db695f7002f97cfcc763d5f131bde2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: 0, u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: 0, u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: 0, u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: 0, v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: 0, v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: 0, v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: 0, v: -math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=0, v=0\",\n\t\t\targs: args{n: 2, l: 0, u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=0, v=0\",\n\t\t\targs: args{n: 3, l: 0, u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=0, v=0\",\n\t\t\targs: args{n: 4, l: 0, u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=0, v=0\",\n\t\t\targs: args{n: 5, l: 0, u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=1, v=1\",\n\t\t\targs: args{n: 2, l: 1, u: 1, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=1, v=1\",\n\t\t\targs: args{n: 3, l: 1, u: 1, v: 1},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=1, v=1\",\n\t\t\targs: args{n: 4, l: 1, u: 1, v: 1},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=1, v=1\",\n\t\t\targs: args{n: 5, l: 1, u: 1, v: 1},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=1, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=1, v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=1, v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=1, v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","971cdb9966ab10f3b6a66f22cf666530":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttype args struct {\n\t\ts1  []float64\n\t\ts2  []float64\n\t\ttol float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.000001, 2.000002, 3.000003},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-5,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 4.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, math.NaN(), 3.0},\n\t\t\t\ts2:  []float64{1.0, math.NaN(), 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualApprox(tt.args.s1, tt.args.s2, tt.args.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t\tfmt.Printf(\"s1: %v\\n\", tt.args.s1)\n\t\t\t\tfmt.Printf(\"s2: %v\\n\", tt.args.s2)\n\t\t\t}\n\t\t})\n\t}\n}","97f6a508a005bcc949f1573f054387f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","98455f52f62b2e50bb908d3d0ed0a1ec":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9968eecfdf30082706212c97588e7293":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0}},\n\t\t\twant: 3.4076059679126216,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0}},\n\t\t\twant: -0.04978706836786394,\n\t\t},\n\t\t{\n\t\t\tname: \"large positive elements\",\n\t\t\targs: args{s: []float64{100.0, 200.0, 300.0}},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large negative elements\",\n\t\t\targs: args{s: []float64{-100.0, -200.0, -300.0}},\n\t\t\twant: -100.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{s: []float64{math.Inf(1), math.Inf(1), math.Inf(1)}},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinities\",\n\t\t\targs: args{s: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)}},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","99d6db2036d4ac3edc0116983f0e560d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Arbitrary L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(math.Pow(3, 3)+math.Pow(3, 3)+math.Pow(3, 3), 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","9a496ba17ec527d8f006609f6f843ff6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDiv(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tDiv(dst, tt.args.s)\n\t\t\tif !Same(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Div() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9a6f496faafe107e1f1f8261c46d7bf1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9a98ff29fee4e9f72e766486242fbc11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","9ab1d4dcd4e6e4dd07be351879e21a61":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9b77ccabddafb9d8dc5b4b9224996375":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9c55932632ea7107edec31327f638aa7":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"within bounds\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 4,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds - below\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"out of bounds - above\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 5.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5, 4, 3, 2, 1},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9cb0d360d85ad376bf2194447eafd178":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestHasNaN(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"no NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"one NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple NaNs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 2, math.NaN(), 4},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := HasNaN(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"HasNaN() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9d291a0a7219e71f1248386c72c4ebdd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9d4ab18a2d3be262fae27fe7439bf295":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find fewer than k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 4\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 3},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 3, 2, 3},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","9e6b0f9dd9f49f75a5ba370e3a417163":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","a016dbc2f0d6caf11e2cb0a3b863ab48":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a27f6a53f7ef837c6a2016083242e078":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","a2bf07ba250a0365f9ac0b0f63d41c94":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a3fe2ed40acd3b91aacc802c7c7b7333":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements, closest to middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a41f57f74af72aeefcd635aa831db8f0":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a47dd1cdc3dc83bbdb439193cd64f607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (reversed)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (opposite signs)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (equal)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf (negative)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a497dd8b46bc2c813c600319f2b295de":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a4b60974e46bfdf6e006c7d82aaa379c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a4d1d307540cd4a4d2ac0b2fb9d31721":"package floats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !float64Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc float64Equal(a, b float64) bool {\n\tconst tolerance = 1e-6\n\treturn math.Abs(a-b) \u003c tolerance\n}","a521218401b9b8dba09f0819080b73d1":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","a54d54664865f2c31b2989b19aa1f707":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with positive bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower and upper bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf lower and upper bounds (even length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","a5e41a7195939f58c03fbd26820a8ba7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0, // This should panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) panicked: %v\", tt.args.s, tt.args.v, r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx(%v, %v) = %v, want %v\", tt.args.s, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a69b30c54f2b14f26c3f18c8767573b0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","a7d15f2cc559aa317134a3b5cf5abf3b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","a9d4441a857e403200ecd0cceab9906d":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","aaf32cd17c4604ddafa4458bb47ea3c4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"BasicSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NegativeSpan\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithNaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithBothInf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"SpanWithBothInfUnequal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","ab7dc606c0b084ab5d94a2ed91fc6c4b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDivTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := DivTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"DivTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","abb812288b8de738509d66c3ec95412e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","adc5acf237e9d9e0b0eaa3cab7609c7a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSwap(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant argsort\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ta := tt.a\n\t\t\ta.Swap(tt.args.i, tt.args.j)\n\t\t\tif !reflect.DeepEqual(a, tt.want) {\n\t\t\t\tt.Errorf(\"Swap() = %v, want %v\", a, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","af54b607219a486ffb62bfa2478b3568":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","af91ec866fc2f872635e8cfdd90e66fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","afb6691cc094d2b363d8525e14a19ac8":"","afc5e1b592f391571a48959e2f9e490f":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCount(t *testing.T) {\n\ttype args struct {\n\t\tf func(float64) bool\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all elements satisfy condition\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 0 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"some elements satisfy condition\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 1 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"no elements satisfy condition\",\n\t\t\targs: args{\n\t\t\t\tf: func(x float64) bool { return x \u003e 3 },\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Count(tt.args.f, tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Count() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b023a706762e4bc46743e63893e9d4ca":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b057253b10925d31efe70b9b96fdeb78":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003e= 2 \u0026\u0026 sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tWithin(tt.args.s, tt.args.v)\n\t\t\t}\n\t\t})\n\t}\n}","b0f9a3504d61dd97d7d30c129c71d603":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b1237c007a154e7551e96e4abef395ac":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b171a68a65a0482c47261417a55b4971":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"simple case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (3)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf (4)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf (2)\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b19603c719cd669e4b4e7417b1673a44":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within(%v, %v) should have panicked\", tt.args.s, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within(%v, %v) should have panicked\", tt.args.s, tt.args.v)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within(%v, %v) = %v, want %v\", tt.args.s, tt.args.v, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b1c211d15e5b97db52c1164cf02ab259":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is positive\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is negative\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, u \u003e l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b213bf54d996e0039fda47719746bfab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"alternating signs\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b24730c325c23f8e9cf5a440666a54cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","b247c18384f0d8daf42cbf9e1815e8cd":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b274b8c757536346f03da55ed0a60c98":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(-1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(-1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = 0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 1, v = 0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 1, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 1, v = 1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 1, v: 1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 1, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 1, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = math.NaN(), v = 0\",\n\t\t\targs: args{n: 2, l: 1, u: math.NaN(), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = math.NaN(), v = 1\",\n\t\t\targs: args{n: 2, l: 1, u: math.NaN(), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 1, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = 0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = 1\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b2b41c0984a6fc130569c29ce9ac8aed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero Length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 0),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Length One\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b39b4e92d68ff04931e1f9c49dce0d52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b40f3129f28d9f1eeaeb9805d894b2d5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Should panic, but we're testing the panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Expected panic\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b453eeefaf291a83ffcb9e4516aac460":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b4b092207079221ea52e0eecea53fb6f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1.0/3.0),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b517facd54cabc2f4032e18bd4d107cd":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Same(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b62580acc0fe992fad3b01981ef69e94":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b62c0496f8758e4bda8819180b790391":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Arbitrary L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Should panic, but we're testing for the panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Panic expected for unequal length slices\n\t\t\t\t\tif tt.name == \"Unequal length slices\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b7f2edbdc613f82d19b5b99c215ff5f3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf lower bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf upper bound\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf both bounds equal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b89f9f1089868798b9e02bcd5e68794b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","b8a05ba3a712e311a1d2e9009147f26b":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"within bounds\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"at lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"at upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 4,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"below lower bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"above upper bound\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: 5.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5, 4, 3, 2, 1},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b90b25d30caac34e602553815fe2c041":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"zero and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.0, -1.0, -2.0, -3.0, -4.0},\n\t\t\t},\n\t\t\twant: -10.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ba6c5492461668b1361d8b51e520bf52":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 10),\n\t\t\t\tl:   0,\n\t\t\t\tu:   100,\n\t\t\t},\n\t\t\twant: []float64{0, 11.11111111111111, 22.22222222222222, 33.33333333333333, 44.44444444444444, 55.55555555555556, 66.66666666666666, 77.77777777777777, 88.88888888888889, 100},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf2\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf3\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(-1), math.Inf(1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf4\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(-1), math.Inf(1), 0, math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bd09c4b3139e4799017cb559fa235589":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","bd0baf941d695935d5dc6dc476aff106":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"general case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bdbac0eb9fce9bd1874ee7d0e7ca5d5a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaled(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst:   []float64{1.0, 2.0, 3.0},\n\t\t\t\talpha: 2.0,\n\t\t\t\ts:     []float64{4.0, 5.0, 6.0},\n\t\t\t},\n\t\t\twant: []float64{9.0, 12.0, 15.0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tAddScaled(dst, tt.args.alpha, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaled() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAddScaledPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"AddScaled() did not panic\")\n\t\t}\n\t}()\n\tAddScaled([]float64{1.0, 2.0}, 2.0, []float64{4.0, 5.0, 6.0})\n}","bf076eed918d7c3223f67e7e25518cf2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, math.NaN(), 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN not treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, math.NaN(), 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","bfda35f3c18a5baeca503393dbab6526":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf different\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","c0ec03dca8cd07a84c9284fb4860376c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v outside bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v equal to upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"u NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u Inf 4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c0edc28b0bb8ad039cd83dc2899be0c1":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c219c9759b2b913ab17a36a30c8a5282":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two slices different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple slices different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c245931e3d9384bd8814b85c1d7c28c5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, nearest to first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, nearest to last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.9,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements, nearest to middle\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c319c9163393d0f1a232cc36990f80f8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf - Even\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","c36fad062905512cad6644b00bea6fb9":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Lower bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Upper bound\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Outside bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 11,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 4\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 5\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds 6\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds 3\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 2\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 3\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 4\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 5\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: 10,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 6\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 7\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 8\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 9\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"Even length 10\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 10,\n\t\t\t\tu: 0,\n\t\t\t\tv: 7.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c424d8a35f7c8b05e45733b34ada50f6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c4347345bb3b757aabbc440dd959adf5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN as maximum\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c44e095c6325fd9ca41dd7c3957a9234":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"One slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Two slices with equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Two slices with different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple slices with equal length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple slices with different length\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c50cc8843b4580e570dbf84f66a3386f":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find k elements not enough\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 2\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c5390b0747a0390f595f5a93fd3be797":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Negative Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Both Inf and Different Values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), 0, math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","c63de35547795507c7e26f34c81f2123":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSub(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tSub(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Sub() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c66f332326724bc488067fc1ae2dee45":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c67238fc1cdc7f32abd6e8a9759afd8f":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Unequal\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(-1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(-1), math.Inf(-1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span(%v, %v, %v) did not panic\", tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span(%v, %v, %v) = %v, want %v\", tt.args.dst, tt.args.l, tt.args.u, got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c68f0eeab1152e158103052b21dc3f6f":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{4, 10, 18},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tMul(tt.args.dst, tt.args.s)\n\t\t\tif !Same(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMulPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Mul() did not panic\")\n\t\t}\n\t}()\n\tMul([]float64{1, 2}, []float64{3, 4, 5})\n}","c6e905e1ad53e35ccd01273d9f1d7878":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, negative\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, positive\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c70bd4226e4382659ab756194d226ddb":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with one element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with two elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 5.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c84004bbf3a69183c622f48e660f5b13":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(125, 1.0/3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","c9072aa3fc2774f4553a579a976d9871":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","c9a488ed3661683813cdc9acf0983fe4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","ca0939efcf7f3a8da4f08dbb68580e05":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSame(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"same slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 3},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"different lengths\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"different values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{1, 2, 4},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200},\n\t\t\t\tt: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN treated as same 2\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200},\n\t\t\t\tt: []float64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 1},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Same(tt.args.s, tt.args.t); got != tt.want {\n\t\t\t\tt.Errorf(\"Same() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ca5c8d4320f117c218de35798e287ba6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, odd n\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, opposite sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v in (l, u)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v in (u, l)\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cad7b02fd7a43024f9e31aaa000ba4d7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cb2f4ecce6f8ce30d05a1cb5dedc4149":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cb50929c3d31ad17a3f460bf88000ad7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"zero and negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{0.0, -1.0, -2.0, -3.0, -4.0},\n\t\t\t},\n\t\t\twant: -10.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cb535218c3f70cf84aad141358af65fc":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"General L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Expect panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// Panic expected for unequal length slices\n\t\t\t\t\tif tt.name == \"Unequal length slices\" {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cba9f4ddaeffe47ca5b276cb857f5a91":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"general L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cbb8d4e698be7f05734f9a6261da1335":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cd1af6b4b2cac1a9911a1fa1e5f63565":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"general case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cd2551357bf5a4761b1d93b27199cd8e":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, -2.0, 3.0, -4.0, 5.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.NaN(), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(1), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, math.Inf(-1), 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cd59b1cd0bb3ec2ddb479fb44184b611":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L-infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1.0/3.0),\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDistancePanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Distance() did not panic\")\n\t\t}\n\t}()\n\tDistance([]float64{1, 2, 3}, []float64{4, 5}, 2)\n}","cdbdf12b54f31cf75f3fe8b5f104b1b6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cec8ccef0f30afa2aa52c89fdd1aaf3a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative L\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: -1,\n\t\t\t},\n\t\t\twant: 0, // Should this panic?\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ced77cd244892a4bc6b7d487dd1b6d4a":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestScaleTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tc   float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := ScaleTo(tt.args.dst, tt.args.c, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"ScaleTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cee9aea2c702fc18ba210f59a68d56ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with two elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 2),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1.0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative step\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   5.0,\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{5.0, 4.0, 3.0, 2.0, 1.0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","cf3d2ac834f186c8f0097e850e7bbbbe":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualFunc(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t\tf  func(float64, float64) bool\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t\tf:  func(a, b float64) bool { return a == b },\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0001, 2.0001, 3.0001},\n\t\t\t\tf:  func(a, b float64) bool { return abs(a-b) \u003c 0.001 },\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualFunc(tt.args.s1, tt.args.s2, tt.args.f); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualFunc() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc abs(x float64) float64 {\n\tif x \u003c 0 {\n\t\treturn -x\n\t}\n\treturn x\n}","cfbb4651815b01c03980fee9bcea668b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","cfc03b5acebd84a7b4d5789bde286391":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find fewer than k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d00820bb1a4bd89672dcb2c82326bc12":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMul(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{2, 3, 4},\n\t\t\t},\n\t\t\twant: []float64{2, 6, 12},\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{2, 3},\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]float64, len(tt.args.dst))\n\t\t\tcopy(dst, tt.args.dst)\n\t\t\tMul(dst, tt.args.s)\n\t\t\tif !Equal(dst, tt.want) {\n\t\t\t\tt.Errorf(\"Mul() = %v, want %v\", dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d03fbbedb07ba59353ee3aa2469554c4":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 5 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 0 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d0618cf3772a1cbdb3f414697491934f":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first k elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{-1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find zero elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(x float64) bool {\n\t\t\t\t\treturn x \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d1ae84045c77da5ac561a7f186238cb5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0.5\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0.5},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d1e51f3ebef2601345a50316d8222b28":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{100.0, 200.0, 300.0},\n\t\t\t},\n\t\t\twant: 300.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d21d94f17836ef34ef6e24fe8f5c1794":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualLengths(t *testing.T) {\n\ttype args struct {\n\t\tslices [][]float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one slice\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two equal slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"two unequal slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple equal slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple unequal slices\",\n\t\t\targs: args{\n\t\t\t\tslices: [][]float64{{1, 2, 3}, {4, 5, 6}, {7, 8}},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualLengths(tt.args.slices...); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualLengths() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d2d4683e15ed6c7820e9cc788de1ae6c":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find all elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 2 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find first 5 elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    5,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find no elements\",\n\t\t\targs: args{\n\t\t\t\tinds: nil,\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 10\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    2,\n\t\t\t},\n\t\t\twant:    []int{0, 1},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices and k \u003c 0\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find with existing indices and k = 0\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, -1, -2, -3},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d3f731fcec5e030b686db890c77b0152":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"value closer to lower index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 2.1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value closer to higher index\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.9,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d472e2d93552a6c0dda8754ae8121fc6":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d54d5f470d5f7010a1f68fb43aacbcd4":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not equal to u and n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not equal to u and n is even and v is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not equal to u and n is even and v is Inf with same sign as l\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf and l is not equal to u and n is even and v is Inf with different sign as l\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf and l is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf and l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf and l is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf and l is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is less than u and v is less than l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is less than u and v is greater than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u and v is greater than l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is greater than u and v is less than u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d54f36e019297f6ad65085cc8a881991":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttype args struct {\n\t\ts1  []float64\n\t\ts2  []float64\n\t\ttol float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.000001, 2.000002, 3.000003},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 1e-5,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 4.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0},\n\t\t\t\ttol: 1e-6,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualApprox(tt.args.s1, tt.args.s2, tt.args.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d7391925b9ae35074c2ad1cdf8cee8b0":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqual(t *testing.T) {\n\ttype args struct {\n\t\ts1 []float64\n\t\ts2 []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Different lengths\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Different values\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2: []float64{1.0, 2.0, 4.0},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty slices\",\n\t\t\targs: args{\n\t\t\t\ts1: []float64{},\n\t\t\t\ts2: []float64{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Equal(tt.args.s1, tt.args.s2); got != tt.want {\n\t\t\t\tt.Errorf(\"Equal() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d799b91a3bd21a0eb9863753a3943661":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\"n=2, l=0, u=1, v=0.5\", args{2, 0, 1, 0.5}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.25\", args{3, 0, 1, 0.25}, 1},\n\t\t{\"n=3, l=0, u=1, v=0.75\", args{3, 0, 1, 0.75}, 2},\n\t\t{\"n=4, l=0, u=1, v=0.25\", args{4, 0, 1, 0.25}, 1},\n\t\t{\"n=4, l=0, u=1, v=0.75\", args{4, 0, 1, 0.75}, 3},\n\t\t{\"n=5, l=0, u=1, v=0.2\", args{5, 0, 1, 0.2}, 1},\n\t\t{\"n=5, l=0, u=1, v=0.8\", args{5, 0, 1, 0.8}, 4},\n\t\t{\"n=5, l=0, u=1, v=0.5\", args{5, 0, 1, 0.5}, 3},\n\t\t{\"n=2, l=1, u=0, v=0.5\", args{2, 1, 0, 0.5}, 1},\n\t\t{\"n=3, l=1, u=0, v=0.25\", args{3, 1, 0, 0.25}, 2},\n\t\t{\"n=3, l=1, u=0, v=0.75\", args{3, 1, 0, 0.75}, 1},\n\t\t{\"n=4, l=1, u=0, v=0.25\", args{4, 1, 0, 0.25}, 3},\n\t\t{\"n=4, l=1, u=0, v=0.75\", args{4, 1, 0, 0.75}, 1},\n\t\t{\"n=5, l=1, u=0, v=0.2\", args{5, 1, 0, 0.2}, 4},\n\t\t{\"n=5, l=1, u=0, v=0.8\", args{5, 1, 0, 0.8}, 1},\n\t\t{\"n=5, l=1, u=0, v=0.5\", args{5, 1, 0, 0.5}, 2},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{2, math.Inf(1), math.Inf(1), math.Inf(-1)}, 1},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)}, args{2, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 1},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{3, math.Inf(1), math.Inf(1), math.Inf(-1)}, 2},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{3, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)}, args{3, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 2},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{4, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{4, math.Inf(1), math.Inf(1), math.Inf(-1)}, 3},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{4, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)}, args{4, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 3},\n\t\t{\"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)}, args{5, math.Inf(1), math.Inf(1), math.Inf(1)}, 0},\n\t\t{\"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(-1)}, args{5, math.Inf(1), math.Inf(1), math.Inf(-1)}, 4},\n\t\t{\"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)}, args{5, math.Inf(-1), math.Inf(-1), math.Inf(-1)}, 0},\n\t\t{\"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)}, args{5, math.Inf(-1), math.Inf(-1), math.Inf(1)}, 4},\n\t\t{\"n=2, l=math.Inf(1), u=0, v=math.Inf(1)}, args{2, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=2, l=math.Inf(1), u=0, v=math.Inf(-1)}, args{2, math.Inf(1), 0, math.Inf(-1)}, 1},\n\t\t{\"n=2, l=0, u=math.Inf(1), v=math.Inf(1)}, args{2, 0, math.Inf(1), math.Inf(1)}, 1},\n\t\t{\"n=2, l=0, u=math.Inf(1), v=math.Inf(-1)}, args{2, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=0, v=math.Inf(1)}, args{3, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=3, l=math.Inf(1), u=0, v=math.Inf(-1)}, args{3, math.Inf(1), 0, math.Inf(-1)}, 2},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=math.Inf(1)}, args{3, 0, math.Inf(1), math.Inf(1)}, 2},\n\t\t{\"n=3, l=0, u=math.Inf(1), v=math.Inf(-1)}, args{3, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=0, v=math.Inf(1)}, args{4, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=4, l=math.Inf(1), u=0, v=math.Inf(-1)}, args{4, math.Inf(1), 0, math.Inf(-1)}, 3},\n\t\t{\"n=4, l=0, u=math.Inf(1), v=math.Inf(1)}, args{4, 0, math.Inf(1), math.Inf(1)}, 3},\n\t\t{\"n=4, l=0, u=math.Inf(1), v=math.Inf(-1)}, args{4, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=5, l=math.Inf(1), u=0, v=math.Inf(1)}, args{5, math.Inf(1), 0, math.Inf(1)}, 0},\n\t\t{\"n=5, l=math.Inf(1), u=0, v=math.Inf(-1)}, args{5, math.Inf(1), 0, math.Inf(-1)}, 4},\n\t\t{\"n=5, l=0, u=math.Inf(1), v=math.Inf(1)}, args{5, 0, math.Inf(1), math.Inf(1)}, 4},\n\t\t{\"n=5, l=0, u=math.Inf(1), v=math.Inf(-1)}, args{5, 0, math.Inf(1), math.Inf(-1)}, 0},\n\t\t{\"n=2, l=math.NaN(), u=0, v=math.NaN()}, args{2, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=2, l=0, u=math.NaN(), v=math.NaN()}, args{2, 0, math.NaN(), math.NaN()}, 1},\n\t\t{\"n=3, l=math.NaN(), u=0, v=math.NaN()}, args{3, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=3, l=0, u=math.NaN(), v=math.NaN()}, args{3, 0, math.NaN(), math.NaN()}, 2},\n\t\t{\"n=4, l=math.NaN(), u=0, v=math.NaN()}, args{4, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=4, l=0, u=math.NaN(), v=math.NaN()}, args{4, 0, math.NaN(), math.NaN()}, 3},\n\t\t{\"n=5, l=math.NaN(), u=0, v=math.NaN()}, args{5, math.NaN(), 0, math.NaN()}, 0},\n\t\t{\"n=5, l=0, u=math.NaN(), v=math.NaN()}, args{5, 0, math.NaN(), math.NaN()}, 4},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d7b6ea6bd6829ec9f86229042aa6cc5b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, n is even, v is positive\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, different sign, n is even, v is negative\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v is equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf, v is not equal to l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v is equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf, v is not equal to u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v is between l and u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d8099fc547bc3e0cba409e34e0be5d49":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf Odd\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","d91536c4291955fa1cb968ab179e0f7a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n%3 == 1\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n%3 == 1, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n%3 != 1\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 10,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 2,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.3,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","d9c055ec104c56718a9f735546ef9f34":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.3,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","db0efa97eac5aa38beace3d862c72995":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dc0c51f114dd31f4e8df118530ca14e5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dc352efe1934cd3627e87fc74681474a":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMaxIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 3.0, 5.0}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN element\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN element at the beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 1.0, 2.0, 3.0, 4.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN element at the end\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, math.NaN()}},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN elements\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MaxIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MaxIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","dcd2c202fca790496c6f66029cca00a0":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (odd length)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","dcfe3ecfae6fa288d7bcd0d33508722c":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","de0f41c026a90025ceeee7a8b47d9b51":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","df7fb887ea18e4ff6789fa276836ed07":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf (even)\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 4),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","e0511d81fad1093714fcf21a2a02a933":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0},\n\t\t\t},\n\t\t\twant: 2.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 3.0, 4.0},\n\t\t\t},\n\t\t\twant: 24.0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e0de08f91bb8621093aea8a6f6895828":"package floats\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"Sorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{0, 1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Unsorted slice\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0, 2.0, 2.0, 3.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{0, 1, 2, 3},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]int, len(tt.args.dst))\n\t\t\tcopy(got, tt.args.inds)\n\t\t\tArgsort(tt.args.dst, got)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e23f0499b54dde9b7d452678e119f319":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e25ace83e9153cf53faa9bc86e8579de":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, same sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, opposite sign\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(-1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, u is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, l is not Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case 2\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.75,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e36e2d6500656f6ab7d05eebfb5207f7":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 3.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element is first\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 1.1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"nearest element is last\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: 4.9,\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nearest elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 3.0, 5.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is positive infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"v is negative infinity\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdx(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e3d4b6f7a4af707bc819ae7f7d99fff2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNorm(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(14),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 6,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"L3 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(14, 1/3),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Norm(tt.args.s, tt.args.L); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"Norm() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e3debfe533834eb7a925993f5da8abed":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []int\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{},\n\t\t\t\tinds: []int{},\n\t\t\t},\n\t\t\twant: []int{},\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{1.0},\n\t\t\t\tinds: []int{0},\n\t\t\t},\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{3.0, 1.0, 2.0, 1.0},\n\t\t\t\tinds: []int{0, 1, 2, 3},\n\t\t\t},\n\t\t\twant: []int{1, 3, 2, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\tdst:  []float64{-3.0, -1.0, -2.0},\n\t\t\t\tinds: []int{0, 1, 2},\n\t\t\t},\n\t\t\twant: []int{1, 2, 0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]int, len(tt.args.dst))\n\t\t\tcopy(got, tt.args.inds)\n\t\t\tArgsort(tt.args.dst, got)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e46741c04a2ae3e8fb5d63a0dfcf1389":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e4b1a35bdcaef67e0246950a70f8a28b":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e551b450b466d5af6639a408ad6d1cd2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.75, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e56decab21bda765dea786add27026fb":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=0\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: 1},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(-1), v=-1\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(-1), v: -1},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: 0},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=0\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: 0},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e5e9fa216268e609baeb416605b77cd2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7908f6ba9246e52947f0c450542ee07":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2, 3, 4},\n\t\t\t},\n\t\t\twant: 24,\n\t\t},\n\t\t{\n\t\t\tname: \"zero element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2, 0, 4},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e7de2bec59d8d297fc181da6f481f74b":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddScaledTo(t *testing.T) {\n\ttype args struct {\n\t\tdst   []float64\n\t\ty     []float64\n\t\talpha float64\n\t\ts     []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddScaledTo(tt.args.dst, tt.args.y, tt.args.alpha, tt.args.s); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddScaledTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e8244b76a457320d0ab3b95b58a6c2da":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with positive values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with negative values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with zero values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf values\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0.0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 1.0, 5.0)\n}","e846085b6c4d3e90047c324e42424143":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value equal to third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value greater than last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 4.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"sorted slice, value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.s) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif !sort.Float64sAreSorted(tt.args.s) {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Within() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","e84c735c076f2f8bd8d768404cfa6161":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is odd\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is positive\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are Inf, l != u, n is even, v is negative\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: -1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v == l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf, v != l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf, v != u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(-1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf, l \u003e u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: -0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"general case\",\n\t\t\targs: args{\n\t\t\t\tn: 5,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.25,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eaffafaa2e0ca1f7561e224cb9d3208c":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestProd(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2, 3, 4},\n\t\t\t},\n\t\t\twant: 24,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Prod(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"Prod() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eb2979221b37e0bc94da0f2b22cd5473":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestDistance(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tt []float64\n\t\tL float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tt: []float64{},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"L2 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: math.Sqrt(27),\n\t\t},\n\t\t{\n\t\t\tname: \"L1 norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 1,\n\t\t\t},\n\t\t\twant: 9,\n\t\t},\n\t\t{\n\t\t\tname: \"L infinity norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: math.Inf(1),\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"Arbitrary L norm\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5, 6},\n\t\t\t\tL: 3,\n\t\t\t},\n\t\t\twant: math.Pow(126, 1/3),\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal length slices\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1, 2, 3},\n\t\t\t\tt: []float64{4, 5},\n\t\t\t\tL: 2,\n\t\t\t},\n\t\t\twant: 0, // Should panic\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\tt.Errorf(\"Distance() panicked: %v\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif got := Distance(tt.args.s, tt.args.t, tt.args.L); got != tt.want {\n\t\t\t\tt.Errorf(\"Distance() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ed4c3249384c384098afcc70d1b2cbca":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSumCompensated(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"Large numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e10, 3e10, 4e10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Small numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e-10, 2e-10, 3e-10, 4e-10, 5e-10},\n\t\t\t},\n\t\t\twant: 1.5e-9,\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1e10, 2e-10, 3e10, 4e-10, 5e10},\n\t\t\t},\n\t\t\twant: 1.5e11,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative numbers\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: -15.0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.NaN(),\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"Negative Inf\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.Inf(-1), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := SumCompensated(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"SumCompensated() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","edd6222fcf0881ddecd2e6230084c628":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Span with two elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   2,\n\t\t\t},\n\t\t\twant: []float64{1, 2},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with multiple elements\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{1, 4, 7, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{1, math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   math.Inf(0),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), 0, math.Inf(0), math.Inf(0)},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(0),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(0), math.Inf(0), math.Inf(0), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Span with Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   1,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{1, math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan([]float64{0}, 1, 2)\n}","ede839d8aa21a2a990793caf464a7fa3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n=2, l=0, u=1, v=0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.25\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=1, v=0.75\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.75},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=1, u=0, v=0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.25\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.25},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=1, u=0, v=0.75\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(1), u=math.Inf(1), v=-math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.Inf(-1), u=math.Inf(-1), v=math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=2, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=3, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=4, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=0, v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=0, u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n=5, l=math.NaN(), u=math.NaN(), v=math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: math.NaN(), v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ee11c775a2b30640658618f6276f10f9":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEqualApprox(t *testing.T) {\n\ttype args struct {\n\t\ts1  []float64\n\t\ts2  []float64\n\t\ttol float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"Equal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 0.001,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Equal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.001, 2.002, 3.003},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 0.005,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0},\n\t\t\t\ttol: 0.001,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Unequal slices with tolerance\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.1},\n\t\t\t\ttol: 0.001,\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN values\",\n\t\t\targs: args{\n\t\t\t\ts1:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ts2:  []float64{1.0, 2.0, 3.0},\n\t\t\t\ttol: 0.001,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := EqualApprox(tt.args.s1, tt.args.s2, tt.args.tol); got != tt.want {\n\t\t\t\tt.Errorf(\"EqualApprox() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","eee73366a6b12e52db5a164b7574ac06":"package floats\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\ttype args struct {\n\t\tinds []int\n\t\tf    func(float64) bool\n\t\ts    []float64\n\t\tk    int\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    []int\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Find_k_0\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    0,\n\t\t\t},\n\t\t\twant:    []int{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_negative\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    -1,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_positive_enough\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_positive_not_enough\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    6,\n\t\t\t},\n\t\t\twant:    []int{0, 1, 2, 3, 4},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Find_k_positive_with_existing_inds\",\n\t\t\targs: args{\n\t\t\t\tinds: []int{1, 2},\n\t\t\t\tf: func(f float64) bool {\n\t\t\t\t\treturn f \u003e 0\n\t\t\t\t},\n\t\t\t\ts:    []float64{1, 2, 3, 4, 5},\n\t\t\t\tk:    3,\n\t\t\t},\n\t\t\twant:    []int{1, 2, 0},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := Find(tt.args.inds, tt.args.f, tt.args.s, tt.args.k)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Find() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Find() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","ef173baae917f51659bbeea6f5a88278":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{2.0, 1.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN value\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f000ba2650b7d541450f4670b4290607":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Both Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Even Length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 6),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   6.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0, 6.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Odd Length\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 7),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   7.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f0b30df2d6d93e47dff67646e0ce6c10":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n \u003c 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN, u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf, v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u, v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u, v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l = u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f15c3362d300b641bf4f7188dbe271b2":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{0, 2.5, 5, 7.5, 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -10,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-10, -7.5, -5, -2.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"Large bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1000,\n\t\t\t\tu:   2000,\n\t\t\t},\n\t\t\twant: []float64{1000, 1250, 1500, 1750, 2000},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{0, math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l and Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf l\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf u\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0,\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{0, math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-6) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSpanPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t}\n\t}()\n\tSpan(make([]float64, 1), 0, 10)\n}","f2c99ede0b70b8c7222aa22af27455ed":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with negative values\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0, -4.0, -5.0},\n\t\t\t},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with NaN at the beginning\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.NaN(), 2.0, 1.0, 4.0, 5.0},\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with NaN at the end\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0, 4.0, math.NaN()},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f2d0a4e0607696b81d0f7831b78f1a69":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMulTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MulTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"MulTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f2f791bd017a2c0391ee414f8e34deb6":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLess(t *testing.T) {\n\ttype args struct {\n\t\ti int\n\t\tj int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\ta    argsort\n\t\targs args\n\t\twant bool\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.a.Less(tt.args.i, tt.args.j); got != tt.want {\n\t\t\t\tt.Errorf(\"Less() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f4050e94ad42ab51bda296b51cea2843":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Empty slice\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Slice with length 1\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Basic case\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   0,\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{0, 0.25, 0.5, 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   -1,\n\t\t\t\tu:   0,\n\t\t\t},\n\t\t\twant: []float64{-1, -0.75, -0.5, 0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   1,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), 1},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed Inf and NaN bounds\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{0, 0, 0, 0},\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Span(tt.args.dst, tt.args.l, tt.args.u); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f51a1aaeae1dd7bf0c8e26f89b8b78ab":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 4.0, 8.0, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -1.0,\n\t\t\t\tu:   -10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   0.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 0.0, 0.0, 0.0, 0.0},\n\t\t},\n\t\t{\n\t\t\tname: \"SmallRange\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   1.1,\n\t\t\t},\n\t\t\twant: []float64{1.0, 1.0232929922765244, 1.0469103329558092, 1.070867506839298, 1.1},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSpan(tt.args.dst, tt.args.l, tt.args.u); !EqualApprox(got, tt.want, 1e-10) {\n\t\t\t\tt.Errorf(\"LogSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f5730e5037fa3baa3a7797e3cf5e3a11":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMinIdx(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{s: []float64{}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{s: []float64{1.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements with duplicates\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 1.0, 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative numbers\",\n\t\t\targs: args{s: []float64{-1.0, -2.0, -3.0, -4.0, -5.0}},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{s: []float64{1.0, 2.0, math.NaN(), 4.0, 5.0}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at beginning\",\n\t\t\targs: args{s: []float64{math.NaN(), 2.0, 3.0, 4.0, 5.0}},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"NaN at end\",\n\t\t\targs: args{s: []float64{1.0, 2.0, 3.0, 4.0, math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"all NaN\",\n\t\t\targs: args{s: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), math.NaN()}},\n\t\t\twant: 0,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := MinIdx(tt.args.s); got != tt.want {\n\t\t\t\tt.Errorf(\"MinIdx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f5bab763ada8fe7c36081efa09724629":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Equal length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{1, 2, 3},\n\t\t\t\ts:   []float64{4, 5, 6},\n\t\t\t},\n\t\t\twant: []float64{5, 7, 9},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero length slices\",\n\t\t\targs: args{\n\t\t\t\tdst: []float64{},\n\t\t\t\ts:   []float64{},\n\t\t\t},\n\t\t\twant: []float64{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tAdd(tt.args.dst, tt.args.s)\n\t\t\tif !Equal(tt.args.dst, tt.want) {\n\t\t\t\tt.Errorf(\"Add() = %v, want %v\", tt.args.dst, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAddPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Add() did not panic\")\n\t\t}\n\t}()\n\tAdd([]float64{1, 2}, []float64{3, 4, 5})\n}","f609d4620b7ad1d4e4f0ba7a78ef6ae8":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = 1, v = 0.5\",\n\t\t\targs: args{n: 2, l: 0, u: 1, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 3, l: 0, u: 1, v: 0.75},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.25\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.25},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = 1, v = 0.75\",\n\t\t\targs: args{n: 4, l: 0, u: 1, v: 0.75},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.2\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.2},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = 1, v = 0.8\",\n\t\t\targs: args{n: 5, l: 0, u: 1, v: 0.8},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 1, u = 0, v = 0.5\",\n\t\t\targs: args{n: 2, l: 1, u: 0, v: 0.5},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.25},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 3, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.25\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.25},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 1, u = 0, v = 0.75\",\n\t\t\targs: args{n: 4, l: 1, u: 0, v: 0.75},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.2\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.2},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 1, u = 0, v = 0.8\",\n\t\t\targs: args{n: 5, l: 1, u: 0, v: 0.8},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(1), u = math.Inf(1), v = -math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(1), u: math.Inf(1), v: -math.Inf(1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 2, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 3, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 4, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(-1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(-1)},\n\t\t\twant: 4,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.Inf(-1), u = math.Inf(-1), v = math.Inf(1)\",\n\t\t\targs: args{n: 5, l: math.Inf(-1), u: math.Inf(-1), v: math.Inf(1)},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = math.NaN(), u = 0, v = math.NaN()\",\n\t\t\targs: args{n: 2, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 2, l = 0, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 2, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = math.NaN(), u = 0, v = math.NaN()\",\n\t\t\targs: args{n: 3, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 3, l = 0, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 3, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = math.NaN(), u = 0, v = math.NaN()\",\n\t\t\targs: args{n: 4, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 4, l = 0, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 4, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = math.NaN(), u = 0, v = math.NaN()\",\n\t\t\targs: args{n: 5, l: math.NaN(), u: 0, v: math.NaN()},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"n = 5, l = 0, u = math.NaN(), v = math.NaN()\",\n\t\t\targs: args{n: 5, l: 0, u: math.NaN(), v: math.NaN()},\n\t\t\twant: 4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f6c14f0baeb9d56eb54d29effcc34ad0":"package floats\n\nimport (\n\t\"math\"\n\t\"sort\"\n\t\"testing\"\n)\n\nfunc TestWithin(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"single element slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"unsorted slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{3.0, 1.0, 2.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"value less than first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 0.0,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"value greater than or equal to last element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 3.0,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to first element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.0,\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t\t{\n\t\t\tname: \"value between first and second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 1.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value between second and third element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"value equal to second element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: 2.0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"value is NaN\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: -2,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Within(tt.args.s, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"Within() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f8164ef3c4d50b252e6a8135c40a0ab5":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestLogSumExp(t *testing.T) {\n\ttype args struct {\n\t\ts []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant float64\n\t}{\n\t\t{\n\t\t\tname: \"empty slice\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"single element\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0},\n\t\t\t},\n\t\t\twant: 1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1.0, 2.0, 3.0},\n\t\t\t},\n\t\t\twant: 3.0,\n\t\t},\n\t\t{\n\t\t\tname: \"negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1.0, -2.0, -3.0},\n\t\t\t},\n\t\t\twant: -1.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large positive elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{1000.0, 1001.0, 1002.0},\n\t\t\t},\n\t\t\twant: 1002.0,\n\t\t},\n\t\t{\n\t\t\tname: \"large negative elements\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{-1000.0, -1001.0, -1002.0},\n\t\t\t},\n\t\t\twant: -1000.0,\n\t\t},\n\t\t{\n\t\t\tname: \"infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(1), math.Inf(1), math.Inf(1)},\n\t\t\t},\n\t\t\twant: math.Inf(1),\n\t\t},\n\t\t{\n\t\t\tname: \"negative infinities\",\n\t\t\targs: args{\n\t\t\t\ts: []float64{math.Inf(-1), math.Inf(-1), math.Inf(-1)},\n\t\t\t},\n\t\t\twant: math.Inf(-1),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := LogSumExp(tt.args.s); !math.IsNaN(got) \u0026\u0026 !math.IsInf(got, 0) \u0026\u0026 got != tt.want {\n\t\t\t\tt.Errorf(\"LogSumExp() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","f8a59234d5fba12b9c07d35cf59640d8":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArgsort(t *testing.T) {\n\ttype args struct {\n\t\tdst  []float64\n\t\tinds []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t\twant1 []int\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := make([]float64, len(tt.args.dst))\n\t\t\tcopy(got, tt.args.dst)\n\t\t\tgot1 := make([]int, len(tt.args.inds))\n\t\t\tcopy(got1, tt.args.inds)\n\t\t\tArgsort(got, got1)\n\t\t\tif !Same(got, tt.want) {\n\t\t\t\tt.Errorf(\"Argsort() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t\tif !Same(got1, tt.want1) {\n\t\t\t\tt.Errorf(\"Argsort() got1 = %v, want %v\", got1, tt.want1)\n\t\t\t}\n\t\t})\n\t}\n}","fbcec84a399d16e857a04dd4101ba926":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSpan(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\tl   float64\n\t\tu   float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t{\n\t\t\tname: \"Basic\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t\twant: []float64{1.0, 2.0, 3.0, 4.0, 5.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Negative\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   -5.0,\n\t\t\t\tu:   -1.0,\n\t\t\t},\n\t\t\twant: []float64{-5.0, -4.0, -3.0, -2.0, -1.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   0.0,\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{0.0, 2.5, 5.0, 7.5, 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.NaN(),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.NaN(), math.NaN(), math.NaN(), math.NaN(), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   10.0,\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), math.Inf(1), math.Inf(1), 10.0},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and NaN\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.NaN(),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.NaN(), math.NaN(), math.NaN(), math.NaN()},\n\t\t},\n\t\t{\n\t\t\tname: \"Inf and Inf\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 5),\n\t\t\t\tl:   math.Inf(1),\n\t\t\t\tu:   math.Inf(1),\n\t\t\t},\n\t\t\twant: []float64{math.Inf(1), math.Inf(1), 0, math.Inf(1), math.Inf(1)},\n\t\t},\n\t\t{\n\t\t\tname: \"Short Span\",\n\t\t\targs: args{\n\t\t\t\tdst: make([]float64, 1),\n\t\t\t\tl:   1.0,\n\t\t\t\tu:   5.0,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif len(tt.args.dst) \u003c 2 {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Span() did not panic\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tSpan(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := Span(tt.args.dst, tt.args.l, tt.args.u)\n\t\t\tif !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"Span() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","fdddd85e91abddc251b9da767bee01fa":"package floats\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddTo(t *testing.T) {\n\ttype args struct {\n\t\tdst []float64\n\t\ts   []float64\n\t\tt   []float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []float64\n\t}{\n\t\t// TODO: Add test cases.\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := AddTo(tt.args.dst, tt.args.s, tt.args.t); !Equal(got, tt.want) {\n\t\t\t\tt.Errorf(\"AddTo() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","fe478ab38e642e30157bc134e5ad80b3":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(0),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.Inf(0),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(0),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 10,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 5,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","fffbfad0db7ae393fa0704ea9b316d33":"package floats\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestNearestIdxForSpan(t *testing.T) {\n\ttype args struct {\n\t\tn int\n\t\tl float64\n\t\tu float64\n\t\tv float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"n is less than 2\",\n\t\t\targs: args{\n\t\t\t\tn: 1,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.NaN(),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l is NaN and u is not NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: math.NaN(),\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"u is NaN\",\n\t\t\targs: args{\n\t\t\t\tn: 2,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.NaN(),\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: -1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and n is even\",\n\t\t\targs: args{\n\t\t\t\tn: 4,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l and u are both Inf and v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: math.Inf(1),\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"u is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: math.Inf(1),\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is -Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(-1),\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"v is Inf\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: math.Inf(1),\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003c= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003c u and v \u003e= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003e= l\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 1,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"l \u003e u and v \u003c= u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 1,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"l == u\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 0,\n\t\t\t\tv: 0,\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"normal case\",\n\t\t\targs: args{\n\t\t\t\tn: 3,\n\t\t\t\tl: 0,\n\t\t\t\tu: 1,\n\t\t\t\tv: 0.5,\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := NearestIdxForSpan(tt.args.n, tt.args.l, tt.args.u, tt.args.v); got != tt.want {\n\t\t\t\tt.Errorf(\"NearestIdxForSpan() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"}