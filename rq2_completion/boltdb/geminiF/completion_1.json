{
    "0bb90f109578954800f05f829db0f630": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestClose(t *testing.T) {\n\t// Create a temporary file for the database\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create a bucket\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Close the database\n\terr = db.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attempt to use the database after closing\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test2\"))\n\t\treturn err\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error after closing database\")\n\t}\n\n\t// Verify that the error message indicates the database is closed\n\tif !fmt.Sprintf(\"%v\", err).Contains(\"database is closed\") {\n\t\tt.Fatalf(\"Expected error message to contain 'database is closed', got: %v\", err)\n\t}\n}",
    "147fa46f4dc737aefded6a669c8a8764": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestBegin(t *testing.T) {\n\t// Create a temporary database file\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test Begin with writable flag\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\n\t// Check that the transaction is writable\n\tif !tx.Writable() {\n\t\tt.Errorf(\"Expected writable transaction, got %v\", tx.Writable())\n\t}\n\n\t// Test Begin without writable flag\n\ttx, err = db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\n\t// Check that the transaction is read-only\n\tif tx.Writable() {\n\t\tt.Errorf(\"Expected read-only transaction, got %v\", tx.Writable())\n\t}\n}\n\nfunc TestBeginConcurrency(t *testing.T) {\n\t// Create a temporary database file\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Start a write transaction\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Start a read-only transaction in a separate goroutine\n\tgo func() {\n\t\ttx, err := db.Begin(false)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error starting read-only transaction: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer tx.Rollback()\n\t\tfmt.Println(\"Read-only transaction started\")\n\t}()\n\n\t// Wait for the read-only transaction to start\n\t// ... (add a synchronization mechanism here if needed)\n\n\t// Attempt to start another write transaction\n\t// This should block until the first write transaction is finished\n\ttx2, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Errorf(\"Error starting second write transaction: %v\", err)\n\t\treturn\n\t}\n\tdefer tx2.Rollback()\n\n\t// Complete the first write transaction\n\ttx.Commit()\n\n\t// The second write transaction should now be able to complete\n\ttx2.Commit()\n}",
    "1608bd792ccda8b2fbb450c291b431e2": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for testing.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a new database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening an existing database.\n\tdb, err = bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with read-only mode.\n\tdb, err = bolt.Open(tempFile.Name(), 0600, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with custom options.\n\tdb, err = bolt.Open(tempFile.Name(), 0600, \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlags(0),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with invalid path.\n\t_, err = bolt.Open(\"\", 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening database with invalid path\")\n\t}\n\n\t// Test opening a database with invalid mode.\n\t_, err = bolt.Open(tempFile.Name(), 0, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening database with invalid mode\")\n\t}\n}\n\nfunc TestOpenWithInvalidPath(t *testing.T) {\n\t_, err := bolt.Open(\"/path/that/does/not/exist\", 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening database with invalid path\")\n\t}\n\tif !os.IsNotExist(err) {\n\t\tt.Fatalf(\"Expected error to be of type os.IsNotExist, got %T\", err)\n\t}\n}\n\nfunc TestOpenWithInvalidMode(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t_, err = bolt.Open(tempFile.Name(), 0, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening database with invalid mode\")\n\t}\n\tif !os.IsPermission(err) {\n\t\tt.Fatalf(\"Expected error to be of type os.IsPermission, got %T\", err)\n\t}\n}\n\nfunc TestOpenWithReadOnly(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0600, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is read-only.\n\tif !db.IsReadOnly() {\n\t\tt.Fatal(\"Expected database to be read-only\")\n\t}\n\n\t// Try to write to the database.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error writing to read-only database\")\n\t}\n}\n\nfunc TestOpenWithCustomOptions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0600, \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlags(0),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the custom options are set.\n\tif db.NoGrowSync != true {\n\t\tt.Fatal(\"Expected NoGrowSync to be true\")\n\t}\n\tif db.MmapFlags != bolt.MmapFlags(0) {\n\t\tt.Fatal(\"Expected MmapFlags to be 0\")\n\t}\n}\n\nfunc TestOpenWithExistingDatabase(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a new database and add some data.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Close the database and open it again.\n\tdb.Close()\n\tdb, err = bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the data is still present.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestOpenWithInvalidDatabase(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Write invalid data to the database file.\n\t_, err = tempFile.Write([]byte(\"invalid data\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Try to open the database.\n\t_, err = bolt.Open(tempFile.Name(), 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening database with invalid data\")\n\t}\n}",
    "1699a8969a43819110b9344efa077e88": "package bolt_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define the batch function.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Create a wait group for the goroutines.\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\n\t// Start 10 goroutines that call Batch concurrently.\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := db.Batch(batchFn)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Batch error: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for all goroutines to finish.\n\twg.Wait()\n\n\t// Verify that the key-value pair is stored in the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test' not found\")\n\t\t}\n\t\tvalue := b.Get([]byte(\"key\"))\n\t\tif !bytes.Equal(value, []byte(\"value\")) {\n\t\t\treturn fmt.Errorf(\"Value for key 'key' is incorrect: %s\", value)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBatch_TrySolo(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define the batch function.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 10\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Simulate a scenario where Batch is called only once.\n\terr = db.Batch(batchFn)\n\tif err != nil {\n\t\tt.Errorf(\"Batch error: %v\", err)\n\t}\n\n\t// Verify that the key-value pair is stored in the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test' not found\")\n\t\t}\n\t\tvalue := b.Get([]byte(\"key\"))\n\t\tif !bytes.Equal(value, []byte(\"value\")) {\n\t\t\treturn fmt.Errorf(\"Value for key 'key' is incorrect: %s\", value)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBatch_Idempotency(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define the batch function with idempotent side effects.\n\tcounter := 0\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tcounter++\n\t\treturn b.Put([]byte(\"counter\"), []byte(fmt.Sprintf(\"%d\", counter)))\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Call Batch multiple times.\n\tfor i := 0; i \u003c 10; i++ {\n\t\terr := db.Batch(batchFn)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Batch error: %v\", err)\n\t\t}\n\t}\n\n\t// Verify that the counter is incremented only once.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test' not found\")\n\t\t}\n\t\tvalue := b.Get([]byte(\"counter\"))\n\t\tif !bytes.Equal(value, []byte(\"1\")) {\n\t\t\treturn fmt.Errorf(\"Counter value is incorrect: %s\", value)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBatch_Concurrency(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define the batch function.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Start a number of goroutines that call Batch concurrently.\n\tnumGoroutines := runtime.NumCPU() * 2\n\tvar wg sync.WaitGroup\n\twg.Add(numGoroutines)\n\n\t// Create a channel to track errors from the goroutines.\n\terrCh := make(chan error, numGoroutines)\n\n\tfor i := 0; i \u003c numGoroutines; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := db.Batch(batchFn)\n\t\t\tif err != nil {\n\t\t\t\terrCh \u003c- err\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for all goroutines to finish.\n\twg.Wait()\n\tclose(errCh)\n\n\t// Check for any errors that occurred in the goroutines.\n\tfor err := range errCh {\n\t\tt.Errorf(\"Batch error: %v\", err)\n\t}\n\n\t// Verify that the key-value pair is stored in the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test' not found\")\n\t\t}\n\t\tvalue := b.Get([]byte(\"key\"))\n\t\tif !bytes.Equal(value, []byte(\"value\")) {\n\t\t\treturn fmt.Errorf(\"Value for key 'key' is incorrect: %s\", value)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBatch_LargeBatchSize(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define the batch function.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Set a large batch size and delay for testing.\n\tdb.MaxBatchSize = 1000\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Start a number of goroutines that call Batch concurrently.\n\tnumGoroutines := runtime.NumCPU() * 2\n\tvar wg sync.WaitGroup\n\twg.Add(numGoroutines)\n\n\t// Create a channel to track errors from the goroutines.\n\terrCh := make(chan error, numGoroutines)\n\n\tfor i := 0; i \u003c numGoroutines; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := db.Batch(batchFn)\n\t\t\tif err != nil {\n\t\t\t\terrCh \u003c- err\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for all goroutines to finish.\n\twg.Wait()\n\tclose(errCh)\n\n\t// Check for any errors that occurred in the goroutines.\n\tfor err := range errCh {\n\t\tt.Errorf(\"Batch error: %v\", err)\n\t}\n\n\t// Verify that the key-value pair is stored in the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test' not found\")\n\t\t}\n\t\tvalue := b.Get([]byte(\"key\"))\n\t\tif !bytes.Equal(value, []byte(\"value\")) {\n\t\t\treturn fmt.Errorf(\"Value for key 'key' is incorrect: %s\", value)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBatch_ErrorHandling(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define the batch function that returns an error.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"Test error\")\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Call Batch and expect an error.\n\terr = db.Batch(batchFn)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n\n\t// Verify that the error message is as expected.\n\tif err.Error() != \"Test error\" {\n\t\tt.Errorf(\"Unexpected error message: %s\", err.Error())\n\t}\n}\n\nfunc TestBatch_MultipleBatches(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define two batch functions with different keys.\n\tbatchFn1 := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test1\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test1\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key1\"), []byte(\"value1\"))\n\t}\n\n\tbatchFn2 := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test2\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test2\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key2\"), []byte(\"value2\"))\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Call the two batch functions concurrently.\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terr := db.Batch(batchFn1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Batch error: %v\", err)\n\t\t}\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terr := db.Batch(batchFn2)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Batch error: %v\", err)\n\t\t}\n\t}()\n\twg.Wait()\n\n\t// Verify that both key-value pairs are stored in the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb1 := tx.Bucket([]byte(\"test1\"))\n\t\tif b1 == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test1' not found\")\n\t\t}\n\t\tvalue1 := b1.Get([]byte(\"key1\"))\n\t\tif !bytes.Equal(value1, []byte(\"value1\")) {\n\t\t\treturn fmt.Errorf(\"Value for key 'key1' is incorrect: %s\", value1)\n\t\t}\n\t\tb2 := tx.Bucket([]byte(\"test2\"))\n\t\tif b2 == nil {\n\t\t\treturn fmt.Errorf(\"Bucket 'test2' not found\")\n\t\t}\n\t\tvalue2 := b2.Get([]byte(\"key2\"))\n\t\tif !bytes.Equal(value2, []byte(\"value2\")) {\n\t\t\treturn fmt.Errorf(\"Value for key 'key2' is incorrect: %s\", value2)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestBatch_Close(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Define the batch function.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\treturn nil\n\t}\n\n\t// Close the database before calling Batch.\n\tdb.Close()\n\n\t// Call Batch and expect an error.\n\terr = db.Batch(batchFn)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n\n\t// Verify that the error message is as expected.\n\tif err.Error() != \"database is closed\" {\n\t\tt.Errorf(\"Unexpected error message: %s\", err.Error())\n\t}\n}\n\nfunc TestBatch_InvalidPath(t *testing.T) {\n\t// Define the batch function.\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\treturn nil\n\t}\n\n\t// Call Batch with an invalid path.\n\terr := bolt.Batch(filepath.Join(\"non\", \"existent\", \"path\"), batchFn)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n\n\t// Verify that the error message is as expected.\n\tif !strings.Contains(err.Error(), \"open\") || !strings.Contains(err.Error(), \"file\") {\n\t\tt.Errorf(\"Unexpected error message: %s\", err.Error())\n\t}\n}",
    "250a9766a74935ca49b94b78bbe40321": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestUpdate(t *testing.T) {\n\t// Create a temporary database file\n\tf, err := ioutil.TempFile(\"\", \"bolt_test_\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(f.Name())\n\tdefer f.Close()\n\n\t// Open the database\n\tdb, err := bolt.Open(f.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test successful update\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test failed update\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn fmt.Errorf(\"error during update\")\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error during update\")\n\t}\n}\n",
    "31a34a93a5e0b26f3108d238622b2c0e": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file\n\ttempFile, err := os.CreateTemp(\"\", \"bolt_test_*.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define a batch function that increments a counter in a bucket\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"myBucket\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"myBucket\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tv := b.Get([]byte(\"counter\"))\n\t\tif v == nil {\n\t\t\treturn b.Put([]byte(\"counter\"), []byte(\"0\"))\n\t\t}\n\t\tcount, err :=  fmt.Sscan(string(v), \u0026count)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn b.Put([]byte(\"counter\"), []byte(fmt.Sprintf(\"%d\", count+1)))\n\t}\n\n\t// Set a small batch size and delay for testing\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Run multiple batch operations concurrently\n\tdone := make(chan bool)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func(i int) {\n\t\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\t\terr := db.Batch(batchFn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone \u003c- true\n\t\t}(i)\n\t}\n\n\t// Wait for all goroutines to finish\n\tfor i := 0; i \u003c 10; i++ {\n\t\t\u003c-done\n\t}\n\n\t// Verify the counter value after all batches have completed\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"myBucket\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"counter\"))\n\t\tif v == nil {\n\t\t\treturn fmt.Errorf(\"counter not found\")\n\t\t}\n\t\tcount, err := fmt.Sscan(string(v), \u0026count)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif count != 100 {\n\t\t\treturn fmt.Errorf(\"expected counter value to be 100, got %d\", count)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "356c178465f2cfec7025749ffb2f8e29": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tpath     string\n\t\tmode     os.FileMode\n\t\toptions  *bolt.Options\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"Create new database\",\n\t\t\tpath:     filepath.Join(tempDir, \"test.db\"),\n\t\t\tmode:     0666,\n\t\t\toptions:  nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Open existing database\",\n\t\t\tpath:     filepath.Join(tempDir, \"test.db\"),\n\t\t\tmode:     0666,\n\t\t\toptions:  nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Open read-only database\",\n\t\t\tpath:     filepath.Join(tempDir, \"test.db\"),\n\t\t\tmode:     0666,\n\t\t\toptions: \u0026bolt.Options{ReadOnly: true},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Open with custom options\",\n\t\t\tpath:     filepath.Join(tempDir, \"test.db\"),\n\t\t\tmode:     0666,\n\t\t\toptions: \u0026bolt.Options{\n\t\t\t\tNoGrowSync: true,\n\t\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Open non-existent database\",\n\t\t\tpath:     filepath.Join(tempDir, \"nonexistent.db\"),\n\t\t\tmode:     0666,\n\t\t\toptions:  nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Open with invalid path\",\n\t\t\tpath:     \"/invalid/path/to/database\",\n\t\t\tmode:     0666,\n\t\t\toptions:  nil,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdb, err := bolt.Open(tc.path, tc.mode, tc.options)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Open() error = %v, wantErr = %v\", err, tc.wantErr)\n\t\t\t}\n\n\t\t\tif !tc.wantErr {\n\t\t\t\tdefer db.Close()\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpen_MultipleOpen(t *testing.T) {\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\tpath := filepath.Join(tempDir, \"test.db\")\n\n\t// Open the database once\n\tdb1, err := bolt.Open(path, 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db1.Close()\n\n\t// Attempt to open the database again\n\tdb2, err := bolt.Open(path, 0666, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Expected error when opening database again, got %v\", err)\n\t}\n\n\t// Close the second database (which should have failed to open)\n\tif err := db2.Close(); err != nil {\n\t\tt.Errorf(\"Error closing second database: %v\", err)\n\t}\n\n\t// Perform a successful operation on the first database\n\terr = db1.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create bucket: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Failed to update database: %v\", err)\n\t}\n}",
    "363ecdb0ef0ab0973e046bbc63fac1f9": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with default options.\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n\n\t// Test opening the database with read-only options.\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is read-only.\n\tif !db.IsReadOnly() {\n\t\tt.Error(\"Database is not read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenExisting(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a new database.\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Close the database.\n\terr = db.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to close database: %v\", err)\n\t}\n\n\t// Open the existing database.\n\tdb, err = bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithCustomOptions(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with custom options.\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlags(bolt.MmapFlagsPrivate|bolt.MmapFlagsSequential),\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database has the correct options.\n\tif !db.NoGrowSync {\n\t\tt.Error(\"NoGrowSync option is not set\")\n\t}\n\tif db.MmapFlags != bolt.MmapFlags(bolt.MmapFlagsPrivate|bolt.MmapFlagsSequential) {\n\t\tt.Errorf(\"Incorrect MmapFlags: %v, expected: %v\", db.MmapFlags, bolt.MmapFlagsPrivate|bolt.MmapFlagsSequential)\n\t}\n}\n\nfunc TestOpenInvalidPath(t *testing.T) {\n\t// Open the database with an invalid path.\n\tdb, err := bolt.Open(\"/invalid/path\", 0666, nil)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n\tif db != nil {\n\t\tt.Error(\"Expected database to be nil, but got non-nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidMmapFlags(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with invalid MmapFlags.\n\toptions := \u0026bolt.Options{\n\t\tMmapFlags: bolt.MmapFlags(0x100),\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n\tif db != nil {\n\t\tt.Error(\"Expected database to be nil, but got non-nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidTimeout(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with an invalid timeout.\n\toptions := \u0026bolt.Options{\n\t\tTimeout: -1,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n\tif db != nil {\n\t\tt.Error(\"Expected database to be nil, but got non-nil\")\n\t}\n}\n\nfunc TestOpenWithReadOnlyAndTimeout(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with read-only and timeout options.\n\toptions := \u0026bolt.Options{\n\t\tReadOnly: true,\n\t\tTimeout:  10,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is read-only.\n\tif !db.IsReadOnly() {\n\t\tt.Error(\"Database is not read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithNoGrowSync(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with NoGrowSync option.\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithInitialMmapSize(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with InitialMmapSize option.\n\toptions := \u0026bolt.Options{\n\t\tInitialMmapSize: 1024 * 1024,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithMaxBatchSize(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with MaxBatchSize option.\n\toptions := \u0026bolt.Options{\n\t\tMaxBatchSize: 1024,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithMaxBatchDelay(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with MaxBatchDelay option.\n\toptions := \u0026bolt.Options{\n\t\tMaxBatchDelay: 1000,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithAllocSize(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with AllocSize option.\n\toptions := \u0026bolt.Options{\n\t\tAllocSize: 4096,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test that the database is open.\n\tif !db.Opened() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has the correct path.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Incorrect database path: %s, expected: %s\", db.Path(), tempFile.Name())\n\t}\n}\n\nfunc TestOpenWithInvalidOptions(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with invalid options.\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlags(bolt.MmapFlagsPrivate|bolt.MmapFlagsSequential),\n\t\tReadOnly:   true,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n\tif db != nil {\n\t\tt.Error(\"Expected database to be nil, but got non-nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidMode(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with invalid mode.\n\tdb, err := bolt.Open(tempFile.Name(), 0000, nil)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n\tif db != nil {\n\t\tt.Error(\"Expected database to be nil, but got non-nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidFileMode(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with invalid file mode.\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Try to open the database with an invalid file mode.\n\t_, err = bolt.Open(tempFile.Name(), 0777, nil)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n}\n\nfunc TestOpenWithNoPermissions(t *testing.T) {\n\t// Create a temporary directory.\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Create a temporary file within the directory.\n\ttempFile := fmt.Sprintf(\"%s/bolt_test.db\", tempDir)\n\n\t// Set permissions to 0000.\n\terr = os.Chmod(tempDir, 0000)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to change directory permissions: %v\", err)\n\t}\n\n\t// Try to open the database.\n\t_, err = bolt.Open(tempFile, 0666, nil)\n\tif err == nil {\n\t\tt.Error(\"Expected an error, but got nil\")\n\t}\n}",
    "40274aaa09d261e3caa7ef2569dd6f80": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file for the database.\n\ttempFile2, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile2.Name())\n\n\t// Open the database with default options.\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Open the database with read-only options.\n\tdbRO, err := bolt.Open(tempFile2.Name(), 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer dbRO.Close()\n\n\t// Test that the database is open.\n\tif !db.IsOpen() {\n\t\tt.Error(\"Database is not open\")\n\t}\n\n\t// Test that the read-only database is open.\n\tif !dbRO.IsOpen() {\n\t\tt.Error(\"Read-only database is not open\")\n\t}\n\n\t// Test that the database path is correct.\n\tif db.Path() != tempFile.Name() {\n\t\tt.Errorf(\"Database path is incorrect: %s != %s\", db.Path(), tempFile.Name())\n\t}\n\n\t// Test that the read-only database path is correct.\n\tif dbRO.Path() != tempFile2.Name() {\n\t\tt.Errorf(\"Read-only database path is incorrect: %s != %s\", dbRO.Path(), tempFile2.Name())\n\t}\n\n\t// Test that the database is read-only.\n\tif !dbRO.IsReadOnly() {\n\t\tt.Error(\"Read-only database is not read-only\")\n\t}\n\n\t// Test that the database is not read-only.\n\tif db.IsReadOnly() {\n\t\tt.Error(\"Database is read-only\")\n\t}\n\n\t// Test that the database has a valid page size.\n\tif db.PageSize() == 0 {\n\t\tt.Error(\"Database page size is zero\")\n\t}\n\n\t// Test that the database has a valid page size.\n\tif dbRO.PageSize() == 0 {\n\t\tt.Error(\"Read-only database page size is zero\")\n\t}\n\n\t// Test that the database has a valid file size.\n\tif db.FileSize() == 0 {\n\t\tt.Error(\"Database file size is zero\")\n\t}\n\n\t// Test that the database has a valid file size.\n\tif dbRO.FileSize() == 0 {\n\t\tt.Error(\"Read-only database file size is zero\")\n\t}\n\n\t// Test that the database has a valid freelist.\n\tif db.Freelist().Count() == 0 {\n\t\tt.Error(\"Database freelist is empty\")\n\t}\n\n\t// Test that the database has a valid freelist.\n\tif dbRO.Freelist().Count() == 0 {\n\t\tt.Error(\"Read-only database freelist is empty\")\n\t}\n\n\t// Test that the database has valid stats.\n\tif db.Stats().TxStats.OpenTransactions == 0 {\n\t\tt.Error(\"Database stats are invalid\")\n\t}\n\n\t// Test that the database has valid stats.\n\tif dbRO.Stats().TxStats.OpenTransactions == 0 {\n\t\tt.Error(\"Read-only database stats are invalid\")\n\t}\n}\n\nfunc TestOpenInvalidPath(t *testing.T) {\n\t// Test that opening a database with an invalid path returns an error.\n\t_, err := bolt.Open(\"/path/to/nonexistent/file\", 0666, nil)\n\tif err == nil {\n\t\tt.Error(\"Expected error when opening database with invalid path\")\n\t} else {\n\t\tfmt.Println(err.Error())\n\t}\n}",
    "460941ef47d160280aca683b47f75088": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create temporary database file.\n\tdir := filepath.Join(os.TempDir(), \"bolt-batch-test\")\n\tos.RemoveAll(dir)\n\tdefer os.RemoveAll(dir)\n\n\tdbFile := filepath.Join(dir, \"test.db\")\n\n\t// Open the database.\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Set batch parameters.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Create a bucket for testing.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Define a batch function that increments a counter.\n\tvar counter int\n\tbatchFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"counter\"))\n\t\tif v == nil {\n\t\t\tcounter = 0\n\t\t} else {\n\t\t\t_, err := fmt.Sscan(string(v), \u0026counter)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tcounter++\n\t\treturn b.Put([]byte(\"counter\"), []byte(fmt.Sprintf(\"%d\", counter)))\n\t}\n\n\t// Run multiple goroutines calling Batch concurrently.\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\t\terr := db.Batch(batchFn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Verify that the counter is incremented correctly.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"counter\"))\n\t\tif v == nil {\n\t\t\treturn fmt.Errorf(\"counter not found\")\n\t\t}\n\t\tvar actual int\n\t\t_, err := fmt.Sscan(string(v), \u0026actual)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif actual != 100 {\n\t\t\tt.Errorf(\"expected counter to be 100, got %d\", actual)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t// Wait for the batch timer to expire and ensure no more calls are\n\t// queued.\n\ttime.Sleep(2 * db.MaxBatchDelay)\n\truntime.Gosched()\n}",
    "4d5cafc7ddcf9af3863083f4fcd90969": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestView(t *testing.T) {\n\t// Create a temporary file for the database\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test case: basic view operation\n\tt.Run(\"BasicView\", func(t *testing.T) {\n\t\terr := db.View(func(tx *bolt.Tx) error {\n\t\t\tb := tx.Bucket([]byte(\"test\"))\n\t\t\tif b == nil {\n\t\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"View function returned an error: %v\", err)\n\t\t}\n\t})\n\n\t// Test case: error in view function\n\tt.Run(\"ViewError\", func(t *testing.T) {\n\t\terr := db.View(func(tx *bolt.Tx) error {\n\t\t\treturn fmt.Errorf(\"intentional error\")\n\t\t})\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected an error from view function, but got none\")\n\t\t}\n\t})\n\n\t// Test case: attempt to rollback within view function\n\tt.Run(\"ViewRollback\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Error(\"Expected a panic due to rollback attempt within view function\")\n\t\t\t}\n\t\t}()\n\t\terr := db.View(func(tx *bolt.Tx) error {\n\t\t\ttx.Rollback()\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected an error due to rollback attempt within view function\")\n\t\t}\n\t})\n}",
    "5032541e777526f4c0d9f392ec6d61a7": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestView(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Test reading a non-existent bucket\n\t\t_, err := tx.Bucket([]byte(\"non-existent-bucket\"))\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error reading non-existent bucket\")\n\t\t}\n\n\t\t// Test reading an existing bucket\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test-bucket\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif err := bucket.Put([]byte(\"key\"), []byte(\"value\")); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tvalue := bucket.Get([]byte(\"key\"))\n\t\tif string(value) != \"value\" {\n\t\t\tt.Errorf(\"Expected value 'value', got %s\", string(value))\n\t\t}\n\n\t\t// Test attempting to rollback\n\t\tif tx.managed {\n\t\t\tt.Error(\"Transaction should not be managed\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestViewError(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"test error\")\n\t})\n\n\tif err == nil {\n\t\tt.Error(\"Expected error from View function\")\n\t}\n}",
    "50f243a1a75f7e29e8759d84d7b5ee16": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test default options\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test read-only mode\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database in read-only mode: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test custom options\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsPrivate|bolt.MmapFlagsSequential,\n\t\tReadOnly:   false,\n\t\tInitialMmapSize: 1024 * 1024,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with custom options: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening an existing database\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating bucket: %v\", err)\n\t}\n\n\tdb, err = bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening existing database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with an invalid path\n\t_, err = bolt.Open(\"/invalid/path\", 0666, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening database with invalid path, got nil\")\n\t} else {\n\t\tfmt.Printf(\"Error opening database with invalid path: %v\\n\", err)\n\t}\n}",
    "56dff2b90ba84d1e30f4b38dfbb4b329": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestUpdate(t *testing.T) {\n\t// Create a temporary file for the database\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test cases\n\ttestCases := []struct {\n\t\tname    string\n\t\tfn      func(*bolt.Tx) error\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"SuccessfulUpdate\",\n\t\t\tfn: func(tx *bolt.Tx) error {\n\t\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to create bucket: %v\", err)\n\t\t\t\t}\n\t\t\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"FailedUpdate\",\n\t\t\tfn: func(tx *bolt.Tx) error {\n\t\t\t\treturn fmt.Errorf(\"intentional error\")\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\t// Run test cases\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := db.Update(tc.fn)\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Update() returned unexpected error: %v, wantErr: %v\", err, tc.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}",
    "5b96a258c5f64894520858d35690013f": "```go\npackage bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tt.Run(\"OpenDefaultOptions\", func(t *testing.T) {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n\n\tt.Run(\"OpenWithOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n\n\tt.Run(\"OpenReadOnly\", func(t *testing.T) {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0444, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n\n\tt.Run(\"OpenWithInvalidPath\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithExistingFile(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file with some content to simulate an existing database.\n\t_, err = tempFile.WriteString(\"test data\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttempFile.Close()\n\n\tt.Run(\"OpenExistingFile\", func(t *testing.T) {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n}\n\nfunc TestOpenWithInvalidFileMode(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\ttempFile.Close()\n\n\tt.Run(\"OpenWithInvalidFileMode\", func(t *testing.T) {\n\t\t_, err := bolt.Open(tempFile.Name(), 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithExistingFileAndReadOnly(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file with some content to simulate an existing database.\n\t_, err = tempFile.WriteString(\"test data\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttempFile.Close()\n\n\tt.Run(\"OpenExistingFileReadOnly\", func(t *testing.T) {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0444, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n}\n\nfunc TestOpenWithExistingFileAndReadWrite(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file with some content to simulate an existing database.\n\t_, err = tempFile.WriteString(\"test data\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttempFile.Close()\n\n\tt.Run(\"OpenExistingFileReadWrite\", func(t *testing.T) {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n}\n\nfunc TestOpenWithExistingFileAndInvalidMode(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file with some content to simulate an existing database.\n\t_, err = tempFile.WriteString(\"test data\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttempFile.Close()\n\n\tt.Run(\"OpenExistingFileInvalidMode\", func(t *testing.T) {\n\t\t_, err := bolt.Open(tempFile.Name(), 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithExistingFileAndInvalidOptions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file with some content to simulate an existing database.\n\t_, err = tempFile.WriteString(\"test data\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttempFile.Close()\n\n\tt.Run(\"OpenExistingFileInvalidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n}\n\nfunc TestOpenWithExistingFileAndValidOptions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create a temporary file with some content to simulate an existing database.\n\t_, err = tempFile.WriteString(\"test data\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttempFile.Close()\n\n\tt.Run(\"OpenExistingFileValidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\tdb, err := bolt.Open(tempFile.Name(), 0444, options)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n}\n\nfunc TestOpenWithInvalidOptions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tt.Run(\"OpenInvalidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\tdb, err := bolt.Open(tempFile.Name(), 0666, options)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n}\n\nfunc TestOpenWithInvalidFileModeAndReadOnly(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\ttempFile.Close()\n\n\tt.Run(\"OpenInvalidFileModeReadOnly\", func(t *testing.T) {\n\t\t_, err := bolt.Open(tempFile.Name(), 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidFileModeAndReadWrite(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\ttempFile.Close()\n\n\tt.Run(\"OpenInvalidFileModeReadWrite\", func(t *testing.T) {\n\t\t_, err := bolt.Open(tempFile.Name(), 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidFileModeAndInvalidOptions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\ttempFile.Close()\n\n\tt.Run(\"OpenInvalidFileModeInvalidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(tempFile.Name(), 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidFileModeAndValidOptions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\ttempFile.Close()\n\n\tt.Run(\"OpenInvalidFileModeValidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(tempFile.Name(), 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathReadOnly\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathReadWrite\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidOptions(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidOptions(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileMode(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileMode\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileMode(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileMode\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeReadOnly\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeReadWrite\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptions(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptions(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeReadOnly\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeReadWrite\", func(t *testing.T) {\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptions(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptions(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptionsAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptionsReadOnly\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptionsAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptionsReadWrite\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadOnly\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadWrite\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadOnly\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadWrite\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadOnly\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadWrite\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadOnly(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadOnly\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadWrite(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadWrite\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndValidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeValidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0000, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndInvalidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeInvalidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: false,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   true,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0444, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndValidFileModeAndValidOptionsAndReadWriteAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathValidFileModeValidOptionsReadWriteTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:   false,\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlags(0),\n\t\t\tTimeout:   0,\n\t\t}\n\t\t_, err := bolt.Open(\"/invalid/path\", 0666, options)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t\t}\n\t})\n}\n\nfunc TestOpenWithInvalidPathAndInvalidFileModeAndInvalidOptionsAndReadOnlyAndTimeout(t *testing.T) {\n\tt.Run(\"OpenInvalidPathInvalidFileModeInvalidOptionsReadOnlyTimeout\", func(t *testing.T) {\n\t\toptions := \u0026bolt.",
    "63b0abeb12604151fee44c0bd836e8fa": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test with default options\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test with custom options\n\toptions := \u0026bolt.Options{\n\t\tReadOnly:   true,\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsDefault,\n\t}\n\tdb, err = bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test with read-only mode\n\tdb, err = bolt.Open(tempFile.Name(), 0444, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected error for read-only mode, got: %v\", err)\n\t}\n\tif db != nil {\n\t\tt.Fatal(\"Expected nil DB for read-only mode, got: \", db)\n\t}\n\n\t// Test with invalid path\n\t_, err = bolt.Open(\"/invalid/path\", 0666, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error for invalid path, got nil\")\n\t}\n\n\t// Test with invalid file mode\n\t_, err = bolt.Open(tempFile.Name(), 0000, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error for invalid file mode, got nil\")\n\t}\n\n\tfmt.Println(\"Open test passed\")\n}",
    "6a7064732d5d745980ba70749fff044d": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Test with default options\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\tdefer os.Remove(dbPath)\n\n\tdb, err := bolt.Open(dbPath, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test with read-only options\n\tdbPath = filepath.Join(tempDir, \"test_readonly.db\")\n\tdefer os.Remove(dbPath)\n\n\tdb, err = bolt.Open(dbPath, 0600, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test with custom options\n\tdbPath = filepath.Join(tempDir, \"test_custom.db\")\n\tdefer os.Remove(dbPath)\n\n\tdb, err = bolt.Open(dbPath, 0600, \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsDefault,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test with invalid path\n\tdbPath = filepath.Join(tempDir, \"test_invalid.db\")\n\t_, err = bolt.Open(dbPath, 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error for invalid path\")\n\t}\n\n\t// Test with existing file but invalid format\n\tdbPath = filepath.Join(tempDir, \"test_invalid_format.db\")\n\tdefer os.Remove(dbPath)\n\tf, err := os.Create(dbPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf.Close()\n\n\t_, err = bolt.Open(dbPath, 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error for invalid database format\")\n\t}\n\n\tfmt.Println(\"Open test successful\")\n}",
    "6ad3f2b79dd82f73ea4fc2f48aae4681": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestUpdate(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tt.Run(\"UpdateSuccess\", func(t *testing.T) {\n\t\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Update failed: %v\", err)\n\t\t}\n\t\terr = db.View(func(tx *bolt.Tx) error {\n\t\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\t\tif bucket == nil {\n\t\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t\t}\n\t\t\tvalue := bucket.Get([]byte(\"key\"))\n\t\t\tif string(value) != \"value\" {\n\t\t\t\treturn fmt.Errorf(\"expected value 'value', got %s\", string(value))\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"View failed: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"UpdateError\", func(t *testing.T) {\n\t\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t\treturn fmt.Errorf(\"intentional error\")\n\t\t})\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected error, got nil\")\n\t\t}\n\t\terr = db.View(func(tx *bolt.Tx) error {\n\t\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\t\tif bucket != nil {\n\t\t\t\treturn fmt.Errorf(\"bucket should not exist\")\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"View failed: %v\", err)\n\t\t}\n\t})\n}\n",
    "7e49f3591a375e5613a9948fba0d40cf": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestView(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\tdefer tempFile.Close()\n\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test successful view\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"mybucket\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"View failed: %v\", err)\n\t}\n\n\t// Test error in view function\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"error in view function\")\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\tif err.Error() != \"error in view function\" {\n\t\tt.Fatalf(\"Expected error message 'error in view function', got '%s'\", err.Error())\n\t}\n\n\t// Test rollback on panic in view function\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tpanic(\"panic in view function\")\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\tif err.Error() != \"panic in view function\" {\n\t\tt.Fatalf(\"Expected error message 'panic in view function', got '%s'\", err.Error())\n\t}\n\n\t// Test manual rollback in view function\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t_ = tx.Rollback()\n\t\treturn nil\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\tif err.Error() != \"bolt: rollback called in managed transaction\" {\n\t\tt.Fatalf(\"Expected error message 'bolt: rollback called in managed transaction', got '%s'\", err.Error())\n\t}\n}\n",
    "8294ade0833e1df718297bd6acc678cb": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary directory for the database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the database file path\n\tdbPath := fmt.Sprintf(\"%s/test.db\", tempDir)\n\n\t// Test case 1: Open a new database\n\tt.Run(\"NewDatabase\", func(t *testing.T) {\n\t\t// Create and open the database\n\t\tdb, err := bolt.Open(dbPath, 0666, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t// Verify that the database file exists\n\t\tif _, err := os.Stat(dbPath); err != nil {\n\t\t\tt.Errorf(\"Database file does not exist: %s\", dbPath)\n\t\t}\n\t})\n\n\t// Test case 2: Open an existing database\n\tt.Run(\"ExistingDatabase\", func(t *testing.T) {\n\t\t// Open the existing database\n\t\tdb, err := bolt.Open(dbPath, 0666, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t// Verify that the database file exists\n\t\tif _, err := os.Stat(dbPath); err != nil {\n\t\t\tt.Errorf(\"Database file does not exist: %s\", dbPath)\n\t\t}\n\t})\n\n\t// Test case 3: Open a database with read-only mode\n\tt.Run(\"ReadOnlyMode\", func(t *testing.T) {\n\t\t// Open the database in read-only mode\n\t\tdb, err := bolt.Open(dbPath, 0666, \u0026bolt.Options{ReadOnly: true})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t// Verify that the database file exists\n\t\tif _, err := os.Stat(dbPath); err != nil {\n\t\t\tt.Errorf(\"Database file does not exist: %s\", dbPath)\n\t\t}\n\t})\n\n\t// Test case 4: Open a database with custom options\n\tt.Run(\"CustomOptions\", func(t *testing.T) {\n\t\t// Define custom options\n\t\toptions := \u0026bolt.Options{\n\t\t\tNoGrowSync: true,\n\t\t\tMmapFlags:  bolt.MmapFlagsPrivate|bolt.MmapFlagsShared,\n\t\t\tTimeout:    10 * time.Second,\n\t\t}\n\n\t\t// Open the database with custom options\n\t\tdb, err := bolt.Open(dbPath, 0666, options)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t// Verify that the database file exists\n\t\tif _, err := os.Stat(dbPath); err != nil {\n\t\t\tt.Errorf(\"Database file does not exist: %s\", dbPath)\n\t\t}\n\t})\n}",
    "849a5dcbe691207f310b72673a5884ad": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file\n\tdbFile := \"test.db\"\n\tdefer os.Remove(dbFile)\n\n\t// Open the database\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define a function to be executed in batches\n\tbatchFunc := func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"create bucket: %w\", err)\n\t\t}\n\n\t\t// Simulate some work by sleeping\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\t// Increment a counter in the bucket\n\t\tcounter := bucket.Get([]byte(\"counter\"))\n\t\tif counter == nil {\n\t\t\tcounter = []byte(\"0\")\n\t\t}\n\t\tcount, err := strconv.Atoi(string(counter))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parse counter: %w\", err)\n\t\t}\n\t\tcount++\n\n\t\terr = bucket.Put([]byte(\"counter\"), []byte(fmt.Sprintf(\"%d\", count)))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"put counter: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Set a small batch size and delay for testing\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 100 * time.Millisecond\n\n\t// Run multiple batches concurrently\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := db.Batch(batchFunc)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"batch error: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Verify the final counter value\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\n\t\tcounter := bucket.Get([]byte(\"counter\"))\n\t\tif counter == nil {\n\t\t\treturn fmt.Errorf(\"counter not found\")\n\t\t}\n\n\t\tcount, err := strconv.Atoi(string(counter))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parse counter: %w\", err)\n\t\t}\n\n\t\tif count != 10 {\n\t\t\tt.Errorf(\"expected counter to be 10, got %d\", count)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "87eb6663d8d338dc85c77e578f9dd49d": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestStatsSub(t *testing.T) {\n\t// Create a temporary database file\n\tdbPath := \"test.db\"\n\tdefer os.Remove(dbPath)\n\n\t// Open the database file\n\tdb, err := bolt.Open(dbPath, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Perform some operations to populate the stats\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Get the initial stats\n\tstats1 := db.Stats()\n\n\t// Perform some more operations\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\terr := bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Get the updated stats\n\tstats2 := db.Stats()\n\n\t// Calculate the difference\n\tdiff := stats2.Sub(\u0026stats1)\n\n\t// Verify the difference\n\tif diff.TxN != 1 {\n\t\tt.Errorf(\"Expected TxN to be 1, got %d\", diff.TxN)\n\t}\n\tif diff.FreePageN != 0 {\n\t\tt.Errorf(\"Expected FreePageN to be 0, got %d\", diff.FreePageN)\n\t}\n\tif diff.PendingPageN != 0 {\n\t\tt.Errorf(\"Expected PendingPageN to be 0, got %d\", diff.PendingPageN)\n\t}\n\tif diff.FreeAlloc != 0 {\n\t\tt.Errorf(\"Expected FreeAlloc to be 0, got %d\", diff.FreeAlloc)\n\t}\n\tif diff.FreelistInuse != 0 {\n\t\tt.Errorf(\"Expected FreelistInuse to be 0, got %d\", diff.FreelistInuse)\n\t}\n}\n",
    "993b6e25fd1c53b883f5fe00e99d0a82": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file\n\tdbFile := \"test.db\"\n\tdefer os.Remove(dbFile)\n\n\t// Open the database\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Set a small batch size and delay for testing\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Define a test function that increments a counter in the database\n\ttestFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tv := b.Get([]byte(\"counter\"))\n\t\tvar count int\n\t\tif v != nil {\n\t\t\tcount, _ = parseInt(v)\n\t\t}\n\t\tcount++\n\t\treturn b.Put([]byte(\"counter\"), []byte(fmt.Sprintf(\"%d\", count)))\n\t}\n\n\t// Run the test function concurrently in multiple goroutines\n\tfor i := 0; i \u003c 5; i++ {\n\t\tgo func() {\n\t\t\tfor j := 0; j \u003c 3; j++ {\n\t\t\t\tif err := db.Batch(testFn); err != nil {\n\t\t\t\t\tt.Fatalf(\"Batch error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for all goroutines to finish\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Verify the counter value\n\tvar count int\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tv := b.Get([]byte(\"counter\"))\n\t\tcount, _ = parseInt(v)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif count != 15 {\n\t\tt.Errorf(\"Expected counter value 15, got %d\", count)\n\t}\n}\n\n// Helper function to parse a byte slice to an integer\nfunc parseInt(b []byte) (int, error) {\n\tvar count int\n\t_, err := fmt.Sscan(string(b), \u0026count)\n\treturn count, err\n}",
    "99c52cf915635f32df9d1ec57871c5b6": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file.\n\tdbFile := \"test.db\"\n\tdefer os.Remove(dbFile)\n\n\t// Open the database.\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define a function to be executed within the batch.\n\tfn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"create bucket: %v\", err)\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Run the batch with a small batch size and delay.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Run multiple goroutines calling the batch function.\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tfor j := 0; j \u003c 5; j++ {\n\t\t\t\terr := db.Batch(fn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"batch error: %v\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for the batch to finish.\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Verify the data is written correctly.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"key\"))\n\t\tif string(v) != \"value\" {\n\t\t\treturn fmt.Errorf(\"value mismatch: got %s, want value\", string(v))\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "9feef69a331cc50e8ad8a42c03657260": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary directory for the database file.\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Create a temporary database file path.\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Test opening a new database file.\n\tdb, err := bolt.Open(dbPath, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening an existing database file.\n\tdb, err = bolt.Open(dbPath, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a read-only database file.\n\tdb, err = bolt.Open(dbPath, 0400, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with custom options.\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlags(0),\n\t}\n\tdb, err = bolt.Open(dbPath, 0600, options)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with invalid file mode.\n\t_, err = bolt.Open(dbPath, 0000, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t}\n}\n\nfunc TestOpenWithInvalidPath(t *testing.T) {\n\t// Try opening a database with an invalid path.\n\t_, err := bolt.Open(\"/invalid/path/to/database.db\", 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t}\n\n\t// Check if the error is a \"no such file or directory\" error.\n\tif !os.IsNotExist(err) {\n\t\tt.Errorf(\"Expected error to be os.IsNotExist, got %v\", err)\n\t}\n}\n\nfunc TestOpenWithExistingFile(t *testing.T) {\n\t// Create a temporary file.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tempFile.Close()\n\tdefer os.Remove(tempFile.Name())\n\n\t// Try opening the file as a Bolt database.\n\t_, err = bolt.Open(tempFile.Name(), 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening existing file\")\n\t}\n\n\t// Check if the error is a \"text file busy\" error.\n\tif !os.IsExist(err) {\n\t\tt.Errorf(\"Expected error to be os.IsExist, got %v\", err)\n\t}\n}\n\nfunc TestOpenWithExistingDirectory(t *testing.T) {\n\t// Create a temporary directory.\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Try opening the directory as a Bolt database.\n\t_, err = bolt.Open(tempDir, 0600, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening existing directory\")\n\t}\n\n\t// Check if the error is a \"is a directory\" error.\n\tif !os.IsNotExist(err) {\n\t\tt.Errorf(\"Expected error to be os.IsNotExist, got %v\", err)\n\t}\n}\n\nfunc TestOpenWithInvalidOptions(t *testing.T) {\n\t// Create a temporary directory for the database file.\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Create a temporary database file path.\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create invalid options.\n\toptions := \u0026bolt.Options{\n\t\tMmapFlags: bolt.MmapFlags(0x100),\n\t}\n\n\t// Try opening the database with invalid options.\n\t_, err = bolt.Open(dbPath, 0600, options)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening with invalid options\")\n\t}\n\n\t// Check if the error message contains \"invalid mmap flags\".\n\tif !strings.Contains(err.Error(), \"invalid mmap flags\") {\n\t\tt.Errorf(\"Expected error message to contain 'invalid mmap flags', got %v\", err)\n\t}\n}",
    "a613686d1f4e703d28a7bf7c939d22de": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestUpdate(t *testing.T) {\n\t// Create a temporary database file.\n\ttempFile, err := os.CreateTemp(\"\", \"bolt_test_\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test case 1: Successful update.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create bucket: %v\", err)\n\t\t}\n\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Update failed: %v\", err)\n\t}\n\n\t// Test case 2: Update with error.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"intentional error\")\n\t})\n\tif err == nil {\n\t\tt.Fatalf(\"Update should have failed, but returned no error\")\n\t}\n\n\t// Test case 3: Attempting to manually commit within the function.\n\t// This should panic.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatalf(\"Expected panic when manually committing within Update\")\n\t\t}\n\t}()\n\t_ = db.Update(func(tx *bolt.Tx) error {\n\t\t_ = tx.Commit()\n\t\treturn nil\n\t})\n\n\t// Test case 4: Attempting to manually rollback within the function.\n\t// This should panic.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatalf(\"Expected panic when manually rolling back within Update\")\n\t\t}\n\t}()\n\t_ = db.Update(func(tx *bolt.Tx) error {\n\t\t_ = tx.Rollback()\n\t\treturn nil\n\t})\n}\n",
    "a712a82e2be22b81405d460bb19ece71": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a new database\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening an existing database\n\tdb, err = bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with read-only mode\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with custom options\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsDefault,\n\t}\n\tdb, err = bolt.Open(tempFile.Name(), 0666, options)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with invalid path\n\t_, err = bolt.Open(\"invalid/path\", 0666, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when opening with invalid path\")\n\t}\n\n\t// Test opening with invalid mode\n\t_, err = bolt.Open(tempFile.Name(), 0000, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when opening with invalid mode\")\n\t}\n\n\t// Test opening with invalid options\n\t_, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{\n\t\tMmapFlags: bolt.MmapFlagsInvalid,\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when opening with invalid options\")\n\t}\n}\n\nfunc TestOpen_WithTimeout(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening with timeout\n\toptions := \u0026bolt.Options{\n\t\tTimeout: 1,\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0666, options)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when opening with timeout\")\n\t} else {\n\t\tfmt.Println(err)\n\t}\n}",
    "a81db5b1eaab1b63a18f04f5ad38a173": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a new database\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening an existing database\n\tdb, err = bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening existing database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with read-only mode\n\tdb, err = bolt.Open(tempFile.Name(), 0400, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with read-only mode: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with custom options\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsPrivate|bolt.MmapFlagsShared,\n\t}\n\tdb, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with custom options: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening a database with invalid path\n\t_, err = bolt.Open(\"invalid_path\", 0600, nil)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid path, but got nil\")\n\t}\n\n\t// Test opening a database with invalid mode\n\t_, err = bolt.Open(tempFile.Name(), 0000, nil)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid mode, but got nil\")\n\t}\n}\n\nfunc TestOpenWithOptions(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with default options\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check default options\n\tif db.NoGrowSync != bolt.DefaultOptions.NoGrowSync {\n\t\tt.Errorf(\"Expected NoGrowSync to be %v, but got %v\", bolt.DefaultOptions.NoGrowSync, db.NoGrowSync)\n\t}\n\tif db.MmapFlags != bolt.DefaultOptions.MmapFlags {\n\t\tt.Errorf(\"Expected MmapFlags to be %v, but got %v\", bolt.DefaultOptions.MmapFlags, db.MmapFlags)\n\t}\n\n\t// Test opening a database with custom options\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsPrivate|bolt.MmapFlagsShared,\n\t}\n\tdb, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with custom options: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check custom options\n\tif db.NoGrowSync != options.NoGrowSync {\n\t\tt.Errorf(\"Expected NoGrowSync to be %v, but got %v\", options.NoGrowSync, db.NoGrowSync)\n\t}\n\tif db.MmapFlags != options.MmapFlags {\n\t\tt.Errorf(\"Expected MmapFlags to be %v, but got %v\", options.MmapFlags, db.MmapFlags)\n\t}\n}\n\nfunc TestOpenWithReadOnly(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with read-only mode\n\tdb, err := bolt.Open(tempFile.Name(), 0400, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with read-only mode: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check read-only flag\n\tif !db.readOnly {\n\t\tt.Errorf(\"Expected readOnly to be true, but got false\")\n\t}\n}\n\nfunc TestOpenWithInvalidPath(t *testing.T) {\n\t// Test opening a database with invalid path\n\t_, err := bolt.Open(\"invalid_path\", 0600, nil)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid path, but got nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidMode(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with invalid mode\n\t_, err = bolt.Open(tempFile.Name(), 0000, nil)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid mode, but got nil\")\n\t}\n}\n\nfunc TestOpenWithTimeout(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with a timeout\n\toptions := \u0026bolt.Options{\n\t\tTimeout: 100, // 100 milliseconds\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with timeout: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check if the timeout was set correctly\n\tif db.Timeout != options.Timeout {\n\t\tt.Errorf(\"Expected timeout to be %d, but got %d\", options.Timeout, db.Timeout)\n\t}\n}\n\nfunc TestOpenWithInvalidTimeout(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an invalid timeout\n\toptions := \u0026bolt.Options{\n\t\tTimeout: -1, // Invalid timeout\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid timeout, but got nil\")\n\t}\n}\n\nfunc TestOpenWithInitialMmapSize(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an initial mmap size\n\toptions := \u0026bolt.Options{\n\t\tInitialMmapSize: 1024 * 1024, // 1 MB\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with initial mmap size: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check if the initial mmap size was set correctly\n\tif db.InitialMmapSize != options.InitialMmapSize {\n\t\tt.Errorf(\"Expected initial mmap size to be %d, but got %d\", options.InitialMmapSize, db.InitialMmapSize)\n\t}\n}\n\nfunc TestOpenWithInvalidInitialMmapSize(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an invalid initial mmap size\n\toptions := \u0026bolt.Options{\n\t\tInitialMmapSize: -1, // Invalid initial mmap size\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid initial mmap size, but got nil\")\n\t}\n}\n\nfunc TestOpenWithMaxBatchSize(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with a max batch size\n\toptions := \u0026bolt.Options{\n\t\tMaxBatchSize: 100,\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with max batch size: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check if the max batch size was set correctly\n\tif db.MaxBatchSize != options.MaxBatchSize {\n\t\tt.Errorf(\"Expected max batch size to be %d, but got %d\", options.MaxBatchSize, db.MaxBatchSize)\n\t}\n}\n\nfunc TestOpenWithInvalidMaxBatchSize(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an invalid max batch size\n\toptions := \u0026bolt.Options{\n\t\tMaxBatchSize: -1, // Invalid max batch size\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid max batch size, but got nil\")\n\t}\n}\n\nfunc TestOpenWithMaxBatchDelay(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with a max batch delay\n\toptions := \u0026bolt.Options{\n\t\tMaxBatchDelay: 100, // 100 milliseconds\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with max batch delay: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check if the max batch delay was set correctly\n\tif db.MaxBatchDelay != options.MaxBatchDelay {\n\t\tt.Errorf(\"Expected max batch delay to be %d, but got %d\", options.MaxBatchDelay, db.MaxBatchDelay)\n\t}\n}\n\nfunc TestOpenWithInvalidMaxBatchDelay(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an invalid max batch delay\n\toptions := \u0026bolt.Options{\n\t\tMaxBatchDelay: -1, // Invalid max batch delay\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid max batch delay, but got nil\")\n\t}\n}\n\nfunc TestOpenWithAllocSize(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an alloc size\n\toptions := \u0026bolt.Options{\n\t\tAllocSize: 1024 * 1024, // 1 MB\n\t}\n\tdb, err := bolt.Open(tempFile.Name(), 0600, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database with alloc size: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Check if the alloc size was set correctly\n\tif db.AllocSize != options.AllocSize {\n\t\tt.Errorf(\"Expected alloc size to be %d, but got %d\", options.AllocSize, db.AllocSize)\n\t}\n}\n\nfunc TestOpenWithInvalidAllocSize(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with an invalid alloc size\n\toptions := \u0026bolt.Options{\n\t\tAllocSize: -1, // Invalid alloc size\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid alloc size, but got nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidMmapFlags(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with invalid mmap flags\n\toptions := \u0026bolt.Options{\n\t\tMmapFlags: 0xFFFFFFFF, // Invalid mmap flags\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid mmap flags, but got nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidNoGrowSync(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with invalid no grow sync flag\n\toptions := \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsPrivate,\n\t}\n\t_, err = bolt.Open(tempFile.Name(), 0600, options)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid no grow sync flag, but got nil\")\n\t}\n}\n\nfunc TestOpenWithInvalidOptions(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a database with invalid options\n\t_, err = bolt.Open(tempFile.Name(), 0600, \u0026bolt.Options{\n\t\tNoGrowSync:   true,\n\t\tMmapFlags:    bolt.MmapFlagsPrivate,\n\t\tInitialMmapSize: -1,        // Invalid initial mmap size\n\t\tMaxBatchSize:   -1,        // Invalid max batch size\n\t\tMaxBatchDelay:  -1,        // Invalid max batch delay\n\t\tAllocSize:     -1,        // Invalid alloc size\n\t\tTimeout:        -1,        // Invalid timeout\n\t\tReadOnly:       true,\n\t})\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening database with invalid options, but got nil\")\n\t}\n}\n\nfunc TestOpenWithMultipleProcesses(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create two goroutines to open the same database\n\tdone := make(chan bool)\n\tgo func() {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error opening database: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer db.Close()\n\t\tdone \u003c- true\n\t}()\n\n\tgo func() {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error opening database: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer db.Close()\n\t\tdone \u003c- true\n\t}()\n\n\t// Wait for both goroutines to finish\n\t\u003c-done\n\t\u003c-done\n}\n\nfunc TestOpenWithMultipleProcessesReadOnly(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating temporary file: %v\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Create two goroutines to open the same database with read-only mode\n\tdone := make(chan bool)\n\tgo func() {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0400, \u0026bolt.Options{ReadOnly: true})\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error opening database: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer db.Close()\n\t\tdone \u003c- true\n\t}()\n\n\tgo func() {\n\t\tdb, err := bolt.Open(tempFile.Name(), 0400, \u0026bolt.Options{ReadOnly: true})\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error opening database: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tdefer db.Close()\n\t\tdone \u003c- true\n\t}()\n\n\t// Wait for both goroutines to finish\n\t\u003c-done\n\t\u003c-done\n}",
    "a8514c022fccbf3cb338504430d77451": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestStats(t *testing.T) {\n\t// Create a temporary database file\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Perform some operations to update the stats\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Get the stats\n\tstats := db.Stats()\n\n\t// Check that stats have been updated\n\tif stats.TxStats.OpenTransactions == 0 {\n\t\tt.Errorf(\"Expected open transactions to be greater than 0, got %d\", stats.TxStats.OpenTransactions)\n\t}\n\n\tif stats.TxStats.WriteTransactions == 0 {\n\t\tt.Errorf(\"Expected write transactions to be greater than 0, got %d\", stats.TxStats.WriteTransactions)\n\t}\n\n\tfmt.Printf(\"Stats: %+v\\n\", stats)\n}\n",
    "aab0f4838db22e8fa7fad64821b9b3c7": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for the database\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test_\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Test opening a new database\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening an existing database\n\tdb, err = bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with read-only mode\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with custom options\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags: bolt.MmapFlags(0),\n\t\tTimeout:   100,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test opening with invalid path\n\t_, err = bolt.Open(\"\", 0666, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening with invalid path\")\n\t}\n\n\t// Test opening with invalid file mode\n\t_, err = bolt.Open(tempFile.Name(), 0, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening with invalid file mode\")\n\t}\n}\n\nfunc TestOpenWithInvalidPageSize(t *testing.T) {\n\t// Create a temporary file for the database\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test_\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Write an invalid page size to the file\n\t_, err = tempFile.Write([]byte{0, 0, 0, 1})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Try to open the database with the invalid page size\n\t_, err = bolt.Open(tempFile.Name(), 0666, nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error opening with invalid page size\")\n\t} else {\n\t\tfmt.Println(err)\n\t}\n}",
    "ab0de6ad4f43b9be7560bdea0df4ac11": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Test cases\n\ttestCases := []struct {\n\t\tname         string\n\t\tmode         os.FileMode\n\t\toptions      *bolt.Options\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tname:         \"DefaultOptions\",\n\t\t\tmode:         0666,\n\t\t\toptions:      nil,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"ReadOnly\",\n\t\t\tmode:         0666,\n\t\t\toptions:      \u0026bolt.Options{ReadOnly: true},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"InvalidPath\",\n\t\t\tmode:         0666,\n\t\t\toptions:      nil,\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Open the database\n\t\t\tdb, err := bolt.Open(tc.name, tc.mode, tc.options)\n\t\t\tif tc.expectedError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Expected error, but got nil\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Unexpected error: %v\", err)\n\t\t\t\t}\n\t\t\t\t// Close the database\n\t\t\t\tif err := db.Close(); err != nil {\n\t\t\t\t\tt.Errorf(\"Failed to close database: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpen_InvalidPath(t *testing.T) {\n\t// Invalid path\n\tinvalidPath := \"/non/existent/path/test.db\"\n\n\t// Open the database with an invalid path\n\tdb, err := bolt.Open(invalidPath, 0666, nil)\n\n\t// Verify that an error is returned\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n\n\t// Verify that the database is nil\n\tif db != nil {\n\t\tt.Errorf(\"Expected database to be nil, but got %v\", db)\n\t}\n}\n\nfunc TestOpen_ReadOnly(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Open the database in read-only mode\n\tdb, err := bolt.Open(dbPath, 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open database in read-only mode: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is read-only\n\tif !db.IsReadOnly() {\n\t\tt.Errorf(\"Expected database to be read-only, but it is not\")\n\t}\n}\n\nfunc TestOpen_DefaultOptions(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Open the database with default options\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open database with default options: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is not read-only\n\tif db.IsReadOnly() {\n\t\tt.Errorf(\"Expected database to not be read-only, but it is\")\n\t}\n\n\t// Verify that the database has the default options\n\tif db.NoGrowSync != bolt.DefaultOptions.NoGrowSync {\n\t\tt.Errorf(\"Expected NoGrowSync to be %v, but got %v\", bolt.DefaultOptions.NoGrowSync, db.NoGrowSync)\n\t}\n\tif db.MmapFlags != bolt.DefaultOptions.MmapFlags {\n\t\tt.Errorf(\"Expected MmapFlags to be %v, but got %v\", bolt.DefaultOptions.MmapFlags, db.MmapFlags)\n\t}\n\tif db.MaxBatchSize != bolt.DefaultMaxBatchSize {\n\t\tt.Errorf(\"Expected MaxBatchSize to be %v, but got %v\", bolt.DefaultMaxBatchSize, db.MaxBatchSize)\n\t}\n\tif db.MaxBatchDelay != bolt.DefaultMaxBatchDelay {\n\t\tt.Errorf(\"Expected MaxBatchDelay to be %v, but got %v\", bolt.DefaultMaxBatchDelay, db.MaxBatchDelay)\n\t}\n\tif db.AllocSize != bolt.DefaultAllocSize {\n\t\tt.Errorf(\"Expected AllocSize to be %v, but got %v\", bolt.DefaultAllocSize, db.AllocSize)\n\t}\n}\n\nfunc TestOpen_ExistingDatabase(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create a new database file\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Open the existing database file\n\tdb, err = bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open existing database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is opened successfully\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Errorf(\"Failed to execute view transaction: %v\", err)\n\t}\n}\n\nfunc TestOpen_ExistingDatabase_ReadOnly(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create a new database file\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Open the existing database file in read-only mode\n\tdb, err = bolt.Open(dbPath, 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open existing database in read-only mode: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is opened successfully\n\tif err := db.View(func(tx *bolt.Tx) error {\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Errorf(\"Failed to execute view transaction: %v\", err)\n\t}\n}\n\nfunc TestOpen_ExistingDatabase_InvalidPath(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create a new database file\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Invalid path\n\tinvalidPath := \"/non/existent/path/test.db\"\n\n\t// Open the existing database file with an invalid path\n\tdb, err = bolt.Open(invalidPath, 0666, nil)\n\n\t// Verify that an error is returned\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n\n\t// Verify that the database is nil\n\tif db != nil {\n\t\tt.Errorf(\"Expected database to be nil, but got %v\", db)\n\t}\n}\n\nfunc TestOpen_ExistingDatabase_InvalidMode(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create a new database file\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Open the existing database file with an invalid mode\n\t_, err = bolt.Open(dbPath, 0000, nil)\n\n\t// Verify that an error is returned\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n}\n\nfunc TestOpen_ExistingDatabase_InvalidOptions(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create a new database file\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Open the existing database file with invalid options\n\t_, err = bolt.Open(dbPath, 0666, \u0026bolt.Options{Timeout: -1})\n\n\t// Verify that an error is returned\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, but got nil\")\n\t}\n}\n\nfunc TestOpen_ExistingDatabase_WithBucket(t *testing.T) {\n\t// Create a temporary directory for the test database file\n\ttempDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n\t}\n\tdefer os.RemoveAll(tempDir)\n\n\t// Define the test database file path\n\tdbPath := filepath.Join(tempDir, \"test.db\")\n\n\t// Create a new database file\n\tdb, err := bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Create a bucket\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create bucket: %v\", err)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create bucket: %v\", err)\n\t}\n\n\t// Open the existing database file\n\tdb, err = bolt.Open(dbPath, 0666, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to open existing database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the bucket exists\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Failed to check for bucket existence: %v\", err)\n\t}\n}",
    "af79fdaadd3b9804ce6bbb3c0799aa27": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file.\n\tdbFile := \"test.db\"\n\tdefer os.Remove(dbFile)\n\n\t// Open the database.\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define a function to be executed in a batch.\n\tfn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Set a small batch size and delay for testing.\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Run the batch function multiple times concurrently.\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func(i int) {\n\t\t\terr := db.Batch(fn)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error in batch %d: %v\", i, err)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Wait for all the batch functions to finish.\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Verify that the key-value pair was inserted.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"key\"))\n\t\tif v == nil {\n\t\t\treturn fmt.Errorf(\"value not found\")\n\t\t}\n\t\tif string(v) != \"value\" {\n\t\t\treturn fmt.Errorf(\"unexpected value: %s\", string(v))\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "afc068ed64e981cdf952ce16a085eb4a": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestStatsSub(t *testing.T) {\n\t// Create a temporary database file.\n\ttempFile, err := os.CreateTemp(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\tdefer tempFile.Close()\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create two sets of stats.\n\tstats1 := db.Stats()\n\tstats2 := db.Stats()\n\n\t// Perform some operations to modify the stats.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Calculate the difference between the stats.\n\tdiff := stats1.Sub(\u0026stats2)\n\n\t// Verify that the difference is correct.\n\tif diff.TxN != 1 {\n\t\tt.Errorf(\"Expected TxN to be 1, got %d\", diff.TxN)\n\t}\n\n\t// Perform more operations to further modify the stats.\n\tif err := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Calculate the difference again.\n\tdiff = stats1.Sub(\u0026stats2)\n\n\t// Verify that the difference is correct.\n\tif diff.TxN != 2 {\n\t\tt.Errorf(\"Expected TxN to be 2, got %d\", diff.TxN)\n\t}\n}\n",
    "bbd4254ebec32abd57adee1d705d45be": "package bolt_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\t\"unsafe\"\n)\n\nfunc TestInfo(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tinfo := db.Info()\n\n\t// Check the data pointer\n\tdataPointer := (*byte)(unsafe.Pointer(info.Data))\n\tif dataPointer == nil {\n\t\tt.Error(\"Expected data pointer to be non-nil\")\n\t}\n\n\t// Check the page size\n\tif info.PageSize != db.pageSize {\n\t\tt.Errorf(\"Expected page size to be %d, got %d\", db.pageSize, info.PageSize)\n\t}\n\n\t// Write a test value to the database and ensure it's reflected in the data pointer\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucket([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Read the data from the data pointer and check for the test value\n\tvar key, value []byte\n\tbuf := bytes.NewBuffer(dataPointer)\n\n\t// Read the key length\n\tkeyLength := binary.LittleEndian.Uint32(buf.Next(4))\n\tkey = make([]byte, keyLength)\n\tbuf.Read(key)\n\n\t// Read the value length\n\tvalueLength := binary.LittleEndian.Uint32(buf.Next(4))\n\tvalue = make([]byte, valueLength)\n\tbuf.Read(value)\n\n\tif string(key) != \"key\" || string(value) != \"value\" {\n\t\tt.Errorf(\"Expected key: %s, value: %s, got key: %s, value: %s\", \"key\", \"value\", key, value)\n\t}\n\n\tfmt.Println(\"Info:\", info)\n}",
    "bcceefd017764e19c23d6dba8e15a24b": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary file\n\tf, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(f.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(f.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Set a small batch size and delay\n\tdb.MaxBatchSize = 2\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\n\t// Create a counter bucket\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucketIfNotExists([]byte(\"counter\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a function that increments the counter\n\tincrementCounter := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"counter\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"count\"))\n\t\tcount := 0\n\t\tif v != nil {\n\t\t\tcount = int(v[0])\n\t\t}\n\t\treturn b.Put([]byte(\"count\"), []byte{byte(count+1)})\n\t}\n\n\t// Run Batch concurrently with multiple goroutines\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tif err := db.Batch(incrementCounter); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Verify the counter value\n\tvar finalCount int\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"counter\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"count\"))\n\t\tif v == nil {\n\t\t\treturn fmt.Errorf(\"count not found\")\n\t\t}\n\t\tfinalCount = int(v[0])\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Assert the final counter value is at least 10\n\tif finalCount \u003c 10 {\n\t\tt.Errorf(\"final counter value %d is less than 10\", finalCount)\n\t}\n}",
    "bd583db7f60e5ef88cc03bec8bcfac55": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create temporary database file.\n\ttempFile, err := os.CreateTemp(\"\", \"bolt-batch-test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open database with a small batch size and delay.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, \u0026bolt.Options{\n\t\tMaxBatchSize: 2,\n\t\tMaxBatchDelay: 10 * time.Millisecond,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test batch execution with multiple goroutines.\n\tt.Run(\"ParallelBatch\", func(t *testing.T) {\n\t\t// Counter for batch operations.\n\t\tvar counter int\n\t\t// Channel to signal completion of all batch operations.\n\t\tdone := make(chan struct{})\n\t\t// Number of goroutines to run.\n\t\tnumGoroutines := 10\n\t\t// Run multiple goroutines that execute batch operations.\n\t\tfor i := 0; i \u003c numGoroutines; i++ {\n\t\t\tgo func(i int) {\n\t\t\t\t// Execute batch operation.\n\t\t\t\terr := db.Batch(func(tx *bolt.Tx) error {\n\t\t\t\t\t// Increment counter.\n\t\t\t\t\tcounter++\n\t\t\t\t\t// Create a bucket if it doesn't exist.\n\t\t\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(fmt.Sprintf(\"bucket-%d\", i)))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\t// Store a value.\n\t\t\t\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t\t// Signal completion.\n\t\t\t\tdone \u003c- struct{}{}\n\t\t\t}(i)\n\t\t}\n\t\t// Wait for all goroutines to finish.\n\t\tfor i := 0; i \u003c numGoroutines; i++ {\n\t\t\t\u003c-done\n\t\t}\n\t\t// Check that all batch operations were executed.\n\t\tif counter != numGoroutines {\n\t\t\tt.Errorf(\"Expected %d batch operations, got %d\", numGoroutines, counter)\n\t\t}\n\t\t// Verify data stored in database.\n\t\terr = db.View(func(tx *bolt.Tx) error {\n\t\t\tfor i := 0; i \u003c numGoroutines; i++ {\n\t\t\t\tb := tx.Bucket([]byte(fmt.Sprintf(\"bucket-%d\", i)))\n\t\t\t\tif b == nil {\n\t\t\t\t\treturn fmt.Errorf(\"bucket %d not found\", i)\n\t\t\t\t}\n\t\t\t\tvalue := b.Get([]byte(\"key\"))\n\t\t\t\tif string(value) != \"value\" {\n\t\t\t\t\treturn fmt.Errorf(\"expected value 'value', got '%s'\", value)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t})\n\n\t// Test batch execution with idempotent functions.\n\tt.Run(\"IdempotentBatch\", func(t *testing.T) {\n\t\t// Counter for batch operations.\n\t\tvar counter int\n\t\t// Execute batch operation multiple times.\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\terr := db.Batch(func(tx *bolt.Tx) error {\n\t\t\t\t// Increment counter.\n\t\t\t\tcounter++\n\t\t\t\t// Create a bucket if it doesn't exist.\n\t\t\t\tb, err := tx.CreateBucketIfNotExists([]byte(\"bucket\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t// Store a value.\n\t\t\t\treturn b.Put([]byte(\"key\"), []byte(\"value\"))\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t}\n\t\t// Check that counter is incremented only once, as the batch operation is idempotent.\n\t\tif counter != 1 {\n\t\t\tt.Errorf(\"Expected counter to be 1, got %d\", counter)\n\t\t}\n\t})\n}\n",
    "be94c376f946e752b9ed855b84f4369b": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file\n\tdbFile := \"test.db\"\n\tdefer os.Remove(dbFile)\n\n\t// Open the database\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define a test function that increments a counter in a bucket\n\ttestFn := func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\tb, err = tx.CreateBucket([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tv := b.Get([]byte(\"count\"))\n\t\tvar count int\n\t\tif v != nil {\n\t\t\tcount, _ =  fmt.Sscan(string(v), \u0026count)\n\t\t}\n\t\treturn b.Put([]byte(\"count\"), []byte(fmt.Sprintf(\"%d\", count+1)))\n\t}\n\n\t// Run Batch multiple times concurrently\n\tn := 10\n\tdone := make(chan bool, n)\n\tfor i := 0; i \u003c n; i++ {\n\t\tgo func() {\n\t\t\tdefer done \u003c- true\n\t\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\t\terr := db.Batch(testFn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\t// Wait for all goroutines to finish\n\tfor i := 0; i \u003c n; i++ {\n\t\t\u003c-done\n\t}\n\n\t// Verify that the counter was incremented correctly\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"count\"))\n\t\tif v == nil {\n\t\t\treturn fmt.Errorf(\"count not found\")\n\t\t}\n\t\tvar count int\n\t\t_, err = fmt.Sscan(string(v), \u0026count)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif count != n*10 {\n\t\t\treturn fmt.Errorf(\"expected count to be %d, got %d\", n*10, count)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test with MaxBatchSize and MaxBatchDelay\n\tdb.MaxBatchSize = 5\n\tdb.MaxBatchDelay = 10 * time.Millisecond\n\t// Reset counter\n\terr = db.Update(testFn)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Run Batch multiple times concurrently\n\tn = 10\n\tdone = make(chan bool, n)\n\tfor i := 0; i \u003c n; i++ {\n\t\tgo func() {\n\t\t\tdefer done \u003c- true\n\t\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\t\terr := db.Batch(testFn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\t// Wait for all goroutines to finish\n\tfor i := 0; i \u003c n; i++ {\n\t\t\u003c-done\n\t}\n\t// Verify that the counter was incremented correctly\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"test\"))\n\t\tif b == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := b.Get([]byte(\"count\"))\n\t\tif v == nil {\n\t\t\treturn fmt.Errorf(\"count not found\")\n\t\t}\n\t\tvar count int\n\t\t_, err = fmt.Sscan(string(v), \u0026count)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif count != n*10+1 {\n\t\t\treturn fmt.Errorf(\"expected count to be %d, got %d\", n*10+1, count)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "cbb301fb74d80a4ae0e8cc778c845277": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttmpDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\ttestCases := []struct {\n\t\tname      string\n\t\tpath      string\n\t\tmode      os.FileMode\n\t\toptions   *bolt.Options\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"open_default\",\n\t\t\tpath:      filepath.Join(tmpDir, \"test.db\"),\n\t\t\tmode:      0666,\n\t\t\toptions:   nil,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"open_read_only\",\n\t\t\tpath:      filepath.Join(tmpDir, \"test.db\"),\n\t\t\tmode:      0666,\n\t\t\toptions:   \u0026bolt.Options{ReadOnly: true},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"open_no_grow_sync\",\n\t\t\tpath:      filepath.Join(tmpDir, \"test.db\"),\n\t\t\tmode:      0666,\n\t\t\toptions:   \u0026bolt.Options{NoGrowSync: true},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"open_invalid_path\",\n\t\t\tpath:      filepath.Join(tmpDir, \"nonexistent.db\"),\n\t\t\tmode:      0666,\n\t\t\toptions:   nil,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdb, err := bolt.Open(tc.path, tc.mode, tc.options)\n\t\t\tif (err != nil) != tc.expectErr {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tc.expectErr, err)\n\t\t\t}\n\n\t\t\tif !tc.expectErr {\n\t\t\t\tdefer db.Close()\n\t\t\t\t// Ensure database file exists.\n\t\t\t\tif _, err := os.Stat(tc.path); err != nil {\n\t\t\t\t\tt.Errorf(\"Database file not created: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpen_InvalidOptions(t *testing.T) {\n\ttmpDir, err := ioutil.TempDir(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\tpath := filepath.Join(tmpDir, \"test.db\")\n\n\t// Test invalid options\n\tt.Run(\"invalid_mmap_flags\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tMmapFlags: 0xFFFFFFFF, // Invalid mmap flags\n\t\t}\n\t\t_, err := bolt.Open(path, 0666, options)\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error for invalid mmap flags, got nil\")\n\t\t}\n\t\tif !fmt.Sprintf(\"%v\", err).Contains(\"mmap flags\") {\n\t\t\tt.Error(\"Error message should contain mmap flags\")\n\t\t}\n\t})\n}",
    "ccb4a929553c31fa9e45cf8d3e3b4fdf": "package bolt_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestClose(t *testing.T) {\n\t// Create a temporary database file\n\tdbFile := \"test.db\"\n\tdefer os.Remove(dbFile)\n\n\t// Open the database\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Ensure that the database can be closed without errors\n\tif err := db.Close(); err != nil {\n\t\tt.Fatalf(\"Error closing database: %v\", err)\n\t}\n}\n",
    "da1b8f7f59e4b32223790617a7ef9d04": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestDBClose(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %s\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %s\", err)\n\t}\n\tdefer db.Close()\n\n\t// Test closing a database with an open transaction\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to start transaction: %s\", err)\n\t}\n\tdefer tx.Rollback()\n\n\t// Close the database while the transaction is open\n\terr = db.Close()\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error closing database with open transaction, got: %s\", err)\n\t}\n\n\t// Verify the database is closed by attempting to open it again\n\t_, err = bolt.Open(tempFile.Name(), 0666, nil)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error opening closed database, got nil\")\n\t}\n}\n\nfunc TestDBCloseWithMultipleTransactions(t *testing.T) {\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create temp file: %s\", err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open database: %s\", err)\n\t}\n\tdefer db.Close()\n\n\t// Start multiple transactions\n\ttx1, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to start transaction 1: %s\", err)\n\t}\n\tdefer tx1.Rollback()\n\n\ttx2, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to start transaction 2: %s\", err)\n\t}\n\tdefer tx2.Rollback()\n\n\t// Close the database with multiple transactions open\n\terr = db.Close()\n\tif err == nil {\n\t\tt.Errorf(\"Expected error closing database with multiple open transactions, got nil\")\n\t} else {\n\t\t// The error message should indicate that there are open transactions\n\t\tif !fmt.Sprintf(\"%s\", err).Contains(\"cannot close database with open transactions\") {\n\t\t\tt.Errorf(\"Expected error message to contain 'cannot close database with open transactions', got: %s\", err)\n\t\t}\n\t}\n}\n",
    "ddc381cc2c922553d31f4b0c2a25e57b": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/boltdb/bolt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestView(t *testing.T) {\n\t// Create a temporary file\n\tfile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\t// Open the database\n\tdb, err := bolt.Open(file.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test successful view\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Simulate a read operation\n\t\tbucket := tx.Bucket([]byte(\"testBucket\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test view with error\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\t// Simulate an error during read operation\n\t\treturn fmt.Errorf(\"simulated error\")\n\t})\n\tif err != nil {\n\t\tif err.Error() != \"simulated error\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\t} else {\n\t\tt.Fatal(\"expected error, got nil\")\n\t}\n\n\t// Test view with panic\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\t// Expect a panic due to manually attempting to rollback\n\t\t\tif r != \"bolt: cannot manually rollback a managed transaction\" {\n\t\t\t\tt.Fatalf(\"Unexpected panic: %v\", r)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatal(\"Expected panic, but none occurred.\")\n\t\t}\n\t}()\n\tdb.View(func(tx *bolt.Tx) error {\n\t\t// Attempt to manually rollback\n\t\ttx.Rollback()\n\t\treturn nil\n\t})\n}",
    "dfe1d6a17a16a7e95efec0e4b725ecd2": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\t// Create a temporary file for testing\n\ttempFile, err := os.CreateTemp(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database with default options\n\tdb, err := bolt.Open(tempFile.Name(), 0666, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is opened successfully\n\tif !db.opened {\n\t\tt.Error(\"Database should be opened\")\n\t}\n\n\t// Verify that the path is set correctly\n\tif db.path != tempFile.Name() {\n\t\tt.Errorf(\"Expected path: %s, got: %s\", tempFile.Name(), db.path)\n\t}\n\n\t// Test opening with read-only mode\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{ReadOnly: true})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the database is opened in read-only mode\n\tif !db.readOnly {\n\t\tt.Error(\"Database should be opened in read-only mode\")\n\t}\n\n\t// Test opening with custom options\n\tdb, err = bolt.Open(tempFile.Name(), 0666, \u0026bolt.Options{\n\t\tNoGrowSync: true,\n\t\tMmapFlags:  bolt.MmapFlagsPrivate|bolt.MmapFlagsShared,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Verify that the custom options are applied\n\tif !db.NoGrowSync {\n\t\tt.Error(\"NoGrowSync option should be applied\")\n\t}\n\tif db.MmapFlags != (bolt.MmapFlagsPrivate|bolt.MmapFlagsShared) {\n\t\tt.Errorf(\"Expected MmapFlags: %v, got: %v\", (bolt.MmapFlagsPrivate|bolt.MmapFlagsShared), db.MmapFlags)\n\t}\n\n\t// Test opening with invalid path\n\t_, err = bolt.Open(\"invalid_path\", 0666, nil)\n\tif err == nil {\n\t\tt.Error(\"Expected error when opening with invalid path\")\n\t} else {\n\t\tfmt.Println(err)\n\t}\n}",
    "ec8092189ca3c7f0a0278e0c74a3c90f": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file\n\tdbPath := \"test.db\"\n\tdefer os.Remove(dbPath)\n\n\t// Open the database\n\tdb, err := bolt.Open(dbPath, 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Define a function to be executed in a batch\n\tfn := func(tx *bolt.Tx) error {\n\t\t// Perform some operation in the transaction\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t}\n\n\t// Test concurrent Batch calls\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := db.Batch(fn)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Batch call %d failed: %v\", i, err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Verify the results\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"Bucket not found\")\n\t\t}\n\t\tvalue := bucket.Get([]byte(\"key\"))\n\t\tif value == nil {\n\t\t\treturn fmt.Errorf(\"Value not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test Batch with errors\n\terr = db.Batch(func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"Intentional error\")\n\t})\n\tif err == nil {\n\t\tt.Error(\"Expected error from Batch call, got nil\")\n\t}\n\n\t// Test Batch with long delays\n\tdb.MaxBatchDelay = 5 * time.Second\n\tstartTime := time.Now()\n\terr = db.Batch(fn)\n\tif err != nil {\n\t\tt.Errorf(\"Batch call failed: %v\", err)\n\t}\n\tendTime := time.Now()\n\tduration := endTime.Sub(startTime)\n\tif duration \u003c 5*time.Second {\n\t\tt.Errorf(\"Batch call duration is less than expected delay: %v\", duration)\n\t}\n}",
    "ef6acfa9fb68a619708069c79fb39ec4": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestOpen(t *testing.T) {\n\ttmpFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tmpFile.Name())\n\n\tt.Run(\"DefaultOptions\", func(t *testing.T) {\n\t\tdb, err := bolt.Open(tmpFile.Name(), 0600, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t})\n\n\tt.Run(\"CustomOptions\", func(t *testing.T) {\n\t\toptions := \u0026bolt.Options{\n\t\t\tReadOnly:     true,\n\t\t\tNoGrowSync:   true,\n\t\t\tMmapFlags:    bolt.DefaultMmapFlags,\n\t\t\tInitialMmapSize: 1024 * 1024, // 1 MB\n\t\t}\n\t\tdb, err := bolt.Open(tmpFile.Name(), 0600, options)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t\tif !db.readOnly {\n\t\t\tt.Error(\"Expected database to be read-only\")\n\t\t}\n\t\tif !db.NoGrowSync {\n\t\t\tt.Error(\"Expected NoGrowSync to be true\")\n\t\t}\n\t\tif db.MmapFlags != options.MmapFlags {\n\t\t\tt.Error(\"Expected MmapFlags to be the same as the options\")\n\t\t}\n\t\tif db.InitialMmapSize != options.InitialMmapSize {\n\t\t\tt.Error(\"Expected InitialMmapSize to be the same as the options\")\n\t\t}\n\t})\n\n\tt.Run(\"OpenExistingFile\", func(t *testing.T) {\n\t\t// Create a simple database file with some content.\n\t\tdb, err := bolt.Open(tmpFile.Name(), 0600, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\t\treturn err\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Open the existing database file.\n\t\tdb, err = bolt.Open(tmpFile.Name(), 0600, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\n\t\t// Verify the bucket exists.\n\t\terr = db.View(func(tx *bolt.Tx) error {\n\t\t\tif tx.Bucket([]byte(\"test\")) == nil {\n\t\t\t\treturn fmt.Errorf(\"bucket 'test' not found\")\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n}",
    "fc56489c5ad79d796d7dfd7370940df6": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestUpdate(t *testing.T) {\n\t// Create a temporary file for the database.\n\ttempFile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tempFile.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(tempFile.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test successful update.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test update with error.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"update error\")\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\n\t// Test manual commit/rollback.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t// Attempt to manually commit.\n\t\tif err := tx.Commit(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test manual rollback.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t// Attempt to manually rollback.\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}",
    "fe0080cf2185497553302f2bd1696acf": "package bolt_test\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestBatch(t *testing.T) {\n\t// Create a temporary database file.\n\tdbPath := \"/tmp/bolt_test_batch.db\"\n\tdefer os.Remove(dbPath)\n\n\t// Open the database.\n\tdb, err := bolt.Open(dbPath, 0600, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Error opening database: %v\", err)\n\t}\n\tdefer db.Close()\n\n\t// Define a function to be executed in the batch.\n\tfn := func(tx *bolt.Tx) error {\n\t\tbucketName := []byte(\"mybucket\")\n\t\tbucket, err := tx.CreateBucketIfNotExists(bucketName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Error creating bucket: %v\", err)\n\t\t}\n\t\tkey := []byte(\"mykey\")\n\t\tvalue := []byte(\"myvalue\")\n\t\treturn bucket.Put(key, value)\n\t}\n\n\t// Create multiple goroutines to call Batch concurrently.\n\tconst numGoroutines = 10\n\tfor i := 0; i \u003c numGoroutines; i++ {\n\t\tgo func() {\n\t\t\tfor j := 0; j \u003c 10; j++ {\n\t\t\t\terr := db.Batch(fn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Error executing batch: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Wait for a short period to allow the goroutines to execute.\n\ttime.Sleep(1 * time.Second)\n\n\t// Verify the data in the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucketName := []byte(\"mybucket\")\n\t\tbucket := tx.Bucket(bucketName)\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"Bucket not found: %s\", bucketName)\n\t\t}\n\t\tvalue := bucket.Get([]byte(\"mykey\"))\n\t\tif value == nil {\n\t\t\treturn fmt.Errorf(\"Key not found: %s\", []byte(\"mykey\"))\n\t\t}\n\t\tif string(value) != \"myvalue\" {\n\t\t\treturn fmt.Errorf(\"Unexpected value: %s\", value)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Error viewing database: %v\", err)\n\t}\n}",
    "ff235c9001b050cb14a1eda3ef703ed9": "package bolt_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc TestView(t *testing.T) {\n\t// Create a temporary file for the database.\n\tfile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(file.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Test a simple view function.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test a view function that returns an error.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\treturn fmt.Errorf(\"error in view function\")\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"expected an error\")\n\t}\n\n\t// Test a view function that writes to the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\t// Attempt to write to the database, this should panic.\n\t\terr := bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected an error\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"expected an error\")\n\t}\n}\n\nfunc TestViewWithBucket(t *testing.T) {\n\t// Create a temporary file for the database.\n\tfile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(file.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create a bucket.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucket([]byte(\"test\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test a view function that retrieves data from the bucket.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := bucket.Get([]byte(\"key\"))\n\t\tif v != nil {\n\t\t\tt.Fatalf(\"unexpected value: %s\", v)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test a view function that writes to the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\t// Attempt to write to the database, this should panic.\n\t\terr := bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected an error\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"expected an error\")\n\t}\n}\n\nfunc TestViewWithKey(t *testing.T) {\n\t// Create a temporary file for the database.\n\tfile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(file.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create a bucket and a key.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucket([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = bucket.Put([]byte(\"key\"), []byte(\"value\"))\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test a view function that retrieves data from the key.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tv := bucket.Get([]byte(\"key\"))\n\t\tif bytes.Compare(v, []byte(\"value\")) != 0 {\n\t\t\tt.Fatalf(\"unexpected value: %s\", v)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test a view function that writes to the database.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\t// Attempt to write to the database, this should panic.\n\t\terr := bucket.Put([]byte(\"key\"), []byte(\"new value\"))\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected an error\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"expected an error\")\n\t}\n}\n\nfunc TestViewWithCursor(t *testing.T) {\n\t// Create a temporary file for the database.\n\tfile, err := ioutil.TempFile(\"\", \"bolt_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\t// Open the database.\n\tdb, err := bolt.Open(file.Name(), 0600, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t// Create a bucket and populate it with some data.\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucket([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\tkey := make([]byte, 8)\n\t\t\tbinary.BigEndian.PutUint64(key, uint64(i))\n\t\t\tvalue := []byte(fmt.Sprintf(\"value%d\", i))\n\t\t\terr = bucket.Put(key, value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Test a view function that iterates through the bucket using a cursor.\n\terr = db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"test\"))\n\t\tif bucket == nil {\n\t\t\treturn fmt.Errorf(\"bucket not found\")\n\t\t}\n\t\tc := bucket.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\t// Verify that the key and value are as expected.\n\t\t\texpectedKey := make([]byte, 8)\n\t\t\tbinary.BigEndian.PutUint64(expectedKey, uint64(c.Index()))\n\t\t\tif bytes.Compare(k, expectedKey) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected key: %s, expected %s\", k, expectedKey)\n\t\t\t}\n\t\t\texpectedValue := []byte(fmt.Sprintf(\"value%d\", c.Index()))\n\t\t\tif bytes.Compare(v, expectedValue) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected value: %s, expected %s\", v, expectedValue)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}"
}