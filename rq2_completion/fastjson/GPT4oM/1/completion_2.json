{"00278ae3692fa09d9f958ad63beba116":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Exists(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Field exists at root\",\n\t\t\tjson:     `{\"name\": \"John\"}`,\n\t\t\tkeys:     []string{\"name\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field does not exist at root\",\n\t\t\tjson:     `{\"name\": \"John\"}`,\n\t\t\tkeys:     []string{\"age\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field exists in nested object\",\n\t\t\tjson:     `{\"person\": {\"name\": \"John\"}}`,\n\t\t\tkeys:     []string{\"person\", \"name\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field does not exist in nested object\",\n\t\t\tjson:     `{\"person\": {\"name\": \"John\"}}`,\n\t\t\tkeys:     []string{\"person\", \"age\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field exists in array\",\n\t\t\tjson:     `{\"people\": [{\"name\": \"John\"}, {\"name\": \"Jane\"}]}`,\n\t\t\tkeys:     []string{\"people\", \"0\", \"name\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field does not exist in array\",\n\t\t\tjson:     `{\"people\": [{\"name\": \"John\"}, {\"name\": \"Jane\"}]}`,\n\t\t\tkeys:     []string{\"people\", \"1\", \"age\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field exists with decimal index\",\n\t\t\tjson:     `{\"array\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Field does not exist with decimal index\",\n\t\t\tjson:     `{\"array\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"array\", \"2\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tgot := v.Exists(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Exists() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0144670a849d18faf8a4f3ce07fa7a09":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\t// Create a sample JSON object\n\tjsonStr := `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`\n\tvalue, err := Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\tobj, err := value.Object()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get object from value: %v\", err)\n\t}\n\n\t// Prepare a slice to capture the results\n\tvar results []string\n\n\t// Define the function to be called for each key-value pair\n\tf := func(key []byte, v *Value) {\n\t\tresults = append(results, string(key)+\": \"+v.String())\n\t}\n\n\t// Call the Visit method\n\tobj.Visit(f)\n\n\t// Expected results\n\texpected := []string{\n\t\t\"key1: value1\",\n\t\t\"key2: value2\",\n\t\t\"key3: value3\",\n\t}\n\n\t// Check if the results match the expected output\n\tif len(results) != len(expected) {\n\t\tt.Fatalf(\"Expected %d results, got %d\", len(expected), len(results))\n\t}\n\n\tfor i, expectedResult := range expected {\n\t\tif results[i] != expectedResult {\n\t\t\tt.Errorf(\"Expected %q, got %q\", expectedResult, results[i])\n\t\t}\n\t}\n}","02a8269c4ee18a4fbb8c09411ab1841f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalueStr string\n\t\texpected uint\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tvalueStr: \"123\",\n\t\t\texpected: 123,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid uint at max\",\n\t\t\tvalueStr: \"4294967295\", // Max value for uint32\n\t\t\texpected: 4294967295,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number type\",\n\t\t\tvalueStr: `\"string\"`, // JSON string type\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number too large for uint\",\n\t\t\tvalueStr: \"4294967296\", // One more than max uint32\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative number\",\n\t\t\tvalueStr: \"-1\", // Negative number\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{s: tt.valueStr, t: TypeNumber} // Simulate the Value struct\n\t\t\tgot, err := v.Uint()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Uint() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Uint() = %v, expected %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","030050b2471e57cd0d6c0d511578aae8":"// skipws_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\t\\n   \", \"\"},\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"   world   \", \"world   \"},\n\t\t{\"   \\t   test\", \"test\"},\n\t\t{\"\\n\\n\\n   example\", \"example\"},\n\t\t{\"\\r\\n   line\", \"line\"},\n\t\t{\"   \\t\\n   mixed   \", \"mixed   \"},\n\t\t{\"   \\x00\\x01\\x02valid\", \"valid\"},\n\t\t{\"   \\x1F\\x20\\x21valid\", \"!valid\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","030088fada765edfb609350d13c2384f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"-nan123\", \"-nan\", \"123\", false},\n\t\t{\"123.45.67\", \"123.45\", \".67\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"\", \"\", \"\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) number = %q, expected = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expected = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","033289b6ad4a2cc3c8f2036ab17e5a0b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3, [4, 5]]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"4\"}, {t: TypeNumber, s: \"5\"}}}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q)[%d] = %v, want %v\", test.input, i, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","033e68fd7e13f2d9c2f9e28af7b159b4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uD83D\", \"Invalid Unicode: \\\\uD83D\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: 😀\"},\n\t\t{\"Escape sequences: \\\\b \\\\f \\\\n \\\\r \\\\t \\\\/\", \"Escape sequences: \\b \\f \\n \\r \\t /\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\" and \\\\u4F60\", \"\\\"Hello\\\" and 你好\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","038822c39cb85eb822913d7b1c215e0d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": \"value\"` + \"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tv, tail, err := parseValue(tt.input, c, 0)\n\n\t\tif (err != nil) != tt.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif !compareValues(v, tt.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", tt.input, v, tt.expected)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, tail, tt.tail)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function for Value types\n\t// This is a placeholder; actual implementation needed based on Value structure\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t\n}","04d0d806717ea36eb17f2b72144f32a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"existing true value\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"existing false value\",\n\t\t\tjson:     `{\"key\": false}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"key\": \"true\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (number)\",\n\t\t\tjson:     `{\"key\": 1}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key with true value\",\n\t\t\tjson:     `{\"outer\": {\"inner\": true}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key with false value\",\n\t\t\tjson:     `{\"outer\": {\"inner\": false}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key non-existing\",\n\t\t\tjson:     `{\"outer\": {\"inner\": true}}`,\n\t\t\tkeys:     []string{\"outer\", \"non_existing\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetBool(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","04d6e97909589953719868a25b6e57cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t// Test cases with valid keys\n\t\t{`\"key\"`, \"key\", \"\", false},\n\t\t{`\"anotherKey\" more text`, \"anotherKey\", \" more text\", false},\n\t\t{`\"keyWithSpaces\"`, \"keyWithSpaces\", \"\", false},\n\n\t\t// Test cases with escape sequences\n\t\t{`\"keyWithEscape\\\"`, \"keyWithEscape\", \"\\\"\", false},\n\t\t{`\"keyWithNewline\\n\"`, \"keyWithNewline\", \"\\n\", false},\n\n\t\t// Test case with missing closing quote\n\t\t{`\"missingClosingQuote`, \"\", \"\", true},\n\t\t{`\"anotherMissingClosingQuote`, \"\", \"\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey = %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, expectedRemaining = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","04dc8272468e903ebae88b5145747003":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tobj := \u0026Object{\n\t\tkvs:           []kv{{k: \"key1\", v: \u0026Value{}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Perform the reset operation\n\tobj.reset()\n\n\t// Check if kvs is reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got %v\", obj.kvs)\n\t}\n\n\t// Check if keysUnescaped is reset\n\tif obj.keysUnescaped {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, got %v\", obj.keysUnescaped)\n\t}\n}","0579ad30148187ef9637d5bc4d216b67":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\texpected: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"[1,true,null]\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal string\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\texpected: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","05d5d41f64663ccd061a86a2c50439e7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","05f386d6426b2ba51ab1618802020780":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uXYZ\", \"Mixed😀\\\\uXYZ\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","07b09c2d02a2a43bf3bdfe6d215f6090":"// int_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tvalue:    \u0026Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative int\",\n\t\t\tvalue:    \u0026Value{s: \"-10\", t: TypeNumber},\n\t\t\texpected: -10,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is not a number\",\n\t\t\tvalue:    \u0026Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is a string\",\n\t\t\tvalue:    \u0026Value{s: \"\\\"string\\\"\", t: TypeString},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value is null\",\n\t\t\tvalue:    \u0026Value{s: \"null\", t: TypeNull},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"overflow int\",\n\t\t\tvalue:    \u0026Value{s: \"9223372036854775807\", t: TypeNumber}, // int64 max\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.value.Int()\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0939d19a198a44e82a69f74a6213352e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: `no quotes here`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"missing closing quote`,\n\t\t\texpectedValue: `\"missing closing quote`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped quote \\\\\"`,\n\t\t\texpectedValue: `escaped quote \\`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","09ab002c025559c976b4c2b3658e55f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\n\t\tif test.hasError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"for input %q, expected %v, got %v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value types\n\treturn false // Placeholder return\n}","0a78ec200670858320d02e398f83adb6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil, // Expected value should be set according to your implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\tdepth:    0,\n\t\t\texpected: nil, // Expected value should be set according to your implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"too deep\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: nil,\n\t\t\ttail:     \"too deep\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(tt.input, c, tt.depth)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif result != nil \u0026\u0026 tt.expected != nil \u0026\u0026 *result != *tt.expected {\n\t\t\t\tt.Fatalf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t}\n\t\t\tif tail != tt.tail {\n\t\t\t\tt.Fatalf(\"expected tail: %q, got: %q\", tt.tail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","0ac5d665a06f3aea0c44fc787c1e6312":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": 3, \"key4\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\t// Additional checks can be added here to compare the actual result with expected Value\n\t\t// For example, you can compare the structure of the returned Value with the expected Value\n\t}\n}","0b937229edec31861deb151c4b2bde02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 'a']\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","0caf733fa5305edee132705c431f4cb5":"// uint_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected uint\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tvalue:    \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpected: 123,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid uint64 that fits in uint\",\n\t\t\tvalue:    \u0026Value{s: \"4294967295\", t: TypeNumber}, // Max uint32\n\t\t\texpected: 4294967295,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tvalue:    \u0026Value{s: `\"not a number\"`, t: TypeString},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (bool)\",\n\t\t\tvalue:    \u0026Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number too large for uint\",\n\t\t\tvalue:    \u0026Value{s: \"4294967296\", t: TypeNumber}, // One more than max uint32\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative number\",\n\t\t\tvalue:    \u0026Value{s: \"-1\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.value.Uint()\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"Uint() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Uint() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0cd53799171f8eab7a7786371d5f8f6a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", nil},\n\t\t{\"-infabc\", \"-inf\", \"abc\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","0d8972029cfd570b7b6fadd35e2a9a42":"// value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected Type\n\t}{\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeRawString\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"raw\"},\n\t\t\texpected: TypeString, // Expect it to be converted to TypeString\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.Type()\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","0dd52c43968564e6763558b0b79bfa78":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: TypeString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Replace with expected Value for array\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Replace with expected Value for object\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: nil, // Replace with expected Value for NaN\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested\": \"value\"}}`,\n\t\t\texpected: nil, // Replace with expected Value for nested object\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: nil, // Replace with expected Value for object with array\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif v == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = nil, want %v\", test.input, test.expected)\n\t\t\t} else if v != nil \u0026\u0026 test.expected == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want nil\", test.input, v)\n\t\t\t} else if v != nil \u0026\u0026 test.expected != nil {\n\t\t\t\t// Compare the expected Value with the actual Value\n\t\t\t\t// This comparison should be implemented based on the structure of Value\n\t\t\t}\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","0e137cd85ee0d22389c92c89df6ce95f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tc := \u0026cache{} // Initialize cache for testing\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Compare result with expected Value (you may need to implement a comparison function)\n\t\tif !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"For input %q, expected %v, got %v\", test.input, test.expected, result)\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"Expected remaining string to be empty for input %q, got %q\", test.input, remaining)\n\t\t}\n\t}\n}\n\n// compareValues is a placeholder for a function that compares two Value instances.\n// You will need to implement this based on the structure of Value.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false\n}","0e2fc36867a75303a40fd010715ca652":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\n\t\tif (err != nil) != test.hasError {\n\t\t\tt.Errorf(\"Parse(%q) error = %v, wantHasError %v\", test.input, err, test.hasError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.hasError \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances.\n// Implement this function based on the structure of Value and its fields.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn true\n}","0e9eb289cd868b9e3366eb39a10000e2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","0f26a105e8a6525daf65d26615bb027c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewLine\", \"Mixed😀\\nNewLine\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Escaped\\\\/Character\", \"Escaped/Character\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","0f616e71d39628a3904565c42de8b8bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial value retrieval\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Fatal(\"Expected a non-nil value on first call to getValue\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif cap(c.vs) != 1 || len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected cache to have 1 value, got len: %d, cap: %d\", len(c.vs), cap(c.vs))\n\t}\n\n\t// Test subsequent value retrieval\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Fatal(\"Expected a non-nil value on second call to getValue\")\n\t}\n\n\t// Test that a new value is appended\n\tif cap(c.vs) != 2 || len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected cache to have 2 values, got len: %d, cap: %d\", len(c.vs), cap(c.vs))\n\t}\n\n\t// Test that the returned value is the last one in the slice\n\tif val1 == val2 {\n\t\tt.Fatal(\"Expected different values for consecutive calls to getValue\")\n\t}\n\n\t// Test that the values are not reset\n\tval1.s = \"modified\"\n\tif val1.s == val2.s {\n\t\tt.Fatal(\"Expected values to be independent after modification\")\n\t}\n}","102240021d6c63d042cc29f0cf5c3c80":"// file: object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test initial state\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Fatal(\"Expected kv to be non-nil\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"Expected length of kvs to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Test adding a second kv\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Fatal(\"Expected kv to be non-nil\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"Expected length of kvs to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Test that kvs are initialized correctly\n\tif kv1 == kv2 {\n\t\tt.Fatal(\"Expected kv1 and kv2 to be different instances\")\n\t}\n\n\t// Test capacity and length behavior\n\tinitialCap := cap(obj.kvs)\n\tfor i := 0; i \u003c initialCap; i++ {\n\t\tobj.getKV()\n\t}\n\tif cap(obj.kvs) != initialCap {\n\t\tt.Fatalf(\"Expected capacity to remain the same, got %d\", cap(obj.kvs))\n\t}\n\n\t// Add one more kv to trigger an append\n\tkv3 := obj.getKV()\n\tif len(obj.kvs) != initialCap+1 {\n\t\tt.Fatalf(\"Expected length of kvs to be %d, got %d\", initialCap+1, len(obj.kvs))\n\t}\n\tif kv3 == nil {\n\t\tt.Fatal(\"Expected kv3 to be non-nil\")\n\t}\n}","10bbc6828a6fc03332fc16f5cfb25807":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","127578a71a6a36cc5701f713d549647a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function that checks if two Value objects are equivalent.\n\t// This function should compare the type, object keys, and values.\n\t// For simplicity, this function is not implemented here.\n\treturn false\n}","131c5e909188ccddbdbc641839726007":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,, 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %q, got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"for input %q, expected %d values, got %d\", test.input, len(test.expected), len(result.a))\n\t\t}\n\n\t\tfor i, expectedValue := range test.expected {\n\t\t\tif result.a[i].t != expectedValue.t || result.a[i].s != expectedValue.s {\n\t\t\t\tt.Errorf(\"for input %q, expected value %v, got %v\", test.input, expectedValue, result.a[i])\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"expected no remaining input, got: %q\", remaining)\n\t\t}\n\t}\n}","13ac2e84e94bb35e0a1906d0f00aa5aa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`,\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tCharacter\"`,\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u0041\"`,\n\t\t\texpected: \"Unicode: A\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid Unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate Pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate Pair: 😀\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped Quotes: \\\"Hello\\\" \"`,\n\t\t\texpected: \"Escaped Quotes: \\\"Hello\\\" \",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No Escapes Here\"`,\n\t\t\texpected: \"No Escapes Here\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Incomplete Escape: \\u\"`,\n\t\t\texpected: \"Incomplete Escape: \\\\u\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","148ad80a180eea71a492d6b0b24097d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"valid string\",\n\t\t\tinput:    \u0026Value{s: \"test\", t: TypeString},\n\t\t\tkeys:     []string{},\n\t\t\texpected: []byte(\"test\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"nil value\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-string type\",\n\t\t\tinput:    \u0026Value{t: TypeNumber},\n\t\t\tkeys:     []string{},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tinput:    \u0026Value{s: \"test\", t: TypeString},\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index as key\",\n\t\t\tinput:    \u0026Value{a: []*Value{{s: \"arrayValue\", t: TypeString}}, t: TypeArray},\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: []byte(\"arrayValue\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array index\",\n\t\t\tinput:    \u0026Value{a: []*Value{{s: \"arrayValue\", t: TypeString}}, t: TypeArray},\n\t\t\tkeys:     []string{\"invalid\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.GetStringBytes(tt.keys...)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","1490d6cb217dd451490dc28ee87e21f0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-infxyz\", \"-inf\", \"xyz\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123.45e-10more\", \"-123.45e-10\", \"more\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-xyz\", \"\", \"-xyz\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","14c58917c9d82fa6db5387dd24350ac4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"t\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"t\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"f\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"f\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"n\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"n\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"a\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","14fbe10b0680f4221116e7b1870b9a89":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil {\n\t\t\tif result == nil || len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif result.a[i].t != v.t || result.a[i].s != v.s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","15857d05467c9fab2c5649930ceed954":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"\\t\\tworld\", \"world\"},\n\t\t{\"\\n\\n\\nfoo\", \"foo\"},\n\t\t{\"   \\t   bar\", \"bar\"},\n\t\t{\"\\r\\nbaz\", \"baz\"},\n\t\t{\"   \\t\\n   \", \"\"},\n\t\t{\"noWhitespace\", \"noWhitespace\"},\n\t\t{\"\\t   \\r\\n   \\n   \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","15a1bd9c4cb7d2c8250487d176211055":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"EscapedSlash\\\\/AndQuote\\\\\\\"\", \"EscapedSlash/AndQuote\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","15d7ed731d71f30fb541c89324e4ba82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Replace with expected Value after implementing parseArray\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Replace with expected Value after implementing parseObject\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: nil, // Replace with expected Value after implementing NaN handling\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: nil, // Replace with expected Value after implementing parseObject\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: nil, // Replace with expected Value after implementing parseObject\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) did not consume the entire input, tail = %q\", test.input, tail)\n\t\t}\n\t}\n}","164ccc2a2be2f8e88436d7a4daedb07f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"innerKey\": \"innerValue\"}}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}, {k: \"nested\", v: \u0026Value{o: Object{kvs: []kv{{k: \"innerKey\", v: \u0026Value{s: \"innerValue\", t: typeRawString}}}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"too big depth\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 !compareValues(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != \"\" \u0026\u0026 tail != test.input[len(test.input):] {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.input[len(test.input):])\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value types\n\t// This function should compare the fields of Value and return true if they are equal\n\treturn false // Placeholder\n}","16723f2ffc32b29d413163cff8fbb420":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\" text`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","1776fcb07dc4d492159b07148dfcd15c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for the Get function\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tinput:    /* initialize with a JSON object containing the key */,\n\t\t\tkeys:     []string{\"existingKey\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key from object\",\n\t\t\tinput:    /* initialize with a JSON object */,\n\t\t\tkeys:     []string{\"nonExistingKey\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing index from array\",\n\t\t\tinput:    /* initialize with a JSON array containing values */,\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: /* expected Value at index 0 */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing index from array\",\n\t\t\tinput:    /* initialize with a JSON array */,\n\t\t\tkeys:     []string{\"10\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested object\",\n\t\t\tinput:    /* initialize with a nested JSON object */,\n\t\t\tkeys:     []string{\"outerKey\", \"innerKey\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested array\",\n\t\t\tinput:    /* initialize with a nested JSON array */,\n\t\t\tkeys:     []string{\"outerArray\", \"0\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get with invalid key type\",\n\t\t\tinput:    /* initialize with a JSON object */,\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nil Value\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"anyKey\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","17b32a79b708d7306585f51b4a70cf38":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\" \"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\" \\\"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\\\"`,\n\t\t\texpectedValue: \"hello\\\\\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" \"another\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" \\\"another\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\" \"missing closing quote`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\" \\\"missing closing quote\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","19b178d5d315f1ee4a910530c85798c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"This is a tab\\\\tcharacter.\", \"This is a tab\\tcharacter.\"},\n\t\t{\"This is a backslash \\\\\\\\ character.\", \"This is a backslash \\\\ character.\"},\n\t\t{\"This is a quote: \\\\\\\" and a forward slash: \\\\/\", \"This is a quote: \\\" and a forward slash: /\"},\n\t\t{\"Invalid unicode \\\\uXYZ\", \"Invalid unicode \\\\uXYZ\"},\n\t\t{\"Valid unicode \\\\u0041\", \"Valid unicode A\"},\n\t\t{\"Surrogate pair \\\\uD83D\\\\uDE00\", \"Surrogate pair 😀\"},\n\t\t{\"Mixed \\\\uD83D\\\\uDE00 and normal text\", \"Mixed 😀 and normal text\"},\n\t\t{\"Escaped backslash: \\\\\\\\ and escaped quote: \\\\\\\"\", \"Escaped backslash: \\\\ and escaped quote: \\\"\"},\n\t\t{\"No escape sequences here\", \"No escape sequences here\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","19b3a5701e18b77f98195cf754c31c57":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","19cc1c015d27484dc43e312ff7b721be":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","1aa906ed44c98caf0327578912d5774d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"This string has a tab\\\\tcharacter.\", \"This string has a tab\\tcharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\"Hello!\\\\\\\"\", \"Escaped quote: \\\"Hello!\\\"\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Valid unicode: \\\\u0041\", \"Valid unicode: A\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"\\nLine1\\nLine2\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t\t{\"Incomplete unicode: \\\\u123\", \"Incomplete unicode: \\\\u123\"},\n\t\t{\"Unknown escape: \\\\x\", \"Unknown escape: \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","1b0cb5367fdb39bc465b2887e82894b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeNull, \"null\"},\n\t\t{TypeObject, \"\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tif got := test.input.String(); got != test.expected {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // Arbitrary value not defined in Type\n\t_ = unknownType.String() // This should cause a panic\n}","1bca194f17562f1a6b2bfbc4f35dc226":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Error(\"Expected a non-nil value from getValue, got nil\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif cap(c.vs) != 2 {\n\t\tt.Errorf(\"Expected capacity of vs to be 2, got %d\", cap(c.vs))\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Get another value\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Error(\"Expected a non-nil value from getValue, got nil\")\n\t}\n\n\t// Test that the length increases\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Get a third value to test capacity increase\n\tval3 := c.getValue()\n\tif val3 == nil {\n\t\tt.Error(\"Expected a non-nil value from getValue, got nil\")\n\t}\n\n\t// Test that the length increases again\n\tif len(c.vs) != 3 {\n\t\tt.Errorf(\"Expected length of vs to be 3, got %d\", len(c.vs))\n\t}\n\n\t// Test that capacity has increased\n\tif cap(c.vs) \u003c= 3 {\n\t\tt.Errorf(\"Expected capacity of vs to be greater than 3, got %d\", cap(c.vs))\n\t}\n}","1c00ead46802235ac5eed2c1d0ca0b65":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\t// Sample JSON data for testing\n\tjsonData := `{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": {\n\t\t\t\"key3\": \"value3\"\n\t\t},\n\t\t\"array\": [\n\t\t\t{\"key4\": \"value4\"},\n\t\t\t{\"key5\": \"value5\"}\n\t\t]\n\t}`\n\n\t// Parse the JSON data\n\tparser := \u0026Parser{}\n\tv, err := parser.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected []byte\n\t}{\n\t\t{[]string{\"key1\"}, []byte(\"value1\")},\n\t\t{[]string{\"key2\", \"key3\"}, []byte(\"value3\")},\n\t\t{[]string{\"array\", \"0\", \"key4\"}, []byte(\"value4\")},\n\t\t{[]string{\"array\", \"1\", \"key5\"}, []byte(\"value5\")},\n\t\t{[]string{\"nonexistent\"}, nil},\n\t\t{[]string{\"key2\", \"key4\"}, nil}, // Invalid path\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.GetStringBytes(test.keys...)\n\t\tif string(result) != string(test.expected) {\n\t\t\tt.Errorf(\"GetStringBytes(%v) = %s; expected %s\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","1c610a9276eeb78e756f2c509ddd525f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\uXYZ\", \"Mixed: 😀 and \\\\uXYZ\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","1ce43c5fa81158f58acaadeba7b8f216":"// string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"unknown type\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for unknown type, but did not panic\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 999 // An arbitrary value not defined in the Type constants\n\t\tunknownType.String()\n\t})\n}","1d6102038107577e8f368fb5065b7559":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"-invalid\", \"\", \"-invalid\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"0.0.0\", \"0.0\", \".0\", nil},\n\t\t{\"123e\", \"123e\", \"\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","1dca8b16fd1f12843f54c38e028842d2":"// file: value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"Valid uint value\",\n\t\t\tjson:     `{\"value\": 42}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"value\": 42}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tjson:     `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (boolean)\",\n\t\t\tjson:     `{\"value\": true}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested valid uint value\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested non-existing key\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index valid uint value\",\n\t\t\tjson:     `{\"values\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of bounds\",\n\t\t\tjson:     `{\"values\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"values\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetUint(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","1ea4de15947de5848d3c8cf899c4801a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n\n\t// Test for the panic case with an unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // Arbitrary value not defined in Type\n\t_ = unknownType.String() // This should trigger the panic\n}","1ef5dafc5651aab64d7c67dcd23d202e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get from nested object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"nested\", v: \u0026Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"nested\", \"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from nested array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"0\", \"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid index\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"invalid\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Nil input\",\n\t\t\tinput: nil,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.Get(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","2013af45e79fe47fbf01b0eaa4ee45fa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","20b5c1c1a4dfaafd124f9ff342248bef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+10xyz\", \"-123.45e+10\", \"xyz\", nil},\n\t\t{\"inf more text\", \"inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"\", \"\", \"\", nil}, // This case should be handled by the caller\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != \"\" \u0026\u0026 (test.err == nil || err.Error() != test.err.Error())) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","20bdc202f514624e2445ff26eb23a8bf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    Object\n\t\texpected Object\n\t}{\n\t\t{\n\t\t\tname: \"NoEscapedKeys\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"EscapedKeys\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key\\\\1\", v: \u0026Value{}},\n\t\t\t\t\t{k: \"key\\\\2\", v: \u0026Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"AlreadyUnescaped\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{}},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.input.unescapeKeys()\n\t\t\tif !equalObjects(tt.input, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %+v, got %+v\", tt.expected, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalObjects(a, b Object) bool {\n\tif len(a.kvs) != len(b.kvs) || a.keysUnescaped != b.keysUnescaped {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","20c0b47d55f6f1274b8c35f08b22d4a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\"`,\n\t\t\texpectedValue: \"escaped \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"escaped\\\" quotes\" and more`,\n\t\t\texpectedValue: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","20c410e6014f42776532d2abe3f935ad":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\" more text`,\n\t\t\texpectedValue:  \"hello\\\"world\",\n\t\t\texpectedRemainder: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\"`,\n\t\t\texpectedValue:  \"hello\\\"world\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\" \"world\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \" \\\"world\\\"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\world\"`,\n\t\t\texpectedValue:  \"hello\\\\world\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\" \"world\" \"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \" \\\"world\\\" \\\"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `hello\"`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: `hello\"`,\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawString(%q) remainder = %q, expectedRemainder %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","20f4fca86896e8b2a8b5f24aff6e129d":"// unescape_string_best_effort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello,\\\\nWorld!\", \"Hello,\\nWorld!\"},\n\t\t{\"This is a tab:\\\\t\", \"This is a tab:\\t\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Quote: \\\\\"\", \"Quote: \\\"\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\nHello\\\\tWorld\\\\u0021\", \"\\nHello\\tWorld!\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Another incomplete: \\\\uD83D\", \"Another incomplete: \\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2100dd028b870c5605e39b71dc4b7a32":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: typeRawString}}}}, t: TypeObject}}}}}, t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // This should be filled with the expected Value\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) returned error %v, expected %v\", test.input, err, test.err)\n\t\t}\n\t\tif v != nil \u0026\u0026 test.expected != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.input[len(test.input)-len(tail):] {\n\t\t\tt.Errorf(\"parseValue(%q) returned tail %q, expected tail to match input\", test.input, tail)\n\t\t}\n\t}\n}","21563450aa831ddb46cebdbf589fe705":"// string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // Arbitrary value not defined in Type\n\t_ = unknownType.String() // This should cause a panic\n}","219d017f87ef89c0155d62b9adcf69a1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif result.t != test.expected.t || len(result.o.kvs) != len(test.expected.o.kvs) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","21c8b9ab6e61b74c9c277e147ee024f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %q, but got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"for input %q, expected %v, but got %v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"expected no remaining string for input %q, but got %q\", test.input, remaining)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value and its fields.\n\t// This is a placeholder for the actual comparison logic.\n\treturn false\n}","21fe26a1eb0ca3f4d414e14beec4b95b":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal Raw String\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"example\"},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","240bda3681d592206cdcef8ff7978b96":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected nested Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure with array */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\t// Compare result with expected Value (you may need to implement a comparison function)\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances.\n// Implement this function based on the structure of Value.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false // Placeholder\n}","2442be74b57fe2079b5eff0a2bc0c33a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"a\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"truea\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"a\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123a\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"a\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\texpected: nil,\n\t\t\ttail:     `{\"key\": \"value\"`,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif v == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = nil, want %v\", test.input, test.expected)\n\t\t\t} else if v != nil \u0026\u0026 test.expected == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want nil\", test.input, v)\n\t\t\t} else if v != nil \u0026\u0026 test.expected != nil \u0026\u0026 v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","2450389b1bc6ad67b7ef7b1235a62386":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\"`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"world`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"world`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expected %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expected %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","2476caea5205f813f94d185bcf37165b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint64\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint64\",\n\t\t\tjson:     `{\"number\": 1234567890123456789}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 1234567890123456789,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"number\": 123}`,\n\t\t\tkeys:     []string{\"missing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"number\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (bool)\",\n\t\t\tjson:     `{\"number\": true}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 9876543210}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 9876543210,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `{\"numbers\": [1, 2, 3, 4]}`,\n\t\t\tkeys:     []string{\"numbers\", \"2\"},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of range\",\n\t\t\tjson:     `{\"numbers\": [1, 2]}`,\n\t\t\tkeys:     []string{\"numbers\", \"5\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetUint64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","24aa5034a511785e1541e0d1a6b12b78":"// uint_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\texpected  uint\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"valid uint\",\n\t\t\tinput:     \"42\",\n\t\t\texpected:  42,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"valid uint at max value\",\n\t\t\tinput:     \"18446744073709551615\", // uint64 max\n\t\t\texpected:  0, // Expecting error since it doesn't fit in uint\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"negative number\",\n\t\t\tinput:     \"-1\",\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"non-numeric string\",\n\t\t\tinput:     `\"not a number\"`,\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"null value\",\n\t\t\tinput:     \"null\",\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"boolean true\",\n\t\t\tinput:     \"true\",\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"boolean false\",\n\t\t\tinput:     \"false\",\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{s: tt.input, t: TypeNumber} // Mocking the Value struct\n\t\t\tif tt.input == \"null\" {\n\t\t\t\tv.t = TypeNull\n\t\t\t} else if tt.input == \"true\" || tt.input == \"false\" {\n\t\t\t\tv.t = TypeTrue\n\t\t\t}\n\n\t\t\tresult, err := v.Uint()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectErr, err)\n\t\t\t}\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","24e116bdb8eb228efbb3cb4d39692562":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse object: unexpected end of JSON input\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"a\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"t\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"t\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"f\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"f\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"n\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"n\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got none\", test.input, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif v != nil \u0026\u0026 test.expected != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) expected: %+v, got: %+v\", test.input, test.expected, v)\n\t\t}\n\t}\n}","24f6ab7fa227301c86006c63fd2bf228":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for the Get function\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get from nested object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"nested\", v: \u0026Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"nested\", \"key1\"},\n\t\t\texpected: \u0026Value{s: \"nestedValue\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from nested array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{\n\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"0\", \"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid key path\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Nil input\",\n\t\t\tinput: nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","2571a7638b76ad2d74e4411f384573ac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\tparser := \u0026Parser{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[]`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, err := parser.Parse(test.input)\n\n\t\tif (err != nil) != test.hasError {\n\t\t\tt.Errorf(\"Parse(%q) error = %v, wantError %v\", test.input, err, test.hasError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.hasError \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two *Value instances.\n// Implement this function based on the structure of Value.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false // Placeholder\n}","2598149e38f0e0fe920438f700e84475":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\u0026Value{s: \"1\", t: TypeNumber},\n\t\t\t\t\t\u0026Value{s: \"2\", t: TypeNumber},\n\t\t\t\t\t\u0026Value{s: \"3\", t: TypeNumber},\n\t\t\t\t}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value.\n\t// This is a placeholder for the actual comparison logic.\n\treturn true // Replace with actual comparison.\n}","25f24fcc36cc60aec68c7ede89d509c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-infabc\", \"-inf\", \"abc\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")}, // edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","2611c8b38fe13525416c8e88ca98ba23":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                          // Test empty string\n\t\t{\"   \", \"   \"},                    // Test only whitespace\n\t\t{\"  a\", \"a\"},                      // Test leading whitespace\n\t\t{\"\\t\\tb\", \"b\"},                    // Test tab characters\n\t\t{\"\\n\\nc\", \"c\"},                    // Test newline characters\n\t\t{\"   d   \", \"d   \"},              // Test whitespace around a word\n\t\t{\"e   f\", \"e   f\"},                // Test whitespace between words\n\t\t{\"   \\t   g   \", \"g   \"},          // Test mixed whitespace\n\t\t{\"h\", \"h\"},                        // Test single character\n\t\t{\"   \\t \\n i\", \"i\"},               // Test mixed whitespace with newline\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","26212585ff2cf80f2aa004def4351ae6":"// string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %q; want %q\", result, test.expected)\n\t\t}\n\t}\n\n\t// Test for unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // An arbitrary value not defined in Type\n\t_ = unknownType.String() // This should cause a panic\n}","264992c214c752cc47b58bbf20058423":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput *Value\n\t\texpectedError  string\n\t}{\n\t\t{\n\t\t\tinput:         `{}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\texpectedError:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}},\n\t\t\texpectedError:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\texpectedError:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\":}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\",}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  \"missing '}'\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key\": \"value\", \"key2\": \"value2\"}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\texpectedError:  \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  \"cannot parse object value: unexpected end of object\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\toutput, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.expectedError != \"\" {\n\t\t\tif err == nil || err.Error() != test.expectedError {\n\t\t\t\tt.Errorf(\"expected error: %s, got: %v\", test.expectedError, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif output == nil || output.t != test.expectedOutput.t || len(output.o.kvs) != len(test.expectedOutput.o.kvs) {\n\t\t\t\tt.Errorf(\"expected output: %+v, got: %+v\", test.expectedOutput, output)\n\t\t\t}\n\t\t}\n\t}\n}","26e7b14d9c8c2b77c7f3fa7a3edd517c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for true\n\t\t{\"false\", valueFalse, false}, // Test for false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test for object with boolean\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test for object with null\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif result == nil || test.expected == nil {\n\t\t\t\tif result != test.expected {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif result.t != test.expected.t || result.s != test.expected.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","272c0c6a1e68be2b97a6035d445c2919":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`,\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tCharacter\"`,\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash\\\\Character\"`,\n\t\t\texpected: \"Backslash\\\\Character\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u4F60\\u597D\"`,\n\t\t\texpected: \"Unicode: 你好\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid Unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate Pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate Pair: 😀\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped quotes: \\\"Hello\\\"\"`,\n\t\t\texpected: \"Escaped quotes: \\\"Hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed \\uD83D\\uDE00 and \\u4F60\"`,\n\t\t\texpected: \"Mixed 😀 and 你好\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escape characters\"`,\n\t\t\texpected: \"No escape characters\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","27cd5aa55d8e553f006c9edbd010abf8":"// hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalString\", false},\n\t\t{\"stringWith\\\"Quote\", true},\n\t\t{\"stringWith\\\\Backslash\", true},\n\t\t{\"stringWith\\000NullChar\", true},\n\t\t{\"stringWith\\nNewline\", true},\n\t\t{\"stringWith\\tTab\", true},\n\t\t{\"stringWith\\rCarriageReturn\", true},\n\t\t{\"stringWith\\x1FControlChar\", true},\n\t\t{\"\", false}, // empty string should not have special chars\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2806f695f214a4e8dff15db27c43a129":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\tdepth := 0\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected structure should be defined based on actual implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected structure should be defined based on actual implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected structure should be defined based on actual implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected structure should be defined based on actual implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\" \"key3\": \"value3\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, depth)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\t// Additional checks can be added here to compare the structure of `result` with `test.expected`\n\t\t// For example, checking the type and contents of the resulting Value\n\t}\n}","297412639b832349e7f5ce6fcb4c4db4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\" more text`,\n\t\t\texpectedValue:  \"hello\\\"world\",\n\t\t\texpectedRemain: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue:  \"hello\\\\\",\n\t\t\texpectedRemain: \"world\\\" text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"\\\"escaped\\\" quote\"`,\n\t\t\texpectedValue:  \"\\\"escaped\\\" quote\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) remain = %q, expectedRemain = %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","297a10288aca5d542180707ce840f7cb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\n   World\", \"World\"},\n\t\t{\"\\t\\t   Test\", \"Test\"},\n\t\t{\"\\r\\n   Example\", \"Example\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\t\\r\", \"\"},\n\t\t{\"   LeadingSpaces\", \"LeadingSpaces\"},\n\t\t{\"TrailingSpaces   \", \"TrailingSpaces   \"},\n\t\t{\"\\n\\n\\n   Multiple\\n\\n\\nNewLines\", \"Multiple\\n\\n\\nNewLines\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2ac68ec39b10b3df95bc31cb624004c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3, 4, 5]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}, {t: TypeNumber, s: \"4\"}, {t: TypeNumber, s: \"5\"}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i := range result.a {\n\t\t\t\tif result.a[i].t != test.expected[i].t || result.a[i].s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","2ad93eb098464d4bf66381bf823da026":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing object key\",\n\t\t\tjson:     `{\"name\": \"John\"}`,\n\t\t\tkeys:     []string{\"name\"},\n\t\t\texpected: \u0026Value{s: \"John\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key\",\n\t\t\tjson:     `{\"name\": \"John\"}`,\n\t\t\tkeys:     []string{\"age\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing array index\",\n\t\t\tjson:     `{\"users\": [\"Alice\", \"Bob\"]}`,\n\t\t\tkeys:     []string{\"users\", \"1\"},\n\t\t\texpected: \u0026Value{s: \"Bob\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing array index\",\n\t\t\tjson:     `{\"users\": [\"Alice\", \"Bob\"]}`,\n\t\t\tkeys:     []string{\"users\", \"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get nested object key\",\n\t\t\tjson:     `{\"user\": {\"name\": \"John\"}}`,\n\t\t\tkeys:     []string{\"user\", \"name\"},\n\t\t\texpected: \u0026Value{s: \"John\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get nested non-existing key\",\n\t\t\tjson:     `{\"user\": {\"name\": \"John\"}}`,\n\t\t\tkeys:     []string{\"user\", \"age\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from non-object value\",\n\t\t\tjson:     `\"not an object\"`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from null value\",\n\t\t\tjson:     `null`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := \u0026Parser{}\n\t\t\tvalue, err := parser.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tresult := value.Get(tt.keys...)\n\t\t\tif result != nil \u0026\u0026 tt.expected != nil {\n\t\t\t\tif result.s != tt.expected.s || result.t != tt.expected.t {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t} else if (result == nil) != (tt.expected == nil) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","2ae0ecdcd56d387cccfbe4e2f5863e58":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewline\", \"Mixed😀\\nNewline\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"EscapedSlash\\\\/\", \"EscapedSlash/\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2cb611f73ab55538a6a679daf9e960b9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Valid unicode: \\\\u0041\", \"Valid unicode: A\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed: \\\\nNewline and \\\\tTab\", \"\\nNewline and \\tTab\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Another incomplete: \\\\uD83D\", \"Another incomplete: \\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2cbc97769b8869a07f477d36c29e51d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}, t: TypeObject}, false}, // Test object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}, t: TypeObject}, false}, // Test object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}, t: TypeObject}, false}, // Test object with number value\n\t\t{\"{\\\"key\\\":\\\"value\\\", \\\"array\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"array\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, t: TypeObject}, false}, // Test complex object\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %+v, want %+v\", test.input, v, test.expected)\n\t\t}\n\t}\n}","2cc3b709604c5951ce3e82ebc9f8d8ad":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"subkey\", v: \u0026Value{s: \"subvalue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t} else if test.expected != nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want empty\", test.input, remaining)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value.\n\t// This is a placeholder for the actual comparison logic.\n\treturn false\n}","2ceadea7d3d22fb61a883ee6a8978095":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+10more\", \"-123.45e+10\", \"more\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"For input %q, expected number: %q, remaining: %q, got number: %q, remaining: %q\", \n\t\t\t\ttest.input, test.expectedNumber, test.expectedRemaining, number, remaining)\n\t\t}\n\n\t\tif (err != nil) != (test.expectedError != nil) {\n\t\t\tt.Errorf(\"For input %q, expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t} else if err != nil \u0026\u0026 err.Error() != test.expectedError.Error() {\n\t\t\tt.Errorf(\"For input %q, expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t}\n}","2d5f2487d64d711a19307d18f38dabf3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"0.123\", \"0.123\", \"\", nil},\n\t\t{\"inf more text\", \"inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\n\t\tif num != test.expectedNum || rest != test.expectedRest || (err != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", \n\t\t\t\ttest.input, num, rest, err, test.expectedNum, test.expectedRest, test.expectedErr)\n\t\t}\n\t}\n}","2d6e38d353e304097ec83f3d45819f1d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": 3}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\t// Add assertions to compare the expected Value with the result\n\t\t}\n\n\t\t// Check if remaining string is as expected\n\t\tif test.err \u0026\u0026 remaining != test.input {\n\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want %q\", test.input, remaining, test.input)\n\t\t}\n\t}\n}","2df992bd75b18193a3fe156e4b85d482":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"infxyz\", \"inf\", \"xyz\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","2e1e87a1802ab10a8d0fff9413ec247c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uXYZ\", \"Mixed😀\\\\uXYZ\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2e2c86f97ac7952a6d612a1dfbcc2116":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as needed\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{t: TypeArray}, // Adjust expected value as needed\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{t: TypeString, s: \"string\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `true`,\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `false`,\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `null`,\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `123.45`,\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as needed\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as needed\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": \"unexpected\"}`,\n\t\t\texpected: nil,\n\t\t\ttail:     `{\"key\": \"value\", \"nested\": \"unexpected\"}`,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\", \"unexpected\": \"unexpected\"}}`,\n\t\t\texpected: nil,\n\t\t\ttail:     `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\", \"unexpected\": \"unexpected\"}}`,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\", \"unexpected\": \"unexpected\"}}`,\n\t\t\texpected: nil,\n\t\t\ttail:     `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\", \"unexpected\": \"unexpected\"}}`,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 !compareValues(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances.\n// You may need to implement this function based on your Value structure.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\treturn false // Placeholder\n}","2f909e3670e0008a815b20c6f7e8a3a7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","2fa92d72de8793804a62897e8d2d73f2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %q; want %q\", result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // An invalid type\n\t_ = unknownType.String()  // This should cause a panic\n}","2fb0fc2eb32e058ac2dd842299b25569":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tinput:    parseJSON(`{\"key\": \"value\"}`), // Assume parseJSON is a helper function to create a Value from JSON string\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: parseJSON(`\"value\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key from object\",\n\t\t\tinput:    parseJSON(`{\"key\": \"value\"}`),\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing index from array\",\n\t\t\tinput:    parseJSON(`[1, 2, 3]`),\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: parseJSON(`2`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing index from array\",\n\t\t\tinput:    parseJSON(`[1, 2, 3]`),\n\t\t\tkeys:     []string{\"3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested object\",\n\t\t\tinput:    parseJSON(`{\"outer\": {\"inner\": \"value\"}}`),\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: parseJSON(`\"value\"`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested array\",\n\t\t\tinput:    parseJSON(`{\"array\": [1, 2, 3]}`),\n\t\t\tkeys:     []string{\"array\", \"2\"},\n\t\t\texpected: parseJSON(`3`),\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid key type\",\n\t\t\tinput:    parseJSON(`{\"key\": 123}`),\n\t\t\tkeys:     []string{\"key\", \"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif !valuesEqual(got, tt.expected) { // Assume valuesEqual is a helper function to compare Value objects\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","2fe3ae84a715a014fd4df63781c671e4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"t\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"t\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"f\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"f\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"n\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"n\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif v == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = nil, want %v\", test.input, test.expected)\n\t\t\t} else if v != nil \u0026\u0026 test.expected == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want nil\", test.input, v)\n\t\t\t} else if v != nil \u0026\u0026 test.expected != nil \u0026\u0026 *v != *test.expected {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","2ff1850ae86de1ccc21484979242f638":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","2ff24b4095c848855256487499af5870":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: \u0026Value{s: \"value\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\tkeys:     []string{\"key1\", \"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": {\"key3\": \"value\"}}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"key3\"},\n\t\t\texpected: \u0026Value{s: \"value\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from array by index\",\n\t\t\tinput:    `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: \u0026Value{s: \"value2\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from array with non-numeric key\",\n\t\t\tinput:    `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from empty object\",\n\t\t\tinput:    `{}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nil value\",\n\t\t\tinput:    `null`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse input: %v\", err)\n\t\t\t}\n\t\t\tgot := v.Get(tt.keys...)\n\t\t\tif got == nil \u0026\u0026 tt.expected != nil {\n\t\t\t\tt.Errorf(\"expected %v, got nil\", tt.expected)\n\t\t\t} else if got != nil \u0026\u0026 tt.expected == nil {\n\t\t\t\tt.Errorf(\"expected nil, got %v\", got)\n\t\t\t} else if got != nil \u0026\u0026 tt.expected != nil \u0026\u0026 got.String() != tt.expected.String() {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected.String(), got.String())\n\t\t\t}\n\t\t})\n\t}\n}","2ff422ba8ebbc2fbda9512c1f666199b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tinput:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}}}},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key from object\",\n\t\t\tinput:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}}}},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing index from array\",\n\t\t\tinput:    \u0026Value{t: TypeArray, a: []*Value{{s: \"value0\"}, {s: \"value1\"}}},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing index from array\",\n\t\t\tinput:    \u0026Value{t: TypeArray, a: []*Value{{s: \"value0\"}, {s: \"value1\"}}},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested object\",\n\t\t\tinput:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"nestedValue\"}}}}}}}}}},\n\t\t\tkeys:     []string{\"nested\", \"key\"},\n\t\t\texpected: \u0026Value{s: \"nestedValue\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested array\",\n\t\t\tinput:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"array\", v: \u0026Value{t: TypeArray, a: []*Value{{s: \"value0\"}, {s: \"value1\"}}}}}}}},\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type access\",\n\t\t\tinput:    \u0026Value{t: TypeString, s: \"not an object or array\"},\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil input\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif (got == nil \u0026\u0026 tt.expected != nil) || (got != nil \u0026\u0026 tt.expected == nil) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, got)\n\t\t\t} else if got != nil \u0026\u0026 got.s != tt.expected.s {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected.s, got.s)\n\t\t\t}\n\t\t})\n\t}\n}","303ad9d4dc410347d2cbd3bf7c648fec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test initial state\n\tkv1 := obj.getKV()\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Test adding first kv\n\tkv1.k = \"key1\"\n\tkv1.v = \u0026Value{} // Assuming Value can be initialized like this\n\tkv2 := obj.getKV()\n\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n\n\t// Test that kv1 is still accessible\n\tif obj.kvs[0].k != \"key1\" {\n\t\tt.Errorf(\"Expected kv[0].k to be 'key1', got: %s\", obj.kvs[0].k)\n\t}\n\n\t// Test adding second kv\n\tkv2.k = \"key2\"\n\tkv2.v = \u0026Value{} // Assuming Value can be initialized like this\n\tkv3 := obj.getKV()\n\n\tif kv3.k != \"\" || kv3.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %v\", kv3.k, kv3.v)\n\t}\n\n\t// Test that kv2 is still accessible\n\tif obj.kvs[1].k != \"key2\" {\n\t\tt.Errorf(\"Expected kv[1].k to be 'key2', got: %s\", obj.kvs[1].k)\n\t}\n\n\t// Test the capacity and length of kvs\n\tif len(obj.kvs) != 3 {\n\t\tt.Errorf(\"Expected length of kvs to be 3, got: %d\", len(obj.kvs))\n\t}\n}","303b207c74ac5ea4ce5afbb436c3bd7f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // Arbitrary value not defined in Type constants\n\t_ = unknownType.String() // This should cause a panic\n}","3054603d186f99fd6bc0c1c19a1e5682":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3081f2b7867988b78d42025b66c8cccd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"0.123\", \"0.123\", \"\", false},\n\t\t{\"-0.456e-2\", \"-0.456e-2\", \"\", false},\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"abc123\", \"\", \"abc123\", true}, // Invalid number\n\t\t{\"-abc\", \"\", \"-abc\", true},      // Invalid number\n\t\t{\"\", \"\", \"\", true},               // Empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want error = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, want %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","30a6bbea29b047461f96d6422567f1ed":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 123,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tinput:    `{\"key\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (array)\",\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key\",\n\t\t\tinput:    `{\"outer\": {\"inner\": 456}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 456,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tinput:    `{\"key\": [0, 1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of bounds\",\n\t\t\tinput:    `{\"key\": [0, 1, 2]}`,\n\t\t\tkeys:     []string{\"key\", \"5\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := parseValue(tt.input, nil, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse input: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","31708e9592fc730726c6da06f0a4e763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\t// Sample JSON data for testing\n\tjsonData := []byte(`{\n\t\t\"key1\": {\n\t\t\t\"subkey1\": \"value1\"\n\t\t},\n\t\t\"key2\": {\n\t\t\t\"subkey2\": \"value2\"\n\t\t},\n\t\t\"array\": [\n\t\t\t{\n\t\t\t\t\"subkey3\": \"value3\"\n\t\t\t}\n\t\t]\n\t}`)\n\n\t// Parse the JSON data\n\tparser := \u0026Parser{}\n\tv, err := parser.ParseBytes(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\t// Test cases\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: v.GetObject(\"key1\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: v.GetObject(\"key2\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"array\", \"0\"},\n\t\t\texpected: v.GetObject(\"array\", \"0\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"key1\", \"subkey1\"},\n\t\t\texpected: v.GetObject(\"key1\", \"subkey1\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.GetObject(test.keys...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"GetObject(%v) = %v; want %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","333e884dc25e2d7b7f3d4f1c2e529dc0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\"`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"more\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"more\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"world`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"world`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\"more\"`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \"more\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","33bbc286c9451caee7ebaaf46dcc21c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object instance\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", nil},\n\t\t\t{\"key2\", nil},\n\t\t\t{\"key3\", nil},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Check the initial length of kvs\n\tif len(obj.kvs) != 3 {\n\t\tt.Fatalf(\"expected kvs length to be 3, got %d\", len(obj.kvs))\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Check the length of kvs after reset\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"expected kvs length to be 2 after reset, got %d\", len(obj.kvs))\n\t}\n\n\t// Check if keysUnescaped remains unchanged\n\tif obj.keysUnescaped != true {\n\t\tt.Fatalf(\"expected keysUnescaped to be true, got %v\", obj.keysUnescaped)\n\t}\n\n\t// Call reset again\n\tobj.reset()\n\n\t// Check the length of kvs after second reset\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"expected kvs length to be 1 after second reset, got %d\", len(obj.kvs))\n\t}\n\n\t// Call reset again\n\tobj.reset()\n\n\t// Check the length of kvs after third reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected kvs length to be 0 after third reset, got %d\", len(obj.kvs))\n\t}\n\n\t// Call reset on an already empty kvs\n\tobj.reset()\n\n\t// Check the length of kvs remains 0\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected kvs length to remain 0 after reset, got %d\", len(obj.kvs))\n\t}\n}","34b7165e20b8f325f1cd12eb03dfd9f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    string\n\t\texpected int\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tvalue:    \"42\",\n\t\t\texpected: 42,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid negative int\",\n\t\t\tvalue:    \"-42\",\n\t\t\texpected: -42,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid int that fits in int\",\n\t\t\tvalue:    \"2147483647\", // Max int32\n\t\t\texpected: 2147483647,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid int that exceeds int\",\n\t\t\tvalue:    \"2147483648\", // Exceeds int32\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"not a number\",\n\t\t\tvalue:    `\"not a number\"`,\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tvalue:    \"null\",\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{s: tt.value, t: TypeNumber} // Simulate a Value with the given JSON string and type\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Int() = %v, expected %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","34e720be16f6ed3adf8118013d3b1dfe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"{}\",\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\" \"key2\": 42}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remain, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif result != nil \u0026\u0026 !compareValues(result, test.expectedValue) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, expectedValue = %v\", test.input, result, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseObject(%q) remain = %q, expectedRemain = %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value and its fields.\n\t// This is a placeholder for the actual comparison logic.\n\treturn false\n}","352054701a05c0ea76f056039ee028d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewline\", \"Mixed😀\\nNewline\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Escaped\\\\/Slash\", \"Escaped/Slash\"},\n\t\t{\"InvalidEscape\\\\x\", \"InvalidEscape\\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","36b8bc01cb6a97aac3ef6a838c4f1a2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"EscapedSlash\\\\/\", \"EscapedSlash/\"},\n\t\t{\"Multiple\\\\nEscapes\\\\tHere\", \"Multiple\\nEscapes\\tHere\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","387bddf6b1481bddeded9525ddd43a5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode \\\\u0041\", \"Unicode A\"},\n\t\t{\"Invalid Unicode \\\\uXYZ\", \"Invalid Unicode \\\\uXYZ\"},\n\t\t{\"Surrogate \\\\uD83D\\\\uDE00\", \"Surrogate 😀\"},\n\t\t{\"Mixed \\\\n\\\\t\\\\u0041\", \"Mixed \\n\\tA\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t\t{\"Incomplete \\\\u\", \"Incomplete \\\\u\"},\n\t\t{\"Incomplete \\\\uD83D\", \"Incomplete \\\\uD83D\"},\n\t\t{\"Incomplete \\\\uD83D\\\\u\", \"Incomplete \\\\uD83D\\\\\"},\n\t\t{\"Invalid escape \\\\x\", \"Invalid escape \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","39322df48baace138a017c3d3bc1d3b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\t// Test cases for GetArray function\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected []*Value\n\t}{\n\t\t{\n\t\t\tname:     \"Valid array path\",\n\t\t\tinput:    `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"array\"},\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, a: nil, s: \"1\"}, \u0026Value{t: TypeNumber, a: nil, s: \"2\"}, \u0026Value{t: TypeNumber, a: nil, s: \"3\"}},\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing path\",\n\t\t\tinput:    `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type\",\n\t\t\tinput:    `{\"not_array\": \"string\"}`,\n\t\t\tkeys:     []string{\"not_array\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested array\",\n\t\t\tinput:    `{\"nested\": {\"array\": [4, 5, 6]}}`,\n\t\t\tkeys:     []string{\"nested\", \"array\"},\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, a: nil, s: \"4\"}, \u0026Value{t: TypeNumber, a: nil, s: \"5\"}, \u0026Value{t: TypeNumber, a: nil, s: \"6\"}},\n\t\t},\n\t\t{\n\t\t\tname:     \"Array with decimal index\",\n\t\t\tinput:    `{\"array\": [7, 8, 9]}`,\n\t\t\tkeys:     []string{\"array\", \"0\"},\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, a: nil, s: \"7\"}},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := \u0026Parser{}\n\t\t\tvalue, err := parser.Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse input: %v\", err)\n\t\t\t}\n\n\t\t\tresult := value.GetArray(tt.keys...)\n\t\t\tif !equalArrays(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalArrays(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i].s != b[i].s || a[i].t != b[i].t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","3a0ad62efe4f25d6536920f0034c4190":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\uXYZ\", \"Mixed: 😀 and \\\\uXYZ\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3a398eada6bb87a5c52c84d718887602":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected *Object\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid Object\",\n\t\t\tvalue:    \u0026Value{o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}}}, t: TypeObject},\n\t\t\texpected: \u0026Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type - Not Object\",\n\t\t\tvalue:    \u0026Value{s: \"not an object\", t: TypeString},\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty Object\",\n\t\t\tvalue:    \u0026Value{o: Object{kvs: []kv{}}, t: TypeObject},\n\t\t\texpected: \u0026Object{kvs: []kv{}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nil Value\",\n\t\t\tvalue:    nil,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.value.Object()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Object() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !reflect.DeepEqual(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Value.Object() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","3aaf7a1aae8189f0ac66ba79a7f3d3ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"example\",\n\t\t\t},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","3b184aa717383a10e0642287c3ad0201":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"for input %q, expected %d values, got %d\", test.input, len(test.expected), len(result.a))\n\t\t}\n\n\t\tfor i, expectedValue := range test.expected {\n\t\t\tif result.a[i].s != expectedValue.s || result.a[i].t != expectedValue.t {\n\t\t\t\tt.Errorf(\"for input %q, expected value %v at index %d, got %v\", test.input, expectedValue, i, result.a[i])\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"]\" {\n\t\t\tt.Errorf(\"for input %q, expected remaining string to be ']', got %q\", test.input, remaining)\n\t\t}\n\t}\n}","3c43fd358c0d29f9399e5e3093638908":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\t\\tHello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\n\\r\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\", \"\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   Leading spaces\", \"Leading spaces\"},\n\t\t{\"Trailing spaces   \", \"Trailing spaces   \"},\n\t\t{\"\\t\\t\\t\\t\", \"\"},\n\t\t{\"\\n\\n\\n\\n\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3c5d58b5438759a28be54d5c21c2f82c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Array(t *testing.T) {\n\t// Test cases for the Array method\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected []*Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid array\",\n\t\t\tinput:    \u0026Value{t: TypeArray, a: []*Value{{}, {}}},\n\t\t\texpected: []*Value{{}, {}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"not an array type\",\n\t\t\tinput:    \u0026Value{t: TypeObject},\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\texpected: []*Value{},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.input.Array()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Value.Array() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !equalValueSlices(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Value.Array() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare slices of *Value\nfunc equalValueSlices(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","3c85e974218694a7de9cb13fa4be2f63":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\": [true, false]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse}, t: TypeArray}}}}}, false}, // Test object with array\n\t\t{\"{\\\"key\\\": null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test object with null\n\t\t{\"{\\\"key\\\": {\\\"nested\\\": \\\"value\\\"}}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{s: \"value\", t: TypeString}}}}}}}}}, false}, // Test nested object\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif !tt.err \u0026\u0026 !compareValues(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\t// This is a placeholder for the actual comparison logic\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t // Simplified comparison\n}","3d1a0785dcf3d2378895c989662c217c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tinput:    `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid int as string\",\n\t\t\tinput:    `{\"key\": \"42\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0, // Expecting 0 because it's a string\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tinput:    `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (bool)\",\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (array)\",\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key\",\n\t\t\tinput:    `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tinput:    `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array index\",\n\t\t\tinput:    `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"invalid\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v Value\n\t\t\t// Assuming a function ParseBytes exists to parse the input JSON string\n\t\t\tif _, err := ParseBytes([]byte(tt.input)); err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse input: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","3d2d4a89f500c5677c5352bea33edf13":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\tif remaining != \"\" \u0026\u0026 test.err == false {\n\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want empty\", test.input, remaining)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value objects\n\t// This is a placeholder for the actual comparison logic\n\treturn false\n}","3d6e3f3ce2b90894ed5585626a6d5265":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"normal string\", \"\\\"normal string\\\"\"},\n\t\t{\"string with newline\\n\", \"\\\"string with newline\\\\n\\\"\"},\n\t\t{\"string with tab\\t\", \"\\\"string with tab\\\\t\\\"\"},\n\t\t{\"string with backslash\\\\\", \"\\\"string with backslash\\\\\\\\\\\"\"},\n\t\t{\"string with quote\\\"\", \"\\\"string with quote\\\\\\\"\\\"\"},\n\t\t{\"\", \"\\\"\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := escapeString(nil, test.input)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"escapeString(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3d8f6ad0ab0bfb926e53c4a95ced9ccd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got[%d] = %v, want %v\", test.input, i, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3f31a54f585efbbec2a16c87a8cbe8e0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got length = %d, want %d\", test.input, len(result.a), len(test.expected))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3f357661c008ff56cdc0f9cfad225fac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected bool\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"true value\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: true,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false value\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: false,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number value\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string value\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"object value\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array value\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := tt.value.Bool()\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","3f7572e75236edb893fcc23f31599964":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"\\nLine1\\nLine2\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Escaped slash: \\\\/\", \"Escaped slash: /\"},\n\t\t{\"Escaped backslash: \\\\\\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","40a195db240c45247c569f188288dc15":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","40bce8756653a7f7b2a826f9d1e70a02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      false, // This should be valid\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif result.t != test.expected.t || len(result.o.kvs) != len(test.expected.o.kvs) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) did not consume all input, remaining: %q\", test.input, remaining)\n\t\t}\n\t}\n}","41702ffcac5eb63c344593da8804a2ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped\\\\\"`,\n\t\t\texpectedValue: \"escaped\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"double \\\" escape \\\\\"`,\n\t\t\texpectedValue: \"double \\\" escape \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","418c69497f59b9f493827f62e95a9c11":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"existing true value\",\n\t\t\tjson:     `{\"key1\": true}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"existing false value\",\n\t\t\tjson:     `{\"key1\": false}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"key1\": true}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"key1\": \"true\"}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (number)\",\n\t\t\tjson:     `{\"key1\": 1}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key with true value\",\n\t\t\tjson:     `{\"key1\": {\"key2\": true}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key with non-existing key\",\n\t\t\tjson:     `{\"key1\": {\"key2\": true}}`,\n\t\t\tkeys:     []string{\"key1\", \"key3\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index with true value\",\n\t\t\tjson:     `{\"key1\": [false, true]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index with non-existing index\",\n\t\t\tjson:     `{\"key1\": [false, true]}`,\n\t\t\tkeys:     []string{\"key1\", \"2\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse([]byte(tt.json))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetBool(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","41eed9330e6f62c05d39e701011084a6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"42abc\", \"42\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", nil}, // This case assumes len(s) \u003e 0 is ensured by the caller\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","42a4581e9bcb47c9cae323e224321838":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"expected %s, got %s\", test.expected, result)\n\t\t}\n\t}\n}","4317dd94c9c81cdfc7394fab018fe2c2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45\", \"-123.45\", \"\", false},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nan123\", \"nan\", \"123\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", false}, // This case assumes len(s) \u003e 0 is ensured by the caller\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expectedNumber = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expectedRemaining = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","438cdd38c430e24205d861b12ce862a1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","43f05169bea4b18464c3beff0572b019":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedOutput: \"hello\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello world\"`,\n\t\t\texpectedOutput: \"hello world\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped \\\" quote\"`,\n\t\t\texpectedOutput: \"escaped \\\" quote\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"unmatched quote`,\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped \\\\\"`,\n\t\t\texpectedOutput: \"escaped \\\\\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"multiple \\\"escaped\\\" quotes\"`,\n\t\t\texpectedOutput: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif output != test.expectedOutput {\n\t\t\tt.Errorf(\"parseRawString(%q) output = %q, expectedOutput %q\", test.input, output, test.expectedOutput)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawString(%q) remainder = %q, expectedRemainder %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","446abaebeeef376ebc93226303f531ed":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\t// Compare the result with expected Value structure\n\t\t\t// You may need to implement a function to compare Value objects\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects.\n// You will need to implement this function based on the structure of Value.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false // Placeholder return\n}","45e9f90038c7ac1a7282335fc1180fe8":"// file: object_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\t// Create a new Object instance\n\tobj := \u0026Object{}\n\n\t// Test the initial state of kvs\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs length to be 0, got %d\", len(obj.kvs))\n\t}\n\n\t// Call getKV and check the state after the first call\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Error(\"Expected to get a non-nil kv after calling getKV\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length to be 1 after first call, got %d\", len(obj.kvs))\n\t}\n\n\t// Check the values of the first kv\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected kv to have default values, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Call getKV again and check the state\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Error(\"Expected to get a non-nil kv after calling getKV again\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2 after second call, got %d\", len(obj.kvs))\n\t}\n\n\t// Check the values of the second kv\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected kv to have default values, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n\n\t// Ensure that kv1 and kv2 are different instances\n\tif kv1 == kv2 {\n\t\tt.Error(\"Expected kv1 and kv2 to be different instances\")\n\t}\n}","46016ef0a20258ffb65f7446c875b298":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances.\n// Implement this function based on the structure of Value.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false\n}","474587a46759d9c9af305ffe6abc10cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tinput          Object\n\t\texpectedUnescaped bool\n\t}{\n\t\t{\n\t\t\tname: \"Test with keys already unescaped\",\n\t\t\tinput: Object{\n\t\t\t\tkvs:           []kv{{k: \"key1\", v: \u0026Value{}}},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with keys needing unescaping\",\n\t\t\tinput: Object{\n\t\t\t\tkvs:           []kv{{k: \"key2\", v: \u0026Value{}}},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with multiple keys needing unescaping\",\n\t\t\tinput: Object{\n\t\t\t\tkvs:           []kv{{k: \"key3\", v: \u0026Value{}}, {k: \"key4\", v: \u0026Value{}}},\n\t\t\t\tkeysUnescaped: false,\n\t\t\t},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.input.unescapeKeys()\n\t\t\tif tt.input.keysUnescaped != tt.expectedUnescaped {\n\t\t\t\tt.Errorf(\"expected keysUnescaped to be %v, got %v\", tt.expectedUnescaped, tt.input.keysUnescaped)\n\t\t\t}\n\t\t})\n\t}\n}","4778417afe75368a35b2b6f4f35fc985":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Errorf(\"parseArray(%q) returned unexpected error: %v\", test.input, err)\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got none\", test.input, test.err)\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"parseArray(%q) expected length: %d, got: %d\", test.input, len(test.expected), len(result.a))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i := range result.a {\n\t\t\tif result.a[i].s != test.expected[i].s || result.a[i].t != test.expected[i].t {\n\t\t\t\tt.Errorf(\"parseArray(%q) expected value: %+v, got: %+v\", test.input, test.expected[i], result.a[i])\n\t\t\t}\n\t\t}\n\t}\n}","47a7a73c5d932bf8413c1aa7692b5419":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty JSON object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty JSON array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for boolean true\n\t\t{\"false\", valueFalse, false}, // Test for boolean false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for JSON object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for JSON array\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test for JSON object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test for JSON object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test for JSON object with number value\n\t\t{\"{\\\"key\\\":\\\"value\\\", \\\"array\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"array\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}}, false}, // Test for complex JSON object\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\t// This is a placeholder; actual implementation may vary based on Value structure\n\treturn v1.t == v2.t \u0026\u0026 v1.s == v2.s \u0026\u0026 len(v1.a) == len(v2.a) // Simplified comparison\n}","47b28de27696c7d835e66559172d7cdc":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"escaped \\\"string\\\"\",\n\t\t\t},\n\t\t\texpected: `\"escaped \\\"string\\\"\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","482458ac461af40cdb53b92e922369b7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","48320e961bd2d8c9a3735fa076ff65ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for the default case which should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // Arbitrary value not defined in Type\n\tunknownType.String()\n}","48615e4e0f80b59be18ffb71c44492a6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for true\n\t\t{\"false\", valueFalse, false}, // Test for false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"nan\", \u0026Value{s: \"nan\", t: TypeNumber}, false}, // Test for NaN\n\t\t{\"{ \\\"key\\\": \\\"value\\\" }\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value types\n\t// This is a placeholder for the actual comparison logic\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t\n}","487b4d87b952e68219b21d44a1371cea":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q)[%d] = %v, want %v\", test.input, i, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","48c9e62e37da97e070e59a6c5e30e526":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput *Value\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"{}\",\n\t\t\texpectedOutput: \u0026Value{t: TypeObject},\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject}, // You would need to set the expected output correctly\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 2,}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\"`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject}, // You would need to set the expected output correctly\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\toutput, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif output != nil \u0026\u0026 test.expectedOutput != nil {\n\t\t\t// You may want to compare the actual contents of the Value here\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseObject(%q) remainder = %q, expectedRemainder = %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","48d318ea87ed8fe26689b887bc8fd3c8":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                             // empty string\n\t\t{\"  Hello\", \"Hello\"},                 // leading spaces\n\t\t{\"\\n\\nWorld\", \"World\"},               // leading newlines\n\t\t{\"\\t\\tTest\", \"Test\"},                 // leading tabs\n\t\t{\"\\r\\n\\r\\nExample\", \"Example\"},      // leading carriage returns\n\t\t{\"   \\t   Text with spaces\", \"Text with spaces\"}, // mixed spaces and text\n\t\t{\"NoLeadingSpaces\", \"NoLeadingSpaces\"}, // no leading whitespace\n\t\t{\"   \", \"\"},                          // only spaces\n\t\t{\"\\n\\t\\r  \", \"\"},                    // only whitespace characters\n\t\t{\"\\tHello World\", \"Hello World\"},     // tab before text\n\t\t{\"\\n\\n\\n\\nNewline Test\", \"Newline Test\"}, // multiple newlines\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","49c1fd950447c90d34f273d87ba7c002":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\t// Additional check for remaining string\n\t\tif err == nil \u0026\u0026 remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) did not consume all input, remaining: %q\", test.input, remaining)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value and its fields.\n\t// This is a placeholder for the actual comparison logic.\n\treturn false\n}","4b129ab98d5c4c731411a79d4a5f508e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\t   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\r   Hello, World!\", \"Hello, World!\"},\n\t\t{\"   \\n\\t\\r   \", \"\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\t\\r\", \"\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","4b87cd4d52570dab9666b264f36b07db":"// string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"unknown type\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for unknown Type\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 100 // An arbitrary value not defined in the constants\n\t\tunknownType.String()\n\t})\n}","4bfd353ce394104c3e5e7330f2d8c37e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" extra`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" extra\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\\\"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","4cdd623a302712e4419ad2c3a2c97876":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\"world\\\"!\"`,\n\t\t\texpectedValue: \"hello \\\"world\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"!\"`,\n\t\t\texpectedValue: \"hello \\\\\\\"world\\\\\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\\\"world\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","4d0122a553f10d32bc49513bf0d9a989":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"This is a string with a tab\\\\tcharacter.\", \"This is a string with a tab\\tcharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\\\\u0042\\\\u0043\", \"Unicode: ABC\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"No escape characters here.\", \"No escape characters here.\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\", \\\\u003Cworld\\\\u003E\", \"\\\"Hello\\\", \u003cworld\u003e\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","4f4491cb7c5cc7f58615a05c592dd536":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"not_a_json\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"not_a_json\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + string(make([]byte, 1024)), // Exceeding max depth\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif !compareValues(v, test.expected) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t\tif tail != test.tail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function for Value types\n\t// This is a placeholder and should be implemented according to the structure of Value\n\treturn false\n}","4fc89e3a630b8e550765596372d584cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello,\\\\nWorld!\", \"Hello,\\nWorld!\"},\n\t\t{\"Escape: \\\\\\\"Quotes\\\\\\\" and \\\\\\\\Backslashes\\\\\\\\\", \"Escape: \\\"Quotes\\\" and \\\\Backslashes\\\\\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"Mixed: \\nLine1\\nLine2\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Valid escape: \\\\tTab\", \"Valid escape: \\tTab\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","503f3922e45e669920f6725150e5602b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"extra\": \"data\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value types\n\treturn false // Placeholder return\n}","507ed88071a072bb161e39e02811a740":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                          // empty string\n\t\t{\"   hello\", \"hello\"},            // leading spaces\n\t\t{\"\\n\\nhello\", \"hello\"},           // leading newlines\n\t\t{\"\\t\\thello\", \"hello\"},           // leading tabs\n\t\t{\"\\r\\rhello\", \"hello\"},           // leading carriage returns\n\t\t{\"   \\n\\t\\rhello\", \"hello\"},      // mixed whitespace\n\t\t{\"hello\", \"hello\"},                // no leading whitespace\n\t\t{\"   \", \"\"},                       // only spaces\n\t\t{\"\\n\\n\", \"\"},                      // only newlines\n\t\t{\"\\t\\t\", \"\"},                      // only tabs\n\t\t{\"\\r\\r\", \"\"},                      // only carriage returns\n\t\t{\"   \\n\\t\\r\", \"\"},                 // mixed whitespace only\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","51623eafceb80d06c6bf0fcefe4a047b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %q, got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"for input %q, expected %d values, got %d\", test.input, len(test.expected), len(result.a))\n\t\t}\n\n\t\tfor i, v := range result.a {\n\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\tt.Errorf(\"for input %q, expected value %v, got %v\", test.input, test.expected[i], v)\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"for input %q, expected remaining string to be empty, got %q\", test.input, remaining)\n\t\t}\n\t}\n}","51deb49920dfc6e510077a17df92cc0a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{t: TypeArray}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string\\\"\",\n\t\t\texpected: \u0026Value{t: TypeString, s: \"string\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"nan\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\", \\\"key2\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\", \\\"key2\\\": [1, 2, 3], \\\"key3\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as per actual implementation\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 result.t != test.expected.t {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","51eb580ec9a46535500e7d56e243aafa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5247ae134bd05d190a83b85d60a407ce":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value should be set according to the actual parsing logic\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual parsing logic\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: nil, // Expected value should be set according to the actual parsing logic\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"innerKey\": \"innerValue\"}}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual parsing logic\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"invalid\": {}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"innerKey\": \"innerValue\"}}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual parsing logic\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif (err != nil) != test.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", test.err, err)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 result != nil \u0026\u0026 test.expected != nil {\n\t\t\t\t// Compare expected and actual values (this may need to be adjusted based on Value's equality)\n\t\t\t\tif result.s != test.expected.s || result.t != test.expected.t {\n\t\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", test.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","526d23c85d09e89c801d9123b00e9a9b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\n new line\", \"Mixed: 😀 and \\n new line\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"Backslash before quote: \\\\\\\"\", \"Backslash before quote: \\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","528a2d825a6aee6a7ac7a372fbecd8b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","52b69c67d9b989e8d08cb882093db87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get from nested object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"nested\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"nested\", \"key1\"},\n\t\t\texpected: \u0026Value{s: \"nestedValue\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid path returns nil\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid type returns nil\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"not an object or array\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif (got == nil \u0026\u0026 tt.expected != nil) || (got != nil \u0026\u0026 tt.expected == nil) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, got)\n\t\t\t} else if got != nil \u0026\u0026 got.s != tt.expected.s {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected.s, got.s)\n\t\t\t}\n\t\t})\n\t}\n}","52d2cdb7fd59ff3333585b77492b3dac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected nested Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected empty object Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure with array */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure with boolean */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare expected and actual Value structures.\n// Implement this function based on your Value structure comparison needs.\nfunc compareValues(a, b *Value) bool {\n\t// Implement comparison logic here\n\treturn true // Placeholder\n}","52f0859c0121dc670dfa3c6394572777":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type\")\n\t\t}\n\t}()\n\n\tvar unknownType Type = 8 // Assuming 8 is an unknown type\n\t_ = unknownType.String() // This should cause a panic\n}","53998db868a67109c659274b129aa427":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","53b23725d802bd896fea42c9c410de4c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true false\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123abc\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif err == nil \u0026\u0026 tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want empty\", test.input, tail)\n\t\t}\n\t}\n}","54d21dbd2f396078b3efb6b6942aa1c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello \\\"world\\\"!\"`,\n\t\t\texpectedValue:  \"hello \\\"world\\\"!\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\\\"world\\\"`,\n\t\t\texpectedValue:  \"hello\\\\\\\"world\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\" \"world\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \" \\\"world\\\"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `hello\"world\"`,\n\t\t\texpectedValue:  `hello`,\n\t\t\texpectedRemainder: `\"world\"`,\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) expected value: %q, got: %q\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawString(%q) expected remainder: %q, got: %q\", test.input, test.expectedRemainder, remainder)\n\t\t}\n\t}\n}","55ab33cd70885a9d7bec39d7c6952a4f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"inner\": \"value\"}}`,\n\t\t\texpected: nil, // Expected value should be set according to the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"t\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"t\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"f\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"f\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"n\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"n\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif v == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = nil, want %v\", test.input, test.expected)\n\t\t\t} else if v != nil \u0026\u0026 test.expected == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want nil\", test.input, v)\n\t\t\t} else if v != nil \u0026\u0026 test.expected != nil \u0026\u0026 v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","55ae7eb91da475c49df165ec95632208":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[\"item1\",42]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","55c709ffad8143534ddeaf41a1e7bd19":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14E10\", \"3.14E10\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-infabc\", \"-inf\", \"abc\", nil},\n\t\t{\"-nanxyz\", \"-nan\", \"xyz\", nil},\n\t\t{\"\", \"\", \"\", nil}, // This case should not be valid as per function contract\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","567dc1a07a611eae451a61af6d9ce469":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Fatal(\"Expected a non-nil Value, got nil\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif cap(c.vs) != 1 || len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected capacity and length of vs to be 1, got cap: %d, len: %d\", cap(c.vs), len(c.vs))\n\t}\n\n\t// Test getting another value\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Fatal(\"Expected a non-nil Value, got nil\")\n\t}\n\n\t// Test that the second value is also initialized correctly\n\tif cap(c.vs) != 2 || len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected capacity and length of vs to be 2, got cap: %d, len: %d\", cap(c.vs), len(c.vs))\n\t}\n\n\t// Test that the values are distinct\n\tif val == val2 {\n\t\tt.Fatal(\"Expected distinct Values, got the same instance\")\n\t}\n\n\t// Test that the values are not reset\n\tif c.vs[0] != (Value{}) {\n\t\tt.Fatal(\"Expected the first Value to be uninitialized, but it was modified\")\n\t}\n}","569adecc916ae3f07b25462da44a89f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Test Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"rawString\",\n\t\t\t},\n\t\t\texpected: \"\\\"rawString\\\"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo([]byte{})\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","569ceb1896d923fc26f5c3de368f3449":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\tHello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\rHello, World!\", \"Hello, World!\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\t\\r \", \"\"},\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","56d6cf5f0d301863de996118db5b3f31":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\"world\\\"!\"`,\n\t\t\texpectedValue: \"hello \\\"world\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\\\"`,\n\t\t\texpectedValue: \"hello\\\\\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","5839b963b0f00d47ba1ea71416983cae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\n\t\tif test.hasError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\t// Here you would typically compare the result with expected\n\t\t\t// For example, you might want to check the type and value of result\n\t\t\t// if !reflect.DeepEqual(result, test.expected) {\n\t\t\t//     t.Errorf(\"for input %q: expected %v, got %v\", test.input, test.expected, result)\n\t\t\t// }\n\t\t}\n\t}\n}","5871d8de5bda10f9c2f0957142902f82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test true\n\t\t{\"false\", valueFalse, false}, // Test false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\": [true, false, null]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse, valueNull}, t: TypeArray}}}}}, false}, // Test object with array\n\t\t{\"{\\\"key\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}}}}}, false}, // Test nested object\n\t\t{\"{\\\"key\\\": \\\"value\\\", \\\"key2\\\": 123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test object with multiple key-value pairs\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif err == nil \u0026\u0026 tail != test.input[len(test.input)-len(tail):] {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want tail to be the remainder of input\", test.input, tail)\n\t\t}\n\t}\n}","58c7405e774342bc9822664969457783":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\"`,\n\t\t\texpectedValue: \"escaped \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"escaped\\\" quotes\" and more`,\n\t\t\texpectedValue: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","58c88278ce1d66a2a2e9a8ffad165b22":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedError  bool\n\t\texpectedKeys   []string\n\t\texpectedValues []string\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedError: false,\n\t\t\texpectedKeys:  []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"value1\", \"value2\"},\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\texpectedError: false,\n\t\t\texpectedKeys:  []string{\"key1\", \"key2\", \"key3\"},\n\t\t\texpectedValues: []string{\"value1\", \"value2\", \"value3\"},\n\t\t},\n\t\t{\n\t\t\tinput:         `{}`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\"`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\"}`,\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\t\t_, remaining, err := parseObject(test.input, c, depth)\n\n\t\tif test.expectedError \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"expected error for input %q, but got none\", test.input)\n\t\t}\n\t\tif !test.expectedError \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"did not expect error for input %q, but got: %v\", test.input, err)\n\t\t}\n\t\tif !test.expectedError \u0026\u0026 remaining != \"\" {\n\t\t\tt.Errorf(\"expected no remaining input for %q, but got: %q\", test.input, remaining)\n\t\t}\n\n\t\tif !test.expectedError {\n\t\t\t// Additional checks for keys and values can be added here\n\t\t\t// For example, you can check if the parsed object contains the expected keys and values\n\t\t}\n\t}\n}","5918e72973e48fabd54b0b57cef2017c":"// unescapeStringBestEffort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"}, // Invalid unicode\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"}, // Valid surrogate pair\n\t\t{\"Incomplete\\\\uD83D\", \"Incomplete\\\\uD83D\"}, // Incomplete surrogate\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewline\", \"Mixed😀\\nNewline\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Escaped\\\\/Characters\", \"Escaped/Characters\"},\n\t\t{\"Multiple\\\\\\\\Backslashes\\\\\\\\\", \"Multiple\\\\Backslashes\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","59947fc5320ff2dac77bc86ecff32065":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\\\"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\\\"world\\\\\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","59b8e71ef0b4aca2099db261e7678633":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\t// Add assertions to compare result with expected\n\t\t\t// e.g., compare the structure of result and test.expected\n\t\t}\n\t}\n}","5babdb3951265dc321e891198b96edd4":"// hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalString\", false},\n\t\t{\"stringWith\\\"Quote\", true},\n\t\t{\"stringWith\\\\Backslash\", true},\n\t\t{\"stringWith\\000NullChar\", true},\n\t\t{\"stringWithControlChar\\x1F\", true}, // Control character\n\t\t{\"\", false}, // Empty string\n\t\t{\"stringWithSpace \", false}, // Space is not a special character\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5cd64ad2aa4560244f16feafbdcdc631":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\t// Additional checks for expected structure can be added here\n\t\t// For example, checking the type and contents of the result\n\t}\n}","5d423fabd7fd94b752240bfb62492b92":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\t// Test case 1: Valid JSON with existing array\n\tjsonStr := `{\"array\": [1, 2, 3]}`\n\tv, err := Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tarr := v.GetArray(\"array\")\n\tif len(arr) != 3 {\n\t\tt.Errorf(\"Expected array length 3, got %d\", len(arr))\n\t}\n\n\t// Test case 2: Valid JSON with non-existing key\n\tjsonStr = `{\"array\": [1, 2, 3]}`\n\tv, err = Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tarr = v.GetArray(\"non_existing_key\")\n\tif arr != nil {\n\t\tt.Error(\"Expected nil for non-existing key, got non-nil\")\n\t}\n\n\t// Test case 3: Valid JSON with non-array type\n\tjsonStr = `{\"not_array\": \"string\"}`\n\tv, err = Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tarr = v.GetArray(\"not_array\")\n\tif arr != nil {\n\t\tt.Error(\"Expected nil for non-array type, got non-nil\")\n\t}\n\n\t// Test case 4: Valid JSON with array and decimal index\n\tjsonStr = `{\"array\": [1, 2, 3]}`\n\tv, err = Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tarr = v.GetArray(\"array.0\")\n\tif len(arr) != 1 || arr[0].Int() != 1 {\n\t\tt.Errorf(\"Expected array with single element 1, got %v\", arr)\n\t}\n\n\t// Test case 5: Valid JSON with nested array\n\tjsonStr = `{\"nested\": {\"array\": [4, 5, 6]}}`\n\tv, err = Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tarr = v.GetArray(\"nested\", \"array\")\n\tif len(arr) != 3 {\n\t\tt.Errorf(\"Expected array length 3, got %d\", len(arr))\n\t}\n}","5d50de60db0396b2d0bd0253f72fb162":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test object with number value\n\t\t{\"{\\\"key\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, false}, // Test object with array value\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif !tt.err \u0026\u0026 !compareValues(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\tswitch v1.t {\n\tcase TypeString:\n\t\treturn v1.s == v2.s\n\tcase TypeNumber:\n\t\treturn v1.s == v2.s\n\tcase TypeObject:\n\t\t// Compare objects (omitted for brevity)\n\t\treturn true\n\tcase TypeArray:\n\t\t// Compare arrays (omitted for brevity)\n\t\treturn true\n\tdefault:\n\t\treturn true\n\t}\n}","5d9ba318f485a038f98ce79add0f925e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","5da18abcb95e96380f9c8fd275d622fd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\Test\", \"Backslash\\\\Test\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Mixed\\\\nEscapes\\\\tAnd\\\\\\\"Quotes\\\\\\\"\", \"Mixed\\nEscapes\\tAnd\\\"Quotes\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5ec1cf68f235fec45dbd1b9bba550fd2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u0041\\\\u0042\\\\u0043\", \"Unicode: ABC\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\uXYZ\", \"Mixed: 😀 and \\\\uXYZ\"},\n\t\t{\"No escape characters here\", \"No escape characters here\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Another incomplete: \\\\uD83D\", \"Another incomplete: \\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5f00dfe65b2cd06b1edd54aff1a38985":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\n\tvar unknownType Type = 100 // An arbitrary value not defined in Type\n\t_ = unknownType.String() // This should trigger the panic\n}","5f2d638daec8a7a43d52ea4a7cee1688":"// file: value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueType(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected Type\n\t}{\n\t\t{\u0026Value{t: TypeNull}, TypeNull},\n\t\t{\u0026Value{t: TypeObject}, TypeObject},\n\t\t{\u0026Value{t: TypeArray}, TypeArray},\n\t\t{\u0026Value{t: TypeString}, TypeString},\n\t\t{\u0026Value{t: TypeNumber}, TypeNumber},\n\t\t{\u0026Value{t: TypeTrue}, TypeTrue},\n\t\t{\u0026Value{t: TypeFalse}, TypeFalse},\n\t\t{\u0026Value{t: typeRawString, s: \"raw string\"}, typeRawString},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.value.Type()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, result)\n\t\t}\n\t}\n}","5f7e1b408299a5feceba48dcfcc3c3e6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) expected value: %q, got: %q\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) expected rest: %q, got: %q\", test.input, test.expectedRest, rest)\n\t\t}\n\t}\n}","60373dd5eb43b7806c0c2d73a68b5a1f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty JSON object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty JSON array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for boolean true\n\t\t{\"false\", valueFalse, false}, // Test for boolean false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test for object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test for object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test for object with number value\n\t\t{\"{\\\"key\\\":\\\"value\\\", \\\"array\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"array\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}}, false}, // Test for complex object\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 !compareValues(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) did not consume all input, tail = %q\", test.input, tail)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\tif v1.t != v2.t || v1.s != v2.s || len(v1.a) != len(v2.a) || len(v1.o.kvs) != len(v2.o.kvs) {\n\t\treturn false\n\t}\n\tfor i, kv := range v1.o.kvs {\n\t\tif kv.k != v2.o.kvs[i].k || !compareValues(kv.v, v2.o.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, v := range v1.a {\n\t\tif !compareValues(v, v2.a[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","61b554d4a71f6eec4c4a774e11524106":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined properly\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Additional checks can be added here to compare the structure of `result` with `test.expected`\n\t\t// For example, checking the type and contents of the resulting Value\n\t}\n}","61c8116723a685d16e3b316f3a1002d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","61fabe52f811641e8d99fbb89579e7fe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, \"\", true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, \"\", false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\", false}, // Test empty array\n\t\t{\"\\\"test\\\"\", \u0026Value{s: \"test\", t: typeRawString}, \"\", false}, // Test string\n\t\t{\"true\", valueTrue, \"\", false}, // Test boolean true\n\t\t{\"false\", valueFalse, \"\", false}, // Test boolean false\n\t\t{\"null\", valueNull, \"\", false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, \"\", false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}}, \"\", false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}}, \"\", false}, // Test array of numbers\n\t\t{\"{\\\"key\\\": [true, false]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse}}}}}}, \"\", false}, // Test object with array of booleans\n\t\t{\"{\\\"key\\\": null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, \"\", false}, // Test object with null value\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","621369ec062ba27fe0667dfb122818cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\t// Sample JSON data for testing\n\tjsonData := []byte(`{\n\t\t\"key1\": {\n\t\t\t\"subkey1\": \"value1\",\n\t\t\t\"subkey2\": {\n\t\t\t\t\"subsubkey1\": \"value2\"\n\t\t\t}\n\t\t},\n\t\t\"key2\": [\n\t\t\t{\"subkey3\": \"value3\"},\n\t\t\t{\"subkey4\": \"value4\"}\n\t\t],\n\t\t\"key3\": null\n\t}`)\n\n\t// Parse the JSON data\n\tparser := \u0026Parser{}\n\tv, err := parser.ParseBytes(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected *Object\n\t}{\n\t\t{\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: v.GetObject(\"key1\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"key1\", \"subkey2\"},\n\t\t\texpected: v.GetObject(\"key1\", \"subkey2\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"key2\", \"1\"},\n\t\t\texpected: v.GetObject(\"key2\", \"1\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: v.GetObject(\"key3\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"key1\", \"subkey3\"},\n\t\t\texpected: nil, // Invalid path\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil, // Non-existing key\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.GetObject(test.keys...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"GetObject(%v) = %v; expected %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","63402e102f86c86928aec807fb0479ab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","638aa3553dd719f069b9f6dffc648994":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tobj := \u0026Object{\n\t\tkvs:           []kv{{k: \"key1\", v: \u0026Value{}}, {k: \"key2\", v: \u0026Value{}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Ensure the object has data before reset\n\tif len(obj.kvs) == 0 || !obj.keysUnescaped {\n\t\tt.Fatalf(\"Object should be initialized with data before reset\")\n\t}\n\n\t// Call the reset function\n\tobj.reset()\n\n\t// Check if the kvs slice is empty after reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"Expected kvs to be empty after reset, got %d\", len(obj.kvs))\n\t}\n\n\t// Check if keysUnescaped is false after reset\n\tif obj.keysUnescaped {\n\t\tt.Fatalf(\"Expected keysUnescaped to be false after reset\")\n\t}\n}","63cc792ba38391a1dc1494e0e4f7ffab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 123}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value objects\n\t// This is a placeholder; actual implementation will depend on the structure of Value\n\treturn false\n}","63d456ce66116ca7c6f98bdfaf7cb763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+10\", \"-123.45e+10\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"infxyz\", \"inf\", \"xyz\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+123\", \"+123\", \"\", nil},\n\t\t{\"-0.123\", \"-0.123\", \"\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","6430a06526b6fe0eb984404080988e8a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\\\"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world\"`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"\\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","645caff14b02a94bc8655b0b42b8bae0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","649e83338fd51e1621a05feef82da083":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"}, // Invalid unicode\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"}, // Valid surrogate pair\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"}, // Incomplete unicode\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"}, // Mixed valid surrogates\n\t\t{\"Escaped\\\\\\\\nNewline\", \"Escaped\\\\nNewline\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6548e1529105cef09542af737bec500c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: typeRawString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test object with number value\n\t\t{\"{\\\"key\\\":[1,2,3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, false}, // Test object with array value\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 (v == nil || v.t != test.expected.t || v.s != test.expected.s) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want empty\", test.input, tail)\n\t\t}\n\t}\n}","65d4ee93a3ee3af7d8087f02220faf12":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test initial state\n\tkv := obj.getKV()\n\tif kv == nil {\n\t\tt.Fatal(\"Expected kv to be non-nil\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"Expected length of kvs to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Test adding another kv\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Fatal(\"Expected kv2 to be non-nil\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"Expected length of kvs to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Test that the second kv is a different instance\n\tif kv == kv2 {\n\t\tt.Fatal(\"Expected kv and kv2 to be different instances\")\n\t}\n\n\t// Test capacity handling\n\tfor i := 0; i \u003c 10; i++ {\n\t\tobj.getKV()\n\t}\n\tif len(obj.kvs) != 12 {\n\t\tt.Fatalf(\"Expected length of kvs to be 12, got %d\", len(obj.kvs))\n\t}\n}","65fc2fe3ed6e0aadf459c8a6722c7911":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: Get value when cache is empty\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Error(\"Expected a non-nil Value when cache is empty\")\n\t}\n\n\t// Test case 2: Get value when cache has one item\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Error(\"Expected a non-nil Value when cache has one item\")\n\t}\n\n\t// Test case 3: Ensure that the second call returns a different Value\n\tif val1 == val2 {\n\t\tt.Error(\"Expected different Values for consecutive calls to getValue\")\n\t}\n\n\t// Test case 4: Check the length of the cache\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected cache length to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Test case 5: Get value when cache is full (simulate by adding more values)\n\tfor i := 0; i \u003c 10; i++ {\n\t\tc.getValue()\n\t}\n\tif len(c.vs) != 12 { // 2 initial + 10 more\n\t\tt.Errorf(\"Expected cache length to be 12, got %d\", len(c.vs))\n\t}\n}","667c7903ac2f443de1f8b57d78b53346":"// parse_value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 v != nil {\n\t\t\tif v.s != test.expected.s || v.t != test.expected.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","668a856045bb7eb8bad1930a3275cef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Escaped\\\\/Slash\", \"Escaped/Slash\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Mixed\\\\nEscapes\\\\tAnd\\\\\\\"Quotes\\\\\\\"\", \"Mixed\\nEscapes\\tAnd\\\"Quotes\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6731289aaef77b8400d83d46dbc76417":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalString\", false},\n\t\t{\"stringWith\\\"Quote\", true},\n\t\t{\"stringWith\\\\Backslash\", true},\n\t\t{\"stringWith\\000NullByte\", true},\n\t\t{\"stringWithControlChar\\x1F\", true}, // Control character\n\t\t{\"\", false}, // Empty string\n\t\t{\"stringWithSpace \", false}, // Space is not a special character\n\t\t{\"stringWithTab\\t\", true}, // Tab is a control character\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","67b025a3b6f0c6ae2fda197859e96ab1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value needs to be defined based on the actual implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpected: nil, // Expected value needs to be defined based on the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true false\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \" false\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null something\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \" something\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"} extra\",\n\t\t\texpected: nil, // Expected value needs to be defined based on the actual implementation of parseObject\n\t\t\ttail:     \" extra\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif v != nil \u0026\u0026 test.expected != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","6804e2a188450095521d19251089a3cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\n new line\", \"Mixed: 😀 and \\n new line\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","682443aef2bd906bc6223297b5892cb3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewline\", \"Mixed😀\\nNewline\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"EscapedSlash\\\\/\", \"EscapedSlash/\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","687b07e488e0a192515ad3f89d12c2ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewLine\", \"Mixed😀\\nNewLine\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Incomplete\\\\uD83D\", \"Incomplete\\\\uD83D\"},\n\t\t{\"Incomplete\\\\uD83D\\\\u\", \"Incomplete\\\\uD83D\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","68808cd021a8ac028c0531f9704bfc29":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test initial state\n\tkv1 := obj.getKV()\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected initial kv to have empty key and nil value, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Test adding a key-value pair\n\tkv1.k = \"key1\"\n\tkv1.v = \u0026Value{} // Assuming Value is properly initialized\n\n\tkv2 := obj.getKV()\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected second kv to have empty key and nil value, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n\n\t// Check if the first kv is still accessible\n\tif obj.kvs[0].k != \"key1\" {\n\t\tt.Errorf(\"Expected first kv key to be 'key1', got: %s\", obj.kvs[0].k)\n\t}\n\n\t// Test capacity and appending\n\tfor i := 0; i \u003c 10; i++ {\n\t\tkv := obj.getKV()\n\t\tkv.k = \"key\" + string(i+'0')\n\t\tkv.v = \u0026Value{}\n\t}\n\n\tif len(obj.kvs) != 11 { // 1 initial kv + 10 added\n\t\tt.Errorf(\"Expected kvs length to be 11, got: %d\", len(obj.kvs))\n\t}\n}","68fecac4233379e0ee0add4e25802abc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.err {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, v := range result.a {\n\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\tt.Errorf(\"parseArray(%q)[%d] = %v, want %v\", test.input, i, v, test.expected[i])\n\t\t\t}\n\t\t}\n\t}\n}","691a36d7ea06c6aa770c81bab56634b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6978245fc46d5f25aaf2c8cac4473f73":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-infabc\", \"-inf\", \"abc\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-nanabc\", \"-nan\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","69e14af1a1cf177e765068338ea97f04":"// file: bool_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected bool\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"true value\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: true,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false value\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: false,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number value\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string value\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"object value\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array value\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := tt.value.Bool()\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","6aca4cb03aca002182ddf53b78161961":"// hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalString\", false},\n\t\t{\"stringWith\\\"Quote\", true},\n\t\t{\"stringWith\\\\Backslash\", true},\n\t\t{\"stringWith\\000NullChar\", true},\n\t\t{\"stringWithControlChar\\x1F\", true}, // Control character\n\t\t{\"\", false}, // Empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6b4af14a43e831b21c655ba7bacce0d5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","6b82b35fcceba03b7e2a861d1ca8a1bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\terr      string\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\terr:      \"cannot parse empty string\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueTrue,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueFalse,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueNull,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as needed\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeArray}, // Adjust expected value as needed\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string\\\"\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeString, s: \"string\"},\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"nan\"},\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: nil,\n\t\t\terr:      \"too big depth for the nested JSON; it exceeds 10\", // Adjust MaxDepth accordingly\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, test.depth)\n\n\t\tif err != nil \u0026\u0026 err.Error() != test.err {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = unexpected error: %v, want %v\", test.input, test.depth, err, test.err)\n\t\t}\n\n\t\tif err == nil \u0026\u0026 test.err != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = expected error: %v, got none\", test.input, test.depth, test.err)\n\t\t}\n\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 *result != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = %v, want %v\", test.input, test.depth, result, test.expected)\n\t\t}\n\t}\n}","6d3a5822e00fab03ff2f1d46789bc3de":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"escaped \\\\\\\"quote\\\\\\\"\\\"\", \"escaped \\\"quote\\\"\", \"\", false},\n\t\t{\"\\\"multiple \\\\\\\"escaped\\\\\\\" quotes \\\\\\\"here\\\\\\\"\\\"\", \"multiple \\\"escaped\\\" quotes \\\"here\\\"\", \"\", false},\n\t\t{\"\\\"unclosed string\", \"\", \"\", true},\n\t\t{\"no quotes\", \"no quotes\", \"\", true},\n\t\t{\"\\\"escaped \\\\\\\\\\\"\", \"escaped \\\\\", \"\", false},\n\t\t{\"\\\"\\\\\\\"\\\"\", \"\\\"\", \"\", false},\n\t\t{\"\\\"\\\\\\\\\\\"\", \"\\\\\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.rest)\n\t\t}\n\t}\n}","6d42cc491bb7931af5168fb29d450757":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", false},\n\t\t{\"-infabc\", \"-inf\", \"abc\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"\", \"\", \"\", true}, // edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) number = %q, expected = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expected = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","6d5a8b1708e96dcfd891f4e6f778b2eb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"123.45\", \"123.45\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-xyz\", \"\", \"-xyz\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\n\t\tif (err != nil) != (test.expectedError != nil) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v; expected error = %v\", test.input, err, test.expectedError)\n\t\t}\n\t}\n}","6da65682ce259312ae9b4cdb1e73416a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"1.0e-10more\", \"1.0e-10\", \"more\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","6db00f06325b618d849dc56822ae75ec":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, want error = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 v != nil {\n\t\t\tif v.s != test.expected.s || v.t != test.expected.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","6df0d4e5d8c2ff606085628a104b67b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-123.45e-10xyz\", \"-123.45e-10\", \"xyz\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","6e33d0d62a23a8721caad8b3e9af809d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\nHello\", \"Hello\"},\n\t\t{\"\\r\\nHello\", \"Hello\"},\n\t\t{\"\\tHello\", \"Hello\"},\n\t\t{\"   \\n   World\", \"World\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\t\\r\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6e8502e4888bb33c5d31d62ffdb69b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a test string with a newline\\\\ncharacter.\", \"This is a test string with a newline\\ncharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\\\\u0042\\\\u0043\", \"Unicode: ABC\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t\t{\"Mixed \\\\n and \\\\t characters\", \"Mixed \\n and \\t characters\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t\t{\"Empty string: \\\"\\\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6f19aa110e6aa422ecee615bd3adb1ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a test string with a newline\\\\ncharacter.\", \"This is a test string with a newline\\ncharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Valid unicode: \\\\u0041\", \"Valid unicode: A\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed: \\\\nNewline, \\\\tTab, \\\\\\\"Quote\\\\\\\" and \\\\\\\\Backslash\", \"\\nNewline, \\tTab, \\\"Quote\\\" and \\\\Backslash\"},\n\t\t{\"No escape sequences here\", \"No escape sequences here\"},\n\t\t{\"Incomplete unicode: \\\\uD83D\", \"Incomplete unicode: \\\\uD83D\"},\n\t\t{\"Multiple escapes: \\\\n\\\\t\\\\\\\"\\\\\\\\\", \"\\n\\t\\\"\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6f44ad38d1750d682e4dc5ccc8c22331":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for object with array */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances.\n// Implement this function based on the structure of Value and its contents.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false\n}","6f51b309595c1399dbabe55956e4e70a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" next`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" next\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes`,\n\t\t\texpectedValue: \"no quotes\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped\\\\\"string\" and more`,\n\t\t\texpectedValue: \"escaped\\\\string\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"escaped\\\" quotes\" end`,\n\t\t\texpectedValue: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:  \" end\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","6fab218b3923aaaeb15f025f2a5a7e40":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"world`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"world`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\"`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","6fd24ebeaee11084b0c385bb63aecac6":"","7058efd0c56b597cc2d9223ff1700ad9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\t// Create a sample JSON object\n\tjsonData := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`)\n\tparser := \u0026Parser{}\n\tvalue, err := parser.ParseBytes(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\tobj, err := value.GetObject()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get object from value: %v\", err)\n\t}\n\n\t// Prepare a slice to capture the results\n\tvar results []string\n\n\t// Define the function to be called for each key-value pair\n\tf := func(key []byte, v *Value) {\n\t\tresults = append(results, string(key)+\": \"+string(v.StringBytes()))\n\t}\n\n\t// Call the Visit method\n\tobj.Visit(f)\n\n\t// Define the expected results\n\texpectedResults := []string{\n\t\t\"key1: value1\",\n\t\t\"key2: value2\",\n\t\t\"key3: value3\",\n\t}\n\n\t// Check if the results match the expected results\n\tif len(results) != len(expectedResults) {\n\t\tt.Fatalf(\"Expected %d results, got %d\", len(expectedResults), len(results))\n\t}\n\n\tfor i, expected := range expectedResults {\n\t\tif results[i] != expected {\n\t\t\tt.Errorf(\"Expected result %d to be %q, got %q\", i, expected, results[i])\n\t\t}\n\t}\n}","706865992798e2e97cf456a24af456c3":"","706e5a0147669f36804cbc0a3f095f5e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uD83D\", \"Invalid Unicode: \\\\uD83D\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: 😀\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"Mixed: \\nLine1\\nLine2\"},\n\t\t{\"Escaped Slash: \\\\/\", \"Escaped Slash: /\"},\n\t\t{\"No Escape\", \"No Escape\"},\n\t\t{\"Incomplete Escape: \\\\u\", \"Incomplete Escape: \\\\u\"},\n\t\t{\"Invalid Escape: \\\\x\", \"Invalid Escape: \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","70a38a44496c23ee87fb465becf29b01":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","71635dd415056a10080843df1cfc642f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\t\\tHello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\r\\rHello, World!\", \"Hello, World!\"},\n\t\t{\"   \\t\\n\\r   \", \"\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   Leading spaces\", \"Leading spaces\"},\n\t\t{\"Trailing spaces   \", \"Trailing spaces   \"},\n\t\t{\"\\t\\t\\t\\t\\t\", \"\"},\n\t\t{\"\\n\\n\\n\\n\\n\", \"\"},\n\t\t{\"\\r\\r\\r\\r\\r\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","7230092514433d8801df7477caa09618":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"key\"`,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"anotherKey\" more text`,\n\t\t\texpectedKey: \"anotherKey\",\n\t\t\texpectedRemaining: \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with spaces\"`,\n\t\t\texpectedKey: \"key with spaces\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\\"escaped\\\" quotes\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `missing quotes`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\\\ backslash\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, expectedRemaining %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","724994c4227fea1f6874c6180fbf74e8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\t// Additional checks for remaining string if necessary\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\treturn false // Placeholder return\n}","728d133d01cc468ecfd0317cc4c69179":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\tparser := \u0026Parser{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, err := parser.Parse(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"Parse(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"Parse(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare expected and actual Value structures.\nfunc compareValues(a, b *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\treturn true // Placeholder\n}","73637f7e1e8efbc7668ced1b35bb1c13":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"item1\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[\"item1\",42]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","73e81573c1097aa5d3bc8873077efe2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\", \\\\u4F60\\\\u597D, \\\\n\", \"\\\"Hello\\\", 你好, \\n\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"Multiple backslashes: \\\\\\\\\\\\n\", \"Multiple backslashes: \\\\\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","73e9cfe5e08926c7976321a2a9cd9a45":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\"}}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}, {k: \"nested\", v: \u0026Value{o: Object{kvs: []kv{{k: \"key2\", v: \u0026Value{s: \"value2\", t: typeRawString}}}}}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got nil\", test.input, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 *result != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) expected: %+v, got: %+v\", test.input, test.expected, result)\n\t\t}\n\t}\n}","7401629604b0f70bcbc19d96baaedff5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uXYZ\", \"Mixed😀\\\\uXYZ\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","74d7cae76125b8d48ca978cf0f627552":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                              // empty string\n\t\t{\"   \", \"\"},                           // only whitespace\n\t\t{\"   hello\", \"hello\"},                 // leading whitespace\n\t\t{\"hello   \", \"hello   \"},              // trailing whitespace\n\t\t{\"   hello   \", \"hello   \"},           // leading and trailing whitespace\n\t\t{\"\\n   hello\", \"hello\"},                // leading newline\n\t\t{\"hello\\n   \", \"hello\\n   \"},          // trailing newline\n\t\t{\"\\t   hello\", \"hello\"},                // leading tab\n\t\t{\"hello\\t   \", \"hello\\t   \"},           // trailing tab\n\t\t{\"   \\n   \", \"\"},                       // only newlines and whitespace\n\t\t{\"\\r\\n   hello\", \"hello\"},              // leading carriage return and newline\n\t\t{\"hello\\r\\n   \", \"hello\\r\\n   \"},      // trailing carriage return and newline\n\t\t{\"\\r   hello\", \"hello\"},                // leading carriage return\n\t\t{\"hello\\r   \", \"hello\\r   \"},          // trailing carriage return\n\t\t{\"   \\t   \", \"\"},                       // only tabs and whitespace\n\t\t{\"\\n\\t   hello\", \"hello\"},              // leading newline and tab\n\t\t{\"hello\\n\\t   \", \"hello\\n\\t   \"},      // trailing newline and tab\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","753a7a1e99cdb1733921791f2452aeb5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 'invalid']\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","75777daeca0c7bd8df52b21d1b780eff":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue, s: \"\"},\n\t\t\t\t\t{t: TypeNull, s: \"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","7687ecf07cfcfde6c5776872c4fb9d33":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test true\n\t\t{\"false\", valueFalse, false}, // Test false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\": [true, false, null]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse, valueNull}, t: TypeArray}}}}}, false}, // Test nested object and array\n\t\t{\"{\\\"key\\\": \\\"value\\\"\", nil, true}, // Test malformed JSON\n\t\t{\"[1, 2, 3,]\", nil, true}, // Test trailing comma\n\t\t{\"{\\\"key\\\": {\\\"nested\\\": \\\"value\\\"}}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{s: \"value\", t: TypeString}}}}}}}}}, false}, // Test nested object\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 v.t != test.expected.t {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v.t, test.expected.t)\n\t\t}\n\t}\n}","76c88dee15d18184fd5aae3fde728d6e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes`,\n\t\t\texpectedValue: \"no quotes\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","76f5fd995e906a4073d48604a7268b3e":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expecting a specific Value for an array\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expecting a specific Value for an object\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: nil, // Expecting a specific Value for NaN\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\"}}`,\n\t\t\texpected: nil, // Expecting a specific Value for a nested object\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 test.expected != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","77bce0e6590e4b18937b930f84c13ca1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\" more text`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","782108c696836cbdae2916bc481df792":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","786947ac52c4718b1416b399695b5978":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[, 1, 2, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil {\n\t\t\tif result == nil || len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","798be09ae942c932c643af314a791107":"// unescape_string_best_effort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\", \\\\u4F60\\\\u597D\", \"\\\"Hello\\\", 你好\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Escape slash: \\\\\\\\\", \"Escape slash: \\\\\"},\n\t\t{\"Escape forward slash: \\\\/\", \"Escape forward slash: /\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","79d8078e796dcbcc4dd823f358ec52aa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeArray, a: []*Value{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeArray, a: []*Value{\u0026Value{s: \"1\", t: TypeNumber}, \u0026Value{s: \"2\", t: TypeNumber}, \u0026Value{s: \"3\", t: TypeNumber}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeArray, a: []*Value{\u0026Value{s: \"true\", t: TypeTrue}, \u0026Value{s: \"false\", t: TypeFalse}, \u0026Value{s: \"\", t: TypeNull}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeArray, a: []*Value{\u0026Value{s: \"string1\", t: TypeString}, \u0026Value{s: \"string2\", t: TypeString}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif len(result.a) != len(test.expected[0].a) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want = %v\", test.input, result, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.s != test.expected[0].a[i].s || v.t != test.expected[0].a[i].t {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want = %v\", test.input, result, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","7a92821e0adc82cb85ceea8247358d8a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\": \"value\", \"key2\": \"value2\" }`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\": \"value\", \"key2\": \"value2\", \"key3\": \"value3\" }`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}, {k: \"key3\", v: \u0026Value{s: \"value3\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want empty\", test.input, remaining)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function to check if two Value objects are equal.\n\t// This function should compare the type, object keys, and values.\n\t// For simplicity, this function is not implemented here.\n\treturn false\n}","7ae139e99d6004412db527f5cec86730":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput: ` \"key\" : \"value\" `,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRemaining: ` : \"value\" `,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: ` \"anotherKey\"`,\n\t\t\texpectedKey: \"anotherKey\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: ` \"keyWithEscape\\\"` ,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: ` \"keyWithoutClosingQuote`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: ` \"keyWithSpace \" : \"value\" `,\n\t\t\texpectedKey: \"keyWithSpace \",\n\t\t\texpectedRemaining: ` : \"value\" `,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: ` \"keyWithBackslash\\\\ : \"value\" `,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, expectedRemaining %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","7b0eb03b9c3c5c2a59058e32333f3f39":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"key\": \"value\"`,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRemaining: \": \\\"value\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"anotherKey\"`,\n\t\t\texpectedKey: \"anotherKey\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with space\": \"value\"`,\n\t\t\texpectedKey: \"key with space\",\n\t\t\texpectedRemaining: \": \\\"value\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\\"escaped\\\" quotes\": \"value\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with backslash \\\\\": \"value\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key without closing quote`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `no quotes here`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, expectedRemaining %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","7be990ce79cb1a8b124a128d9ab3387a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\\\" world`,\n\t\t\texpected: \"hello\\\\\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\" \"world\"`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" \\\"world\\\"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `hello\"`,\n\t\t\texpected: `hello`,\n\t\t\trest:     `\"`,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\\\"`,\n\t\t\texpected: \"escaped \\\\\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"double \\\" escape\"`,\n\t\t\texpected: `double \" escape`,\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.rest)\n\t\t}\n\t}\n}","7c09caf0ea87aa843bac1becd45191fc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}, t: TypeObject}, false}, // Test object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}, t: TypeObject}, false}, // Test object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}, t: TypeObject}, false}, // Test object with number value\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif v == nil || v.t != test.expected.t || v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","7ca549d288828fbe5328bbd86e0db62a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","7dad3b1c46ec53aac2f667a5953c1862":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"InvalidUnicode\\\\uXYZ\", \"InvalidUnicode\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"EscapedSlash\\\\\\\\\", \"EscapedSlash\\\\\"},\n\t\t{\"EscapedQuote\\\\\\\"\", \"EscapedQuote\\\"\"},\n\t\t{\"EscapedForwardSlash\\\\/\", \"EscapedForwardSlash/\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","7db1f88e3c96395375451e83de16c5b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"inf more text\", \"inf\", \"more text\", nil},\n\t\t{\"nan more text\", \"nan\", \"more text\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", test.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","7dcd4b2020590e522e3b8a940cc501f3":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                          // empty string\n\t\t{\"   Hello\", \"   Hello\"},         // leading spaces\n\t\t{\"\\n\\nHello\", \"\\n\\nHello\"},       // leading newlines\n\t\t{\"\\t\\tHello\", \"\\t\\tHello\"},       // leading tabs\n\t\t{\"\\r\\rHello\", \"\\r\\rHello\"},       // leading carriage returns\n\t\t{\"   \\n\\t  Hello\", \"Hello\"},      // mixed whitespace leading\n\t\t{\"Hello\", \"Hello\"},                // no leading whitespace\n\t\t{\"   \\n\\t  \", \"\"},                 // only whitespace\n\t\t{\"\\n\\n\", \"\\n\\n\"},                  // only newlines\n\t\t{\"\\t\\t\", \"\\t\\t\"},                  // only tabs\n\t\t{\"\\r\\r\", \"\\r\\r\"},                  // only carriage returns\n\t\t{\"   \\n\\t  World\", \"World\"},       // mixed whitespace with text\n\t\t{\"\\n\\nWorld\", \"\\n\\nWorld\"},        // mixed whitespace with text\n\t\t{\"\\t\\tWorld\", \"\\t\\tWorld\"},        // mixed whitespace with text\n\t\t{\"\\r\\rWorld\", \"\\r\\rWorld\"},        // mixed whitespace with text\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","7dd7034a21a9529c961f608a308225ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\tif !test.err \u0026\u0026 remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want empty\", test.input, remaining)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function for Value types\n\t// This function should compare the structure and content of two Value instances\n\t// For simplicity, you can compare types and string representations for now\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\tif v1.t != v2.t {\n\t\treturn false\n\t}\n\t// Further comparisons based on type can be added here\n\treturn v1.s == v2.s \u0026\u0026 compareObjects(v1.o, v2.o)\n}\n\nfunc compareObjects(o1, o2 Object) bool {\n\t// Implement a comparison function for Object types\n\t// Compare the length and key-value pairs of the objects\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k || !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","7e8e562ef2d27c182d546cf4c9a07086":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tjson       string\n\t\tkeys       []string\n\t\texpected   []*Value\n\t\texpectNil  bool\n\t}{\n\t\t{\n\t\t\tjson:      `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:      []string{\"array\"},\n\t\t\texpected:  []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"array\": [true, false]}`,\n\t\t\tkeys:      []string{\"array\"},\n\t\t\texpected:  []*Value{\u0026Value{t: TypeTrue, s: \"true\"}, \u0026Value{t: TypeFalse, s: \"false\"}},\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"notArray\": {}}`,\n\t\t\tkeys:      []string{\"notArray\"},\n\t\t\texpected:  nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:      []string{\"array\", \"0\"},\n\t\t\texpected:  nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:      []string{\"array\", \"3\"},\n\t\t\texpected:  nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:      []string{\"array\", \"1.0\"},\n\t\t\texpected:  []*Value{\u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\texpectNil: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tparser := \u0026Parser{}\n\t\tvalue, err := parser.Parse(test.json)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t}\n\n\t\tresult := value.GetArray(test.keys...)\n\t\tif test.expectNil {\n\t\t\tif result != nil {\n\t\t\t\tt.Errorf(\"Expected nil for keys %v, got %v\", test.keys, result)\n\t\t\t}\n\t\t} else {\n\t\t\tif len(result) != len(test.expected) {\n\t\t\t\tt.Errorf(\"Expected length %d for keys %v, got %d\", len(test.expected), test.keys, len(result))\n\t\t\t}\n\t\t\tfor i, expectedValue := range test.expected {\n\t\t\t\tif result[i].s != expectedValue.s || result[i].t != expectedValue.t {\n\t\t\t\t\tt.Errorf(\"Expected %v, got %v for keys %v at index %d\", expectedValue, result[i], test.keys, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","7f4ba0b171c71cd762dba9c2e617f4ff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\t// Create test cases\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"Valid uint value\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tjson:     `{\"key\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (boolean)\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (null)\",\n\t\t\tjson:     `{\"key\": null}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid uint in nested object\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index access\",\n\t\t\tjson:     `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid array index\",\n\t\t\tjson:     `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetUint(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","7f60f1b39103ded7daa1b75a4ee76a2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty JSON object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty JSON array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for true\n\t\t{\"false\", valueFalse, false}, // Test for false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}, t: TypeObject}, false}, // Test for object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}, t: TypeObject}, false}, // Test for object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}, t: TypeObject}, false}, // Test for object with number value\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif !tt.err \u0026\u0026 !compareValues(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function for Value to check equality\n\t// This function should compare the type and content of the Value instances\n\treturn false // Placeholder return\n}","807d013abe86474680c99a8397c44ef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for the Get function\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Nil Value\",\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid key\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Array index out of bounds\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"value0\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid array index\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"value0\"},\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Nested object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\"nestedKey\", \u0026Value{t: TypeString, s: \"nestedValue\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\", \"nestedKey\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"nestedValue\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","80eb4c1412d255ee46292aae604c32df":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-infabc\", \"-inf\", \"abc\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-nanxyz\", \"-nan\", \"xyz\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","813b6cc65bfab253187227574002ee26":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value0\"},\n\t\t\t\t\t{t: TypeString, s: \"value1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing index from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"value0\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get from nested object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"nested\", v: \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"nested\", \"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname: \"Get with invalid key type\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"not an object or array\",\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.Get(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","8177a350d4c4cce2597cc004623711f5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\" more text`,\n\t\t\texpectedValue:  \"hello\\\"world\",\n\t\t\texpectedRemainder: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue:  \"hello\\\\\",\n\t\t\texpectedRemainder: \"world\\\" text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\"`,\n\t\t\texpectedValue:  \"hello\\\\\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawString(%q) remainder = %q, expectedRemainder %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","829f3bee55cc6c18e8df104328bf5e2b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: `hello\"world`,\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text`,\n\t\t\texpectedValue: `hello\\\"world`,\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\\\"`,\n\t\t\texpectedValue: `hello\\\\`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","8357f5d24e1cdb9aefc22a135c1b9466":"// unescape_string_best_effort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a test string with no escapes.\", \"This is a test string with no escapes.\"},\n\t\t{\"Escaped quote: \\\\\\\"Hello\\\\\\\".\", \"Escaped quote: \\\"Hello\\\".\"},\n\t\t{\"New line:\\\\nSecond line.\", \"New line:\\nSecond line.\"},\n\t\t{\"Tab:\\\\tTabbed text.\", \"Tab:\\tTabbed text.\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed: \\\\nNew line and \\\\t tab.\", \"\\nNew line and \\t tab.\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","846b5a8936b60cdcefab9152a8a78e08":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","85860e752a54f3e60b619400d8ea0e22":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"123abc456\", \"123\", \"abc456\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","867153df9b6a69ea618b77a3fc27945c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nan123\", \"nan\", \"123\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"\", \"\", \"\", true}, // Edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned number: %q, expected: %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned remaining: %q, expected: %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","8717eb40e7c5b1502a86c46aec6f0a2f":"","871e93cc734c52c098de30486d1c84ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid float64\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (object)\",\n\t\t\tjson:     `{\"value\": {}}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (array)\",\n\t\t\tjson:     `{\"value\": []}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float64 in nested object\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 2.71}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 2.71,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float64 with array index\",\n\t\t\tjson:     `{\"values\": [1.23, 4.56]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 4.56,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of bounds\",\n\t\t\tjson:     `{\"values\": [1.23]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","880ea0b271ad5f9e12e05cf9dcf137a3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uXYZ\", \"Mixed😀\\\\uXYZ\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"EscapedSlash\\\\\\\\\", \"EscapedSlash\\\\\"},\n\t\t{\"EscapedQuote\\\\\\\"\", \"EscapedQuote\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","88843da73a4c0686070c97ea98d37280":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","88b3d88545e7b71fef3f2ddd387f7e6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","88bc848125f2ad9eae9f374f797cdd6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode:\\\\u4F60\\\\u597D\", \"Unicode:你好\"},\n\t\t{\"Invalid Unicode:\\\\uXYZ\", \"Invalid Unicode:\\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Mixed: \\\\nHello\\\\tWorld\\\\u0021\", \"Mixed: \\nHello\\tWorld!\"},\n\t\t{\"No escape characters\", \"No escape characters\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","8a73b2899763b71a1e7be8fdde02f4a4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"3.14\", \"3.14\", \"\", false},\n\t\t{\"inf123\", \"\", \"123\", false},\n\t\t{\"nanxyz\", \"\", \"xyz\", false},\n\t\t{\"-inf\", \"\", \"\", false},\n\t\t{\"nan\", \"\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", true}, // edge case: empty string\n\t\t{\"-abc\", \"\", \"-abc\", true}, // edge case: negative with non-numeric\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expected = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","8a92d6cf40fb9967c46b22a97cd7d74c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                             // Test empty string\n\t\t{\"   \", \"\"},                          // Test string with only whitespace\n\t\t{\"\\n\\t\\r   \", \"\"},                   // Test string with newlines and tabs\n\t\t{\"   hello\", \"hello\"},                // Test leading whitespace\n\t\t{\"\\n\\t\\r   world\", \"world\"},          // Test leading whitespace with newlines and tabs\n\t\t{\"hello   \", \"hello   \"},             // Test trailing whitespace\n\t\t{\"   hello   world   \", \"hello   world   \"}, // Test leading and trailing whitespace\n\t\t{\"\\n\\t\\rhello\", \"hello\"},             // Test newlines and tabs before text\n\t\t{\"hello\\n\\t\\r\", \"hello\\n\\t\\r\"},       // Test newlines and tabs after text\n\t\t{\"\\n\\t\\r   \\n\\t\\r\", \"\"},              // Test multiple newlines and tabs\n\t\t{\"   \\n\\t\\r   \", \"\"},                 // Test whitespace with newlines and tabs\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","8bd5ac54a8d97cb3498cac05c38ebb21":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"42abc\", \"42\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","8cebbaf56eed54ae7ac1f41dc7bca55a":"","8e7a2d1d824892a379375c34369f029f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) \u0026\u0026 (test.err == nil || err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseObject(%q) returned unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value objects here.\n\t// This is a placeholder for the actual comparison logic.\n\treturn false\n}","8eae25ac5e53288751b9137800585cf9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested\": \"value\"}}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{s: \"value\", t: typeRawString}}}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested\": [1, 2, 3]}}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}}}}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested\": \"value\", \"invalid\": \"unexpected\"}}`,\n\t\t\texpected: nil, // This case is for testing error handling, expected to fail\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif result.s != test.expected.s || result.t != test.expected.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","8f3577abc1e9b4953cc10e31b104475d":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\t   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\r   Hello, World!\", \"Hello, World!\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"\\r\", \"\"},\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"   Leading spaces\", \"Leading spaces\"},\n\t\t{\"Trailing spaces   \", \"Trailing spaces   \"},\n\t\t{\"\\n\\n\\n   Only newlines\", \"Only newlines\"},\n\t\t{\"\\t\\t\\t   Only tabs\", \"Only tabs\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","8f686768662947d3b2eeeb2bfd5865e5":"","9077a4076d664e3c106ffc6a35892930":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"-invalid\", \"\", \"-invalid\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","90accc99b0223bbeeeeba3f4b5a0306c":"// file: object_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object with some initial key-value pairs\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", \u0026Value{}},\n\t\t\t{\"key2\", \u0026Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Check the initial state of the Object\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped != true {\n\t\tt.Errorf(\"Expected keysUnescaped to be true, got %v\", obj.keysUnescaped)\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Check the state of the Object after reset\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length to be 1 after reset, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped != false {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, got %v\", obj.keysUnescaped)\n\t}\n}","927442f535b7e4a37d3a499635756263":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                              // empty string\n\t\t{\"   \", \"\"},                           // only whitespace\n\t\t{\"   a\", \"a\"},                         // leading whitespace\n\t\t{\"\\n   a\", \"a\"},                       // newline followed by text\n\t\t{\"\\t   a\", \"a\"},                       // tab followed by text\n\t\t{\"   a   \", \"a   \"},                  // leading and trailing whitespace\n\t\t{\"\\r\\n   a\", \"a\"},                     // carriage return and newline\n\t\t{\"a\", \"a\"},                            // no whitespace\n\t\t{\"   a   b   \", \"a   b   \"},          // multiple words with leading and trailing whitespace\n\t\t{\"\\n\\n   a\\nb\\n\", \"a\\nb\\n\"},          // newlines and text\n\t\t{\"\\t\\t   a\\tb\\t\", \"a\\tb\\t\"},          // tabs and text\n\t\t{\"   \\r\\n   a\", \"a\"},                  // mixed whitespace\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","931de4c9bc95fb1424329131cacd818c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","944cf59ea2ceb697831d45af4347d2e0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\"world\\\"!\"`,\n\t\t\texpectedValue: \"hello \\\"world\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"!\"`,\n\t\t\texpectedValue: \"hello \\\\\\\"world\\\\\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\"quote\\\\\" and more\" text`,\n\t\t\texpectedValue: \"escaped \\\\\\\"quote\\\\\\\" and more\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"quotes\\\" inside\" and \"outside\"`,\n\t\t\texpectedValue: \"multiple \\\"quotes\\\" inside\",\n\t\t\texpectedRest:  \" and \\\"outside\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","95389a6837d9eb3a84111077fcf4a879":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+10xyz\", \"-123.45e+10\", \"xyz\", false},\n\t\t{\"0.123\", \"0.123\", \"\", false},\n\t\t{\"-nan123\", \"-nan\", \"123\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"\", \"\", \"\", false}, // Edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expected = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","962a6598fdf73728f2ed67799af5edd1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"extra\": \"data\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tparser := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := parser.Parse(test.input)\n\n\t\tif test.hasError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\t// Add assertions to compare result with expected value\n\t\t\t// For example, you might want to check the type or specific fields\n\t\t}\n\t}\n}","973c84c52e171785247ca35616aa1d1f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"\\t\\tworld\", \"world\"},\n\t\t{\"\\n\\n\\nfoo\", \"foo\"},\n\t\t{\"bar\", \"bar\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\t\\t\\t\", \"\"},\n\t\t{\"\\n\\n\\n\", \"\"},\n\t\t{\"   \\t\\n  baz\", \"baz\"},\n\t\t{\"\\t\\n  qux  \", \"qux  \"},\n\t\t{\"   \\x00\\x01\\x02\", \"\\x00\\x01\\x02\"}, // Non-whitespace characters\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","97f2c7add671ebe3902cf2bb0b7a7f33":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected Value structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected Value structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected Value structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected Value structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected Value structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected Value structure\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\t// Additional checks for the expected Value can be added here\n\t\t// e.g., comparing the structure of the result with the expected Value\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) = remaining %q, want empty\", test.input, remaining)\n\t\t}\n\t}\n}","988e774d0c9bbf8ebec69401aa6197ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\" and \\\\u4F60\\\\u597D\", \"\\\"Hello\\\" and 你好\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","98c795bf1798c0c906aef3710ac7839f":"// hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"hello\", false},\n\t\t{\"hello\\nworld\", true},\n\t\t{\"hello\\tworld\", true},\n\t\t{\"hello\\\\world\", true},\n\t\t{\"hello\\x00world\", true}, // null byte\n\t\t{\"normal string\", false},\n\t\t{\"string with special chars !@#$%^\u0026*()\", true},\n\t\t{\"\", false}, // empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9914998199e4809edead0dd3661441c4":"// parse_raw_string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\\\"escaped\\\" quote\"`,\n\t\t\texpectedValue: \"\\\"escaped\\\" quote\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","99f957235d301b83e920e28e6e699f3b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, , 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","9a400049bc667439078b6f295edaa514":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","9b380eec8fa2e09aba0eeacd0f8da3ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\uD83D\", \"Incomplete\\\\uD83D\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9c63bb399dab302f6903eab6bf141443":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: Initial state\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t}\n\n\t// Test case 2: Check if the value is of type Value\n\tif _, ok := val.(*Value); !ok {\n\t\tt.Errorf(\"Expected value to be of type *Value, got %T\", val)\n\t}\n\n\t// Test case 3: Ensure that the value is initialized properly\n\tif cap(c.vs) != 1 {\n\t\tt.Errorf(\"Expected capacity of vs to be 1, got %d\", cap(c.vs))\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Test case 4: Get another value and check if it expands the slice\n\tval2 := c.getValue()\n\tif cap(c.vs) != 2 {\n\t\tt.Errorf(\"Expected capacity of vs to be 2 after getting another value, got %d\", cap(c.vs))\n\t}\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of vs to be 2 after getting another value, got %d\", len(c.vs))\n\t}\n\n\t// Test case 5: Check if the second value is also of type Value\n\tif _, ok := val2.(*Value); !ok {\n\t\tt.Errorf(\"Expected second value to be of type *Value, got %T\", val2)\n\t}\n}","9d1c733b765c6e5bb2e318b7bf7b1f1d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid float64\",\n\t\t\tinput:    parseJSON(`{\"key\": 3.14}`),\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tinput:    parseJSON(`{\"key\": 3.14}`),\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tinput:    parseJSON(`{\"key\": \"not_a_number\"}`),\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (object)\",\n\t\t\tinput:    parseJSON(`{\"key\": {}}`),\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested valid float64\",\n\t\t\tinput:    parseJSON(`{\"outer\": {\"inner\": 2.71}}`),\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 2.71,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index valid float64\",\n\t\t\tinput:    parseJSON(`{\"array\": [1.23, 4.56]}`),\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 4.56,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of bounds\",\n\t\t\tinput:    parseJSON(`{\"array\": [1.23]}`),\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to parse JSON strings into Value objects\nfunc parseJSON(s string) *Value {\n\t// Assume this function is implemented to parse a JSON string into a Value\n}","9d722c9775b36fd5ffebc9644db7afd5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRest string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:        `\"key\"`,\n\t\t\texpectedKey: `\"key\"`,\n\t\t\texpectedRest: ``,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"anotherKey\"`,\n\t\t\texpectedKey: `\"anotherKey\"`,\n\t\t\texpectedRest: ``,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"keyWithEscapedChars\\\\\"`,\n\t\t\texpectedKey: `\"keyWithEscapedChars\\\\\"`,\n\t\t\texpectedRest: ``,\n\t\t\texpectedError: true, // should trigger slow path\n\t\t},\n\t\t{\n\t\t\tinput:        `\"keyWith\\\\Escape\"`,\n\t\t\texpectedKey: ``,\n\t\t\texpectedRest: ``,\n\t\t\texpectedError: true, // should trigger slow path\n\t\t},\n\t\t{\n\t\t\tinput:        `missingQuote`,\n\t\t\texpectedKey: ``,\n\t\t\texpectedRest: ``,\n\t\t\texpectedError: true, // missing closing quote\n\t\t},\n\t\t{\n\t\t\tinput:        `\"keyWithMissingEnd`,\n\t\t\texpectedKey: ``,\n\t\t\texpectedRest: ``,\n\t\t\texpectedError: true, // missing closing quote\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, rest, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","9ded4cbbfb091b99193517a3125351b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a test string with no escapes.\", \"This is a test string with no escapes.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Newline\\\\ncharacter\", \"Newline\\ncharacter\"},\n\t\t{\"Tab\\\\tcharacter\", \"Tab\\tcharacter\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed \\\\uD83D\\\\uDE00 and normal text\", \"Mixed 😀 and normal text\"},\n\t\t{\"Incomplete escape \\\\uD83D\", \"Incomplete escape \\\\uD83D\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9e07e1684a9175571829fc4b6c2848ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: \u0026Value{s: \"value\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key\",\n\t\t\tinput:    `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\tkeys:     []string{\"key1\", \"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing index from array\",\n\t\t\tinput:    `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: \u0026Value{s: \"value2\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing index from array\",\n\t\t\tinput:    `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"key1\", \"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested structure\",\n\t\t\tinput:    `{\"key1\": {\"key2\": [\"value1\", \"value2\"]}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\", \"0\"},\n\t\t\texpected: \u0026Value{s: \"value1\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from empty object\",\n\t\t\tinput:    `{}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from empty array\",\n\t\t\tinput:    `{\"key1\": []}`,\n\t\t\tkeys:     []string{\"key1\", \"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse input: %v\", err)\n\t\t\t}\n\t\t\tresult := v.Get(tt.keys...)\n\t\t\tif (result == nil) != (tt.expected == nil) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t} else if result != nil \u0026\u0026 result.s != tt.expected.s {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected.s, result.s)\n\t\t\t}\n\t\t})\n\t}\n}","9e0ed56369c9670fc81d5c33642bb3d0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"   a\", \"a\"},\n\t\t{\"a   \", \"a   \"},\n\t\t{\"  a b  \", \"a b  \"},\n\t\t{\"\\t\\n a\", \"a\"},\n\t\t{\"\\t\\n a b \\t\\n\", \"a b \\t\\n\"},\n\t\t{\"\\x00\\x01\\x02 a\", \"a\"}, // Non-whitespace characters before\n\t\t{\"a\\x00\\x01\\x02\", \"a\\x00\\x01\\x02\"}, // Non-whitespace characters after\n\t\t{\"\\x20\\x20\\x20a\", \"a\"}, // Space characters\n\t\t{\"\\x20\\x20\\x20\", \"\"}, // Only space characters\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9e524aa14aefac4ab3ed67beab293c90":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                             // empty string\n\t\t{\"   \", \"\"},                         // only whitespace\n\t\t{\"   hello\", \"hello\"},               // leading whitespace\n\t\t{\"hello   \", \"hello   \"},            // trailing whitespace\n\t\t{\"   hello   \", \"hello   \"},         // leading and trailing whitespace\n\t\t{\"\\nhello\", \"hello\"},                 // newline at the start\n\t\t{\"\\thello\", \"hello\"},                 // tab at the start\n\t\t{\"\\rhello\", \"hello\"},                 // carriage return at the start\n\t\t{\"hello\\n\", \"hello\\n\"},               // newline at the end\n\t\t{\"hello\\t\", \"hello\\t\"},               // tab at the end\n\t\t{\"hello\\r\", \"hello\\r\"},               // carriage return at the end\n\t\t{\"   hello world   \", \"hello world   \"}, // mixed whitespace\n\t\t{\"\\n\\n\\nhello\", \"hello\"},             // multiple newlines\n\t\t{\"\\t\\t\\thello\", \"hello\"},             // multiple tabs\n\t\t{\"\\r\\r\\rhello\", \"hello\"},             // multiple carriage returns\n\t\t{\"   \\n\\t\\rhello   \", \"hello   \"},    // mixed leading whitespace\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9ecd12b15090c9fb41c1b44b254548bd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\world\"`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","9f53176c39cd51e97ea861dcb0f5391f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Replace with expected Value\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Replace with expected Value\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true false\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \" false\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"{\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": \"value\"` + \"}\",\n\t\t\texpected: nil, // Replace with expected Value\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"[\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif v != test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","9f91440c10436878372c66e4c407c431":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"normal string\", `\"normal string\"`},\n\t\t{\"string with newline\\n\", `\"string with newline\\n\"`},\n\t\t{\"string with tab\\t\", `\"string with tab\\t\"`},\n\t\t{\"string with quote\\\"\", `\"string with quote\\\"\"`},\n\t\t{\"string with backslash\\\\\", `\"string with backslash\\\\\"`},\n\t\t{\"\", `\"\"`}, // empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := escapeString(nil, test.input)\n\t\tif string(dst) != test.expected {\n\t\t\tt.Errorf(\"escapeString(%q) = %q; expected %q\", test.input, dst, test.expected)\n\t\t}\n\t}\n}","9fedd9038220768c2bac39e510f99dc1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Fatal(\"Expected a non-nil Value\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected cache to have 1 value, got %d\", len(c.vs))\n\t}\n\n\t// Test getting another value\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Fatal(\"Expected a non-nil Value\")\n\t}\n\n\t// Test that the cache size increases\n\tif len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected cache to have 2 values, got %d\", len(c.vs))\n\t}\n\n\t// Test that the returned values are distinct\n\tif val1 == val2 {\n\t\tt.Fatal(\"Expected distinct Value pointers\")\n\t}\n\n\t// Test capacity behavior\n\tfor i := 0; i \u003c 100; i++ {\n\t\tc.getValue()\n\t}\n\tif cap(c.vs) \u003c 102 {\n\t\tt.Fatalf(\"Expected cache capacity to be at least 102, got %d\", cap(c.vs))\n\t}\n}","a0373d3677e79e645b6cf3ae1430e524":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 'invalid']\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","a0be294fe6b017709180cd40c5a0fee5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid float64\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float64 with nested keys\",\n\t\t\tjson:     `{\"data\": {\"value\": 2.71}}`,\n\t\t\tkeys:     []string{\"data\", \"value\"},\n\t\t\texpected: 2.71,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (array)\",\n\t\t\tjson:     `{\"value\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float64 with array index\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 2.2,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array index\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"values\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","a182a5363911766a168f3e7aaec2dfd7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","a1999ce8c66e2667b511eb94b5a41394":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"-nan more text\", \"-nan\", \" more text\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","a1df8c3e567b7b354393345c6fe5b1af":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Test cases for the Get function\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tinput:    /* initialize with a valid JSON object */,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key from object\",\n\t\t\tinput:    /* initialize with a valid JSON object */,\n\t\t\tkeys:     []string{\"nonExistingKey\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing index from array\",\n\t\t\tinput:    /* initialize with a valid JSON array */,\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing index from array\",\n\t\t\tinput:    /* initialize with a valid JSON array */,\n\t\t\tkeys:     []string{\"10\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested object\",\n\t\t\tinput:    /* initialize with a valid nested JSON object */,\n\t\t\tkeys:     []string{\"outerKey\", \"innerKey\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nested array\",\n\t\t\tinput:    /* initialize with a valid nested JSON array */,\n\t\t\tkeys:     []string{\"outerArray\", \"0\", \"innerKey\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get with invalid key type\",\n\t\t\tinput:    /* initialize with a valid JSON object */,\n\t\t\tkeys:     []string{\"key1\", \"0\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get with mixed keys\",\n\t\t\tinput:    /* initialize with a valid JSON object */,\n\t\t\tkeys:     []string{\"arrayKey\", \"1\", \"objectKey\"},\n\t\t\texpected: /* expected Value */,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","a235cfa8a800f97d978cf0010f204605":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil, // Expected value should be set according to the implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\tdepth:    0,\n\t\t\texpected: nil, // Expected value should be set according to the implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\ttail:     \"a\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, test.depth)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q, %d) error = %v, wantErr %v\", test.input, test.depth, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif v != test.expected {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = %v, want %v\", test.input, test.depth, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q, %d) tail = %q, want %q\", test.input, test.depth, tail, test.tail)\n\t\t}\n\t}\n}","a25d25f02f8b86580274389aa74aef8f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty array\n\t\t{\"\\\"hello\\\"\", \u0026Value{s: \"hello\", t: typeRawString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for true\n\t\t{\"false\", valueFalse, false}, // Test for false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}}, t: TypeObject}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}, t: TypeObject}, false}, // Test for object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}, t: TypeObject}, false}, // Test for object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}, t: TypeObject}, false}, // Test for object with number value\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 (v == nil || v.t != test.expected.t || v.s != test.expected.s) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t}\n}","a26b80d5cf03fc8984eb5057109c119c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: typeRawString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test object with boolean\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test object with null\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test object with number\n\t\t{\"{\\\"key\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, false}, // Test object with array\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 v != nil {\n\t\t\tif v.t != test.expected.t || v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t} else if (v == nil) != (test.expected == nil) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t}\n}","a26ff4e2909ed2e5edc90ee00447e0ab":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","a2c3d304cfd86c61fd58859dae8a49a4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\\\\u0042\\\\u0043\", \"Unicode: ABC\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: Hello\\\\nWorld\\\\t\\\\u0031\", \"Mixed: Hello\\nWorld\\t1\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t\t{\"Multiple escapes: \\\\\\\"\\\\n\\\\t\\\\u0032\", \"\\\"\\n\\t2\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a2f4f8f4570d0c7dbc3af7e259d2ec73":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\Test\", \"Backslash\\\\Test\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewLine\", \"Mixed😀\\nNewLine\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Incomplete\\\\uD83D\", \"Incomplete\\\\uD83D\"},\n\t\t{\"Incomplete\\\\uD83D\\\\u\", \"Incomplete\\\\uD83D\\\\\"},\n\t\t{\"Escape\\\\x\", \"Escape\\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a31ab6e2a85edb4433203a49ee3c665e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode:\\\\u0041\\\\u0042\\\\u0043\", \"Unicode:ABC\"},\n\t\t{\"Invalid Unicode:\\\\uXYZ\", \"Invalid Unicode:\\\\uXYZ\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\u0041\", \"Mixed: 😀 and A\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a33528d332979ee2e87754f0c86d20ab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","a3df68aeb767bb59890390b17452dac4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\" \"key3\": \"value3\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\t// You can also check the remaining string if necessary\n\t\t// if remaining != expectedRemaining {\n\t\t//     t.Errorf(\"parseObject(%q) remaining = %q, want %q\", test.input, remaining, expectedRemaining)\n\t\t// }\n\t}\n}\n\n// compareValues is a helper function to compare expected and actual Value structures\nfunc compareValues(a, b *Value) bool {\n\t// Implement comparison logic based on Value structure\n\treturn true // Placeholder\n}","a3e48b7e8794256346743472b05097d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Invalid escape: \\\\x\", \"Invalid escape: \\\\x\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\nWorld\\\\\\\"\", \"Mixed: \\\"Hello\\nWorld\\\"\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Empty: \\\"\\\"\", \"\"},\n\t\t{\"Backslash only: \\\\\\\\\", \"\\\\\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"/\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a4fba82f647f277618decc132ad6bbbd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete: \\\\uD83D\", \"Incomplete: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\u4F60\\\\u597D\", \"Mixed: 😀 and 你好\"},\n\t\t{\"Escaped slashes: \\\\\\\\ and /\", \"Escaped slashes: \\\\ and /\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a5b8556bdc21d1ed32652816cb936193":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"Null Value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Boolean True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Boolean False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"[1,2,3]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"raw string\",\n\t\t\t},\n\t\t\texpected: []byte(\"raw string\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","a5e01f7b9aa5ec2f7147d5827f47b853":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // An arbitrary value not defined in the Type constants\n\tunknownType.String()\n}","a5e6d71fa8c194773dae5aec918f7650":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\t// Add more detailed comparison logic as needed\n\treturn v1.t == v2.t \u0026\u0026 v1.s == v2.s \u0026\u0026 compareObjects(v1.o, v2.o)\n}\n\n// compareObjects is a helper function to compare two Object objects for equality.\nfunc compareObjects(o1, o2 Object) bool {\n\tif len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k || !compareValues(o1.kvs[i].v, o2.kvs[i].v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","a68b8acf83004d4b6f250b3f0d6d4899":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t} else if test.expected != nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) did not consume all input, remaining: %q\", test.input, remaining)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function to check if two Value instances are equal\n\t// This function should compare the type, object keys, and values accordingly\n\treturn false // Placeholder, implement the actual comparison logic\n}","a70e42d00ffb9791be3db5ccdfec5efc":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal Raw String\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"raw\"},\n\t\t\texpected: `\"raw\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}},\n\t\t\t},\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: `123`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","a811fb62916e790dd566077bd6a35109":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // Assuming 8 is not a defined Type\n\tunknownType.String()\n}","a9e232b93b484e6e3469207334efc237":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: Initial state\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Error(\"Expected a non-nil value, got nil\")\n\t}\n\n\t// Test case 2: Adding a value\n\tc.vs = append(c.vs, Value{})\n\tval = c.getValue()\n\tif val == nil {\n\t\tt.Error(\"Expected a non-nil value, got nil\")\n\t}\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Test case 3: Capacity increase\n\tc.vs = make([]Value, 0, 1) // Set capacity to 1\n\tval = c.getValue()\n\tif val == nil {\n\t\tt.Error(\"Expected a non-nil value, got nil\")\n\t}\n\tif cap(c.vs) != 2 {\n\t\tt.Errorf(\"Expected capacity of vs to be 2, got %d\", cap(c.vs))\n\t}\n\n\t// Test case 4: Retrieving the same value\n\tval1 := c.getValue()\n\tval2 := c.getValue()\n\tif val1 == val2 {\n\t\tt.Log(\"Successfully retrieved the same value from cache\")\n\t} else {\n\t\tt.Error(\"Expected the same value, got different values\")\n\t}\n\n\t// Test case 5: Ensure the value is not reset\n\tc.vs[0] = Value{s: \"test\"}\n\tretrievedVal := c.getValue()\n\tif retrievedVal.s != \"test\" {\n\t\tt.Errorf(\"Expected retrieved value to be 'test', got '%s'\", retrievedVal.s)\n\t}\n}","aa6b9126a55855fa7d61ff927be5d07b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinput        []kv\n\t\texpectedKeys []string\n\t}{\n\t\t{\n\t\t\tname: \"No escape sequences\",\n\t\t\tinput: []kv{\n\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t},\n\t\t\texpectedKeys: []string{\"key1\", \"key2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"With escape sequences\",\n\t\t\tinput: []kv{\n\t\t\t\t{k: \"key\\\\1\", v: nil},\n\t\t\t\t{k: \"key\\\\2\", v: nil},\n\t\t\t},\n\t\t\texpectedKeys: []string{\"key1\", \"key2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Mixed keys\",\n\t\t\tinput: []kv{\n\t\t\t\t{k: \"key\\\\1\", v: nil},\n\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t\t{k: \"key\\\\3\", v: nil},\n\t\t\t},\n\t\t\texpectedKeys: []string{\"key1\", \"key2\", \"key3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Already unescaped\",\n\t\t\tinput: []kv{\n\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t},\n\t\t\texpectedKeys: []string{\"key1\", \"key2\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tobj := \u0026Object{\n\t\t\t\tkvs:           tt.input,\n\t\t\t\tkeysUnescaped: false,\n\t\t\t}\n\n\t\t\tobj.unescapeKeys()\n\n\t\t\tfor i, kv := range obj.kvs {\n\t\t\t\tif kv.k != tt.expectedKeys[i] {\n\t\t\t\t\tt.Errorf(\"expected key %s, got %s\", tt.expectedKeys[i], kv.k)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","aadbb8a32afe4362ea210a5afd1631b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"existing object key\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing object key\",\n\t\t\tinput: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"existing array index\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"non-existing array index\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid array index\",\n\t\t\tinput: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value0\"},\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\tkeys:     []string{\"-1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"nil input\",\n\t\t\tinput: nil,\n\t\t\tkeys:  []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Get() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","ab7254c63d697a2098f1843de7716d02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Valid float64 value\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tjson:     `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (object)\",\n\t\t\tjson:     `{\"value\": {}}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (array)\",\n\t\t\tjson:     `{\"value\": []}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested valid float64 value\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 2.71}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 2.71,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested non-existing key\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 2.71}}`,\n\t\t\tkeys:     []string{\"outer\", \"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index access\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 2.2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid array index\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"values\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{}\n\t\t\tif err := v.Parse(tt.json); err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse json: %v\", err)\n\t\t\t}\n\t\t\tgot := v.GetFloat64(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"GetFloat64(%v) = %v; want %v\", tt.keys, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","abaa0a9b4a1101f0ffe6fbdd0d47f13e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\t  World\", \"World\"},\n\t\t{\"   \\n\\t   \", \"\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   LeadingSpaces\", \"LeadingSpaces\"},\n\t\t{\"TrailingSpaces   \", \"TrailingSpaces   \"},\n\t\t{\"\\n\\n\\nNewLine\", \"NewLine\"},\n\t\t{\"\\tTabbed\", \"Tabbed\"},\n\t\t{\"Mixed \\n\\tWhitespace\", \"Mixed \\n\\tWhitespace\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","abc7cd4d914a92eeb50b3ac0d0168973":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"inf more text\", \"inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"For input %q, expected number: %q, remaining: %q; got number: %q, remaining: %q\", \n\t\t\t\ttest.input, test.expectedNumber, test.expectedRemaining, number, remaining)\n\t\t}\n\n\t\tif (err == nil \u0026\u0026 test.expectedError != nil) || (err != nil \u0026\u0026 test.expectedError == nil) {\n\t\t\tt.Errorf(\"For input %q, expected error: %v; got error: %v\", test.input, test.expectedError, err)\n\t\t} else if err != nil \u0026\u0026 test.expectedError != nil \u0026\u0026 err.Error() != test.expectedError.Error() {\n\t\t\tt.Errorf(\"For input %q, expected error: %v; got error: %v\", test.input, test.expectedError, err)\n\t\t}\n\t}\n}","abf55f53ceb89bc55eca47b43f24c5c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key1\": \"value1\", \"key2\": { \"nestedKey\": \"nestedValue\" } }`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value instances\n\t// This is a placeholder for the actual comparison logic\n\treturn false\n}","ac3e7c0295a352264e9924a302df5bfd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemainder string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"key\"`,\n\t\t\texpectedKey:   \"key\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"anotherKey\"`,\n\t\t\texpectedKey:   \"anotherKey\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWithNoClosing`,\n\t\t\texpectedKey:   \"keyWithNoClosing\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:          `keyWithoutQuotes`,\n\t\t\texpectedKey:   \"keyWithoutQuotes\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWithEscape\\\\\"`,\n\t\t\texpectedKey:   \"keyWithEscape\\\\\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWith\\\\Escape\"`,\n\t\t\texpectedKey:   \"keyWith\\\\Escape\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWith\\\\EscapeAndMore\"`,\n\t\t\texpectedKey:   \"keyWith\\\\EscapeAndMore\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remainder, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawKey(%q) remainder = %q, expectedRemainder %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","ac7b78a14ebcaa3e2da32258ce951a82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"0.123\", \"0.123\", \"\", nil},\n\t\t{\"-0.456xyz\", \"-0.456\", \"xyz\", nil},\n\t\t{\"123e10more\", \"123e10\", \"more\", nil},\n\t\t{\"-123.45E-10\", \"-123.45E-10\", \"\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", nil}, // No valid number at the start\n\t\t{\"\", \"\", \"\", nil}, // Empty string\n\t\t{\"-abc\", \"\", \"-abc\", nil}, // Invalid number\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining || err != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","adf277bf36616eaa81aa73858644bb63":"// string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"unknown type\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for unknown type\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 999 // An arbitrary value not defined in Type\n\t\tunknownType.String()\n\t})\n}","ae0b572cc88c22817952f3cafbbcef57":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": \"value\"` + \"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": \"value\", \"nested\": {\"inner_key\": \"inner_value\"}` + \"}\",\n\t\t\texpected: nil, // Expecting an error due to incomplete JSON\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"array\": [1, 2, 3]}`,\n\t\t\texpected: nil, // Expecting a valid object but will need to check the expected structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"array\": [1, 2, \"string\"]}`,\n\t\t\texpected: nil, // Expecting a valid object but will need to check the expected structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"array\": [1, 2, 3, {\"nested\": \"value\"}]}`,\n\t\t\texpected: nil, // Expecting a valid object but will need to check the expected structure\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\t// This is a placeholder for the actual comparison logic\n\treturn false\n}","ae4d8039b488babc11d0ff7d99cdce09":"// file: object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Initial state: kvs should be empty\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs length to be 0, got %d\", len(obj.kvs))\n\t}\n\n\t// Call getKV and check the state after the first call\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Error(\"Expected kv1 to be non-nil\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length to be 1 after first getKV, got %d\", len(obj.kvs))\n\t}\n\n\t// Check the kv1 values\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected kv1 to have default values, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Call getKV again and check the state\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Error(\"Expected kv2 to be non-nil\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2 after second getKV, got %d\", len(obj.kvs))\n\t}\n\n\t// Ensure kv2 is a different instance than kv1\n\tif kv1 == kv2 {\n\t\tt.Error(\"Expected kv1 and kv2 to be different instances\")\n\t}\n\n\t// Check the kv2 values\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected kv2 to have default values, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n}","ae9123f503428ba5692e3ea27ac17461":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) value = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","ae9693e983789f3217631b97120308a1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45\", \"-123.45\", \"\", false},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"abc123\", \"\", \"abc123\", true},\n\t\t{\"\", \"\", \"\", true}, // Edge case: empty string\n\t\t{\"-123.45e+10\", \"-123.45e+10\", \"\", false},\n\t\t{\"+123\", \"+123\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want err = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\n\t\tif remaining != test.remaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, want %q\", test.input, remaining, test.remaining)\n\t\t}\n\t}\n}","af10a7f04b7057fbe477a26022125bc6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\\\"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\\\"world\\\\\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"\\\"world\\\\\\\"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","afef6c05b46268a259be59a5a9fca661":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"example\",\n\t\t\t},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","b04b74319d940f0635ec6c3ab0c4f8db":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string\\\", true, null]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeString, s: \"string\"}, \u0026Value{t: TypeTrue}, \u0026Value{t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","b0b5fd686ad16fef8e8d59f74a9f67c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Create a sample JSON structure for testing\n\tjsonStr := `{\"name\": \"John\", \"age\": 30, \"skills\": [\"Go\", \"Python\"], \"address\": {\"city\": \"New York\", \"zip\": \"10001\"}}`\n\tv, err := Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t// Test for existing keys\n\t\t{[]string{\"name\"}, v.Get(\"name\")},\n\t\t{[]string{\"age\"}, v.Get(\"age\")},\n\t\t{[]string{\"skills\", \"0\"}, v.Get(\"skills\", \"0\")},\n\t\t{[]string{\"address\", \"city\"}, v.Get(\"address\", \"city\")},\n\n\t\t// Test for non-existing keys\n\t\t{[]string{\"nonexistent\"}, nil},\n\t\t{[]string{\"address\", \"nonexistent\"}, nil},\n\t\t{[]string{\"skills\", \"10\"}, nil},\n\n\t\t// Test for invalid key types\n\t\t{[]string{\"age\", \"nonexistent\"}, nil},\n\t\t{[]string{\"skills\", \"not_a_number\"}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.Get(test.keys...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Get(%v) = %v; want %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","b19489aa7c40cead98db30a214543112":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"-invalid\", \"\", \"-invalid\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","b23f165790dec92592a71e74e8fd8fd3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","b274ce25e34f5619bedd4d1f51c52eb9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"for input %q, expected %d values, got %d\", test.input, len(test.expected), len(result.a))\n\t\t}\n\n\t\tfor i, expectedValue := range test.expected {\n\t\t\tif result.a[i].t != expectedValue.t || result.a[i].s != expectedValue.s {\n\t\t\t\tt.Errorf(\"for input %q, expected value %v at index %d, got %v\", test.input, expectedValue, i, result.a[i])\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"for input %q, expected no remaining string, got %q\", test.input, remaining)\n\t\t}\n\t}\n}","b2c1c16f19f788e01adcb94f55cad0b0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for object with array */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\t// Compare expected and actual Value structures here\n\t\t\t// This will depend on how you implement equality for Value\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want empty\", test.input, remaining)\n\t\t}\n\t}\n}","b2cf84a6aeb0b423ad46a2a92b4babdf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Test Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Test String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"rawString\",\n\t\t\t},\n\t\t\texpected: \"\\\"rawString\\\"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","b450486b468a9852733fdb3976569a3c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid float64\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 2.71}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 2.71,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 2.2,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of bounds\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2]}`,\n\t\t\tkeys:     []string{\"values\", \"5\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty JSON\",\n\t\t\tjson:     `{}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tjson:     `{\"value\": null}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tgot := v.GetFloat64(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"GetFloat64() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","b514df76d6af14fc4f444c942cde5ac8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"\\n\\n\\t\\tworld\", \"world\"},\n\t\t{\"   \\t   \\n\\n   \", \"\"},\n\t\t{\"noWhitespace\", \"noWhitespace\"},\n\t\t{\"   leading spaces\", \"leading spaces\"},\n\t\t{\"trailing spaces   \", \"trailing spaces   \"},\n\t\t{\"\\nnew line\\n\", \"new line\\n\"},\n\t\t{\"\\t tabbed\\t\", \"tabbed\\t\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","b5ba9e305ed271a13086bb75c92eeb74":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test true\n\t\t{\"false\", valueFalse, false}, // Test false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test object with boolean\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test object with null\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test object with number\n\t\t{\"{\\\"key\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, false}, // Test object with array\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, expected error = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 result != nil {\n\t\t\tif result.t != test.expected.t || result.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected = %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","b649516c92ed84646401f9a0c8be1b42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Get existing key from object\",\n\t\t\tjson:     `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: \u0026Value{s: \"value\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing key\",\n\t\t\tjson:     `{\"key1\": {\"key2\": \"value\"}}`,\n\t\t\tkeys:     []string{\"key1\", \"key3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get existing key from array\",\n\t\t\tjson:     `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: \u0026Value{s: \"value2\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tname:     \"Get non-existing index from array\",\n\t\t\tjson:     `{\"key1\": [\"value1\", \"value2\"]}`,\n\t\t\tkeys:     []string{\"key1\", \"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from non-object type\",\n\t\t\tjson:     `{\"key1\": \"value\"}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Get from nil value\",\n\t\t\tjson:     `null`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := \u0026Parser{}\n\t\t\tv, err := parser.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tresult := v.Get(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","b677050dbcec629c8d29f82e2c3f2fd6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected Type\n\t}{\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeRawString\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\texpected: typeRawString,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.value.Type(); got != tt.expected {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","b702b7f64b16cbf5e64694750a7a6b86":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"key\"`,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"anotherKey\" more text`,\n\t\t\texpectedKey: \"anotherKey\",\n\t\t\texpectedRemaining: \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with spaces\"`,\n\t\t\texpectedKey: \"key with spaces\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\\"escaped\\\" quotes\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `no quotes`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with a backslash \\\\ \"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, expectedRemaining %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","b77435e569aff9b55cf6558a968f476c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world\\\\\"`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\\\\\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello \\\\\\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","b7a19dad9f8dc44de63625c70135f9cb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", false},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"\", \"\", \"\", true}, // edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expectedNumber = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expectedRemaining = %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","b820683300c14c36357582b48bac4df3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\" more text`,\n\t\t\texpectedValue:  \"hello\\\"world\",\n\t\t\texpectedRemain: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue:  \"hello\\\\\",\n\t\t\texpectedRemain: \"world\\\" text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `no quotes here`,\n\t\t\texpectedValue:  \"no quotes here\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) remain = %q, expectedRemain %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","b9027e608afcd64bdeefc42196d68462":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"example\",\n\t\t\t},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","b94c8a675ca01c0e5705f4898a327a1f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q)[%d] = %v, want %v\", test.input, i, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","b986d4c589f56a16c52eb378505a2e52":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for unknown type (should panic)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // Assuming 8 is an invalid type\n\tunknownType.String()\n}","bae59786f5c861d477ca897b14a101e7":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[\"item1\",42]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","bae6aaeb6d2dde466a9d225e8b25689e":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","bba33bd45299023ca8b7a83a78d12329":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","bbd4aacd501b5510c301e28e2c99a7a2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"Valid string path\",\n\t\t\tjson:     `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: []byte(\"value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested valid string path\",\n\t\t\tjson:     `{\"outer\": {\"inner\": \"value\"}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: []byte(\"value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (number)\",\n\t\t\tjson:     `{\"key\": 123}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (array)\",\n\t\t\tjson:     `{\"key\": [\"value\"]}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid string with array index\",\n\t\t\tjson:     `{\"array\": [\"first\", \"second\"]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: []byte(\"second\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid array index\",\n\t\t\tjson:     `{\"array\": [\"first\", \"second\"]}`,\n\t\t\tkeys:     []string{\"array\", \"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetStringBytes(tt.keys...)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","bbe3e673670e6d1a8100b95f3f3b6604":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"{}\",\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remain, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != nil \u0026\u0026 test.expectedValue != nil {\n\t\t\tif result.t != test.expectedValue.t || len(result.o.kvs) != len(test.expectedValue.o.kvs) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expectedValue = %v\", test.input, result, test.expectedValue)\n\t\t\t}\n\t\t} else if (result == nil) != (test.expectedValue == nil) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, expectedValue = %v\", test.input, result, test.expectedValue)\n\t\t}\n\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseObject(%q) remain = %q, expectedRemain = %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","bc32bb4bd7cd7c280d27c80f1da62f5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","bc5d285469a1c0d8fc4ef44b5183d6ea":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"expected %d values for input %q, got %d\", len(test.expected), test.input, len(result.a))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, expectedValue := range test.expected {\n\t\t\tif result.a[i].t != expectedValue.t || result.a[i].s != expectedValue.s {\n\t\t\t\tt.Errorf(\"expected value %v at index %d for input %q, got %v\", expectedValue, i, test.input, result.a[i])\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"expected no remaining input for %q, got %q\", test.input, remaining)\n\t\t}\n\t}\n}","bd08cdc2e23161062627047e003b8850":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`,\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tCharacter\"`,\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u0041\"`,\n\t\t\texpected: \"Unicode: A\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid Unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate Pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate Pair: 😀\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed: \\u0041 and \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Mixed: A and 😀\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped quotes: \\\"Hello\\\" and \\\"World\\\".\"`,\n\t\t\texpected: \"Escaped quotes: \\\"Hello\\\" and \\\"World\\\".\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escape here\"`,\n\t\t\texpected: \"No escape here\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","bd43f4fafcaeeba798c3f402040ffc31":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\", \\\\u4F60\\\\u597D, \\\\xFF\", \"\\\"Hello\\\", 你好, \\\\xFF\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","be3fef38b753fb00b2dd27df1c22fb9f":"// fastjson_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for an unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 999 // An arbitrary value not defined in the Type constants\n\tunknownType.String()\n}","bfd9bf47990529b6e2f1fe69b5593909":"// hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalString\", false},\n\t\t{\"stringWith\\\"Quote\", true},\n\t\t{\"stringWith\\\\Backslash\", true},\n\t\t{\"stringWith\\000NullChar\", true},\n\t\t{\"stringWith\\007BellChar\", true},\n\t\t{\"stringWithNewline\\n\", true},\n\t\t{\"stringWithTab\\t\", true},\n\t\t{\"stringWithCarriageReturn\\r\", true},\n\t\t{\"stringWithFormFeed\\f\", true},\n\t\t{\"stringWithVerticalTab\\v\", true},\n\t\t{\"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","bfff9a81256b0c60aeeaa312fc7ea322":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","c0874c7164c921c92d5c73b5e96f2adc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"3.14\", \"3.14\", \"\", nil},\n\t\t{\"infxyz\", \"inf\", \"xyz\", nil},\n\t\t{\"nanabc\", \"nan\", \"abc\", nil},\n\t\t{\"-infxyz\", \"-inf\", \"xyz\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\n\t\tif (err != nil) != (test.expectedError != nil) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v; expected error = %v\", test.input, err, test.expectedError)\n\t\t}\n\t}\n}","c139b8b840fd95c233cf58a5b0b8e307":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" rest`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" rest\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"world\"`,\n\t\t\texpectedValue: `hello`,\n\t\t\texpectedRest:  `\"world\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped\\\\\"`,\n\t\t\texpectedValue: `escaped\\`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"double \\\" escape\\\\\"`,\n\t\t\texpectedValue: `double \" escape\\`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","c2da5751cd2c5398838167b28b6919cf":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","c32a429bd8165819c0e2efc39c6b825a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"missing closing quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped quote \\\\\"`,\n\t\t\texpectedValue: \"escaped quote \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"escaped\\\" quotes\" and more`,\n\t\t\texpectedValue: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","c3af1e47e08002ea2a66ba4555dc8b2c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\t// Sample JSON for testing\n\tjsonData := `{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": {\n\t\t\t\"key3\": \"value3\"\n\t\t},\n\t\t\"array\": [\n\t\t\t{\"key4\": \"value4\"},\n\t\t\t{\"key5\": \"value5\"}\n\t\t]\n\t}`\n\n\t// Parse the JSON data\n\tparser := \u0026Parser{}\n\tv, err := parser.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected []byte\n\t}{\n\t\t{[]string{\"key1\"}, []byte(\"value1\")},\n\t\t{[]string{\"key2\", \"key3\"}, []byte(\"value3\")},\n\t\t{[]string{\"array\", \"0\", \"key4\"}, []byte(\"value4\")},\n\t\t{[]string{\"array\", \"1\", \"key5\"}, []byte(\"value5\")},\n\t\t{[]string{\"nonexistent\"}, nil},\n\t\t{[]string{\"key2\", \"nonexistent\"}, nil},\n\t\t{[]string{\"array\", \"2\"}, nil}, // Out of bounds\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.GetStringBytes(test.keys...)\n\t\tif string(result) != string(test.expected) {\n\t\t\tt.Errorf(\"GetStringBytes(%v) = %v; expected %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","c3ca300ea3ef3c2d58924dcfd3e7b4d8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode:\\\\u0041\", \"Unicode:A\"},\n\t\t{\"Invalid Unicode:\\\\uXYZ\", \"Invalid Unicode:\\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete escape: \\\\uD83D\", \"Incomplete escape: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\u0041\", \"Mixed: 😀 and A\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c3d3743fdc801655ec63135d7bb59672":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Error(\"Expected a non-nil value from getValue, got nil\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected cache to have 1 value, got %d\", len(c.vs))\n\t}\n\n\t// Test getting another value\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Error(\"Expected a non-nil value from getValue, got nil\")\n\t}\n\n\t// Test that the cache size increases\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected cache to have 2 values, got %d\", len(c.vs))\n\t}\n\n\t// Test that the values are distinct\n\tif val == val2 {\n\t\tt.Error(\"Expected distinct values from consecutive calls to getValue\")\n\t}\n\n\t// Fill the cache to test capacity handling\n\tfor i := 0; i \u003c 100; i++ {\n\t\tc.getValue()\n\t}\n\tif len(c.vs) != 102 {\n\t\tt.Errorf(\"Expected cache to have 102 values, got %d\", len(c.vs))\n\t}\n}","c3f9de78bc4ab5f2c224c68fe6a512d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\t// Example JSON data for testing\n\tjsonData := `{\n\t\t\"key1\": {\n\t\t\t\"subkey1\": \"value1\",\n\t\t\t\"subkey2\": {\n\t\t\t\t\"subsubkey1\": \"value2\"\n\t\t\t}\n\t\t},\n\t\t\"key2\": [\n\t\t\t{\n\t\t\t\t\"arrayKey1\": \"arrayValue1\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"arrayKey2\": \"arrayValue2\"\n\t\t\t}\n\t\t]\n\t}`\n\n\t// Parse the JSON data\n\tparser := \u0026Parser{}\n\tv, err := parser.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\t// Test valid key path\n\tobj := v.GetObject(\"key1\")\n\tif obj == nil {\n\t\tt.Error(\"Expected non-nil object for key1\")\n\t}\n\n\t// Test nested key path\n\tsubObj := v.GetObject(\"key1\", \"subkey2\")\n\tif subObj == nil {\n\t\tt.Error(\"Expected non-nil object for key1.subkey2\")\n\t}\n\n\t// Test non-existing key path\n\tnonExistentObj := v.GetObject(\"key1\", \"nonExistentKey\")\n\tif nonExistentObj != nil {\n\t\tt.Error(\"Expected nil object for non-existing key path\")\n\t}\n\n\t// Test invalid key path\n\tinvalidObj := v.GetObject(\"key2\", \"0\", \"invalidKey\")\n\tif invalidObj != nil {\n\t\tt.Error(\"Expected nil object for invalid key path\")\n\t}\n\n\t// Test array index access\n\tarrayObj := v.GetObject(\"key2\", \"0\")\n\tif arrayObj == nil {\n\t\tt.Error(\"Expected non-nil object for key2[0]\")\n\t}\n}","c41fada46f28a36a945f14b1dabf43f8":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                          // empty string\n\t\t{\"   \", \"\"},                       // only whitespace\n\t\t{\"\\n\\t\\r \", \"\"},                  // only whitespace with newlines and tabs\n\t\t{\"Hello, World!\", \"Hello, World!\"}, // no leading whitespace\n\t\t{\"   Hello, World!\", \"Hello, World!\"}, // leading whitespace\n\t\t{\"\\n   Hello, World!\", \"Hello, World!\"}, // leading newline and whitespace\n\t\t{\"\\tHello, World!\", \"Hello, World!\"}, // leading tab\n\t\t{\"\\r\\nHello, World!\", \"Hello, World!\"}, // leading carriage return and newline\n\t\t{\"   Hello,   World!   \", \"Hello,   World!   \"}, // leading whitespace, trailing whitespace\n\t\t{\"\\n\\n\\nHello\", \"Hello\"}, // multiple newlines\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c4ca0fa3d11b72162681fabfbab58d61":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Fatal(\"Expected a non-nil value\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected cache to have 1 value, got %d\", len(c.vs))\n\t}\n\n\t// Test getting a second value\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Fatal(\"Expected a non-nil value\")\n\t}\n\tif len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected cache to have 2 values, got %d\", len(c.vs))\n\t}\n\n\t// Test that the second value is distinct from the first\n\tif val == val2 {\n\t\tt.Fatal(\"Expected distinct values from getValue\")\n\t}\n\n\t// Test capacity increase\n\tfor i := 0; i \u003c 10; i++ {\n\t\tc.getValue()\n\t}\n\tif cap(c.vs) \u003c= 2 {\n\t\tt.Fatalf(\"Expected cache capacity to increase, got %d\", cap(c.vs))\n\t}\n\n\t// Test that values are not reset\n\tval3 := c.getValue()\n\tif len(c.vs) != 13 {\n\t\tt.Fatalf(\"Expected cache to have 13 values, got %d\", len(c.vs))\n\t}\n}","c5586c4ceae5d3f167bcc3ee23c33dbe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","c55ae409893aa760b6837960ae6d3139":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"Escape a quote: \\\\\\\" and a backslash: \\\\\\\\\", \"Escape a quote: \\\" and a backslash: \\\\\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Mixed: \\\\nNewline, \\\\tTab, \\\\bBackspace\", \"\\nNewline, \\tTab, \\bBackspace\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c5cb7d728cb8fdc34f85c406b961cc9e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: 😀\"},\n\t\t{\"Mixed: \\\\nHello\\\\tWorld\\\\uD83D\\\\uDE00\", \"Mixed: \\nHello\\tWorld😀\"},\n\t\t{\"No Escape\", \"No Escape\"},\n\t\t{\"Incomplete Escape: \\\\u\", \"Incomplete Escape: \\\\u\"},\n\t\t{\"Another Invalid: \\\\uD83D\", \"Another Invalid: \\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c5cdd5f26f85c8b4f71fd4ad327b5a2e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create an instance of Object\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", \u0026Value{}},\n\t\t\t{\"key2\", \u0026Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Ensure the initial state is as expected\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"expected 2 key-value pairs, got %d\", len(obj.kvs))\n\t}\n\tif !obj.keysUnescaped {\n\t\tt.Fatal(\"expected keysUnescaped to be true\")\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Check the state after reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected 0 key-value pairs after reset, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped {\n\t\tt.Fatal(\"expected keysUnescaped to be false after reset\")\n\t}\n}","c6faba2bbfc994b9485296bddc91361b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Add expected structure here\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\t// Additional checks can be added here to compare the structure of result and expected\n\t}\n}","c764ce35ca14ae6a72207278122d0d5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Number\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test String\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw\"},\n\t\t\texpected: \"\\\"raw\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,\\\"two\\\"]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","c7df6ab3486acf816f4a9b764f6a03d8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello \\\"world\\\"!\"`,\n\t\t\texpectedValue:  \"hello \\\"world\\\"!\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\\\"world\\\" more text`,\n\t\t\texpectedValue:  \"hello\\\\\\\"world\",\n\t\t\texpectedRemain: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `no quotes here`,\n\t\t\texpectedValue:  `no quotes here`,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"missing closing quote`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped quote \\\\\"`,\n\t\t\texpectedValue:  \"escaped quote \\\\\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) remain = %q, expectedRemain %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","c8009aa53c1b79da028713d43677a10e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","c80f450b5ed4b0fa2ce024b7f69bb8fc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"},}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\u0026Value{s: \"1\", t: TypeNumber},\n\t\t\t\t\t\u0026Value{s: \"2\", t: TypeNumber},\n\t\t\t\t\t\u0026Value{s: \"3\", t: TypeNumber},\n\t\t\t\t}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif result.t != test.expected.t || len(result.o.kvs) != len(test.expected.o.kvs) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) did not consume all input, remaining: %q\", test.input, remaining)\n\t\t}\n\t}\n}","c862c57bfd6664eb3772ddfd9cc5ec8c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\u00G1\", \"Invalid\\\\u00G1\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Escaped\\\\/Slash\", \"Escaped/Slash\"},\n\t\t{\"Escaped\\\\bBackspace\", \"Escaped\\bBackspace\"},\n\t\t{\"Escaped\\\\fFormfeed\", \"Escaped\\fFormfeed\"},\n\t\t{\"Escaped\\\\rCarriageReturn\", \"Escaped\\rCarriageReturn\"},\n\t\t{\"Escaped\\\\tTab\", \"Escaped\\tTab\"},\n\t\t{\"Escaped\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\\\\uD83D\\\\uDE02\", \"Escaped😀😁😂\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c89109383f77829fd96d34eb2ecc83ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Number\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test String\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw\"},\n\t\t\texpected: \"\\\"raw\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t{t: TypeTrue},\n\t\t\t}},\n\t\t\texpected: \"[1,\\\"two\\\",true]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","c9f4acd3cb04b2ed994e2e7099cc5b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"}, // Assuming TypeString should return \"string\"\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n\n\t// Test for an unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // An arbitrary value that is not defined\n\tunknownType.String()\n}","cac4f04680835dd843013cfc1b730880":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"simple\", `\"simple\"`},\n\t\t{\"with newline\\n\", `\"with newline\\n\"`},\n\t\t{\"with tab\\t\", `\"with tab\\t\"`},\n\t\t{\"with quote\\\"\", `\"with quote\\\"\"`},\n\t\t{\"with backslash\\\\\", `\"with backslash\\\\\"`},\n\t\t{\"\", `\"\"`},\n\t\t{\"special chars: \\u2022\", `\"special chars: \\u2022\"`},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := escapeString(nil, test.input)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"escapeString(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","cb85710523cfb04cdcdf04451f7449d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" rest`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" rest\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\"`,\n\t\t\texpectedValue: \"escaped \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","cb8b337a5da945f53db16b6db1e7cef5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"validKey\\\"\", \"validKey\", false},\n\t\t{\"\\\"anotherKey\\\"\", \"anotherKey\", false},\n\t\t{\"\\\"keyWithEscape\\\\\\\"\\\"\", \"keyWithEscape\\\"\", true}, // should trigger slow path\n\t\t{\"\\\"keyWithBackslash\\\\\\\\\\\"\", \"keyWithBackslash\\\\\", true}, // should trigger slow path\n\t\t{\"\\\"missingClosingQuote\", \"\", true}, // missing closing quote\n\t\t{\"noQuotes\", \"\", true}, // no quotes at all\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseRawKey(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","cbef8bb22fee92b10afa87f54f0a53b0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value should be set appropriately after implementing parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value should be set appropriately after implementing parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"t\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"t\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"f\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"f\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"n\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"n\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"invalid\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","cc2ca3ffb95a189c0927b89f2ea28794":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","cc89c1bed9800d39da5e4dc1a0fd47ba":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"infxyz\", \"inf\", \"xyz\", nil},\n\t\t{\"nanmore\", \"nan\", \"more\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","cd096a26bec96244813fa324ca0118d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"too deep\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"too deep\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 *result != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","cd09872ff98ed51df9fc60253203ac1c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"hello \\\\\\\"world\\\\\\\"\\\"\", \"hello \\\"world\\\"\", \"\", false},\n\t\t{\"\\\"hello \\\\\\\"world\\\\\\\" and more\\\"\", \"hello \\\"world\\\" and more\", \"\", false},\n\t\t{\"\\\"hello \\\\\\\"world\\\\\\\" and more\\\\\\\"\", \"hello \\\"world\\\" and more\\\\\", \"\", false},\n\t\t{\"\\\"hello \\\\\\\"world\\\\\\\" and more\\\\\\\" extra\\\"\", \"hello \\\"world\\\" and more\\\\\", \" extra\", false},\n\t\t{\"\\\"hello \\\\\\\"world\\\\\\\" and more\\\\\\\" extra\", \"\", \"\", true}, // missing closing quote\n\t\t{\"hello\", \"\", \"\", true}, // no quotes at all\n\t\t{\"\\\"hello with \\\\\\\"escaped quotes\\\\\\\" and \\\\\\\"more\\\\\\\"\", \"hello with \\\"escaped quotes\\\" and \\\"more\", \"\", true}, // missing closing quote\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, want err = %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.rest)\n\t\t}\n\t}\n}","cd6cb6e8218d1f8c8539694471a3eebe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Escaped\\\\nNewline\", \"Escaped\\nNewline\"},\n\t\t{\"Escaped\\\\tTab\", \"Escaped\\tTab\"},\n\t\t{\"Escaped\\\\rCarriageReturn\", \"Escaped\\rCarriageReturn\"},\n\t\t{\"Escaped\\\\bBackspace\", \"Escaped\\bBackspace\"},\n\t\t{\"Escaped\\\\fFormFeed\", \"Escaped\\fFormFeed\"},\n\t\t{\"Escaped\\\\/\", \"Escaped/\"},\n\t\t{\"Invalid\\\\uD83D\", \"Invalid\\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","ce19768ad4ca3977d0976120357c68d6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\t  \", \"\"},\n\t\t{\"\\r\\n\\t  Hello\", \"Hello\"},\n\t\t{\"   World\", \"World\"},\n\t\t{\"\\r\\n\\t  Test String\", \"Test String\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"\\r\\n\", \"\"},\n\t\t{\"\\r\\n\\t\\t\", \"\"},\n\t\t{\"\\r\\n\\t\\tExtra\", \"Extra\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","ce393aeae9568082d69d7a6c00ded17e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for true\n\t\t{\"false\", valueFalse, false}, // Test for false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test for object with boolean\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test for object with null\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test for object with number\n\t\t{\"{\\\"key\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, false}, // Test for object with array\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif v == nil || v.t != test.expected.t || v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","cee6ab93546cb62c80fb31265cc0b0c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nan123\", \"nan\", \"123\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"123.45\", \"123.45\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"123abc456\", \"123\", \"abc456\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, expected %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","cf569eccca807a583e3e1abb4542ed42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\"world\\\"!\"`,\n\t\t\texpectedValue: \"hello \\\"world\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\\\" more text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\\\"escaped\\\" quote\"`,\n\t\t\texpectedValue: \"\\\"escaped\\\" quote\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","cfc916037e0bc9ef8c3ad68cd5ccc315":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Create a sample JSON structure for testing\n\tjsonData := `{\"name\": \"John\", \"age\": 30, \"friends\": [\"Alice\", \"Bob\"], \"address\": {\"city\": \"New York\", \"zip\": \"10001\"}}`\n\tv, err := Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{[]string{\"name\"}, v.Get(\"name\")},\n\t\t{[]string{\"age\"}, v.Get(\"age\")},\n\t\t{[]string{\"friends\", \"1\"}, v.Get(\"friends\", \"1\")},\n\t\t{[]string{\"address\", \"city\"}, v.Get(\"address\", \"city\")},\n\t\t{[]string{\"address\", \"zip\"}, v.Get(\"address\", \"zip\")},\n\t\t{[]string{\"friends\", \"2\"}, nil}, // Non-existing index\n\t\t{[]string{\"address\", \"country\"}, nil}, // Non-existing key\n\t\t{[]string{\"nonexistent\"}, nil}, // Non-existing key\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.Get(test.keys...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Get(%v) = %v; want %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","d022cd027712a505cb7c482afa838bb6":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test boolean true\n\t\t{\"false\", valueFalse, false}, // Test boolean false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}, t: TypeObject}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}, t: TypeObject}, false}, // Test object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}, t: TypeObject}, false}, // Test object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}, t: TypeObject}, false}, // Test object with number value\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif result == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = nil, want %v\", test.input, test.expected)\n\t\t\t} else if result != nil \u0026\u0026 test.expected == nil {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want nil\", test.input)\n\t\t\t} else if result != nil \u0026\u0026 test.expected != nil \u0026\u0026 result.t != test.expected.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","d08a0b4bda078a33a560fef033579209":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"Tab\\\\tcharacter.\", \"Tab\\tcharacter.\"},\n\t\t{\"Backslash\\\\\\\\character.\", \"Backslash\\\\character.\"},\n\t\t{\"Quote: \\\\\\\"Hello\\\\\\\".\", \"Quote: \\\"Hello\\\".\"},\n\t\t{\"Invalid unicode \\\\uXYZ\", \"Invalid unicode \\\\uXYZ\"},\n\t\t{\"Valid unicode \\\\u0041\", \"Valid unicode A\"},\n\t\t{\"Surrogate pair \\\\uD83D\\\\uDE00\", \"Surrogate pair 😀\"},\n\t\t{\"Mixed \\\\uD83D\\\\uDE00 and normal text\", \"Mixed 😀 and normal text\"},\n\t\t{\"Escaped forward slash \\\\/\", \"Escaped forward slash /\"},\n\t\t{\"Incomplete unicode \\\\u\", \"Incomplete unicode \\\\u\"},\n\t\t{\"Another incomplete unicode \\\\uD83D\", \"Another incomplete unicode \\\\uD83D\"},\n\t\t{\"Unknown escape \\\\x\", \"Unknown escape \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","d17936696f61395fe3f9b52667ef3ece":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\nHello\", \"Hello\"},\n\t\t{\"\\t\\tHello\", \"Hello\"},\n\t\t{\"\\r\\rHello\", \"Hello\"},\n\t\t{\"   Hello World   \", \"Hello World   \"},\n\t\t{\"\\n\\nHello World\\n\\n\", \"Hello World\\n\\n\"},\n\t\t{\"\\t\\tHello World\\t\\t\", \"Hello World\\t\\t\"},\n\t\t{\"\\r\\rHello World\\r\\r\", \"Hello World\\r\\r\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\n\", \"\"},\n\t\t{\"\\t\\t\", \"\"},\n\t\t{\"\\r\\r\", \"\"},\n\t\t{\"Hello\", \"Hello\"},\n\t\t{\"   Hello   \", \"Hello   \"},\n\t\t{\"\\nHello\\n\", \"Hello\\n\"},\n\t\t{\"\\tHello\\t\", \"Hello\\t\"},\n\t\t{\"\\rHello\\r\", \"Hello\\r\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","d19552cb4a85b8bdc7ee59d416f1defb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\t\t\u0026Value{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","d1c42aa0ff9a668dfcf23c9f797c946e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 42}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function for Value to check if two Value instances are equal.\n\t// This function should compare the type, object keys, and values.\n\t// For simplicity, the implementation is omitted here.\n\treturn false // Placeholder\n}","d2756c18d2278ae148d9b3426eb9553b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"true\", t: TypeTrue}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{t: TypeNull}}}}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"for input %q, expected %v, got %v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"expected no remaining input for %q, got %q\", test.input, remaining)\n\t\t}\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\t// Implement a comparison function to check if two Value objects are equal\n\t// This function should compare the type, object keys, and values.\n\treturn false // Placeholder implementation\n}","d37f73f2514549345a227ae9b96d41ee":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"key\"`,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"anotherKey\" more text`,\n\t\t\texpectedKey: \"anotherKey\",\n\t\t\texpectedRemaining: \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with space\"`,\n\t\t\texpectedKey: \"key with space\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\\\\"escape\\\\\" characters\"`,\n\t\t\texpectedKey: \"key with \\\\escape\\\\ characters\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key without closing`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\\\\"escape\\\\\" and more text`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expectedKey %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, expectedRemaining %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","d384e78a0455b8094e0cc981c2bfffd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    Object\n\t\texpected Object\n\t}{\n\t\t{\n\t\t\tname: \"No keys to unescape\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Keys with escape sequences\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key\\\\1\", v: nil},\n\t\t\t\t\t{k: \"key\\\\2\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Keys already unescaped\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: nil},\n\t\t\t\t\t{k: \"key2\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.input.unescapeKeys()\n\t\t\tif !equalObjects(tt.input, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalObjects(a, b Object) bool {\n\tif a.keysUnescaped != b.keysUnescaped {\n\t\treturn false\n\t}\n\tif len(a.kvs) != len(b.kvs) {\n\t\treturn false\n\t}\n\tfor i := range a.kvs {\n\t\tif a.kvs[i].k != b.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d4399876666ac672c67f3ad25ddf2cf4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Expected value needs to be set based on the actual implementation of parseArray\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Expected value needs to be set based on the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"not_a_value\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"not_a_value\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested_key\": \"nested_value\"}}`,\n\t\t\texpected: nil, // Expected value needs to be set based on the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: nil, // Expected value needs to be set based on the actual implementation of parseObject\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 *v != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","d4b604f7b013fd7cbb085e5d0f4c170d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+10more\", \"-123.45e+10\", \"more\", false},\n\t\t{\"inf more text\", \"inf\", \" more text\", false},\n\t\t{\"nan more text\", \"nan\", \" more text\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", false}, // This case assumes len(s) \u003e 0 is handled elsewhere\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, rest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","d5afcbd21334131754f319a21296c8e1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","d6b58a3300f6f0aa3be4fdc50d3224d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tvalue     *Value\n\t\texpectErr bool\n\t\texpected  []byte\n\t}{\n\t\t{\n\t\t\tname:      \"Valid String Value\",\n\t\t\tvalue:     \u0026Value{s: \"test string\", t: TypeString},\n\t\t\texpectErr: false,\n\t\t\texpected:  []byte(\"test string\"),\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid Type (Number)\",\n\t\t\tvalue:     \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectErr: true,\n\t\t\texpected:  nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid Type (Object)\",\n\t\t\tvalue:     \u0026Value{s: \"{}\", t: TypeObject},\n\t\t\texpectErr: true,\n\t\t\texpected:  nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid Type (Array)\",\n\t\t\tvalue:     \u0026Value{s: \"[]\", t: TypeArray},\n\t\t\texpectErr: true,\n\t\t\texpected:  nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid Type (Null)\",\n\t\t\tvalue:     \u0026Value{s: \"null\", t: TypeNull},\n\t\t\texpectErr: true,\n\t\t\texpected:  nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"Empty String Value\",\n\t\t\tvalue:     \u0026Value{s: \"\", t: TypeString},\n\t\t\texpectErr: false,\n\t\t\texpected:  []byte(\"\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := tt.value.StringBytes()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"StringBytes() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.expectErr \u0026\u0026 string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"StringBytes() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","d82823f69afa030b585520cf90bdf567":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t\t{typeRawString, \"\"}, // typeRawString is not expected to be visible\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n}","db61f8c8bafafa3f785b8278370ea805":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\" quote\" and more`,\n\t\t\texpectedValue: \"escaped \\\" quote\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"escaped\\\" quotes\" in text`,\n\t\t\texpectedValue: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:  \" in text\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","dc8534c514a95ac790249388b3fb0c86":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"-invalid\", \"\", \"-invalid\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","dc8ba8ea3d6e15a7873c4367652b2c60":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                          // Empty string\n\t\t{\"   Hello\", \"Hello\"},            // Leading spaces\n\t\t{\"\\n\\nHello\", \"Hello\"},           // Leading newlines\n\t\t{\"\\t\\tHello\", \"Hello\"},           // Leading tabs\n\t\t{\"\\r\\rHello\", \"Hello\"},           // Leading carriage returns\n\t\t{\"   Hello World\", \"Hello World\"}, // Spaces in the middle\n\t\t{\"\\n\\nHello World\", \"Hello World\"}, // Newlines in the middle\n\t\t{\"\\t\\tHello World\", \"Hello World\"}, // Tabs in the middle\n\t\t{\"   \", \"\"},                       // Only spaces\n\t\t{\"\\n\\n\", \"\"},                      // Only newlines\n\t\t{\"\\t\\t\", \"\"},                      // Only tabs\n\t\t{\"\\r\\r\", \"\"},                      // Only carriage returns\n\t\t{\"Hello\", \"Hello\"},                // No whitespace\n\t\t{\"   Hello   \", \"Hello   \"},      // Leading and trailing spaces\n\t\t{\"\\nHello\\n\", \"Hello\\n\"},         // Newlines around text\n\t\t{\"\\tHello\\t\", \"Hello\\t\"},          // Tabs around text\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","dca2d006634fa60407c962b9f0af8fda":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected Value structure should be defined based on your implementation\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\t\t// Additional checks can be added here to compare the actual result with the expected result\n\t}\n}","dd219a2aa44bcb66c6744f5b2ba36ce9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u0041\\\\u0042\\\\u0043\", \"Unicode: ABC\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"Mixed: \\nLine1\\nLine2\"},\n\t\t{\"No escape characters\", \"No escape characters\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"Backslash at end: \\\\\", \"Backslash at end: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","dde25cf643e56e97e53ca4ead8c2e7f0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", false},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", false},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", false},\n\t\t{\"nan more text\", \"nan\", \" more text\", false},\n\t\t{\"invalid\", \"\", \"invalid\", true},\n\t\t{\"-invalid\", \"\", \"-invalid\", true},\n\t\t{\"\", \"\", \"\", true}, // Edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif remaining != test.remaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remaining = %q, want %q\", test.input, remaining, test.remaining)\n\t\t}\n\t}\n}","de1d09d9d4effb17d78a1263560aee71":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\nHello\", \"Hello\"},\n\t\t{\"\\t\\tHello\", \"Hello\"},\n\t\t{\"\\r\\rHello\", \"Hello\"},\n\t\t{\"   \\n\\t\\r   World\", \"World\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\t\\r\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","df4c44fc41f3659b59dbb32405ad0613":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid true value\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid false value\",\n\t\t\tjson:     `{\"key\": false}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tjson:     `{\"key\": \"true\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (number)\",\n\t\t\tjson:     `{\"key\": 1}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested key with true value\",\n\t\t\tjson:     `{\"outer\": {\"inner\": true}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested key with false value\",\n\t\t\tjson:     `{\"outer\": {\"inner\": false}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index with true value\",\n\t\t\tjson:     `{\"array\": [true, false]}`,\n\t\t\tkeys:     []string{\"array\", \"0\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index with false value\",\n\t\t\tjson:     `{\"array\": [true, false]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of bounds\",\n\t\t\tjson:     `{\"array\": [true]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := \u0026Parser{}\n\t\t\tvalue, err := parser.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := value.GetBool(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","e08540605cae6ed9a666d3cee7b412f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a test string with no escapes.\", \"This is a test string with no escapes.\"},\n\t\t{\"Escaped quote: \\\\\\\" and backslash: \\\\\\\\\", \"Escaped quote: \\\" and backslash: \\\\\"},\n\t\t{\"Newline\\\\ncharacter\", \"Newline\\ncharacter\"},\n\t\t{\"Tab\\\\tcharacter\", \"Tab\\tcharacter\"},\n\t\t{\"Backspace\\\\bcharacter\", \"Backspace\\bcharacter\"},\n\t\t{\"Form feed\\\\fcharacter\", \"Form feed\\fcharacter\"},\n\t\t{\"Carriage return\\\\rcharacter\", \"Carriage return\\rcharacter\"},\n\t\t{\"Unicode\\\\u0041character\", \"UnicodeAcharacter\"},\n\t\t{\"Invalid unicode\\\\uXYZcharacter\", \"Invalid unicode\\\\uXYZcharacter\"},\n\t\t{\"Surrogate pair\\\\uD83D\\\\uDE00\", \"Surrogate pair😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\u0041characters\", \"Mixed😀Acharacters\"},\n\t\t{\"Incomplete escape\\\\u\", \"Incomplete escape\\\\u\"},\n\t\t{\"Another incomplete\\\\uD83D\", \"Another incomplete\\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e0c44423b42e12e4986c689637048fc2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewline\", \"Mixed😀\\nNewline\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Escaped\\\\/Slash\", \"Escaped/Slash\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e21671345d404e178d58a9be757c585b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 'invalid']\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","e23f2363915a7f8671a8500fbf19be5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"foo\"},\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"bar\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[\\\"foo\\\",\\\"bar\\\"]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"Alice\"}},\n\t\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"expected %s, got %s\", test.expected, result)\n\t\t}\n\t}\n}","e29ea33cab5b9f9fb4523fdea62a7bfd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","e2f1c5765c1a8aba24c0ebf5d434d945":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": { \"nestedKey\": \"nestedValue\" }}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\t// Compare result with expected Value structure\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%q) did not consume all input, remaining: %q\", test.input, remaining)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\n// Implement this function based on the structure of Value and its fields.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic here\n\treturn false // Placeholder\n}","e310404b1d11354d4286fbf82a7a9788":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\", \"key4\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\treturn false // Placeholder return\n}","e32f3799b5fb1bcda0719fd195661530":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewline\", \"Mixed😀\\nNewline\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"NoEscape\", \"NoEscape\"},\n\t\t{\"Escaped\\\\/Slash\", \"Escaped/Slash\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e367c07855bfa56e25589782286ec8b7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\"`,\n\t\t\texpectedValue: \"escaped \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple \\\"escaped\\\" quotes\" and more`,\n\t\t\texpectedValue: \"multiple \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched \\\" quote here`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","e3b625c10b9083a177ee75bf2554ab5a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q)[%d] = %v, want %v\", test.input, i, v, test.expected[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","e3eb0620aefa4f7a91429e17a5df1d87":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"New line:\\\\nNext line\", \"New line:\\nNext line\"},\n\t\t{\"Tab:\\\\tEnd\", \"Tab:\\tEnd\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"Mixed: \\nLine1\\nLine2\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Multiple escapes: \\\\\\\"Hello\\\\\\\" and \\\\\\\\ and \\\\n\", \"\\\"Hello\\\" and \\\\ and \\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e3f590dbf2ba58be97e9c05ed05fbb1a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // Assuming 8 is an unknown type\n\tunknownType.String()\n}","e51e94608dd11bf35b4e80233aad4416":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Null value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Boolean true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Boolean false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"String\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello world\"},\n\t\t\texpected: \"\\\"hello world\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","e5485be886fbf998b404fd9392355eb6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"valid float64\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float64 in array\",\n\t\t\tjson:     `{\"values\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 2.2,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"value\": 3.14}`,\n\t\t\tkeys:     []string{\"non_existing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type\",\n\t\t\tjson:     `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 42.0}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 42.0,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index as string\",\n\t\t\tjson:     `{\"values\": [0.5, 1.5, 2.5]}`,\n\t\t\tkeys:     []string{\"values\", \"0\"},\n\t\t\texpected: 0.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index as number\",\n\t\t\tjson:     `{\"values\": [0.5, 1.5, 2.5]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 1.5,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := \u0026Parser{}\n\t\t\tvalue, err := parser.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := value.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","e5859f88ecff2e15e312b6c54fde32c3":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,\"two\",true]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal True\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal False\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","e59539ec2cf73eea40662f8b045e72c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\t// Create a sample JSON object\n\tjsonStr := `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`\n\tvalue, err := Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\tobj, err := value.Object()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get object from value: %v\", err)\n\t}\n\n\t// Prepare a map to track calls to the function f\n\tcalls := make(map[string]string)\n\n\t// Define the function f to be called by Visit\n\tf := func(key []byte, v *Value) {\n\t\tcalls[string(key)] = v.String()\n\t}\n\n\t// Call the Visit method\n\tobj.Visit(f)\n\n\t// Check if the calls were made in the correct order\n\texpectedCalls := map[string]string{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": \"value2\",\n\t\t\"key3\": \"value3\",\n\t}\n\n\tfor key, expectedValue := range expectedCalls {\n\t\tif value, exists := calls[key]; !exists || value != expectedValue {\n\t\t\tt.Errorf(\"Expected call for key %s with value %s, got %s\", key, expectedValue, value)\n\t\t}\n\t}\n}","e68dfded8d2b26a44da71ff5e78c83dd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+10\", \"-123.45e+10\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"ab\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-a\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","e6b2976f720156be6211fd77b2f75c07":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal Raw String\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"example\"},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","e6cb490bb2c0d83ed347c3d9f08ba14a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\t\\tHello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\", \"\"},\n\t\t{\"Non-whitespace string\", \"Non-whitespace string\"},\n\t\t{\" \\t \\n \\r \\t \", \"\"},\n\t\t{\" \\t \\n \\r \\t Hello\", \"Hello\"},\n\t\t{\"\\x00\\x01\\x02Hello\", \"Hello\"}, // Non-whitespace characters\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e7400b10fb6d7115b93dba7c2dfd9129":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a test string with a newline\\\\ncharacter.\", \"This is a test string with a newline\\ncharacter.\"},\n\t\t{\"Escaped quote: \\\\\\\"Hello\\\\\\\".\", \"Escaped quote: \\\"Hello\\\".\"},\n\t\t{\"Invalid unicode: \\\\u123\", \"Invalid unicode: \\\\u123\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: 😀\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Mixed: \\\\nNewline and \\\\tTab\", \"\\nNewline and \\tTab\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Invalid escape: \\\\x\", \"Invalid escape: \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e74702fd6fc7d1ac731ed0c5591cd278":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t} else if test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value objects here.\n\t// This is a placeholder for the actual comparison logic.\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t // Simplified comparison for demonstration.\n}","e7490200a8c15ff50bab2c7d5fde9cac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","e783a3e5d0076d408007be0cbdc07566":"// file: object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object and populate it with some data\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", \u0026Value{}},\n\t\t\t{\"key2\", \u0026Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Ensure the Object is populated before reset\n\tif len(obj.kvs) == 0 || !obj.keysUnescaped {\n\t\tt.Fatalf(\"Object should be populated before reset\")\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Check if the kvs slice is empty after reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got length: %d\", len(obj.kvs))\n\t}\n\n\t// Check if keysUnescaped is false after reset\n\tif obj.keysUnescaped {\n\t\tt.Error(\"Expected keysUnescaped to be false after reset\")\n\t}\n}","e7853b1995be2a7e0f2c932045cca477":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{t: TypeArray}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string\\\"\",\n\t\t\texpected: \u0026Value{t: typeRawString, s: \"string\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"nan\"},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected value as necessary\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 result.t != test.expected.t {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result.t, test.expected.t)\n\t\t}\n\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","e83bb0b3a53e8c49660f6e11d35138f1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Populate expected Value as needed\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Populate expected Value as needed\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2, \"key3\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Populate expected Value as needed\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Populate expected Value as needed\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Populate expected Value as needed\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Populate expected Value as needed\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\t\t// Additional checks can be added here to compare the actual result with expected\n\t}\n}","e897c35ec322a812216cfd3f5ff03ffd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"Valid integer\",\n\t\t\tinput:    `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tinput:    `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tinput:    `{\"key\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (array)\",\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested key\",\n\t\t\tinput:    `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index\",\n\t\t\tinput:    `{\"key\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of bounds\",\n\t\t\tinput:    `{\"key\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse([]byte(tt.input))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse input: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","ea1af124e3f14fce95ff74dac77cb87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Initial call to getKV\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Fatal(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"Expected kvs length to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Second call to getKV\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Fatal(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Check if kv1 and kv2 are different instances\n\tif kv1 == kv2 {\n\t\tt.Fatal(\"Expected kv1 and kv2 to be different instances\")\n\t}\n\n\t// Fill the kvs to test capacity handling\n\tfor i := 0; i \u003c 100; i++ {\n\t\tobj.getKV()\n\t}\n\tif len(obj.kvs) != 102 {\n\t\tt.Fatalf(\"Expected kvs length to be 102, got %d\", len(obj.kvs))\n\t}\n}","eb071f816583aa7cfc1e96a4582d81f2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRemainder string\n\t\texpectedError  error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"\", \"\", \"\", nil}, // This case should not happen as per the function's comment\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remainder, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remainder != test.expectedRemainder || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remainder, err, test.expectedNumber, test.expectedRemainder, test.expectedError)\n\t\t}\n\t}\n}","eb0bed6b248796ac2aa5e59b1e4f4066":"// string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"unknown type\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"expected panic for unknown Type\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 999 // An arbitrary value not defined in the Type constants\n\t\tunknownType.String()\n\t})\n}","eb2f7a09786ed520e3c0026730fb8e56":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Number\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test String\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw\"},\n\t\t\texpected: \"\\\"raw\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","eb885289b7d2fd99a584dd8528e7a597":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedValue string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRemaining: \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRemaining: \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRemaining: \"\\\"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\\\\\"world\"more`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRemaining: \"more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `hello\"world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRemaining: `hello\"world`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\\world\"`,\n\t\t\texpectedValue: \"hello\\\\world\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remaining, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawString(%q) remaining = %q, expectedRemaining %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","ebf2cbcce69e6375a3f5bae521ef8b70":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6xyz\", \"-123.45e+6\", \"xyz\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", false},\n\t\t{\"123.45.67\", \"123.45\", \".67\", false},\n\t\t{\"abc123\", \"\", \"abc123\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"\", \"\", \"\", true}, // edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned number: %q, expected: %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned remaining: %q, expected: %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","ebf877e63e90ebbf0504c5ddb8afea58":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for true\n\t\t{\"false\", valueFalse, false}, // Test for false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test for object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test for object with null value\n\t\t{\"{\\\"key\\\":123}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}, false}, // Test for object with number value\n\t\t{\"{\\\"key\\\":[1, 2, 3]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}}, false}, // Test for object with array value\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 !compareValues(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.input[len(test.input):] {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.input[len(test.input):])\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value objects for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\t// This is a placeholder; actual implementation will depend on Value's structure\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t // Simplified comparison\n}","ec026c231b0d836d21a262081a7a59a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\t// Test case 1: Valid object retrieval\n\tjsonStr := `{\"key1\": {\"subkey1\": \"value1\"}, \"key2\": {\"subkey2\": \"value2\"}}`\n\tv, err := Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tobj := v.GetObject(\"key1\")\n\tif obj == nil {\n\t\tt.Error(\"Expected to retrieve object for key1, but got nil\")\n\t}\n\n\t// Test case 2: Non-existing key\n\tobj = v.GetObject(\"nonExistingKey\")\n\tif obj != nil {\n\t\tt.Error(\"Expected nil for non-existing key, but got an object\")\n\t}\n\n\t// Test case 3: Valid object with nested keys\n\tobj = v.GetObject(\"key1\", \"subkey1\")\n\tif obj != nil {\n\t\tt.Error(\"Expected nil for nested key, but got an object\")\n\t}\n\n\t// Test case 4: Invalid type retrieval\n\tjsonStr = `{\"key1\": \"stringValue\"}`\n\tv, err = Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tobj = v.GetObject(\"key1\")\n\tif obj != nil {\n\t\tt.Error(\"Expected nil for key1 which is a string, but got an object\")\n\t}\n\n\t// Test case 5: Valid object with array index\n\tjsonStr = `{\"key1\": [{\"subkey1\": \"value1\"}, {\"subkey2\": \"value2\"}]}`\n\tv, err = Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tobj = v.GetObject(\"key1\", \"0\")\n\tif obj == nil {\n\t\tt.Error(\"Expected to retrieve object for key1[0], but got nil\")\n\t}\n}","ecb9681ec50f26f5fdb26414aabd3121":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", `Hello, \"World!\"`},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tSeparated\", \"Tab\\tSeparated\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid Unicode\\\\uXYZ\", \"Invalid Unicode\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Escaped slash \\\\/\", \"Escaped slash /\"},\n\t\t{\"Mixed \\\\uD83D\\\\uDE00 and \\\\uXYZ\", \"Mixed 😀 and \\\\uXYZ\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","ed2bbe5d8b0addacee0007eb6c33fdd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for the default case (panic)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // An invalid type\n\t_ = unknownType.String()  // This should cause a panic\n}","ed60335579948b7d973b557c9487f30f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalueStr string\n\t\texpected uint64\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint64\",\n\t\t\tvalueStr: \"1234567890\",\n\t\t\texpected: 1234567890,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid uint64 zero\",\n\t\t\tvalueStr: \"0\",\n\t\t\texpected: 0,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type string\",\n\t\t\tvalueStr: `\"not a number\"`,\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type boolean\",\n\t\t\tvalueStr: \"true\",\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type null\",\n\t\t\tvalueStr: \"null\",\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{s: tt.valueStr, t: TypeNumber} // Assuming TypeNumber is set for valid number strings\n\t\t\tgot, err := v.Uint64()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Uint64() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Uint64() = %v, expected %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","ed7f1f9db9ebf8c730e6dec6ab9e2901":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"extra\": \"data\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\n\t\tif test.hasError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\t// Here you would typically compare the result with the expected value.\n\t\t\t// This could involve checking the type and content of the resulting Value.\n\t\t\t// For example:\n\t\t\t// if !reflect.DeepEqual(result, test.expected) {\n\t\t\t//     t.Errorf(\"for input %q, expected %v, got %v\", test.input, test.expected, result)\n\t\t\t// }\n\t\t}\n\t}\n}","edc73e729f5fb16c77ddb02f2d62c7f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Number\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test String\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw\"},\n\t\t\texpected: \"\\\"raw\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,\\\"two\\\",true]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","ee281fd673e0e5921d985e16d66274ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: 😀\"},\n\t\t{\"Incomplete: \\\\uD83D\", \"Incomplete: \\\\uD83D\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\uXYZ\", \"Mixed: 😀 and \\\\uXYZ\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"No escape: Just a string\", \"No escape: Just a string\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","efa4903c7248777618b60131d2acc577":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: 😀\"},\n\t\t{\"Mixed: \\\\uD83D\\\\uDE00 and \\\\n newline\", \"Mixed: 😀 and \\n newline\"},\n\t\t{\"No escape sequences\", \"No escape sequences\"},\n\t\t{\"Incomplete escape: \\\\u\", \"Incomplete escape: \\\\u\"},\n\t\t{\"Escaped forward slash: \\\\/\", \"Escaped forward slash: /\"},\n\t\t{\"Backslash before quote: \\\\\\\"\", \"Backslash before quote: \\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f05845715af1ed66ea29327c8a4a23ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial state\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Fatal(\"Expected a non-nil value on first call to getValue\")\n\t}\n\n\t// Test that the value is initialized correctly\n\tif cap(c.vs) != 1 || len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected capacity and length of vs to be 1, got cap: %d, len: %d\", cap(c.vs), len(c.vs))\n\t}\n\n\t// Test subsequent calls to getValue\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Fatal(\"Expected a non-nil value on second call to getValue\")\n\t}\n\n\t// Check that the capacity increases as expected\n\tif cap(c.vs) != 2 || len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected capacity to be 2 and length to be 2, got cap: %d, len: %d\", cap(c.vs), len(c.vs))\n\t}\n\n\t// Test that the values returned are distinct\n\tif val1 == val2 {\n\t\tt.Fatal(\"Expected distinct values from consecutive calls to getValue\")\n\t}\n\n\t// Test behavior when capacity is reached\n\tfor i := 0; i \u003c 10; i++ {\n\t\tc.getValue()\n\t}\n\n\t// Check that the capacity has increased appropriately\n\tif cap(c.vs) \u003c 12 {\n\t\tt.Fatalf(\"Expected capacity to be at least 12 after multiple calls, got cap: %d\", cap(c.vs))\n\t}\n}","f0667afc84cf5da4eedaac8df46a195b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"{}\",\n\t\t\texpectedValue:  \u0026Value{t: TypeObject},\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}},\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}}}}},\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\":}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemainder: `{\"key\":}`,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\",}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemainder: `{\"key\": \"value\",}`,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemainder: `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\"}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemainder: `{\"key\": \"value\"}`,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\", \"key2\": \"value2\"}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemainder: `{\"key\": \"value\", \"key2\": \"value2\"}`,\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif result != nil \u0026\u0026 !compareValues(result, test.expectedValue) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, expectedValue = %v\", test.input, result, test.expectedValue)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseObject(%q) remainder = %q, expectedRemainder = %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances for equality.\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on the structure of Value.\n\t// This is a placeholder for actual comparison logic.\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t // Simplified comparison for demonstration\n}","f090bde8d09c3c16eb0203495d317a50":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Replace with actual expected Value\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tc := \u0026cache{} // Initialize cache\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\t\t// Additional checks can be added here for the expected Value\n\t}\n}","f131920ae34d0848f01ae4cda57a1695":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_getKV(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinitialKvs []kv\n\t\texpectedKvs []kv\n\t}{\n\t\t{\n\t\t\tname: \"Empty initial kvs\",\n\t\t\tinitialKvs: []kv{},\n\t\t\texpectedKvs: []kv{{}},\n\t\t},\n\t\t{\n\t\t\tname: \"Single kv\",\n\t\t\tinitialKvs: []kv{{k: \"key1\", v: nil}},\n\t\t\texpectedKvs: []kv{{k: \"key1\", v: nil}},\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple kvs\",\n\t\t\tinitialKvs: []kv{{k: \"key1\", v: nil}, {k: \"key2\", v: nil}},\n\t\t\texpectedKvs: []kv{{k: \"key1\", v: nil}, {k: \"key2\", v: nil}},\n\t\t},\n\t\t{\n\t\t\tname: \"Capacity reached\",\n\t\t\tinitialKvs: []kv{{k: \"key1\", v: nil}},\n\t\t\texpectedKvs: []kv{{k: \"key1\", v: nil}, {}},\n\t\t},\n\t\t{\n\t\t\tname: \"Trimming kvs\",\n\t\t\tinitialKvs: []kv{{k: \"key1\", v: nil}, {k: \"key2\", v: nil}},\n\t\t\texpectedKvs: []kv{{k: \"key1\", v: nil}},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tobj := \u0026Object{kvs: tt.initialKvs}\n\t\t\tgot := obj.getKV()\n\n\t\t\tif len(obj.kvs) != len(tt.expectedKvs) {\n\t\t\t\tt.Errorf(\"expected kvs length %d, got %d\", len(tt.expectedKvs), len(obj.kvs))\n\t\t\t}\n\n\t\t\tfor i, expected := range tt.expectedKvs {\n\t\t\t\tif obj.kvs[i] != expected {\n\t\t\t\t\tt.Errorf(\"at index %d: expected %+v, got %+v\", i, expected, obj.kvs[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif got != \u0026obj.kvs[len(obj.kvs)-1] {\n\t\t\t\tt.Errorf(\"expected got to be the last kv, got %+v\", got)\n\t\t\t}\n\t\t})\n\t}\n}","f1d4a580fbdf8c143281df8713dc7b06":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": \"value\"` + \"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": [1, 2, 3]` + \"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}, t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, want err = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif result.s != test.expected.s || result.t != test.expected.t {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t} else if test.expected == nil \u0026\u0026 result != nil {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want nil\", test.input, result)\n\t\t}\n\t}\n}","f1fe434c7c5c4eee4f1b5f499d63ef52":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test for empty JSON object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test for empty JSON array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test for string\n\t\t{\"true\", valueTrue, false}, // Test for boolean true\n\t\t{\"false\", valueFalse, false}, // Test for boolean false\n\t\t{\"null\", valueNull, false}, // Test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test for number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test for object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test for array of numbers\n\t\t{\"{\\\"key\\\":true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}}, false}, // Test for object with boolean value\n\t\t{\"{\\\"key\\\":null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test for object with null value\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, want error = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif v == nil || test.expected == nil {\n\t\t\t\tif v != test.expected {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif v.t != test.expected.t || v.s != test.expected.s {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","f23543cc8a2f20450756636e16c7ac84":"// file: object_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Initial call to getKV\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Fatal(\"Expected non-nil kv from first getKV call\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"Expected kvs length to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Check the first kv\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Fatalf(\"Expected first kv to have empty key and nil value, got key: %s, value: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Second call to getKV\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Fatal(\"Expected non-nil kv from second getKV call\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Check the second kv\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Fatalf(\"Expected second kv to have empty key and nil value, got key: %s, value: %v\", kv2.k, kv2.v)\n\t}\n\n\t// Check that kv1 and kv2 point to different kv structs\n\tif kv1 == kv2 {\n\t\tt.Fatal(\"Expected kv1 and kv2 to be different instances\")\n\t}\n\n\t// Fill the kvs to test capacity handling\n\tfor i := 0; i \u003c 100; i++ {\n\t\t_ = obj.getKV()\n\t}\n\tif len(obj.kvs) != 102 {\n\t\tt.Fatalf(\"Expected kvs length to be 102 after filling, got %d\", len(obj.kvs))\n\t}\n}","f42b808694ac056f3434ca48d3a97f42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\t// Compare the expected Value with the result Value\n\t\t\t// This requires implementing a comparison function for Value\n\t\t}\n\n\t\t// Additional checks on remaining string if necessary\n\t}\n}","f43be1abf4b1b32657a9009cca3aa5f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\" world`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\\\\\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\\\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\" \"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\" \\\"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\\\"`,\n\t\t\texpectedValue: \"hello\\\\\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","f4bcb92947eb553e92ce8b89aba331e3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\nNewLine\", \"Mixed😀\\nNewLine\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Escaped\\\\\\\\nCharacters\", \"Escaped\\\\nCharacters\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f4ec22d1a5a18bc89b39a41074f20a98":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"-inf more text\", \"-inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"-nan more text\", \"-nan\", \" more text\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","f507afd9a2e710907103163f30938768":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0041\", \"UnicodeA\"},\n\t\t{\"Invalid\\\\uXYZ\", \"Invalid\\\\uXYZ\"},\n\t\t{\"Surrogate\\\\uD83D\\\\uDE00\", \"Surrogate😀\"},\n\t\t{\"Incomplete\\\\u\", \"Incomplete\\\\u\"},\n\t\t{\"Mixed\\\\uD83D\\\\uDE00\\\\uD83D\\\\uDE01\", \"Mixed😀😁\"},\n\t\t{\"Escape\\\\n\\\\t\\\\b\\\\f\\\\r\\\\\\\"\", \"Escape\\n\\t\\b\\f\\r\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f52a9ba437685c8435afc8b5272bb656":"// fastjson_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid int as string\",\n\t\t\tjson:     `{\"key\": \"42\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0, // Expecting 0 because it's a string\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid nested int\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid array index\",\n\t\t\tjson:     `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array index\",\n\t\t\tjson:     `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"3\"},\n\t\t\texpected: -1, // Out of bounds\n\t\t},\n\t\t{\n\t\t\tname:     \"valid float\",\n\t\t\tjson:     `{\"key\": 3.14}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0, // Expecting 0 because it's a float\n\t\t},\n\t\t{\n\t\t\tname:     \"valid boolean\",\n\t\t\tjson:     `{\"key\": true}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0, // Expecting 0 because it's a boolean\n\t\t},\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tjson:     `{\"key\": null}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: -1, // Expecting -1 because it's null\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse json: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","f583068e21b7ee06f424a489cd2eb93d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedTail   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"string\"`,\n\t\t\texpectedValue: \u0026Value{s: \"string\", t: TypeString},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"123\",\n\t\t\texpectedValue: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}, keysUnescaped: false}, t: TypeObject},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"invalid\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"invalid\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nan\",\n\t\t\texpectedValue: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}, keysUnescaped: false}, t: TypeObject},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif v != test.expectedValue {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, expectedValue = %v\", test.input, v, test.expectedValue)\n\t\t}\n\t\tif tail != test.expectedTail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, expectedTail = %q\", test.input, tail, test.expectedTail)\n\t\t}\n\t}\n}","f59ee05c8531a20d9be7e8f6127935d7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Newline:\\\\nTab:\\\\tBackslash:\\\\\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: 你好\"},\n\t\t{\"Invalid Unicode: \\\\uD83D\", \"Invalid Unicode: \\\\uD83D\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: 😀\"},\n\t\t{\"Mixed: \\\\nLine1\\\\nLine2\", \"Mixed: \\nLine1\\nLine2\"},\n\t\t{\"Escaped Slash: \\\\/\", \"Escaped Slash: /\"},\n\t\t{\"No Escape\", \"No Escape\"},\n\t\t{\"Incomplete Escape: \\\\u\", \"Incomplete Escape: \\\\u\"},\n\t\t{\"Invalid Escape: \\\\x\", \"Invalid Escape: \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f5e0639406a7ac149ef59ce46b9fd877":"// file: object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test initial state\n\tkv := obj.getKV()\n\tif kv.k != \"\" || kv.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %v\", kv.k, kv.v)\n\t}\n\n\t// Test adding a key-value pair\n\tkv.k = \"key1\"\n\tkv.v = \u0026Value{} // Assuming Value is initialized properly\n\tkv = obj.getKV()\n\n\tif kv.k != \"\" || kv.v != nil {\n\t\tt.Errorf(\"Expected empty kv after getKV, got k: %s, v: %v\", kv.k, kv.v)\n\t}\n\n\t// Test capacity increase\n\tfor i := 0; i \u003c 10; i++ {\n\t\tkv := obj.getKV()\n\t\tkv.k = \"key\" + string(i)\n\t\tkv.v = \u0026Value{}\n\t}\n\n\tif len(obj.kvs) != 11 { // 1 initial + 10 added\n\t\tt.Errorf(\"Expected kvs length to be 11, got %d\", len(obj.kvs))\n\t}\n\n\t// Test that kvs are correctly populated\n\tfor i, kv := range obj.kvs {\n\t\tif kv.k != \"key\"+string(i) {\n\t\t\tt.Errorf(\"Expected key to be key%d, got %s\", i, kv.k)\n\t\t}\n\t\tif kv.v == nil {\n\t\t\tt.Errorf(\"Expected non-nil value for key%d\", i)\n\t\t}\n\t}\n}","f61bfa80baef78dd9ee3035bba841ed5":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                             // empty string\n\t\t{\"   hello\", \"hello\"},                // leading spaces\n\t\t{\"\\n\\nhello\", \"hello\"},               // leading newlines\n\t\t{\"\\thello\", \"hello\"},                 // leading tab\n\t\t{\"\\r\\nhello\", \"hello\"},               // leading carriage return and newline\n\t\t{\"   \\n   hello\", \"hello\"},           // mixed leading whitespace\n\t\t{\"hello\", \"hello\"},                    // no leading whitespace\n\t\t{\"   \", \"\"},                           // only spaces\n\t\t{\"\\n\", \"\"},                            // only newline\n\t\t{\"\\t\", \"\"},                            // only tab\n\t\t{\"\\r\", \"\"},                            // only carriage return\n\t\t{\"   \\n   \", \"\"},                     // mixed whitespace with trailing spaces\n\t\t{\"\\n\\n\\n\", \"\"},                       // only newlines\n\t\t{\"\\t\\t\\t\", \"\"},                       // only tabs\n\t\t{\"\\r\\r\\r\", \"\"},                       // only carriage returns\n\t\t{\"   hello world   \", \"hello world   \"}, // leading spaces with trailing spaces\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f625b903fe1f87df3db897c6edb4f6ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeString, s: \"item1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"42\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[\"item1\",42]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal boolean false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","f6f799d652f95548df1454b0da524481":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","f7174365718278f6c246af3c02df800c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected value structure */ },\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tresult, err := p.Parse(test.input)\n\n\t\tif test.hasError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\t// Here you would typically compare the result with the expected value.\n\t\t\t// This comparison will depend on how you define equality for Value.\n\t\t}\n\t}\n}","f7c57cc5d4987c63433126e4c45ef159":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                             // empty string\n\t\t{\"   Hello\", \"Hello\"},                // leading spaces\n\t\t{\"\\n\\nHello\", \"Hello\"},               // leading newlines\n\t\t{\"\\t\\tHello\", \"Hello\"},               // leading tabs\n\t\t{\"\\r\\rHello\", \"Hello\"},               // leading carriage returns\n\t\t{\"   \\n\\t\\r   World\", \"World\"},       // mixed whitespace\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},      // no whitespace\n\t\t{\"   \", \"\"},                          // only whitespace\n\t\t{\"\\n\\n\\n\", \"\"},                       // only newlines\n\t\t{\"\\t\\t\\t\", \"\"},                       // only tabs\n\t\t{\"\\r\\r\\r\", \"\"},                       // only carriage returns\n\t\t{\"   \\n\\t\\r   \", \"\"},                 // trailing whitespace\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f8928951972e02af89edabbec7377750":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected int\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid int\",\n\t\t\tvalue:    \u0026Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid negative int\",\n\t\t\tvalue:    \u0026Value{s: \"-42\", t: TypeNumber},\n\t\t\texpected: -42,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tvalue:    \u0026Value{s: `\"not a number\"`, t: TypeString},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (bool)\",\n\t\t\tvalue:    \u0026Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Overflow int\",\n\t\t\tvalue:    \u0026Value{s: \"2147483648\", t: TypeNumber}, // 2^31\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Underflow int\",\n\t\t\tvalue:    \u0026Value{s: \"-2147483649\", t: TypeNumber}, // -2^31 - 1\n\t\t\texpected: 0,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.value.Int()\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"Int() error = %v, wantErr %v\", err, tt.err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","f8da9bdf20008c2b106a9e69d349e4ba":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" extra`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" extra\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes`,\n\t\t\texpectedValue: \"no quotes\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\"`,\n\t\t\texpectedValue: \"escaped \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","f95819b73bedc0740878a7252e4ef62b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"}, // Assuming you want to test this case, but the original code doesn't return a string for TypeNumber\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for the panic case\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\t\n\tvar unknownType Type = 100 // An arbitrary value not defined in the Type constants\n\t_ = unknownType.String() // This should cause a panic\n}","f9747230c68e23c0a3a3fc2165b2b8a6":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue, s: \"\"},\n\t\t\t\t\t{t: TypeNull, s: \"\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,null]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","f981bfe9171513de09c0681357443d27":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" more text`,\n\t\t\texpectedValue: \"hello\\\\\\\"world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\" \"world\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" \\\"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\"world\"`,\n\t\t\texpectedValue: \"hello\\\\\",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","fa1f625cfa6f647e389ef8b2e4a2b0f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for object with array */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for object with boolean */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: \u0026Value{ /* expected Value structure for object with null */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\t// Additional checks can be added for the remaining string if necessary\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on Value structure\n\treturn false // Placeholder\n}","fa43a2f1438e1f409b9dcf9d2fc25dc6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{a: []*Value{{s: \"2\", t: TypeNumber}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result != nil {\n\t\t\tif result.t != test.expected.t || len(result.o.kvs) != len(test.expected.o.kvs) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","fad2cd55a1437b3ce0da7feb21a2c28c":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"test\",\n\t\t\t},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,true,false]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"42\",\n\t\t\t},\n\t\t\texpected: `42`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","fafe949e40ef0e679a1dce9f0ab14244":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value should be constructed properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value should be constructed properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value should be constructed properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value should be constructed properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value should be constructed properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value should be constructed properly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%q) = nil, want %v\", test.input, test.expected)\n\t\t}\n\n\t\t// Additional checks can be added here to compare the actual structure of the result with expected\n\t}\n}","fb729c9e664590824f43d00dd4575e18":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello world\"`,\n\t\t\texpectedValue:  \"hello world\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello \\\"world\\\"\"`,\n\t\t\texpectedValue:  \"hello \\\"world\\\"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\\\"world\"`,\n\t\t\texpectedValue:  \"hello\\\\\\\"world\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\"world\"`,\n\t\t\texpectedValue:  \"hello\\\\\",\n\t\t\texpectedRemain: \"world\\\"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) remain = %q, expectedRemain = %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","fb7e9ab90d925bed85b64d15b8032d26":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) got = %v, want %v\", test.input, result.a, test.expected)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","fce70cc9e40ba2c400ed89f3e0ba423b":"// file: get_int_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid int as string\",\n\t\t\tjson:     `{\"key\": \"42\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0, // Assuming GetInt returns 0 for string values.\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"key\": 42}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"key\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (array)\",\n\t\t\tjson:     `{\"key\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested key\",\n\t\t\tjson:     `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `{\"key\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of bounds\",\n\t\t\tjson:     `{\"key\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"key\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","feacaa5e88202caacf33cb33a02608a6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // Test empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // Test empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // Test empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // Test string\n\t\t{\"true\", valueTrue, false}, // Test true\n\t\t{\"false\", valueFalse, false}, // Test false\n\t\t{\"null\", valueNull, false}, // Test null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test number\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, false}, // Test object with key-value\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\": [true, false]}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse}, t: TypeArray}}}}}, false}, // Test object with array\n\t\t{\"{\\\"key\\\": null}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}}, false}, // Test object with null\n\t\t{\"{\\\"key\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}}}}}, false}, // Test nested object\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif v == nil || v.t != test.expected.t || v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t}\n\t}\n}","ff29818ed9c5eb2e04b751c3ad5a474c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: TypeString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}, t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"1.23\",\n\t\t\texpected: \u0026Value{s: \"1.23\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}}}}, t: TypeObject},\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got none\", test.input, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 *result != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif tail != test.input[len(test.input)-len(tail):] {\n\t\t\tt.Errorf(\"parseValue(%q) returned tail %q, want %q\", test.input, tail, test.input[len(test.input)-len(tail):])\n\t\t}\n\t}\n}","ff2e64941735c4b5b5fb0f73d2564232":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\tname:     \"Valid uint value\",\n\t\t\tinput:    parseJSON(`{\"key\": 42}`),\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tinput:    parseJSON(`{\"key\": 42}`),\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tinput:    parseJSON(`{\"key\": \"not_a_number\"}`),\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (array)\",\n\t\t\tinput:    parseJSON(`{\"key\": [1, 2, 3]}`),\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid uint value with array index\",\n\t\t\tinput:    parseJSON(`{\"key\": [10, 20, 30]}`),\n\t\t\tkeys:     []string{\"key\", \"0\"},\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tname:     \"Out of bounds array index\",\n\t\t\tinput:    parseJSON(`{\"key\": [10, 20, 30]}`),\n\t\t\tkeys:     []string{\"key\", \"3\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid uint value with nested keys\",\n\t\t\tinput:    parseJSON(`{\"outer\": {\"inner\": 100}}`),\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.GetUint(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to parse JSON strings into Value objects\nfunc parseJSON(s string) *Value {\n\t// Assume this function correctly parses a JSON string into a *Value\n\t// Implementation is omitted for brevity\n}","ff75975ea5cedab01a573834e62bf964":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", nil},\n\t\t{\"3.14abc\", \"3.14\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"123.45.67\", \"123.45\", \".67\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}"}