{"00278ae3692fa09d9f958ad63beba116":"// file: exists_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Exists(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tjsonInput  string\n\t\tkeys       []string\n\t\texpected   bool\n\t}{\n\t\t{\n\t\t\tname:       \"Field exists at root\",\n\t\t\tjsonInput:  `{\"field1\": \"value1\"}`,\n\t\t\tkeys:       []string{\"field1\"},\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Field does not exist at root\",\n\t\t\tjsonInput:  `{\"field1\": \"value1\"}`,\n\t\t\tkeys:       []string{\"field2\"},\n\t\t\texpected:   false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Field exists in nested object\",\n\t\t\tjsonInput:  `{\"outer\": {\"inner\": \"value2\"}}`,\n\t\t\tkeys:       []string{\"outer\", \"inner\"},\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Field does not exist in nested object\",\n\t\t\tjsonInput:  `{\"outer\": {\"inner\": \"value2\"}}`,\n\t\t\tkeys:       []string{\"outer\", \"nonexistent\"},\n\t\t\texpected:   false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Array index exists\",\n\t\t\tjsonInput:  `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:       []string{\"array\", \"0\"},\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Array index does not exist\",\n\t\t\tjsonInput:  `{\"array\": [1, 2, 3]}`,\n\t\t\tkeys:       []string{\"array\", \"3\"},\n\t\t\texpected:   false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Nested array index exists\",\n\t\t\tjsonInput:  `{\"outer\": {\"array\": [1, 2, 3]}}`,\n\t\t\tkeys:       []string{\"outer\", \"array\", \"1\"},\n\t\t\texpected:   true,\n\t\t},\n\t\t{\n\t\t\tname:       \"Nested array index does not exist\",\n\t\t\tjsonInput:  `{\"outer\": {\"array\": [1, 2, 3]}}`,\n\t\t\tkeys:       []string{\"outer\", \"array\", \"5\"},\n\t\t\texpected:   false,\n\t\t},\n\t\t{\n\t\t\tname:       \"Empty keys returns false\",\n\t\t\tjsonInput:  `{\"field1\": \"value1\"}`,\n\t\t\tkeys:       []string{},\n\t\t\texpected:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.jsonInput)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse json: %v\", err)\n\t\t\t}\n\t\t\tgot := v.Exists(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Exists() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0144670a849d18faf8a4f3ce07fa7a09":"// visit_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\n// Mock function to be passed to Visit for testing\nfunc mockVisit(key []byte, v *Value) {\n\t// Implementation of mock, could collect results or assert conditions\n}\n\n// TestVisit tests the Visit function within the Object type.\nfunc TestVisit(t *testing.T) {\n\t// Sample JSON to test\n\tjsonStr := `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\"}`\n\t\n\t// Parse the JSON string into a Value\n\tvalue, err := parseObject(jsonStr, nil, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\t// Get the underlying Object from the parsed Value\n\tobj, err := value.Object()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get Object from Value: %v\", err)\n\t}\n\n\t// Call the Visit method with the mock function\n\tobj.Visit(mockVisit)\n\n\t// Additional checks or assertions can be placed here to validate\n\t// that the Visit method behaved as expected.\n}","02a8269c4ee18a4fbb8c09411ab1841f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twant      uint\n\t\twantErr   bool\n\t}{\n\t\t{\n\t\t\tname:    \"valid uint\",\n\t\t\tinput:   \"42\",\n\t\t\twant:    42,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid uint64 maximum value\",\n\t\t\tinput:   \"18446744073709551615\", // Max uint64\n\t\t\twant:    0,                     // Expect an error\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"valid number larger than uint\",\n\t\t\tinput:   \"4294967296\", // Overflow for uint\n\t\t\twant:    0,            // Expect an error\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"not a number\",\n\t\t\tinput:   `\"not a number\"`, // Invalid JSON type\n\t\t\twant:    0,                // Expect an error\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"negative number\",\n\t\t\tinput:   \"-10\", // Invalid for uint\n\t\t\twant:    0,    // Expect an error\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{s: tt.input, t: TypeNumber}\n\t\t\tgot, err := v.Uint()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Uint() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Uint() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","030050b2471e57cd0d6c0d511578aae8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\n// TestSkipWS tests the skipWS function for various input cases.\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   leading spaces\", \"leading spaces\"},\n\t\t{\"   \", \"\"},\n\t\t{\"noSpacesHere\", \"noSpacesHere\"},\n\t\t{\"\\n\\t\\tmore spaces\", \"more spaces\"},\n\t\t{\"\\r\\nhello\", \"hello\"},\n\t\t{\"\", \"\"},\n\t\t{\"   trailing spaces   \", \"trailing spaces   \"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","030088fada765edfb609350d13c2384f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremains  string\n\t\terr      bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", false},\n\t\t{\"nan123\", \"nan\", \"123\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"-infabc\", \"-inf\", \"abc\", false},\n\t\t{\"42abc\", \"42\", \"abc\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot, remains, err := parseRawNumber(tt.input)\n\n\t\tif (err != nil) != tt.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error: got %v, want error: %v\", tt.input, err, tt.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif got != tt.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, got, tt.expected)\n\t\t}\n\n\t\tif remains != tt.remains {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remains = %q, want %q\", tt.input, remains, tt.remains)\n\t\t}\n\t}\n}","033289b6ad4a2cc3c8f2036ab17e5a0b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1 2 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tresult, _, err := parseArray(tt.input, c, 0)\n\n\t\tif tt.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q but got none\", tt.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %s\", tt.input, err)\n\t\t\t} else if len(result.a) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %d elements, got %d for input %q\", len(tt.expected), len(result.a), tt.input)\n\t\t\t} else {\n\t\t\t\tfor i, v := range result.a {\n\t\t\t\t\tif v.t != tt.expected[i].t || v.s != tt.expected[i].s {\n\t\t\t\t\t\tt.Errorf(\"Element %d mismatch for input %q: expected %+v, got %+v\", i, tt.input, tt.expected[i], v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","033e68fd7e13f2d9c2f9e28af7b159b4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello\\\\nWorld\", \"Hello\\nWorld\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Quote: \\\\\\\"example\\\\\\\"\", \"Quote: \\\"example\\\"\"},\n\t\t{\"Backslash: \\\\\\\\example\", \"Backslash: \\\\example\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: ðŸ˜€\"},\n\t\t{\"Mixed: Hello\\\\n\\\\uD83D\\\\uDE00World\", \"Mixed: Hello\\nðŸ˜€World\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","038822c39cb85eb822913d7b1c215e0d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", 0, nil, true}, // Test case for empty string\n\t\t{\"{}\", 0, \u0026Value{t: TypeObject}, false}, // Test case for an empty object\n\t\t{\"[]\", 0, \u0026Value{t: TypeArray}, false}, // Test case for an empty array\n\t\t{\"\\\"hello\\\"\", 0, \u0026Value{s: \"hello\", t: typeRawString}, false}, // Test case for a string\n\t\t{\"true\", 0, valueTrue, false}, // Test case for true\n\t\t{\"false\", 0, valueFalse, false}, // Test case for false\n\t\t{\"null\", 0, valueNull, false}, // Test case for null\n\t\t{\"123\", 0, \u0026Value{s: \"123\", t: TypeNumber}, false}, // Test case for number\n\t\t{\"{ \\\"key\\\": \\\"value\\\" }\", 0, \u0026Value{t: TypeObject}, false}, // Test case for a simple object\n\t\t{\"[1, 2, 3]\", 0, \u0026Value{t: TypeArray}, false}, // Test case for an array\n\t\t{\"{ \\\"key\\\": [1, 2, null] }\", 0, \u0026Value{t: TypeObject}, false}, // Test case for object with array containing null\n\t\t{\"[true, false, null]\", 0, \u0026Value{t: TypeArray}, false}, // Test case for an array with boolean and null\n\t\t{\"{\\\"key\\\": {\\\"subkey\\\": \\\"subvalue\\\"}}\", 0, \u0026Value{t: TypeObject}, false}, // Test case for nested objects\n\t\t{\"{\\\"key\\\": \\\"unmatched\"}\", 0, nil, true}, // Test case for unmatched braces\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, test.depth)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q, %d) error = %v, expected error: %v\", test.input, test.depth, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif v != nil \u0026\u0026 (v.t != test.expected.t || v.s != test.expected.s) {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = %v, expected %v\", test.input, test.depth, v, test.expected)\n\t\t}\n\t}\n}","04d0d806717ea36eb17f2b72144f32a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjsonData string\n\t\tkeys     []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"existing true value\",\n\t\t\tjsonData: `{\"key1\": true}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"existing false value\",\n\t\t\tjsonData: `{\"key1\": false}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjsonData: `{\"key1\": true}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid value type\",\n\t\t\tjsonData: `{\"key1\": \"string\"}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested keys - true\",\n\t\t\tjsonData: `{\"key1\": {\"key2\": true}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested keys - false\",\n\t\t\tjsonData: `{\"key1\": {\"key2\": false}}`,\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested keys - non-existing\",\n\t\t\tjsonData: `{\"key1\": {\"key2\": true}}`,\n\t\t\tkeys:     []string{\"key1\", \"key3\"},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvalue, err := Parse(tt.jsonData)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Parse() error: %v\", err)\n\t\t\t}\n\t\t\tgot := value.GetBool(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"GetBool() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","04d6e97909589953719868a25b6e57cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedKey   string\n\t\texpectedRemaining string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"key\"rest`,\n\t\t\texpectedKey:   \"key\",\n\t\t\texpectedRemaining: \"rest\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"anotherKey\"more`,\n\t\t\texpectedKey:   \"anotherKey\",\n\t\t\texpectedRemaining: \"more\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWithEscape\\\\n\"rest`,\n\t\t\texpectedKey:   \"keyWithEscape\\\\n\",\n\t\t\texpectedRemaining: \"rest\",\n\t\t\texpectedError:  true,  // Expect an error due to escape character\n\t\t},\n\t\t{\n\t\t\tinput:          `\"missingQuote`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError:  true,  // Expect an error due to missing closing quote\n\t\t},\n\t\t{\n\t\t\tinput:          `\"\"rest`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedRemaining: \"rest\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\t\t\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned key: %q, expected: %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned remaining: %q, expected: %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","04dc8272468e903ebae88b5145747003":"// file: object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new object\n\tobj := \u0026Object{\n\t\tkvs:           []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Ensure the initial state is as expected\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"expected kvs length 1, got %d\", len(obj.kvs))\n\t}\n\tif !obj.keysUnescaped {\n\t\tt.Fatal(\"expected keysUnescaped to be true\")\n\t}\n\n\t// Call the reset function\n\tobj.reset()\n\n\t// Check that the object is reset to its initial state\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected kvs length 0 after reset, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped {\n\t\tt.Fatal(\"expected keysUnescaped to be false after reset\")\n\t}\n}","0579ad30148187ef9637d5bc4d216b67":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\t`\"hello\"`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}}, \n\t\t\t`{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\t`[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeString, s: \"some string\"},\n\t\t\t`\"some string\"`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\t`123.45`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t`true`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeFalse},\n\t\t\t`false`,\n\t\t},\n\t\t{\n\t\t\t\u0026Value{t: TypeNull},\n\t\t\t`null`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0)\n\t\t\tgot := test.value.MarshalTo(dst)\n\t\t\tif string(got) != test.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", test.expected, string(got))\n\t\t\t}\n\t\t})\n\t}\n}","05d5d41f64663ccd061a86a2c50439e7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue string\n\t\texpectedRest  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\" world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\\\"world`,\n\t\t\texpectedValue: \"hello \\\\\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \"world\"`,\n\t\t\texpectedValue: \"hello \",\n\t\t\texpectedRest:  \"world\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello world`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped quote \\\\\"\"\" here\"`,\n\t\t\texpectedValue: `escaped quote \\\\\"`,\n\t\t\texpectedRest:  `\" here\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","05f386d6426b2ba51ab1618802020780":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Test cases for simple strings\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Escaped quote: \\\\\\\"\", `Escaped quote: \"`},\n\t\t{\"Newline:\\nTest\", \"Newline:\\nTest\"},\n\t\t{\"Tab:\\tTest\", \"Tab:\\tTest\"},\n\n\t\t// Test cases for escape sequences\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Single Quote: \\'\", \"Single Quote: '\"},\n\t\t{\"Form Feed: \\fTest\", \"Form Feed: \\fTest\"},\n\t\t{\"Carriage Return:\\rTest\", \"Carriage Return:\\rTest\"},\n\t\t{\"Unicode: \\u2713\", \"Unicode: âœ“\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Mixed: \\\\\\\"Hello\\\\\\\" and \\\\n\", `\"Hello\" and \\n`},\n\t\t\n\t\t// Test poorly formed unicode sequences\n\t\t{\"Bad unicode \\\\u123\", \"Bad unicode \\\\u123\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: ðŸ˜„\"},\n\t\t{\"Incomplete Escape: \\\\uD83D\", \"Incomplete Escape: \\\\uD83D\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","07b09c2d02a2a43bf3bdfe6d215f6090":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tjson      string\n\t\texpectInt int\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"valid integer\",\n\t\t\tjson:      `{\"number\": 42}`,\n\t\t\texpectInt: 42,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"valid negative integer\",\n\t\t\tjson:      `{\"number\": -1}`,\n\t\t\texpectInt: -1,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"value is null\",\n\t\t\tjson:      `{\"number\": null}`,\n\t\t\texpectInt: 0, // Expecting 0 because null is being interpreted\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"value is a boolean\",\n\t\t\tjson:      `{\"number\": true}`,\n\t\t\texpectInt: 0, // Expecting 0 because true is not an int\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"value is a string\",\n\t\t\tjson:      `{\"number\": \"not a number\"}`,\n\t\t\texpectInt: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"value is a float\",\n\t\t\tjson:      `{\"number\": 3.14}`,\n\t\t\texpectInt: 0, // Expecting 0 because float cannot fit in int\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := new(Value) // Assuming Value can be created like this\n\t\t\t// Assign JSON parsed value to v here\n\t\t\t// Example: v, _ = Parse(tt.json) // Use the appropriate parsing function\n\n\t\t\tgot, err := v.Int()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expectInt {\n\t\t\t\tt.Errorf(\"Int() = %v, want %v\", got, tt.expectInt)\n\t\t\t}\n\t\t})\n\t}\n}","0939d19a198a44e82a69f74a6213352e":"// file: parse_raw_string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue string\n\t\texpectedRest  string\n\t\texpectedError bool\n\t}{\n\t\t// Test case 1: Normal JSON string\n\t\t{`\"hello\"world`, \"hello\", \"world\", false},\n\n\t\t// Test case 2: String with escaped quotes\n\t\t{`\"hello \\\"world\\\"\"more`, \"hello \\\"world\\\"\", \"more\", false},\n\n\t\t// Test case 3: String with missing closing quote\n\t\t{`\"hello`, \"\", \"\", true},\n\n\t\t// Test case 4: Empty string\n\t\t{`\"\"more`, \"\", \"more\", false},\n\n\t\t// Test case 5: String with multiple escaped quotes\n\t\t{`\"a string with a \\\"quote\\\" here\" and some text`, \"a string with a \\\"quote\\\" here\", \" and some text\", false},\n\n\t\t// Test case 6: String with no quotes\n\t\t{`no quotes here`, \"no quotes here\", \"\", false},\n\n\t\t// Test case 7: String with quotes at the start\n\t\t{`\"quoted string\"`, \"quoted string\", \"\", false},\n\n\t\t// Test case 8: Only escaped quotes (should fail)\n\t\t{`\"\\\\\"`, \"\", \"\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expected %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expected %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","09ab002c025559c976b4c2b3658e55f7":"// file: parser_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParser_Parse(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput *Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\"}`,\n\t\t\texpectedOutput: \u0026Value{}, // Replace with the expected Value\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `[\"element1\", \"element2\"]`,\n\t\t\texpectedOutput: \u0026Value{}, // Replace with the expected Value\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `invalid json`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tparser := \u0026Parser{}\n\t\toutput, err := parser.Parse(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"Parse(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\n\t\tif err == nil \u0026\u0026 output == nil \u0026\u0026 test.expectedOutput != nil {\n\t\t\tt.Errorf(\"Parse(%q) output = nil, expectedOutput %v\", test.input, test.expectedOutput)\n\t\t} else if err == nil \u0026\u0026 output != nil {\n\t\t\t// Add more logic to compare output with expectedOutput if needed\n\t\t}\n\t}\n}","0a78ec200670858320d02e398f83adb6":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\"\", nil, fmt.Errorf(\"cannot parse empty string\")}, // testing empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, nil},              // testing empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, nil},               // testing empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, nil}, // testing string value\n\t\t{\"true\", valueTrue, nil},                         // testing boolean true\n\t\t{\"false\", valueFalse, nil},                       // testing boolean false\n\t\t{\"null\", valueNull, nil},                         // testing null value\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, nil},  // testing number\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", \u0026Value{t: TypeObject}, nil}, // testing object with one key-value pair\n\t\t{\"[1, 2, 3]\", \u0026Value{t: TypeArray}, nil},             // testing array with numbers\n\t\t{\"{\\\"key\\\": [true, false]}\", \u0026Value{t: TypeObject}, nil}, // testing object with an array\n\t}\n\n\tfor _, tt := range tests {\n\t\tv, tail, err := parseValue(tt.input, c, 0)\n\t\tif err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) returned unexpected error: %v, want: %v\", tt.input, err, tt.err)\n\t\t}\n\t\tif v != nil \u0026\u0026 tt.expected != nil \u0026\u0026 v.Type() != tt.expected.Type() {\n\t\t\tt.Errorf(\"parseValue(%q) returned unexpected type: got: %v, want: %v\", tt.input, v.Type(), tt.expected.Type())\n\t\t}\n\t}\n}","0ac5d665a06f3aea0c44fc787c1e6312":"package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected *Value\n        err      error\n    }{\n        {\n            input:    `{\"key\": \"value\"}`,\n            expected: \u0026Value{ /* populate expected Value for this test case */ },\n            err:      nil,\n        },\n        {\n            input:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n            expected: \u0026Value{ /* populate expected Value for this test case */ },\n            err:      nil,\n        },\n        {\n            input:    `{\"key\": 123}`,\n            expected: \u0026Value{ /* populate expected Value for this test case */ },\n            err:      nil,\n        },\n        {\n            input:    `{\"key\": \"value\",}`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing ',' after object value\"),\n        },\n        {\n            input:    `{\"key\"}`,\n            expected: nil,\n            err:      fmt.Errorf(`cannot find opening '\"\" for object key`),\n        },\n        {\n            input:    `{}`,\n            expected: \u0026Value{ /* populate expected Value for an empty object */ },\n            err:      nil,\n        },\n        {\n            input:    `{ \"invalid\": \"object\"`,\n            expected: nil,\n            err:      fmt.Errorf(\"missing '}'\"),\n        },\n        // Add more test cases as necessary\n    }\n\n    for _, test := range tests {\n        c := \u0026cache{}\n        result, remaining, err := parseObject(test.input, c, 0)\n\n        if err != nil \u0026\u0026 test.err == nil {\n            t.Errorf(\"parseObject(%q) returned unexpected error: %v\", test.input, err)\n            continue\n        }\n\n        if err == nil \u0026\u0026 test.err != nil {\n            t.Errorf(\"parseObject(%q) expected error: %v, got none\", test.input, test.err)\n            continue\n        }\n\n        if err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n            t.Errorf(\"parseObject(%q) expected error: %v, got: %v\", test.input, test.err, err)\n            continue\n        }\n\n        // If expected is not nil, you would also want to check if the result matches the expected Value\n        if test.expected != nil \u0026\u0026 result != nil {\n            // Compare result and expected here (you need to implement a method to compare Value types)\n        }\n    }\n}","0b937229edec31861deb151c4b2bde02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      string\n\t}{\n\t\t{\n\t\t\tname:  \"empty array\",\n\t\t\tinput: \"[]\",\n\t\t\texpected: []*Value{\n\t\t\t\t// Expecting a Value with TypeArray and no elements.\n\t\t\t},\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"array with one number\",\n\t\t\tinput: \"[1]\",\n\t\t\texpected: []*Value{\n\t\t\t\t// Expecting a Value with TypeArray containing one number Value.\n\t\t\t},\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"array with multiple numbers\",\n\t\t\tinput: \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\n\t\t\t\t// Expecting a Value with TypeArray containing multiple number Values.\n\t\t\t},\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tname:  \"array with invalid format\",\n\t\t\tinput: \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ',' after array value\",\n\t\t},\n\t\t{\n\t\t\tname:  \"array with unexpected end\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      \"unexpected end of array\",\n\t\t},\n\t\t{\n\t\t\tname:  \"array with missing bracket\",\n\t\t\tinput: \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ']'\",\n\t\t},\n\t\t// More cases can be added as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{} // Assume cache is initialized appropriately.\n\t\t\tdepth := 0 // Assuming a default depth of 0.\n\t\t\tv, remaining, err := parseArray(tt.input, c, depth)\n\t\t\t\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.err {\n\t\t\t\tt.Fatalf(\"expected error %q, got %q\", tt.err, err)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tt.err != \"\" {\n\t\t\t\tt.Fatalf(\"expected error %q but got none\", tt.err)\n\t\t\t}\n\n\t\t\tif v != nil {\n\t\t\t\tif v.Type() != TypeArray {\n\t\t\t\t\tt.Fatalf(\"expected TypeArray, got %v\", v.Type())\n\t\t\t\t}\n\t\t\t\t// Additional checks on v.a can be done here to match expected Values\n\t\t\t}\n\t\t\t\n\t\t\tif remaining != \"\" {\n\t\t\t\tt.Fatalf(\"expected no remaining string, got %q\", remaining)\n\t\t\t}\n\t\t})\n\t}\n}","0caf733fa5305edee132705c431f4cb5":"// value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Uint(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tvalue     string\n\t\texpectUint uint\n\t\texpectErr  bool\n\t}{\n\t\t{\n\t\t\tname:      \"Valid uint\",\n\t\t\tvalue:     \"12345\",\n\t\t\texpectUint: 12345,\n\t\t\texpectErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid type - string\",\n\t\t\tvalue:     `\"hello\"`,\n\t\t\texpectUint: 0,\n\t\t\texpectErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid type - bool\",\n\t\t\tvalue:     \"true\",\n\t\t\texpectUint: 0,\n\t\t\texpectErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Large uint64 value\",\n\t\t\tvalue:     \"18446744073709551615\", // max uint64\n\t\t\texpectUint: 0,\n\t\t\texpectErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Negative number\",\n\t\t\tvalue:     \"-123\",\n\t\t\texpectUint: 0,\n\t\t\texpectErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvalue := \u0026Value{s: tt.value, t: TypeNumber} // Mocking Value with number type\n\t\t\tgot, err := value.Uint()\n\t\t\t\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Uint() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.expectErr \u0026\u0026 got != tt.expectUint {\n\t\t\t\tt.Errorf(\"Uint() = %v, expectUint %v\", got, tt.expectUint)\n\t\t\t}\n\t\t})\n\t}\n}","0cd53799171f8eab7a7786371d5f8f6a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e10\", \"-123.45e10\", \"\", nil},\n\t\t{\"0.1abc\", \"0.1\", \"abc\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"infxyz\", \"inf\", \"xyz\", nil},\n\t\t{\"+inf\", \"+inf\", \"\", nil},\n\t\t{\"-nanabc\", \"-nan\", \"abc\", nil},\n\t\t{\"123abc456\", \"123\", \"abc456\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-123abc\", \"-123\", \"abc\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\t\tif num != test.expectedNum || rest != test.expectedRest || (err != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\",\n\t\t\t\ttest.input, num, rest, err, test.expectedNum, test.expectedRest, test.expectedErr)\n\t\t}\n\t}\n}","0d8972029cfd570b7b6fadd35e2a9a42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tvalue     *Value\n\t\texpected  Type\n\t}{\n\t\t{\n\t\t\tname:     \"TypeRawString\",\n\t\t\tvalue:    \u0026Value{s: \"test\", t: typeRawString},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tvalue:    \u0026Value{s: \"test\", t: TypeString},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tvalue:    \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpected: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tvalue:    \u0026Value{o: Object{kvs: []kv{}}, t: TypeObject},\n\t\t\texpected: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tvalue:    \u0026Value{a: []*Value{}, t: TypeArray},\n\t\t\texpected: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: TypeNull,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.Type()\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Value.Type() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","0dd52c43968564e6763558b0b79bfa78":"// parse_value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\ttail     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"hello\\\"\",\n\t\t\texpected: \u0026Value{s: \"hello\", t: TypeString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{invalid json}\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [\\\"value1\\\", \\\"value2\\\"]}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"value1\", t: TypeString}, {s: \"value2\", t: TypeString}}}}}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\",\n\t\t\texpected: nil,\n\t\t\ttail:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"  [ \\n\\t1, 2, 3]\\n  \",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"    \\\"text\\\"    \",\n\t\t\texpected: \u0026Value{s: \"text\", t: TypeString},\n\t\t\ttail:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) err = %v, want error = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 !reflect.DeepEqual(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %+v, want %+v\", test.input, v, test.expected)\n\t\t}\n\t\tif tail != test.tail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", test.input, tail, test.tail)\n\t\t}\n\t}\n}","0e137cd85ee0d22389c92c89df6ce95f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tinput         string\n\t\texpectedKeys  []string\n\t\texpectedValues []string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\tname:          \"Basic Object\",\n\t\t\tinput:         `{\"key1\":\"value1\", \"key2\":\"value2\"}`,\n\t\t\texpectedKeys:  []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"value1\", \"value2\"},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tname:          \"Empty Object\",\n\t\t\tinput:         `{}`,\n\t\t\texpectedKeys:  []string{},\n\t\t\texpectedValues: []string{},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tname:          \"Missing Value\",\n\t\t\tinput:         `{\"key1\":}`,\n\t\t\texpectedKeys:  nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:          \"Invalid JSON\",\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpectedKeys:  nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:          \"Malformed Key\",\n\t\t\tinput:         `{key1:\"value1\"}`,\n\t\t\texpectedKeys:  nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tname:          \"Extra Comma\",\n\t\t\tinput:         `{\"key1\":\"value1\",}`,\n\t\t\texpectedKeys:  []string{\"key1\"},\n\t\t\texpectedValues: []string{\"value1\"},\n\t\t\texpectError:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tvalue, rest, err := parseObject(tt.input, c, depth)\n\n\t\t\tif tt.expectError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected an error but got none\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(rest) != 0 {\n\t\t\t\tt.Errorf(\"expected empty rest but got: %q\", rest)\n\t\t\t}\n\n\t\t\tif value == nil {\n\t\t\t\tt.Fatal(\"expected a value but got nil\")\n\t\t\t}\n\n\t\t\tobject := value.o.kvs\n\t\t\tif len(object) != len(tt.expectedKeys) {\n\t\t\t\tt.Fatalf(\"expected %d keys but got %d\", len(tt.expectedKeys), len(object))\n\t\t\t}\n\n\t\t\tfor i, kv := range object {\n\t\t\t\tif kv.k != tt.expectedKeys[i] {\n\t\t\t\t\tt.Errorf(\"expected key %q but got %q\", tt.expectedKeys[i], kv.k)\n\t\t\t\t}\n\t\t\t\tactualValue, _ := kv.v.StringBytes()\n\t\t\t\tif string(actualValue) != tt.expectedValues[i] {\n\t\t\t\t\tt.Errorf(\"expected value %q but got %q\", tt.expectedValues[i], string(actualValue))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","0e2fc36867a75303a40fd010715ca652":"// parser_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedError  bool\n\t\texpectedType   Type\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedError: false,\n\t\t\texpectedType:  TypeObject,\n\t\t},\n\t\t{\n\t\t\tinput:         `[\"value1\", \"value2\"]`,\n\t\t\texpectedError: false,\n\t\t\texpectedType:  TypeArray,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"just a string\"`,\n\t\t\texpectedError: false,\n\t\t\texpectedType:  TypeString,\n\t\t},\n\t\t{\n\t\t\tinput:         `123`,\n\t\t\texpectedError: false,\n\t\t\texpectedType:  TypeNumber,\n\t\t},\n\t\t{\n\t\t\tinput:         `true`,\n\t\t\texpectedError: false,\n\t\t\texpectedType:  TypeTrue,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\", \"number\": 123}`,\n\t\t\texpectedError: false,\n\t\t\texpectedType:  TypeObject,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"invalid_json\": 123,}`,\n\t\t\texpectedError: true, // Trailing comma should cause an error\n\t\t\texpectedType:  TypeNull,\n\t\t},\n\t\t{\n\t\t\tinput:         `invalid_json`,\n\t\t\texpectedError: true, // Invalid JSON\n\t\t\texpectedType:  TypeNull,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tv, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"unexpected error: got %v, want error: %v\", err, tt.expectedError)\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tif v.Type() != tt.expectedType {\n\t\t\t\t\tt.Errorf(\"unexpected type: got %v, want %v\", v.Type(), tt.expectedType)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","0e9eb289cd868b9e3366eb39a10000e2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple array\",\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested array\",\n\t\t\tinput:    \"[1, [2, 3], 4]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeArray, a: []*Value{{t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, {t: TypeNumber, s: \"4\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"error missing closing bracket\",\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"error unexpected end of array\",\n\t\t\tinput:    \"[1, 2, 3,\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"error missing comma\",\n\t\t\tinput:    \"[1 2, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"error invalid character\",\n\t\t\tinput:    \"[1, 2, invalid]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{vs: make([]Value, 0)}\n\t\t\tresult, _, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !tt.err \u0026\u0026 !compareValueSlices(result.a, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result.a)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValueSlices(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i].s != b[i].s || a[i].t != b[i].t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","0f26a105e8a6525daf65d26615bb027c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"Hello, World!\"`, \"Hello, World!\"},\n\t\t{`\"This is a backslash: \\\\\"`, \"This is a backslash: \\\\\"},\n\t\t{`\"Quotes: \\\"\"`, \"Quotes: \\\"\"},\n\t\t{`\"Newline: \\nThis is a new line.\"`, \"Newline: \\nThis is a new line.\"},\n\t\t{`\"Tab: \\tThis is a tab.\"`, \"Tab: \\tThis is a tab.\"},\n\t\t{`\"Unicode: \\u03A9\"`, \"Unicode: Î©\"},\n\t\t{`\"Invalid Unicode: \\uD800\"`, \"Invalid Unicode: \\\\uD800\"},\n\t\t{`\"Malformed escape: \\uD800\\\\\"`, \"Malformed escape: \\\\uD800\\\\\"},\n\t\t{`\"Regular string without escapes\"`, \"Regular string without escapes\"},\n\t\t{`\"Escaped forward slash: \\/\"`, \"Escaped forward slash: /\"},\n\t\t{`\"Multiple escapes: \\\"hello\\\" \\n world\"`, \"Multiple escapes: \\\"hello\\\" \\n world\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","0f616e71d39628a3904565c42de8b8bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\t// Create a new cache instance\n\tc := \u0026cache{}\n\n\t// Call getValue and expect a non-nil result\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Error(\"Expected non-nil value from getValue, got nil\")\n\t}\n\n\t// Call getValue multiple times to check if values are being cached correctly\n\tval1 := c.getValue()\n\tval2 := c.getValue()\n\n\t// Check that we still get non-nil values\n\tif val1 == nil || val2 == nil {\n\t\tt.Error(\"Expected non-nil values from getValue, got nil\")\n\t}\n\n\t// Check that we are getting different instances of Value \n\tif val1 == val2 {\n\t\tt.Error(\"Expected different instances from multiple calls to getValue\")\n\t}\n\n\t// Ensure the length of the cache vs slice is as expected\n\tif len(c.vs) != 3 { // 1 initial from first call, 2 from subsequent calls\n\t\tt.Errorf(\"Expected 3 values in cache, got %d\", len(c.vs))\n\t}\n}","102240021d6c63d042cc29f0cf5c3c80":"// file: object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\t// Initialize an Object\n\tobj := \u0026Object{}\n\n\t// Call getKV multiple times to test its behavior\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Fatal(\"Expected non-nil kv, got nil\")\n\t}\n\n\t// Check initial values\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected kv with empty key and nil value, got key: %s, value: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Call getKV again to check that another kv is created\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Fatal(\"Expected non-nil kv, got nil\")\n\t}\n\n\t// Check that kv2 is distinct from kv1\n\tif kv1 == kv2 {\n\t\tt.Fatal(\"Expected kv1 and kv2 to be different instances\")\n\t}\n\n\t// Check that the array of kvs has been updated\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n}","10bbc6828a6fc03332fc16f5cfb25807":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123.456e+2\", \"-123.456e+2\", \"\", nil},\n\t\t{\"3.14xyz\", \"3.14\", \"xyz\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-infxyz\", \"-inf\", \"xyz\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-nanTest\", \"-nan\", \"Test\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+mod\", \"\", \"+mod\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-mod\", \"\", \"-mod\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\t\t\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","127578a71a6a36cc5701f713d549647a":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedKey string\n\t\texpectedVal string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\"}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"value1\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"value1\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedVal: \"\",\n\t\t\texpectError: true, // missing value for key2\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedVal: \"\",\n\t\t\texpectError: true, // trailing comma\n\t\t},\n\t\t{\n\t\t\tinput:       `{}`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedVal: \"\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": 100}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"100\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": true}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"true\",\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key1\": null}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"null\",\n\t\t\texpectError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"Input: %s\", test.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tvar depth int\n\t\t\tresult, remaining, err := parseObject(test.input, c, depth)\n\n\t\t\tif test.expectError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Error(\"expected an error but got nil\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t\t}\n\n\t\t\t\tif result == nil {\n\t\t\t\t\tt.Error(\"expected a result but got nil\")\n\t\t\t\t} else {\n\t\t\t\t\tkv := result.o.kvs[0] // assuming first key-value pair for simplicity\n\t\t\t\t\tif kv.k != test.expectedKey {\n\t\t\t\t\t\tt.Errorf(\"expected key %s, got %s\", test.expectedKey, kv.k)\n\t\t\t\t\t}\n\t\t\t\t\t// here we assume you have a method to get the string representation of Value\n\t\t\t\t\tvalBytes, _ := kv.v.StringBytes()\n\t\t\t\t\tif string(valBytes) != test.expectedVal {\n\t\t\t\t\t\tt.Errorf(\"expected value %s, got %s\", test.expectedVal, string(valBytes))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","131c5e909188ccddbdbc641839726007":"// parse_array_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"hello\"}, {t: TypeString, s: \"world\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,, 4]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid json\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) expected length: %d, got: %d\", test.input, len(test.expected), len(result.a))\n\t\t\t}\n\t\t\tfor i, v := range test.expected {\n\t\t\t\tif v.t != result.a[i].t || v.s != result.a[i].s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) expected value: %v, got: %v\", test.input, v, result.a[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif remainder != \"\" \u0026\u0026 test.err == false {\n\t\t\tt.Errorf(\"parseArray(%q) expected no remainder, got: %q\", test.input, remainder)\n\t\t}\n\t}\n}","13ac2e84e94bb35e0a1906d0f00aa5aa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{input: `\"Hello, World!\"`, expected: \"Hello, World!\"},\n\t\t{input: `\"Escaped \\\\ backslash\"`, expected: \"Escaped \\\\ backslash\"},\n\t\t{input: `\"Tab\\\\tCharacter\"`, expected: \"Tab\\tCharacter\"},\n\t\t{input: `\"Newline\\\\nCharacter\"`, expected: \"Newline\\nCharacter\"},\n\t\t{input: `\"Unicode\\\\u0041\"`, expected: \"UnicodeA\"},\n\t\t{input: `\"Incomplete\\\\u00\"`, expected: \"Incomplete\\\\u00\"},\n\t\t{input: `\"Invalid\\\\u123\"`, expected: \"Invalid\\\\u123\"},\n\t\t{input: `\"Surrogate\\\\uD800\\\\uDC00\"`, expected: \"Surrogateð°€\"},\n\t\t{input: `\"Mixed \\\\uD800\\\\uDC00 and \\\\n new line\"`, expected: \"Mixed ð°€ and \\n new line\"},\n\t\t{input: `\"Unescaped characters: \\x01\\x02\\x03\"`, expected: \"Unescaped characters: \\x01\\x02\\x03\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","148ad80a180eea71a492d6b0b24097d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tjson      string\n\t\tkeys      []string\n\t\twant      []byte\n\t\texpectNil bool\n\t}{\n\t\t{\n\t\t\tjson:      `{\"key1\":\"value1\"}`,\n\t\t\tkeys:      []string{\"key1\"},\n\t\t\twant:      []byte(\"value1\"),\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"key1\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t\tkeys:      []string{\"key1\", \"nestedKey\"},\n\t\t\twant:      []byte(\"nestedValue\"),\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"key2\":[\"item1\", \"item2\"]}`,\n\t\t\tkeys:      []string{\"key2\", \"0\"},\n\t\t\twant:      []byte(\"item1\"),\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"key3\": 100}`,\n\t\t\tkeys:      []string{\"key3\"},\n\t\t\twant:      nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"key4\":null}`,\n\t\t\tkeys:      []string{\"key4\"},\n\t\t\twant:      nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tjson:      `{\"key5\":\"value5\"}`,\n\t\t\tkeys:      []string{\"keyThatDoesNotExist\"},\n\t\t\twant:      nil,\n\t\t\texpectNil: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(string(tt.keys), func(t *testing.T) {\n\t\t\tv, err := Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tgot := v.GetStringBytes(tt.keys...)\n\t\t\tif (got == nil) != tt.expectNil {\n\t\t\t\tt.Errorf(\"expected nil: %v, got: %v\", tt.expectNil, got)\n\t\t\t} else if !tt.expectNil \u0026\u0026 string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"got = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","1490d6cb217dd451490dc28ee87e21f0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError   error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-inf123\", \"-inf\", \"123\", nil},\n\t\t{\"\u0026567\", \"5\", \"67\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"++5\", \"\", \"++5\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"-+5\", \"\", \"-+5\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\tif result != test.expectedNumber || remaining != test.expectedRemaining || (err != nil \u0026\u0026 (test.expectedError == nil || err.Error() != test.expectedError.Error())) {\n\t\t\tt.Errorf(\"For input '%s': expected (%s, %s, %v), got (%s, %s, %v)\", test.input, test.expectedNumber, test.expectedRemaining, test.expectedError, result, remaining, err)\n\t\t}\n\t}\n}","14c58917c9d82fa6db5387dd24350ac4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedType  Type\n\t\texpectError   bool\n\t\terrorMessage  string\n\t}{\n\t\t{\"\", TypeNull, true, \"cannot parse empty string\"},\n\t\t{\"{\", TypeNull, true, \"cannot parse object: unexpected end of JSON\"},\n\t\t{\"{}\", TypeObject, false, \"\"},\n\t\t{\"[1, 2, 3]\", TypeArray, false, \"\"},\n\t\t{\"true\", TypeTrue, false, \"\"},\n\t\t{\"false\", TypeFalse, false, \"\"},\n\t\t{\"null\", TypeNull, false, \"\"},\n\t\t{\"\\\"test\\\"\", TypeString, false, \"\"},\n\t\t{\"123\", TypeNumber, false, \"\"},\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", TypeObject, false, \"\"},\n\t\t{\"[\\\"string1\\\", \\\"string2\\\"]\", TypeArray, false, \"\"},\n\t\t{\"{\\\"key\\\": true}\", TypeObject, false, \"\"},\n\t\t{\"{\\n\\t\\\"key1\\\": \\\"value1\\\",\\n\\t\\\"key2\\\": [1, 2, 3]\\n}\", TypeObject, false, \"\"},\n\t\t{\"[1, true, null, \\\"string\\\"]\", TypeArray, false, \"\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tif tt.expectError {\n\t\t\t\t\tt.Errorf(\"expected error but got none\")\n\t\t\t\t} else {\n\t\t\t\t\tt.Errorf(\"expected no error but got: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.errorMessage {\n\t\t\t\tt.Errorf(\"expected error message: %v, got: %v\", tt.errorMessage, err.Error())\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\tif result.Type() != tt.expectedType {\n\t\t\t\t\tt.Errorf(\"expected type: %v, got: %v\", tt.expectedType, result.Type())\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","14fbe10b0680f4221116e7b1870b9a89":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected []*Value\n\t\terrMsg   string\n\t}{\n\t\t{\n\t\t\tname:   \"empty array\",\n\t\t\tinput:  \"[]\",\n\t\t\texpected: []*Value{},\n\t\t},\n\t\t{\n\t\t\tname:   \"single element\",\n\t\t\tinput:  \"[1]\",\n\t\t\texpected: []*Value{\n\t\t\t\t\u0026Value{s: \"1\", t: TypeNumber},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple elements\",\n\t\t\tinput:  \"[1,2,3]\",\n\t\t\texpected: []*Value{\n\t\t\t\t\u0026Value{s: \"1\", t: TypeNumber},\n\t\t\t\t\u0026Value{s: \"2\", t: TypeNumber},\n\t\t\t\t\u0026Value{s: \"3\", t: TypeNumber},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"nested array\",\n\t\t\tinput:  \"[1, [2,3]]\",\n\t\t\texpected: []*Value{\n\t\t\t\t\u0026Value{s: \"1\", t: TypeNumber},\n\t\t\t\t\u0026Value{\n\t\t\t\t\ts: \"\",\n\t\t\t\t\tt: TypeArray,\n\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\u0026Value{s: \"2\", t: TypeNumber},\n\t\t\t\t\t\t\u0026Value{s: \"3\", t: TypeNumber},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"missing closing bracket\",\n\t\t\tinput:  \"[1,2\",\n\t\t\terrMsg: \"missing ']'\",\n\t\t},\n\t\t{\n\t\t\tname:   \"unexpected end of array\",\n\t\t\tinput:  \"[1,2,3\",\n\t\t\terrMsg: \"unexpected end of array\",\n\t\t},\n\t\t{\n\t\t\tname:   \"missing comma\",\n\t\t\tinput:  \"[1 2]\",\n\t\t\terrMsg: \"missing ',' after array value\",\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid character\",\n\t\t\tinput:  \"[1,2,3$]\",\n\t\t\terrMsg: \"missing ',' after array value\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tresult, remaining, err := parseArray(tt.input, c, 0)\n\n\t\t\tif tt.errMsg != \"\" {\n\t\t\t\tif err == nil || err.Error() != tt.errMsg {\n\t\t\t\t\tt.Fatalf(\"expected error '%s', got '%v'\", tt.errMsg, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif remaining != \"\" {\n\t\t\t\tt.Fatalf(\"expected remaining string to be empty, got '%s'\", remaining)\n\t\t\t}\n\n\t\t\t// Check the length of the resulting parsed array\n\t\t\tif len(result.a) != len(tt.expected) {\n\t\t\t\tt.Fatalf(\"expected %d elements, got %d\", len(tt.expected), len(result.a))\n\t\t\t}\n\n\t\t\t// Check the values\n\t\t\tfor i, expectedValue := range tt.expected {\n\t\t\t\tif result.a[i].s != expectedValue.s || result.a[i].t != expectedValue.t {\n\t\t\t\t\tt.Errorf(\"at index %d: expected %v, got %v\", i, expectedValue, result.a[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","15857d05467c9fab2c5649930ceed954":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\t\\t\\t  \", \"\"},\n\t\t{\"\\n   abc\", \"abc\"},\n\t\t{\"\\r\\nabc\", \"abc\"},\n\t\t{\"   abc\", \"abc\"},\n\t\t{\"abc   \", \"abc   \"},\n\t\t{\"\\t\\tabc\", \"abc\"},\n\t\t{\"\\n\\nabc\", \"abc\"},\n\t\t{\"\\rabc\", \"abc\"},\n\t\t{\" \\t\\n\\t  \", \"\"},\n\t\t{\" \\r\\n    \", \"\"},\n\t\t{\" \\t \\nabc\", \"abc\"},\n\t\t{\"\\n\\t\\r \\n\\t \", \"\"},\n\t\t{\"abc\\t\\n\\r\", \"abc\\t\\n\\r\"},\n\t\t{\"   abc   \", \"abc   \"},\n\t}\n\n\tfor _, test := range tests {\n\t\tif output := skipWSSlow(test.input); output != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, output, test.expected)\n\t\t}\n\t}\n}","15a1bd9c4cb7d2c8250487d176211055":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{input: `\"Hello, World!\"`, expected: \"Hello, World!\"},\n\t\t{input: `\"Line1\\nLine2\"`, expected: \"Line1\\nLine2\"},\n\t\t{input: `\"Tab\\tCharacter\"`, expected: \"Tab\\tCharacter\"},\n\t\t{input: `\"Unicode \\u4F60\\u597D\"`, expected: \"Unicode ä½ å¥½\"},\n\t\t{input: `\"Invalid unicode \\uD83D\"`, expected: \"Invalid unicode \\\\uD83D\"},\n\t\t{input: `\"Backslash \\\\\"`, expected: \"Backslash \\\\\"},\n\t\t{input: `\"String with an invalid escape \\x\"`, expected: \"String with an invalid escape \\\\x\"},\n\t\t{input: `\"\"`, expected: \"\"},\n\t\t{input: `\"Escaped quotes: \\\"Quotes\\\"\"`, expected: \"Escaped quotes: \\\"Quotes\\\"\"},\n\t\t{input: `\"Mixed escape: \\n\\t\\\"Hello \\\\ World \\\"\"`, expected: \"Mixed escape: \\n\\t\\\"Hello \\\\ World \\\"\"},\n\t\t{input: \"No escape sequences\", expected: \"No escape sequences\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","15d7ed731d71f30fb541c89324e4ba82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t// Test case for empty string\n\t\t{\"\", nil, fmt.Errorf(\"cannot parse empty string\")},\n\n\t\t// Test case for valid JSON object\n\t\t{\"{}\", \u0026Value{t: TypeObject}, nil},\n\n\t\t// Test case for valid JSON array\n\t\t{\"[]\", \u0026Value{t: TypeArray}, nil},\n\n\t\t// Test case for valid JSON string\n\t\t{\"\\\"test\\\"\", \u0026Value{s: \"test\", t: typeRawString}, nil},\n\n\t\t// Test case for true boolean\n\t\t{\"true\", valueTrue, nil},\n\n\t\t// Test case for false boolean\n\t\t{\"false\", valueFalse, nil},\n\n\t\t// Test case for null\n\t\t{\"null\", valueNull, nil},\n\n\t\t// Test case for valid number\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, nil},\n\n\t\t// Test case for too deep JSON nested structure\n\t\t{\"{ \\\"key\\\": {\\\"another_key\\\": {\\\"deep_key\\\": {}}} }\", nil,\n\t\t\tfmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth)},\n\n\t\t// Test case for invalid JSON structure\n\t\t{\"{\", nil, fmt.Errorf(\"cannot parse object: unexpected end of JSON input\")},\n\n\t\t// Test case for unexpected value\n\t\t{\"unexpectedValue\", nil, fmt.Errorf(\"unexpected value found: %q\", \"unexpectedValue\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(tt.input, c, 0)\n\n\t\t\tif !compareValues(result, tt.expected) || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = (%v, %v), expected (%v, %v)\", tt.input, result, err, tt.expected, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues compares two *Value pointers for equality\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t\n}","164ccc2a2be2f8e88436d7a4daedb07f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": \"value\"` + \"}\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [\"value1\", \"value2\"]}`,\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested\": \"value\"}}`,\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\" + `\"key\": {` + `\"value\": \"deep\"}` + \"}\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": {\"nested\": \"value\"}`,\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, test.depth)\n\t\tif (err != nil) != test.wantErr {\n\t\t\tt.Errorf(\"parseValue(%q, %d) error = %v, wantErr %v\", test.input, test.depth, err, test.wantErr)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil \u0026\u0026 test.expected != nil \u0026\u0026 *result != *test.expected {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = %v, expected %v\", test.input, test.depth, result, test.expected)\n\t\t}\n\t\tif tail != test.input[len(test.input):] {\n\t\t\tt.Errorf(\"parseValue(%q, %d) tail = %q, want %q\", test.input, test.depth, tail, test.input[len(test.input):])\n\t\t}\n\t}\n}","16723f2ffc32b29d413163cff8fbb420":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput     string\n\t\texpected  string\n\t\tremaining string\n\t\terr       bool\n\t}{\n\t\t{\"\\\"Hello, World!\\\"\", \"Hello, World!\", \"\", false},\n\t\t{\"\\\"Hello, \\\\\\\"World!\\\\\\\"\\\"\", \"Hello, \\\"World!\\\"\", \"\", false},\n\t\t{\"\\\"Hello, World!\\\" and more\", \"Hello, World!\", \" and more\", false},\n\t\t{\"\\\"Unescaped \\\\\\\"quote\\\"\", \"Unescaped \\\"quote\", \"\", true},\n\t\t{\"Missing closing quote\", \"\", \"\", true},\n\t\t{\"\\\"Escaped \\\\\\\\ quote\\\"\", \"Escaped \\\\ quote\", \"\", false},\n\t\t{\"\\\"Another\\\\\\\" escaped quote\\\\\\\" string\\\"\", \"Another\\\" escaped quote\\\"\", \"\", false},\n\t\t{\"\\\"A string with \\\" unescaped quotes\", \"\", \"\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawString(test.input)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q, but got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For input %q, expected %q, got %q\", test.input, test.expected, result)\n\t\t}\n\n\t\tif remaining != test.remaining {\n\t\t\tt.Errorf(\"For input %q, expected remaining %q, got %q\", test.input, test.remaining, remaining)\n\t\t}\n\t}\n}","1776fcb07dc4d492159b07148dfcd15c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"simple object access\",\n\t\t\tinput:    `{\"a\": 1, \"b\": {\"c\": 2}}`,\n\t\t\tkeys:     []string{\"b\", \"c\"},\n\t\t\texpected: // expected Value representing 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"array access\",\n\t\t\tinput:    `{\"a\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"a\", \"1\"},\n\t\t\texpected: // expected Value representing 2,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existent key\",\n\t\t\tinput:    `{\"a\": 1}`,\n\t\t\tkeys:     []string{\"b\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array index\",\n\t\t\tinput:    `{\"a\": [1, 2]}`,\n\t\t\tkeys:     []string{\"a\", \"5\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"nil value\",\n\t\t\tinput:    `null`,\n\t\t\tkeys:     []string{\"a\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type access\",\n\t\t\tinput:    `\"string\"`,\n\t\t\tkeys:     []string{\"a\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"decimal array index\",\n\t\t\tinput:    `{\"a\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"a\", \"2\"},\n\t\t\texpected: // expected Value representing 3,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Parse failed: %s\", err)\n\t\t\t}\n\t\t\tresult := v.Get(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","17b32a79b708d7306585f51b4a70cf38":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedString string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpectedString: \"hello\",\n\t\t\texpectedRemaining: \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\\\" string\" next`,\n\t\t\texpectedString: \"escaped \\\\ string\",\n\t\t\texpectedRemaining: \" next\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"some \"escaped\" string\" next`,\n\t\t\texpectedString: `some \"escaped\" string`,\n\t\t\texpectedRemaining: \" next\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpectedString: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"this is not \\\\\\\" escaped\" and more`,\n\t\t\texpectedString: `this is not \\\" escaped`,\n\t\t\texpectedRemaining: \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"just a string\"`,\n\t\t\texpectedString: \"just a string\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `no quotes at all`,\n\t\t\texpectedString: \"no quotes at all\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresultString, resultRemaining, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif resultString != test.expectedString {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expected %q\", test.input, resultString, test.expectedString)\n\t\t}\n\t\tif resultRemaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawString(%q) remaining = %q, expected %q\", test.input, resultRemaining, test.expectedRemaining)\n\t\t}\n\t}\n}","19b178d5d315f1ee4a910530c85798c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello \\\\n World\", \"Hello \\n World\"},\n\t\t{\"String with no escape sequences\", \"String with no escape sequences\"},\n\t\t{\"Escaped quotes: \\\\\\\"Hello\\\\\\\"!\", `Escaped quotes: \"Hello!\"`},\n\t\t{\"Backslash: \\\\\\\\\", `Backslash: \\`},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: ðŸ˜€\"},\n\t\t{\"Mixed \\\\n and escaped \\\\\\\" quotes\", \"Mixed \\n and escaped \\\" quotes\"},\n\t\t{\"Incomplete escape \\\\u\", \"Incomplete escape \\\\u\"},\n\t\t{\"Normal string\", \"Normal string\"},\n\t\t{\"Double backslash: \\\\\\\\\\\\\", \"Double backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","19b3a5701e18b77f98195cf754c31c57":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"valid string\" extra`,\n\t\t\texpectedValue: \"valid string\",\n\t\t\texpectedRest:  \" extra\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"string with \\\"escaped quotes\\\" inside\" remaining`,\n\t\t\texpectedValue: \"string with \\\"escaped quotes\\\" inside\",\n\t\t\texpectedRest:  \" remaining\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `missing closing quote`,\n\t\t\texpectedValue: \"missing closing quote\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped quotes\\\" testing\" remaining`,\n\t\t\texpectedValue: \"escaped quotes\\\" testing\",\n\t\t\texpectedRest:  \" remaining\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"another test with \\\\\"extra backslash\\\\\" and more\"`,\n\t\t\texpectedValue: \"another test with \\\\extra backslash\\\\ and more\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"` + `\"`, // Empty string\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tvalue, rest, err := parseRawString(tt.input)\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", tt.input, err, tt.expectedError)\n\t\t}\n\t\tif value != tt.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", tt.input, value, tt.expectedValue)\n\t\t}\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", tt.input, rest, tt.expectedRest)\n\t\t}\n\t}\n}","19cc1c015d27484dc43e312ff7b721be":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray_EmptyArray(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[]\"\n\texpected := 0\n\n\tv, remaining, err := parseArray(input, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif len(v.a) != expected {\n\t\tt.Fatalf(\"Expected array length %d, got %d\", expected, len(v.a))\n\t}\n\tif remaining != \"\" {\n\t\tt.Errorf(\"Expected remaining string to be empty, got %q\", remaining)\n\t}\n}\n\nfunc TestParseArray_SingleElement(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[1]\"\n\texpected := 1\n\n\tv, remaining, err := parseArray(input, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif len(v.a) != expected {\n\t\tt.Fatalf(\"Expected array length %d, got %d\", expected, len(v.a))\n\t}\n\tif remaining != \"\" {\n\t\tt.Errorf(\"Expected remaining string to be empty, got %q\", remaining)\n\t}\n}\n\nfunc TestParseArray_MultipleElements(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[1, 2, 3]\"\n\texpected := 3\n\n\tv, remaining, err := parseArray(input, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif len(v.a) != expected {\n\t\tt.Fatalf(\"Expected array length %d, got %d\", expected, len(v.a))\n\t}\n\tif remaining != \"\" {\n\t\tt.Errorf(\"Expected remaining string to be empty, got %q\", remaining)\n\t}\n}\n\nfunc TestParseArray_MissingComma(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[1 2]\"\n\t\n\t_, remaining, err := parseArray(input, c, 0)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\tif remaining != \" 2]\" {\n\t\tt.Errorf(\"Expected remaining string to be %q, got %q\", \" 2]\", remaining)\n\t}\n}\n\nfunc TestParseArray_UnexpectedEnd(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[1, 2\"\n\n\t_, remaining, err := parseArray(input, c, 0)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\tif remaining != \"\" {\n\t\tt.Errorf(\"Expected remaining string to be empty, got %q\", remaining)\n\t}\n}\n\nfunc TestParseArray_MissingClosingBracket(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[1, 2, 3\"\n\n\t_, remaining, err := parseArray(input, c, 0)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got nil\")\n\t}\n\tif remaining != \"\" {\n\t\tt.Errorf(\"Expected remaining string to be empty, got %q\", remaining)\n\t}\n}\n\nfunc TestParseArray_NestedArray(t *testing.T) {\n\tc := \u0026cache{}\n\tinput := \"[1, [2, 3], 4]\"\n\n\tv, remaining, err := parseArray(input, c, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif len(v.a) != 3 {\n\t\tt.Fatalf(\"Expected array length %d, got %d\", 3, len(v.a))\n\t}\n\tif remaining != \"\" {\n\t\tt.Errorf(\"Expected remaining string to be empty, got %q\", remaining)\n\t}\n}","1aa906ed44c98caf0327578912d5774d":"// unescape_string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"hello\"`, \"hello\"},\n\t\t{`\"line1\\nline2\"`, \"line1\\nline2\"},\n\t\t{`\"tab\\thello\"`, \"tab\\thello\"},\n\t\t{`\"backslash\\\\here\"`, \"backslash\\\\here\"},\n\t\t{`\"unicode\\\\u0041\"`, \"unicodeA\"},\n\t\t{`\"surrogate\\\\uD83D\\\\uDE00\"`, \"surrogateðŸ˜€\"}, // Valid surrogate pair\n\t\t{`\"invalid\\\\uD83D\"`, \"invalid\\\\uD83D\"},       // Incomplete surrogate\n\t\t{`\"escaped quotes: \\\\\"`, `escaped quotes: \\`},\n\t\t{`\"non-escaped string\"`, \"non-escaped string\"},\n\t\t{`\"complete sequence: \\u0042\"`, \"complete sequence: B\"},\n\t\t{`\"invalid unicode: \\uXYZ1\"`, \"invalid unicode: \\\\uXYZ1\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","1b0cb5367fdb39bc465b2887e82894b3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := test.input.String()\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"Type.String() for %v = %v; expected %v\", test.input, actual, test.expected)\n\t\t}\n\t}\n\n\t// Test panic for unknown type\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for unknown Value type\")\n\t\t\t}\n\t\t}()\n\t\tvar unknown Type = 999 // some value that is not defined\n\t\tunknown.String()\n\t}()\n}","1bca194f17562f1a6b2bfbc4f35dc226":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test initial capacity and first value retrieval\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Errorf(\"Expected non-nil value, got nil\")\n\t}\n\n\t// Test the length of the vs slice after first call\n\tif len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Test retrieval of second value\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Errorf(\"Expected non-nil value, got nil on second call\")\n\t}\n\n\t// Test length of vs slice after second call\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Ensure that the returned pointers are distinct for separate calls\n\tif val1 == val2 {\n\t\tt.Errorf(\"Expected different pointers for values returned by getValue\")\n\t}\n\n\t// Further tests could include checking the state of the Value returned,\n\t// or invoking getValue multiple times and ensuring the capacity grows as expected.\n}","1c00ead46802235ac5eed2c1d0ca0b65":"// file: getstringbytes_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\t// Sample JSON data for testing\n\tjsonData := `{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": {\n\t\t\t\"key3\": \"value2\"\n\t\t},\n\t\t\"array\": [\"item1\", \"item2\", \"item3\"],\n\t\t\"invalid\": null\n\t}`\n\n\t// Create a new Parser from the JSON data\n\tparser := \u0026Parser{}\n\tvalue, err := parser.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys       []string\n\t\texpectBytes []byte\n\t\texpectNil  bool\n\t}{\n\t\t{[]string{\"key1\"}, []byte(\"value1\"), false},\n\t\t{[]string{\"key2\", \"key3\"}, []byte(\"value2\"), false},\n\t\t{[]string{\"array\", \"1\"}, []byte(\"item2\"), false},\n\t\t{[]string{\"invalid\"}, nil, true}, // Expecting nil for invalid type\n\t\t{[]string{\"nonexistent\"}, nil, true}, // Non-existent key\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := value.GetStringBytes(test.keys...)\n\t\tif test.expectNil {\n\t\t\tif result != nil {\n\t\t\t\tt.Errorf(\"GetStringBytes(%v) = %v; want nil\", test.keys, result)\n\t\t\t}\n\t\t} else {\n\t\t\tif string(result) != string(test.expectBytes) {\n\t\t\t\tt.Errorf(\"GetStringBytes(%v) = %v; want %v\", test.keys, result, test.expectBytes)\n\t\t\t}\n\t\t}\n\t}\n}","1c610a9276eeb78e756f2c509ddd525f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello\\\\nWorld!\", \"Hello\\nWorld!\"},\n\t\t{\"Test\\\\tString\", \"Test\\tString\"},\n\t\t{\"Escaped quotes: \\\\\\\"Hello\\\\\\\"\", \"Escaped quotes: \\\"Hello\\\"\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: ðŸ˜€\"},\n\t\t{\"Mixed: \\\\nHello\\\\u0020World\\\\t\\\\!\", \"\\nHello World\\t!\"},\n\t\t{\"Empty: \", \"\"},\n\t\t{\"No escape: abcdef\", \"No escape: abcdef\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","1ce43c5fa81158f58acaadeba7b8f216":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %s but got %s\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for unknown Type\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic.\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 999 // Assuming 999 is an undefined/unknown type\n\t\t_ = unknownType.String()\n\t}()\n}","1d6102038107577e8f368fb5065b7559":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedNum   string\n\t\texpectedRest  string\n\t\texpectedError error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6 more data\", \"-123.45e+6\", \" more data\", nil},\n\t\t{\"0\", \"0\", \"\", nil},\n\t\t{\"inf more\", \"inf\", \" more\", nil},\n\t\t{\"-inf more\", \"-inf\", \" more\", nil},\n\t\t{\"+inf more\", \"+inf\", \" more\", nil},\n\t\t{\"nan more\", \"\", \"nan more\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\t\tif num != test.expectedNum || rest != test.expectedRest || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); want (%q, %q, %v)\", test.input, num, rest, err, test.expectedNum, test.expectedRest, test.expectedError)\n\t\t}\n\t}\n}","1dca8b16fd1f12843f54c38e028842d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\t// Create test cases\n\ttests := []struct {\n\t\tname       string\n\t\tinputValue *Value\n\t\tkeys       []string\n\t\texpected   uint\n\t}{\n\t\t{\n\t\t\tname:       \"Valid Uint Value\",\n\t\t\tinputValue: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\tkeys:       []string{},\n\t\t\texpected:   123,\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-existing key path\",\n\t\t\tinputValue: \u0026Value{s: \"456\", t: TypeNumber},\n\t\t\tkeys:       []string{\"nonexistent\"},\n\t\t\texpected:   0,\n\t\t},\n\t\t{\n\t\t\tname:       \"Invalid Value Type\",\n\t\t\tinputValue: \u0026Value{s: \"not_a_number\", t: TypeString},\n\t\t\tkeys:       []string{},\n\t\t\texpected:   0,\n\t\t},\n\t\t{\n\t\t\tname:       \"Nil Value\",\n\t\t\tinputValue: nil,\n\t\t\tkeys:       []string{},\n\t\t\texpected:   0,\n\t\t},\n\t\t{\n\t\t\tname:       \"Out of Range Uint\",\n\t\t\tinputValue: \u0026Value{s: \"18446744073709551616\", t: TypeNumber}, // larger than uint64\n\t\t\tkeys:       []string{},\n\t\t\texpected:   0,\n\t\t},\n\t}\n\n\t// Execute each test case\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.inputValue.GetUint(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"GetUint() = %v, expected %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","1ea4de15947de5848d3c8cf899c4801a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type(%d).String() = %q, expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test panic case for an unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\n\tvar invalidType Type = 99 // or any invalid number\n\tinvalidType.String()\n}","1ef5dafc5651aab64d7c67dcd23d202e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Create a sample JSON structure as a test case\n\ttests := []struct {\n\t\tjsonStr     string\n\t\tkeys        []string\n\t\texpected    *Value\n\t\tdescription string\n\t}{\n\t\t{\n\t\t\tjsonStr:     `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\tkeys:        []string{\"key1\"},\n\t\t\texpected:    \u0026Value{s: \"value1\", t: TypeString},\n\t\t\tdescription: \"Get value by a single key\",\n\t\t},\n\t\t{\n\t\t\tjsonStr:     `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\tkeys:        []string{\"key2\", \"0\"},\n\t\t\texpected:    \u0026Value{s: \"item1\", t: TypeString},\n\t\t\tdescription: \"Get array value by key and index\",\n\t\t},\n\t\t{\n\t\t\tjsonStr:     `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\tkeys:        []string{\"key2\", \"1\"},\n\t\t\texpected:    \u0026Value{s: \"item2\", t: TypeString},\n\t\t\tdescription: \"Get second item from array\",\n\t\t},\n\t\t{\n\t\t\tjsonStr:     `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\tkeys:        []string{\"nonExistingKey\"},\n\t\t\texpected:    nil,\n\t\t\tdescription: \"Get from a non-existing key\",\n\t\t},\n\t\t{\n\t\t\tjsonStr:     `{\"key1\": \"value1\", \"key2\": [\"item1\", \"item2\"]}`,\n\t\t\tkeys:        []string{\"key2\", \"2\"},\n\t\t\texpected:    nil,\n\t\t\tdescription: \"Get from an invalid array index\",\n\t\t},\n\t\t{\n\t\t\tjsonStr:     `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\tkeys:        []string{\"key2\", \"subkey\"},\n\t\t\texpected:    \u0026Value{s: \"subvalue\", t: TypeString},\n\t\t\tdescription: \"Get nested object value\",\n\t\t},\n\t\t{\n\t\t\tjsonStr:     `null`,\n\t\t\tkeys:        []string{\"anyKey\"},\n\t\t\texpected:    nil,\n\t\t\tdescription: \"Get value from null\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tparser := Parser{}\n\t\tv, err := parser.Parse(tt.jsonStr)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t}\n\t\t\n\t\tresult := v.Get(tt.keys...)\n\t\tif !compareValues(result, tt.expected) {\n\t\t\tt.Errorf(\"Test '%s' failed: expected %v, got %v\", tt.description, tt.expected, result)\n\t\t}\n\t}\n}\n\n// compareValues compares two *Value types for test assertions.\nfunc compareValues(a, b *Value) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.s == b.s \u0026\u0026 a.t == b.t\n}","2013af45e79fe47fbf01b0eaa4ee45fa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t// Valid JSON arrays\n\t\t{\"[1, 2, 3]\", []*Value{\n\t\t\t{t: TypeNumber, a: nil, s: \"1\"},\n\t\t\t{t: TypeNumber, a: nil, s: \"2\"},\n\t\t\t{t: TypeNumber, a: nil, s: \"3\"},\n\t\t}, false},\n\t\t{\"[]\", []*Value{}, false},\n\n\t\t// Arrays with nested arrays\n\t\t{\"[1, [2, 3], 4]\", []*Value{\n\t\t\t{t: TypeNumber, a: nil, s: \"1\"},\n\t\t\t{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, a: nil, s: \"2\"},\n\t\t\t\t{t: TypeNumber, a: nil, s: \"3\"},\n\t\t\t}},\n\t\t\t{t: TypeNumber, a: nil, s: \"4\"},\n\t\t}, false},\n\n\t\t// Errors\n\t\t{\"[1, 2, , 4]\", nil, true}, // Extra comma\n\t\t{\"[1, 2, 3\", nil, true},    // Missing closing bracket\n\t\t{\"[1, 2, 3,, 5]\", nil, true}, // Extra comma\n\t\t{\"[1 2 3]\", nil, true},     // Missing commas\n\t}\n\n\tfor _, test := range tests {\n\t\tvar c cache\n\t\tresult, remainder, err := parseArray(test.input, \u0026c, 0)\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %s, but got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %s: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"for input %s, expected %d values, got %d\", test.input, len(test.expected), len(result.a))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, exp := range test.expected {\n\t\t\tif result.a[i].s != exp.s {\n\t\t\t\tt.Errorf(\"for input %s, expected value %s at index %d, got %s\", test.input, exp.s, i, result.a[i].s)\n\t\t\t}\n\t\t}\n\n\t\tif remainder != \"\" {\n\t\t\tt.Errorf(\"for input %s, expected remainder to be empty, got %s\", test.input, remainder)\n\t\t}\n\t}\n}","20b5c1c1a4dfaafd124f9ff342248bef":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"1234.56abc\", \"1234.56\", \"abc\", nil},\n\t\t{\"-123.45e6 more text\", \"-123.45e6\", \" more text\", nil},\n\t\t{\"0.0\", \"0.0\", \"\", nil},\n\t\t{\"inf this is infinity\", \"inf\", \" this is infinity\", nil},\n\t\t{\"NaN something\", \"NaN\", \" something\", nil},\n\t\t{\"not_a_number\", \"\", \"not_a_number\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"\", \"\", \"\", nil}, // since the caller must ensure len(s) \u003e 0, this should be tested outside this context\n\t\t{\"123a456\", \"123\", \"a456\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot, remaining, err := parseRawNumber(test.input)\n\t\tif got != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\", test.input, got, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","20bdc202f514624e2445ff26eb23a8bf":"// unescapeKeys_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tinput          Object\n\t\texpectedKeys   []string\n\t\texpectedUnescaped bool\n\t}{\n\t\t{\n\t\t\tname: \"simple escape\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"some\\\\key\", v: nil},\n\t\t\t\t\t{k: \"another\\\\key\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedKeys:     []string{\"some/key\", \"another/key\"},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t\t{\n\t\t\tname: \"already unescaped\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"alreadyUnescapedKey\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\texpectedKeys:     []string{\"alreadyUnescapedKey\"},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t\t{\n\t\t\tname: \"no escape\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"noEscapeKey\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedKeys:     []string{\"noEscapeKey\"},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty key\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedKeys:     []string{\"\"},\n\t\t\texpectedUnescaped: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.input.unescapeKeys()\n\n\t\t\tfor i, expected := range tt.expectedKeys {\n\t\t\t\tif tt.input.kvs[i].k != expected {\n\t\t\t\t\tt.Errorf(\"expected key %q, got %q\", expected, tt.input.kvs[i].k)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tt.input.keysUnescaped != tt.expectedUnescaped {\n\t\t\t\tt.Errorf(\"expected keysUnescaped to be %v, got %v\", tt.expectedUnescaped, tt.input.keysUnescaped)\n\t\t\t}\n\t\t})\n\t}\n}","20c0b47d55f6f1274b8c35f08b22d4a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedValue string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput: ` \"hello world\" ,`,\n\t\t\texpectedValue: \"hello world\",\n\t\t\texpectedRemaining: \" ,\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"escaped \\\\\"`,\n\t\t\texpectedValue: \"escaped \\\\\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"escaped \" sequence\"`,\n\t\t\texpectedValue: \"escaped \",\n\t\t\texpectedRemaining: \" sequence\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"not closed`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: `\"string with \\\"escaped quote\\\"\"`,\n\t\t\texpectedValue: \"string with \\\"escaped quote\\\"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"example with \\\\\"`,\n\t\t\texpectedValue: \"example with \\\\\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remaining, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%v) = unexpected error status: %v\", test.input, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%v) = expected value %v, got %v\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawString(%v) = expected remaining %v, got %v\", test.input, test.expectedRemaining, remaining)\n\t\t}\n\t}\n}","20c410e6014f42776532d2abe3f935ad":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedOutput string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpectedOutput: \"hello\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello world\"`,\n\t\t\texpectedOutput: \"hello world\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"foo \\\"bar\\\" baz\"`,\n\t\t\texpectedOutput: \"foo \\\"bar\\\" baz\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `not a quoted string`,\n\t\t\texpectedOutput: \"not a quoted string\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped quote \\\\\"hello\\\\\" there\"`,\n\t\t\texpectedOutput: \"escaped quote \\\\\",\n\t\t\texpectedRemaining: `\"hello\\\\\" there\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput, remaining, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"Expected error: %v; got: %v\", test.expectedError, err)\n\t\t}\n\t\tif output != test.expectedOutput {\n\t\t\tt.Errorf(\"For input '%s', expected output: '%s', got: '%s'\", test.input, test.expectedOutput, output)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"For input '%s', expected remaining: '%s', got: '%s'\", test.input, test.expectedRemaining, remaining)\n\t\t}\n\t}\n}","20f4fca86896e8b2a8b5f24aff6e129d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`,\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tTest\"`,\n\t\t\texpected: \"Tab\\tTest\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u00A9\"`,\n\t\t\texpected: \"Unicode: Â©\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid Unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unescaped / and \\\\\"`,\n\t\t\texpected: \"Unescaped / and \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escape sequences\"`,\n\t\t\texpected: \"No escape sequences\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped quote: \\\"\"`,\n\t\t\texpected: \"Escaped quote: \\\"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2100dd028b870c5605e39b71dc4b7a32":"// file: parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedTail   string\n\t\texpectedError  error\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\\\"string\\\"\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nan\",\n\t\t\texpectedValue: /* populate expected Value for NaN */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\":}\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: fmt.Errorf(\"cannot parse object: %s\", /* error message */),\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2,]\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: fmt.Errorf(\"cannot parse array: %s\", /* error message */),\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": 123}\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\",\n\t\t\texpectedValue: /* populate expected Value */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgotValue, gotTail, gotErr := parseValue(tt.input, c, 0)\n\n\t\t\tif gotErr != nil \u0026\u0026 tt.expectedError != nil {\n\t\t\t\tif gotErr.Error() != tt.expectedError.Error() {\n\t\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, gotErr, tt.expectedError)\n\t\t\t\t}\n\t\t\t} else if gotErr != tt.expectedError {\n\t\t\t\tt.Errorf(\"parseValue(%q) error = %v, want %v\", tt.input, gotErr, tt.expectedError)\n\t\t\t}\n\n\t\t\tif gotTail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want %q\", tt.input, gotTail, tt.expectedTail)\n\t\t\t}\n\n\t\t\t// Additional assertion of Value struct can be added here as needed\n\t\t\t// if !reflect.DeepEqual(gotValue, tt.expectedValue) {\n\t\t\t//     t.Errorf(\"parseValue(%q) gotValue = %v, want %v\", tt.input, gotValue, tt.expectedValue)\n\t\t\t// }\n\t\t})\n\t}\n}","21563450aa831ddb46cebdbf589fe705":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected %q, got %q for Type %d\", test.expected, result, test.input)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 999 // An arbitrary value that shouldn't be valid\n\tunknownType.String()\n}","219d017f87ef89c0155d62b9adcf69a1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: // Define the expected value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2,}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: // Define the expected empty object value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: // Define the nested expected value\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key1\": \"value1\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) returned error: %v, expected error: %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != nil \u0026\u0026 !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) returned %v, expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","21c8b9ab6e61b74c9c277e147ee024f4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"{}\",\n\t\t\texpectedValue:  \u0026Value{t: TypeObject},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\"}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 42}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\"}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpectedValue:  \u0026Value{t: TypeObject},\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\",}}`,\n\t\t\texpectedValue:  nil,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"input: %s, expected error status %v, got %v\", test.input, test.expectedError, err)\n\t\t}\n\n\t\tif !test.expectedError \u0026\u0026 !equalValues(value, test.expectedValue) {\n\t\t\tt.Errorf(\"input: %s, expected value %+v, got %+v\", test.input, test.expectedValue, value)\n\t\t}\n\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"input: %s, expected remaining string to be '%s', got '%s'\", test.input, test.expectedRemain, remain)\n\t\t}\n\t}\n}\n\n// Helper function to compare Values\nfunc equalValues(a, b *Value) bool {\n\t// This would need to be implemented according to the actual structure of Value.\n\t// You could compare the types and contents of the values if necessary.\n\treturn (a == nil \u0026\u0026 b == nil) || (a != nil \u0026\u0026 b != nil \u0026\u0026 a.t == b.t) // Simplified comparison\n}","21fe26a1eb0ca3f4d414e14beec4b95b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: []byte(\"123\")},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: []byte(\"1\")},\n\t\t\t\t\t{t: TypeNumber, s: []byte(\"2\")},\n\t\t\t\t\t{t: TypeNumber, s: []byte(\"3\")},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: []byte(\"100\")}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":100}\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := test.value.MarshalTo(nil)\n\t\tgot := string(dst)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"MarshalTo(%v) = %s; want %s\", test.value, got, test.expected)\n\t\t}\n\t}\n}","240bda3681d592206cdcef8ff7978b96":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected map[string]interface{}\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: map[string]interface{}{},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\"}`,\n\t\t\texpected: map[string]interface{}{\"key1\": \"value1\"},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":42}`,\n\t\t\texpected: map[string]interface{}{\"key1\": \"value1\", \"key2\": 42},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":true}`,\n\t\t\texpected: map[string]interface{}{\"key1\": true},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":null}`,\n\t\t\texpected: map[string]interface{}{\"key1\": nil},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\",}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 42,}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{key1:value1}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tresult, _, err := parseObject(tt.input, c, depth)\n\n\t\t\tif (err != nil) != tt.hasError {\n\t\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tt.input, err, tt.hasError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\tobj, _ := result.Object()\n\t\t\t\tfor _, kv := range obj.kvs {\n\t\t\t\t\tif val, ok := tt.expected[kv.k]; !ok || kv.v.String() != toString(val) {\n\t\t\t\t\t\tt.Errorf(\"Unexpected value for key %q: got %v, want %v\", kv.k, kv.v.String(), val)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc toString(value interface{}) string {\n\tswitch v := value.(type) {\n\tcase string:\n\t\treturn v\n\tcase int:\n\t\treturn fmt.Sprintf(\"%d\", v)\n\tcase bool:\n\t\treturn fmt.Sprintf(\"%t\", v)\n\tdefault:\n\t\tif value == nil {\n\t\t\treturn \"null\"\n\t\t}\n\t\treturn \"\"\n\t}\n}","2442be74b57fe2079b5eff0a2bc0c33a":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedTail   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\\\"Hello, world!\\\"\",\n\t\t\texpectedValue: \u0026Value{t: typeRawString, s: \"Hello, world!\"},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: \u0026Value{t: TypeArray},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpectedValue: \u0026Value{t: TypeObject},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"100\",\n\t\t\texpectedValue: \u0026Value{t: TypeNumber, s: \"100\"},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nonsense\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"nonsense\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpectedValue: \u0026Value{t: TypeObject},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": {\\\"nested\\\": true}}\",\n\t\t\texpectedValue: \u0026Value{t: TypeObject},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t// Test for max depth exceeded\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": {\\\"nested\\\": {\\\"moreNested\\\": {\\\"deep\\\": true}}}}\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true, // Expect error due to exceeding max depth.\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t}\n\n\t\t\tif v != nil \u0026\u0026 !compareValues(v, tt.expectedValue) {\n\t\t\t\tt.Errorf(\"expected value: %#v, got: %#v\", tt.expectedValue, v)\n\t\t\t}\n\n\t\t\tif tail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail: %q, got: %q\", tt.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues is a placeholder function to compare expected and actual Value.\n// Define this function properly based on your Value structure equality.\nfunc compareValues(a, b *Value) bool {\n\t// Implement detail comparison for comparing Value types and their content.\n\treturn false // This should properly compare Value instances.\n}","2450389b1bc6ad67b7ef7b1235a62386":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedNext   string\n\t\texpectedErr    bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedNext:  \" world\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" rest`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedNext:  \" rest\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `noquotes`,\n\t\t\texpectedValue: \"noquotes\",\n\t\t\texpectedNext:  \"\",\n\t\t\texpectedErr:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unclosed`,\n\t\t\texpectedValue: \"unclosed\",\n\t\t\texpectedNext:  \"\",\n\t\t\texpectedErr:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped quote: \\\\\"`,\n\t\t\texpectedValue: \"escaped quote: \\\\\",\n\t\t\texpectedNext:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"complex \\\\\"string\\\\\" example\" still more`,\n\t\t\texpectedValue: \"complex \\\\\\\"string\\\\\\\" example\",\n\t\t\texpectedNext:  \" still more\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, next, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr = %v\", test.input, err, test.expectedErr)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif next != test.expectedNext {\n\t\t\tt.Errorf(\"parseRawString(%q) next = %q, expectedNext = %q\", test.input, next, test.expectedNext)\n\t\t}\n\t}\n}","2476caea5205f813f94d185bcf37165b":"// file: value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint64(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected uint64\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint64\",\n\t\t\tjson:     `{\"key\": 1234567890123456789}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 1234567890123456789,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"key\": 1234567890123456789}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"key\": \"string_value\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (object)\",\n\t\t\tjson:     `{\"key\": {}}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"complex path\",\n\t\t\tjson:     `{\"parent\": {\"child\": 9876543210123456789}}`,\n\t\t\tkeys:     []string{\"parent\", \"child\"},\n\t\t\texpected: 9876543210123456789,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `[{\"key\": 123}, {\"key\": 456}]`,\n\t\t\tkeys:     []string{\"1\", \"key\"},\n\t\t\texpected: 456,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index out of range\",\n\t\t\tjson:     `[{\"key\": 123}]`,\n\t\t\tkeys:     []string{\"2\", \"key\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := \u0026Parser{}\n\t\t\tv, err := parser.Parse(tt.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetUint64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","24aa5034a511785e1541e0d1a6b12b78":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUint(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected uint\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid uint\",\n\t\t\tvalue:    \u0026Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: 42,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid uint zero\",\n\t\t\tvalue:    \u0026Value{s: \"0\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid uint large value\",\n\t\t\tvalue:    \u0026Value{s: \"1234567890\", t: TypeNumber},\n\t\t\texpected: 1234567890,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tvalue:    \u0026Value{s: \"\\\"not a number\\\"\", t: TypeString},\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (boolean)\",\n\t\t\tvalue:    \u0026Value{s: \"true\", t: TypeTrue},\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"value too large for uint\",\n\t\t\tvalue:    \u0026Value{s: \"18446744073709551615\", t: TypeNumber}, // larger than uint\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid number format\",\n\t\t\tvalue:    \u0026Value{s: \"42abc\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.value.Uint()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Uint() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Uint() = %v, expected %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","24e116bdb8eb228efbb3cb4d39692562":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue *Value\n\t\texpectedTail  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\\\"Hello, World!\\\"\",\n\t\t\texpectedValue: \u0026Value{s: \"Hello, World!\", t: typeRawString},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1,2,3]\",\n\t\t\texpectedValue: nil, // Expected value should be set according to parse logic\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpectedValue: nil, // Expected value should be set according to parse logic\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"123.45\",\n\t\t\texpectedValue: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nan\",\n\t\t\texpectedValue: nil, // Expected value should be set according to parse logic\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"not-a-number\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"not-a-number\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"Input: %q, Expected error: %v, Got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"Input: %q, Expected value: %+v, Got: %+v\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif tail != test.expectedTail {\n\t\t\tt.Errorf(\"Input: %q, Expected tail: %q, Got: %q\", test.input, test.expectedTail, tail)\n\t\t}\n\t}\n}","24f6ab7fa227301c86006c63fd2bf228":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Create test cases for the Get function\n\ttests := []struct {\n\t\tname   string\n\t\tinput  *Value\n\t\tkeys   []string\n\t\toutput *Value\n\t}{\n\t\t{\n\t\t\tname:   \"existing key\",\n\t\t\tinput:  /* initialize a valid Value containing a key */,\n\t\t\tkeys:   []string{\"key1\"},\n\t\t\toutput: /* expected Value for the key1 */,\n\t\t},\n\t\t{\n\t\t\tname:   \"non-existing key\",\n\t\t\tinput:  /* initialize a valid Value */,\n\t\t\tkeys:   []string{\"nonExistingKey\"},\n\t\t\toutput: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index existing\",\n\t\t\tinput:  /* initialize a Value representing an array */,\n\t\t\tkeys:   []string{\"0\"},\n\t\t\toutput: /* expected Value at index 0 */,\n\t\t},\n\t\t{\n\t\t\tname:   \"array index out of bounds\",\n\t\t\tinput:  /* initialize a Value representing an array */,\n\t\t\tkeys:   []string{\"10\"}, // Assuming the array has fewer than 11 elements\n\t\t\toutput: nil,\n\t\t},\n\t\t{\n\t\t\tname:   \"nested keys\",\n\t\t\tinput:  /* initialize a nested Value */,\n\t\t\tkeys:   []string{\"level1\", \"level2\"},\n\t\t\toutput: /* expected Value at nested path */,\n\t\t},\n\t\t{\n\t\t\tname:   \"using decimal key index\",\n\t\t\tinput:  /* initialize a Value representing a nested array */,\n\t\t\tkeys:   []string{\"level\", \"0\", \"key\"},\n\t\t\toutput: /* expected Value for the path */,\n\t\t},\n\t\t{\n\t\t\tname:   \"nil value\",\n\t\t\tinput:  nil,\n\t\t\tkeys:   []string{\"key\"},\n\t\t\toutput: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.Get(tt.keys...)\n\t\t\tif result != tt.output {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.output, result)\n\t\t\t}\n\t\t})\n\t}\n}","2571a7638b76ad2d74e4411f384573ac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\tparser := \u0026Parser{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedType  Type\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedType:  TypeObject,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `[1, 2, 3]`,\n\t\t\texpectedType:  TypeArray,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"string\"`,\n\t\t\texpectedType:  TypeString,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `12345`,\n\t\t\texpectedType:  TypeNumber,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `true`,\n\t\t\texpectedType:  TypeTrue,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `false`,\n\t\t\texpectedType:  TypeFalse,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `null`,\n\t\t\texpectedType:  TypeNull,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{invalid}`,\n\t\t\texpectedType:  TypeNull,\n\t\t\texpectError:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tv, err := parser.Parse(tt.input)\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\n\t\t\tif !tt.expectError \u0026\u0026 v.Type() != tt.expectedType {\n\t\t\t\tt.Errorf(\"expected type: %v, got: %v\", tt.expectedType, v.Type())\n\t\t\t}\n\t\t})\n\t}\n}","2598149e38f0e0fe920438f700e84475":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      string\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":2}`,\n\t\t\texpected: // expected value structure,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":2,}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\texpected: nil,\n\t\t\terr:      \"cannot parse object value: unexpected end of object\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: // expected empty object structure,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: // expected object structure with array,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: // expected valid single key-value object,\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ':' after object key\",\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != (test.err != \"\") {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr = %v\", test.input, err, test.err != \"\")\n\t\t\tcontinue\n\t\t}\n\t\tif test.err != \"\" \u0026\u0026 err != nil \u0026\u0026 err.Error() != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr = %v\", test.input, err, test.err)\n\t\t}\n\n\t\t// You would typically need to check for expected result here\n\t\tif result != nil \u0026\u0026 !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want = %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n}","25f24fcc36cc60aec68c7ede89d509c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"-456.78xyz\", \"-456.78\", \"xyz\", false},\n\t\t{\"789e10more\", \"789e10\", \"more\", false},\n\t\t{\"0.123e-5more\", \"0.123e-5\", \"more\", false},\n\t\t{\"infabc\", \"inf\", \"abc\", false},\n\t\t{\"NaNxyz\", \"NaN\", \"xyz\", false},\n\t\t{\"+3.14extra\", \"+3.14\", \"extra\", false},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-infsomething\", \"-inf\", \"something\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput, rest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = error: %v, want error: %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif output != test.expectedOutput {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = output: %q, want: %q\", test.input, output, test.expectedOutput)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = rest: %q, want: %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","2611c8b38fe13525416c8e88ca98ba23":"package fastjson\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                         // empty string\n\t\t{\"   \", \"   \"},                  // only whitespace\n\t\t{\"abc\", \"abc\"},                  // no leading whitespace\n\t\t{\"   abc\", \"abc\"},               // leading whitespace\n\t\t{\"\\t\\n abc\", \"abc\"},             // leading tabs and newlines\n\t\t{\"\\n\\n   abc\", \"abc\"},           // multiple newlines and spaces\n\t\t{\"   a b c\", \"a b c\"},           // mixed whitespace in front\n\t\t{\"no leading space\", \"no leading space\"}, // no leading whitespace again\n\t\t{\"\\x00abc\", \"abc\"},              // control character\n\t\t{\"    \", \"\"},                    // whitespace only should hit skipWSSlow\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(strings.ReplaceAll(tt.input, \" \", \"_\"), func(t *testing.T) {\n\t\t\tresult := skipWS(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"skipWS(%q) = %q; want %q\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","26212585ff2cf80f2aa004def4351ae6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput  Type\n\t\toutput string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.output {\n\t\t\tt.Errorf(\"expected %q, got %q for input %v\", test.output, result, test.input)\n\t\t}\n\t}\n\n\t// Test for an unknown type to trigger panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type, got no panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 100 // This value is not defined in the Type constants\n\tunknownType.String()\n}","264992c214c752cc47b58bbf20058423":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tvar c cache\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{}, // Set expected value based on your logic\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil, // Expecting an error, so nil here\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil, // Expecting an error for trailing comma\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{}, // Expect an empty object\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": 123, \"key2\": true}`,\n\t\t\texpected: \u0026Value{}, // Set expected value based on your logic\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{}, // Set expected value based on your logic\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseObject(test.input, \u0026c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) returned error: %v, expected error: %v\", test.input, err, test.err)\n\t\t}\n\t\tif err == nil {\n\t\t\t// Here, you might want to perform checks on `result` to see if it matches `test.expected`\n\t\t\t// This is left abstract because the expected value structure depends on your implementation.\n\t\t}\n\t}\n}","26e7b14d9c8c2b77c7f3fa7a3edd517c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\t// Create a new cache instance\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\terrorMsg string\n\t}{\n\t\t// Test cases for empty string\n\t\t{\"\", 0, nil, \"cannot parse empty string\"},\n\n\t\t// Test cases for exceeding MaxDepth\n\t\t{\"{}\", MaxDepth, nil, \"too big depth for the nested JSON; it exceeds 100\"},\n\n\t\t// Test cases for valid JSON objects\n\t\t{\"{}\", 0, \u0026Value{o: Object{}}, \"\"},\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", 0, \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\"}}}}}, \"\"},\n\n\t\t// Test cases for valid JSON arrays\n\t\t{\"[]\", 0, \u0026Value{a: []*Value{}}, \"\"},\n\t\t{\"[1, 2, 3]\", 0, \u0026Value{a: []*Value{{s: \"1\"}, {s: \"2\"}, {s: \"3\"}}}, \"\"},\n\n\t\t// Test cases for strings\n\t\t{\"\\\"hello\\\"\", 0, \u0026Value{s: \"hello\"}, \"\"},\n\t\t{\"\\\"\\\\\\\"escaped\\\\\\\"\\\"\", 0, \u0026Value{s: \"\\\"escaped\\\"\"}, \"\"},\n\n\t\t// Test cases for boolean values\n\t\t{\"true\", 0, valueTrue, \"\"},\n\t\t{\"false\", 0, valueFalse, \"\"},\n\n\t\t// Test cases for null\n\t\t{\"null\", 0, valueNull, \"\"},\n\n\t\t// Test cases for numbers\n\t\t{\"123\", 0, \u0026Value{s: \"123\"}, \"\"},\n\t\t{\"-123.456\", 0, \u0026Value{s: \"-123.456\"}, \"\"},\n\t\t{\"3.14e10\", 0, \u0026Value{s: \"3.14e10\"}, \"\"},\n\t\t\n\t\t// Test cases for invalid JSON\n\t\t{\"{\", 0, nil, \"unexpected end of JSON\"},\n\t\t{\"[\", 0, nil, \"unexpected end of JSON\"},\n\t\t{\"{key: value}\", 0, nil, \"unexpected value found: \\\"key: value\\\"\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(tt.input, c, tt.depth)\n\t\t\t\n\t\t\tif err != nil {\n\t\t\t\tif err.Error() != tt.errorMsg {\n\t\t\t\t\tt.Errorf(\"expected error message: %s, got: %s\", tt.errorMsg, err.Error())\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} \n\n\t\t\tif err == nil \u0026\u0026 tt.expected == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","272c0c6a1e68be2b97a6035d445c2919":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, \\nWorld!\"`,\n\t\t\texpected: \"Hello, \\nWorld!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab: \\tCharacter\"`,\n\t\t\texpected: \"Tab: \\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Quote: \\\"\"`,\n\t\t\texpected: \"Quote: \\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Funny characters: \\u263A\"`,\n\t\t\texpected: \"Funny characters: â˜º\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unescaped string with no backslashes\"`,\n\t\t\texpected: \"Unescaped string with no backslashes\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\b\\f\\n\\r\\t\"`,\n\t\t\texpected: \"\\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed: \\u0041\\u0042\\\\\\u0043\"`,\n\t\t\texpected: \"Mixed: ABC\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","27cd5aa55d8e553f006c9edbd010abf8":"// hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normal\", false},                          // no special chars\n\t\t{\"string with space\", false},               // no special chars\n\t\t{\"string with newline\\n\", true},            // contains special char: newline\n\t\t{\"string with tab\\t\", true},                // contains special char: tab\n\t\t{\"contains null byte\\x00\", true},          // contains special char: null byte\n\t\t{\"quotes \\\"inside\\\"\", true},                // contains special char: double quote\n\t\t{\"backslash \\\\ here\", true},                // contains special char: backslash\n\t\t{\"valid \u0026 character\", false},               // no special chars\n\t\t{\"\", false},                                 // empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2806f695f214a4e8dff15db27c43a129":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\tdepth := 0\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":42}`,\n\t\t\texpected: \u0026Value{ // Specify what the expected Value should be\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\"}`,\n\t\t\texpected: nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: \u0026Value{ // Specify what the expected Value should be\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": 123, \"key2\": true, \"key3\": null}`,\n\t\t\texpected: \u0026Value{ // Specify what the expected Value should be\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"123\", t: TypeNumber}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"true\", t: TypeTrue}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{s: \"null\", t: TypeNull}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseObject(test.input, c, depth)\n\t\t\n\t\tif (err != nil) != test.expectErr {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, expectErr %v\", test.input, err, test.expectErr)\n\t\t}\n\t\tif !test.expectErr \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare two Value instances\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic for Value, considering the structure and types.\n\t// This function needs to check whether both values are equal based on\n\t// your specific requirements.\n\treturn false\n}","297412639b832349e7f5ce6fcb4c4db4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" rest`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" rest\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: `no quotes here`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\" quote\" remaining`,\n\t\t\texpectedValue: `escaped \" quote`,\n\t\t\texpectedRest:  \" remaining\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"incomplete string`,\n\t\t\texpectedValue: `incomplete string`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"for input %q, expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"for input %q, expected value: %q, got: %q\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"for input %q, expected rest: %q, got: %q\", test.input, test.expectedRest, rest)\n\t\t}\n\t}\n}","297a10288aca5d542180707ce840f7cb":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                                          // empty string\n\t\t{\"   some text\", \"some text\"},                   // leading spaces\n\t\t{\"\\n\\n\\nline\", \"line\"},                          // leading newlines\n\t\t{\"\\t\\t\\tTabbed\", \"Tabbed\"},                      // leading tabs\n\t\t{\"\\r\\r\\rcarriage return\", \"carriage return\"},    // leading carriage returns\n\t\t{\"\\n  \\t    mixed whitespace\", \"mixed whitespace\"}, // mixed leading whitespace\n\t\t{\"     \", \"\"},                                   // only whitespace\n\t\t{\"another\\nexample\\n\", \"another\\nexample\\n\"},   // text with trailing newlines\n\t\t{\"  multiple \\t \\nspaces\", \"multiple \\t \\nspaces\"}, // mixed whitespace\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2ac68ec39b10b3df95bc31cb624004c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{} // Create a new cache instance\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value // Expected array of parsed values\n\t\terr      bool     // Expect an error?\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, a: nil, s: \"1\"}, \u0026Value{t: TypeNumber, a: nil, s: \"2\"}, \u0026Value{t: TypeNumber, a: nil, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"one\\\", \\\"two\\\", \\\"three\\\"]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeString, a: nil, s: \"one\"}, \u0026Value{t: TypeString, a: nil, s: \"two\"}, \u0026Value{t: TypeString, a: nil, s: \"three\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeTrue, a: nil, s: \"\"}, \u0026Value{t: TypeFalse, a: nil, s: \"\"}, \u0026Value{t: TypeNull, a: nil, s: \"\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect an error due to trailing comma\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect an error due to empty value\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect an error due to missing closing bracket\n\t\t},\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\t// Check if we expected an error\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Verify the result\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"unexpected number of elements in result for input %q: got %d, want %d\", test.input, len(result.a), len(test.expected))\n\t\t\tcontinue\n\t\t}\n\n\t\t// Compare individual values (you can expand this based on Value structure)\n\t\tfor i, expectedValue := range test.expected {\n\t\t\tif result.a[i].t != expectedValue.t || result.a[i].s != expectedValue.s {\n\t\t\t\tt.Errorf(\"unexpected value at index %d for input %q: got %+v, want %+v\", i, test.input, result.a[i], expectedValue)\n\t\t\t}\n\t\t}\n\t}\n}","2ad93eb098464d4bf66381bf823da026":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname:     \"get existing key from object\",\n\t\t\tjson:     `{\"name\":\"John\"}`,\n\t\t\tkeys:     []string{\"name\"},\n\t\t\texpected: NewValue().SetString(\"John\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"get existing index from array\",\n\t\t\tjson:     `[{\"name\":\"John\"},{\"name\":\"Doe\"}]`,\n\t\t\tkeys:     []string{\"0\", \"name\"},\n\t\t\texpected: NewValue().SetString(\"John\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"get non-existing key\",\n\t\t\tjson:     `{\"name\":\"John\"}`,\n\t\t\tkeys:     []string{\"age\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"get non-existing index from array\",\n\t\t\tjson:     `[\"apple\", \"banana\"]`,\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"get invalid path\",\n\t\t\tjson:     `{\"name\":\"John\"}`,\n\t\t\tkeys:     []string{\"name\", \"first\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"get from nested objects\",\n\t\t\tjson:     `{\"user\":{\"name\":\"John\"}}`,\n\t\t\tkeys:     []string{\"user\", \"name\"},\n\t\t\texpected: NewValue().SetString(\"John\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"get from a nested array\",\n\t\t\tjson:     `[{\"user\":{\"name\":\"John\"}},{\"user\":{\"name\":\"Doe\"}}]`,\n\t\t\tkeys:     []string{\"0\", \"user\", \"name\"},\n\t\t\texpected: NewValue().SetString(\"John\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := Parse(tt.json)\n\t\t\tresult := v.Get(tt.keys...)\n\n\t\t\tif (result == nil) != (tt.expected == nil) {\n\t\t\t\tt.Fatalf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif result != nil \u0026\u0026 result.String() != tt.expected.String() {\n\t\t\t\tt.Fatalf(\"expected %s, got %s\", tt.expected.String(), result.String())\n\t\t\t}\n\t\t})\n\t}\n}","2ae0ecdcd56d387cccfbe4e2f5863e58":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"simple string\", \"simple string\"},\n\t\t{\"string with \\\\n newline\", \"string with \\n newline\"},\n\t\t{\"string with \\\\t tab\", \"string with \\t tab\"},\n\t\t{\"string with \\\\\\\" quote\", \"string with \\\" quote\"},\n\t\t{\"string with \\\\\\\\ backslash\", \"string with \\\\ backslash\"},\n\t\t{\"string with \\\\/ forward slash\", \"string with / forward slash\"},\n\t\t{\"string with \\\\u0020 unicode\", \"string with   unicode\"}, // space\n\t\t{\"string with \\\\uD83D\\\\uDE03 smiley\", \"string with ðŸ˜€ smiley\"},\n\t\t{\"invalid \\\\u escape\", \"invalid \\\\u escape\"},\n\t\t{\"string with unknown \\\\x character\", \"string with unknown \\\\x character\"},\n\t\t{\"trailing backslash\\\\\", \"trailing backslash\\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2cb611f73ab55538a6a679daf9e960b9":"// unescape_string_best_effort_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"plain string\", \"plain string\"},\n\t\t{\"escaped \\\\n new line\", \"escaped \\n new line\"},\n\t\t{\"double quotes: \\\"\", \"double quotes: \\\"\"},\n\t\t{\"backslash: \\\\\\\\\", \"backslash: \\\\\"},\n\t\t{\"mixed: \\\\\\\" JSON string with new line \\\\n and tab \\\\t\", \"mixed: \\\" JSON string with new line \\n and tab \\t\"},\n\t\t{\"invalid unicode: \\\\uXYZ\", \"invalid unicode: \\\\uXYZ\"},\n\t\t{\"valid unicode: \\\\u0041\", \"valid unicode: A\"},\n\t\t{\"surrogates: \\\\uD800\\\\uDC00\", \"surrogates: ð°€\"}, // represents a surrogate pair\n\t\t{\"escaped unicode \\\\uD800\", \"escaped unicode \\\\uD800\"},\n\t\t{\"no escape\", \"no escape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2cbc97769b8869a07f477d36c29e51d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\texpectedTail string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"true\",\n\t\t\texpected:    valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"false\",\n\t\t\texpected:    valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"null\",\n\t\t\texpected:    valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"string\"`,\n\t\t\texpected:    \u0026Value{s: \"string\", t: typeRawString},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"123\",\n\t\t\texpected:    \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\texpected:    // Expect a correctly parsed Value representing the object,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3]\",\n\t\t\texpected:    // Expect a correctly parsed Value representing the array,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"notavalidjson\",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"notavalidjson\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"   \",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"   \",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"nonnumericstring\",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"nonnumericstring\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"For input %q, expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For input %q, expected result: %+v, got: %+v\", test.input, test.expected, result)\n\t\t}\n\n\t\tif tail != test.expectedTail {\n\t\t\tt.Errorf(\"For input %q, expected tail: %q, got: %q\", test.input, test.expectedTail, tail)\n\t\t}\n\t}\n}","2cc3b709604c5951ce3e82ebc9f8d8ad":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\t`{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\t// Expected Value for a proper object\n\t\t\t\u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`{}`,\n\t\t\t\u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`{\"key1\": \"value1\",}`,\n\t\t\tnil,\n\t\t\t\"\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`{\"key1\" \"value1\"}`,\n\t\t\tnil,\n\t\t\t\"\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`{\"key1\":}`,\n\t\t\tnil,\n\t\t\t\"\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`{\"key1\":\"value1\", \"key2\":`,\n\t\t\tnil,\n\t\t\t\"\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`{ \"key1\" : \"value1\", \"key2\": \"value2\", \"key3\": \"value3\" }`,\n\t\t\t// Expected Value for a proper object\n\t\t\t\u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\"}},\n\t\t\t\t\t\t{k: \"key3\", v: \u0026Value{s: \"value3\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"\",\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\n\t\tparsedValue, remain, err := parseObject(test.input, c, depth)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\n\t\tif err == nil {\n\t\t\tif !reflect.DeepEqual(parsedValue, test.expectedValue) {\n\t\t\t\tt.Errorf(\"parseObject(%q) = %v, expectedValue %v\", test.input, parsedValue, test.expectedValue)\n\t\t\t}\n\t\t\tif remain != test.expectedRemain {\n\t\t\t\tt.Errorf(\"parseObject(%q) remain = %q, expectedRemain %q\", test.input, remain, test.expectedRemain)\n\t\t\t}\n\t\t}\n\t}\n}","2ceadea7d3d22fb61a883ee6a8978095":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{\"123.456abc\", \"123.456\", \"abc\", nil},\n\t\t{\"-789.01test\", \"-789.01\", \"test\", nil},\n\t\t{\"42\", \"42\", \"\", nil},\n\t\t{\"0.001more\", \"0.001\", \"more\", nil},\n\t\t{\"inf something\", \"inf\", \" something\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-inf more\", \"-inf\", \" more\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", errInvalidCharacter}, // assuming errInvalidCharacter is defined as part of the error handling\n\t\t{\"\", \"\", \"\", errEmptyString}, // assuming errEmptyString is defined for handling empty input\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || remaining != test.expectedRemaining || err != nil \u0026\u0026 err.Error() != test.expectedError.Error() {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\", test.input, number, remaining, err, test.expectedNumber, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","2d5f2487d64d711a19307d18f38dabf3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345.67abc\", \"12345.67\", \"abc\", nil},\n\t\t{\"-123.45e+10xyz\", \"-123.45e+10\", \"xyz\", nil},\n\t\t{\"3.14\", \"3.14\", \"\", nil},\n\t\t{\"infXYZ\", \"inf\", \"XYZ\", nil},\n\t\t{\"nanABC\", \"nan\", \"ABC\", nil},\n\t\t{\"-nanAB\", \"-nan\", \"AB\", nil},\n\t\t{\"-infXYZ\", \"-inf\", \"XYZ\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"+123\", \"123\", \"\", nil},\n\t\t{\"\", \"\", \"\", nil}, // Edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\n\t\t// Check for expected output\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != \"\" \u0026\u0026 (test.err == nil || err.Error() != test.err.Error())) {\n\t\t\tt.Fatalf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\",\n\t\t\t\ttest.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","2d6e38d353e304097ec83f3d45819f1d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput *Value\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpectedOutput: // initialize with expected Value struct,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{}`,\n\t\t\texpectedOutput: // initialize with expected Value struct,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": false,}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": { \"innerKey\": \"innerValue\" }}`,\n\t\t\texpectedOutput: // initialize with expected Value struct,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t// Additional test cases can be added here\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}  // Use appropriate initialization for the cache if needed.\n\t\t\toutput, remainder, err := parseObject(test.input, c, 0)\n\n\t\t\tif test.expectedError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected an error but got none\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t\t}\n\t\t\t\tif output == nil || output.t != TypeObject {\n\t\t\t\t\tt.Fatalf(\"expected a Value of TypeObject but got %v\", output)\n\t\t\t\t}\n\t\t\t\tif remainder != test.expectedRemainder {\n\t\t\t\t\tt.Fatalf(\"expected remainder %q but got %q\", test.expectedRemainder, remainder)\n\t\t\t\t}\n\t\t\t\t// Additional checks on output can be performed\n\t\t\t}\n\t\t})\n\t}\n}","2df992bd75b18193a3fe156e4b85d482":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedNum string\n\t\texpectedRemainder string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e10more\", \"-123.45e10\", \"more\", false},\n\t\t{\"infxyz\", \"inf\", \"xyz\", false},\n\t\t{\"nan123\", \"nan\", \"123\", false},\n\t\t{\"+-wrong\", \"\", \"+-wrong\", true},\n\t\t{\"\", \"\", \"\", true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tnum, remainder, err := parseRawNumber(tt.input)\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected error: %v, got: %v\", tt.input, tt.expectedError, err)\n\t\t\tcontinue\n\t\t}\n\t\tif num != tt.expectedNum {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected num: %q, got: %q\", tt.input, tt.expectedNum, num)\n\t\t}\n\t\tif remainder != tt.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected remainder: %q, got: %q\", tt.input, tt.expectedRemainder, remainder)\n\t\t}\n\t}\n}","2e1e87a1802ab10a8d0fff9413ec247c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Newline:\\nTab:\\tBackslash:\\\\\", \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{\"Quotes: \\\"test\\\"\", \"Quotes: \\\"test\\\"\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate pairs: \\\\uD83D\\\\uDE00\", \"Surrogate pairs: ðŸ˜€\"},\n\t\t{\"Mixed: \\\"\\\\n\\\\t\\\\\\\\\\\\/\\\"\", \"\\n\\t\\\\/\\\\\"},\n\t\t{\"Escape: \\\\a\", \"Escape: \\\\a\"}, // unknown escape sequences\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","2e2c86f97ac7952a6d612a1dfbcc2116":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\texpectErr bool\n\t}{\n\t\t{\"{}\", \u0026Value{o: Object{}}, false},\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}, false},\n\t\t{\"\\\"test\\\"\", \u0026Value{t: typeRawString, s: \"test\"}, false},\n\t\t{\"true\", valueTrue, false},\n\t\t{\"false\", valueFalse, false},\n\t\t{\"null\", valueNull, false},\n\t\t{\"invalid\", nil, true},\n\t\t{\"[1, 2, [3, 4]]\", nil, true}, // Add depth test if necessary\n\t\t// Add more test cases as required...\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"parseValue() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tif result == nil \u0026\u0026 tt.expected != nil {\n\t\t\t\t\tt.Errorf(\"Expected value: %v, got nil\", tt.expected)\n\t\t\t\t} else if result != nil \u0026\u0026 tt.expected == nil {\n\t\t\t\t\tt.Errorf(\"Expected nil, got value: %v\", result)\n\t\t\t\t} else if result != nil \u0026\u0026 tt.expected != nil {\n\t\t\t\t\t// Additional comparison logic can be added here as needed\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","2f909e3670e0008a815b20c6f7e8a3a7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"This is a test string with an escaped quote: \\\".\"`,\n\t\t\texpected: \"This is a test string with an escaped quote: \\\".\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unescaped quote at the end`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"A quote with \\\\\"Escape\\\\\".\"`,\n\t\t\texpected: \"A quote with \\\\Escape\\\\.\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Multiple escaped quotes: \\\\\" and another \\\\\".`,\n\t\t\texpected: \"Multiple escaped quotes: \\\\ and another \\\\.\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Incomplete escape sequence: \\`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) returned error = %v, expected error = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expected = %q\", test.input, result, test.expected)\n\t\t}\n\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expected = %q\", test.input, rest, test.rest)\n\t\t}\n\t}\n}","2fa92d72de8793804a62897e8d2d73f2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t\t// Include a case to test the panic scenario\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For Type %v, expected %s, but got %s\", test.input, test.expected, result)\n\t\t}\n\t}\n\n\t// Test for an invalid Type value to ensure it panics\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for an unknown Type but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // Assuming this is an unknown Type\n\tunknownType.String()\n}","2fb0fc2eb32e058ac2dd842299b25569":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tinputJSON  string\n\t\tkeys       []string\n\t\texpected   *Value\n\t}{\n\t\t{\n\t\t\tname:       \"Get from nested object\",\n\t\t\tinputJSON:  `{\"a\": {\"b\": {\"c\": 1}}}`,\n\t\t\tkeys:       []string{\"a\", \"b\", \"c\"},\n\t\t\texpected:   \u0026Value{t: TypeNumber, s: \"1\"},\n\t\t},\n\t\t{\n\t\t\tname:       \"Get from array\",\n\t\t\tinputJSON:  `{\"a\": [1, 2, 3]}`,\n\t\t\tkeys:       []string{\"a\", \"1\"},\n\t\t\texpected:   \u0026Value{t: TypeNumber, s: \"2\"},\n\t\t},\n\t\t{\n\t\t\tname:       \"Non-existing key\",\n\t\t\tinputJSON:  `{\"a\": 1}`,\n\t\t\tkeys:       []string{\"b\"},\n\t\t\texpected:   nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"Invalid key path\",\n\t\t\tinputJSON:  `{\"a\": {\"b\": 1}}`,\n\t\t\tkeys:       []string{\"a\", \"b\", \"c\"},\n\t\t\texpected:   nil,\n\t\t},\n\t\t{\n\t\t\tname:       \"Array index out of range\",\n\t\t\tinputJSON:  `{\"a\": [0, 1, 2]}`,\n\t\t\tkeys:       []string{\"a\", \"3\"},\n\t\t\texpected:   nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := (\u0026Parser{}).Parse(tt.inputJSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected error parsing JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.Get(tt.keys...)\n\t\t\tif result != nil \u0026\u0026 tt.expected != nil \u0026\u0026 result.StringBytes() != tt.expected.StringBytes() {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected.StringBytes(), result.StringBytes())\n\t\t\t}\n\t\t\tif (result == nil) != (tt.expected == nil) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","2fe3ae84a715a014fd4df63781c671e4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedTail   string\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\\\"string\\\"\",\n\t\t\texpectedValue: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nan\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"1.23\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"too\\\": {\\\"nested\\\": {\\\"object\\\": {\\\"data\\\": [1, 2, 3]}}}}}\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"value\\\", \\\"key2\\\": [1, 2, 3]}\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": {\\\"nested\\\": {\\\"too\\\": 1}}}\",\n\t\t\texpectedValue: nil, // to be filled with expected structure\n\t\t\texpectedTail:  \"\",\n\t\t\texpectError:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t// Here we will call to parseValue with appropriate depth\n\t\t\tresultValue, resultTail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\n\t\t\t// Compare expected and actual value, implement comparison according to your needs\n\t\t\tif tt.expectedValue != nil \u0026\u0026 resultValue != nil {\n\t\t\t\t// Example: Should implement a deep comparison function for two Values\n\t\t\t\t// if !compareValues(resultValue, tt.expectedValue) {\n\t\t\t\t//     t.Errorf(\"Expected value: %+v, got: %+v\", tt.expectedValue, resultValue)\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\tif resultTail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"Expected tail: %q, got: %q\", tt.expectedTail, resultTail)\n\t\t\t}\n\t\t})\n\t}\n}","2ff1850ae86de1ccc21484979242f638":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\" quote\" remainder`,\n\t\t\texpectedValue: \"escaped \\\" quote\",\n\t\t\texpectedRest:  \" remainder\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unterminated string`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\" empty string`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \" empty string\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"double backslash \\\\\"`,\n\t\t\texpectedValue: \"double backslash \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"path with \\\\\" nested quote\\\" and more`,\n\t\t\texpectedValue: \"path with \\\\ nested quote\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) value = %q, want %q\", test.input, value, test.expectedValue)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","2ff24b4095c848855256487499af5870":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Example JSON for testing\n\tjsonData := `{\n\t\t\"key1\": {\n\t\t\t\"key2\": \"value2\",\n\t\t\t\"key3\": [1, 2, 3]\n\t\t},\n\t\t\"key4\": false,\n\t\t\"key5\": null\n\t}`\n\n\t// Parse the JSON string\n\tp := Parser{}\n\tv, err := p.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\t// Test valid key paths\n\ttests := []struct {\n\t\tkeys   []string\n\t\texpVal *Value\n\t}{\n\t\t{[]string{\"key1\"}, v.Get(\"key1\")},\n\t\t{[]string{\"key1\", \"key2\"}, v.Get(\"key1\", \"key2\")},\n\t\t{[]string{\"key1\", \"key3\", \"0\"}, v.Get(\"key1\", \"key3\", \"0\")},\n\t\t{[]string{\"key4\"}, v.Get(\"key4\")},\n\t\t{[]string{\"key5\"}, v.Get(\"key5\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := v.Get(test.keys...); got != test.expVal {\n\t\t\tt.Errorf(\"Get(%v) = %v; want %v\", test.keys, got, test.expVal)\n\t\t}\n\t}\n\n\t// Test invalid key paths\n\tinvalidTests := [][]string{\n\t\t{\"nonexistent\"},\n\t\t{\"key1\", \"nonexistent\"},\n\t\t{\"key1\", \"key3\", \"nonexistent\"},\n\t}\n\n\tfor _, keys := range invalidTests {\n\t\tif got := v.Get(keys...); got != nil {\n\t\t\tt.Errorf(\"Get(%v) = %v; want nil\", keys, got)\n\t\t}\n\t}\n\n\t// Test when v is nil\n\tvar nilValue *Value\n\tif got := nilValue.Get(\"somekey\"); got != nil {\n\t\tt.Errorf(\"Get on nil value = %v; want nil\", got)\n\t}\n}","2ff422ba8ebbc2fbda9512c1f666199b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tinput    *Value       // Input JSON Value\n\t\tkeys     []string     // Keys path for getting the value\n\t\texpected *Value       // Expected output\n\t}{\n\t\t{\n\t\t\tinput:    parseJSON(`{\"key1\": \"value1\"}`),\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"key1\": {\"key2\": \"value2\"}}`),\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: \u0026Value{s: \"value2\", t: TypeString},\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"key1\": [1, 2, 3]}`),\n\t\t\tkeys:     []string{\"key1\", \"1\"},\n\t\t\texpected: \u0026Value{s: \"2\", t: TypeNumber},\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"key1\": [1, 2, 3]}`),\n\t\t\tkeys:     []string{\"key1\", \"3\"},\n\t\t\texpected: nil, // Out of bounds\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"key1\": null}`),\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{t: TypeNull},\n\t\t},\n\t\t{\n\t\t\tinput:    nil, // Input is nil\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"key1\": {\"key2\": 5}}`),\n\t\t\tkeys:     []string{\"key1\", \"key3\"},\n\t\t\texpected: nil, // Non-existing key\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"Get(%v) = %v; want %v\", tt.keys, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc parseJSON(s string) *Value {\n\t// Simulate JSON parsing. In actual implementation, this should use the Parser\n\tv, _ := new(Parser).Parse(s)\n\treturn v\n}","303ad9d4dc410347d2cbd3bf7c648fec":"// object_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\t// Initialize an Object instance\n\tobj := \u0026Object{\n\t\tkvs: make([]kv, 0),\n\t}\n\n\t// Call getKV method and check the results\n\tkv1 := obj.getKV()\n\tkv2 := obj.getKV()\n\n\t// Check if the capacity and length of kvs slice are correct after two calls\n\tif cap(obj.kvs) \u003c 2 {\n\t\tt.Errorf(\"Expected capacity to be at least 2, got %d\", cap(obj.kvs))\n\t}\n\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of kvs to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Check if kv1 and kv2 point to different elements\n\tif kv1 == kv2 {\n\t\tt.Error(\"Expected kv1 and kv2 to point to different elements\")\n\t}\n\n\t// Check if kv1 is not empty\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected kv1 to be an empty kv, got %+v\", kv1)\n\t}\n\n\t// Further tests can be added here to cover edge cases as necessary\n}","303b207c74ac5ea4ce5afbb436c3bd7f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n\n\t// Testing an invalid Type case which should panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Value type, but did not panic\")\n\t\t}\n\t}()\n\t\n\tvar invalidType Type = 999 // Using a value that doesn't match any of the defined types\n\t_ = invalidType.String()\n}","3054603d186f99fd6bc0c1c19a1e5682":"// unescape_string_besteffort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\nworld\", \"hello\\nworld\"},\n\t\t{\"json\\\\tstring\", \"json\\tstring\"},\n\t\t{\"unicode\\\\u4F60\\\\u597D\", \"unicodeä½ å¥½\"},\n\t\t{\"escape \\\\\\\"quotes\\\\\\\"\", \"escape \\\"quotes\\\"\"},\n\t\t{\"backslash\\\\\\\\\", \"backslash\\\\\"},\n\t\t{\"unknown\\\\xFF\", \"unknown\\xFF\"},\n\t\t{\"incomplete\\\\uD83D\\\\\", \"incomplete\\\\uD83D\\\\\"},\n\t\t{\"no escapes here\", \"no escapes here\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3081f2b7867988b78d42025b66c8cccd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremains  string\n\t\twantErr  bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-1.23\", \"-1.23\", \"\", false},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", false},\n\t\t{\"+42\", \"+42\", \"\", false},\n\t\t{\"9876abc\", \"9876\", \"abc\", false},\n\t\t{\"abc123\", \"\", \"abc123\", true},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"--10\", \"\", \"--10\", true},\n\t\t{\"+-5\", \"\", \"+-5\", true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, remains, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRawNumber() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"parseRawNumber() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t\tif remains != tt.remains {\n\t\t\t\tt.Errorf(\"remains = %v, want %v\", remains, tt.remains)\n\t\t\t}\n\t\t})\n\t}\n}","30a6bbea29b047461f96d6422567f1ed":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tinputJSON     string\n\t\tkeys          []string\n\t\texpectedInt   int\n\t}{\n\t\t{\n\t\t\tname:        \"Valid integer\",\n\t\t\tinputJSON:   `{\"a\": 1}`,\n\t\t\tkeys:        []string{\"a\"},\n\t\t\texpectedInt: 1,\n\t\t},\n\t\t{\n\t\t\tname:        \"Nested keys\",\n\t\t\tinputJSON:   `{\"a\": {\"b\": 2}}`,\n\t\t\tkeys:        []string{\"a\", \"b\"},\n\t\t\texpectedInt: 2,\n\t\t},\n\t\t{\n\t\t\tname:        \"Non-existing key\",\n\t\t\tinputJSON:   `{\"a\": 1}`,\n\t\t\tkeys:        []string{\"b\"},\n\t\t\texpectedInt: 0,\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid type\",\n\t\t\tinputJSON:   `{\"a\": \"string\"}`,\n\t\t\tkeys:        []string{\"a\"},\n\t\t\texpectedInt: 0,\n\t\t},\n\t\t{\n\t\t\tname:        \"Array access\",\n\t\t\tinputJSON:   `{\"a\": [1, 2, 3]}`,\n\t\t\tkeys:        []string{\"a\", \"0\"},\n\t\t\texpectedInt: 1,\n\t\t},\n\t\t{\n\t\t\tname:        \"Array out of bounds\",\n\t\t\tinputJSON:   `{\"a\": [1, 2, 3]}`,\n\t\t\tkeys:        []string{\"a\", \"3\"},\n\t\t\texpectedInt: 0,\n\t\t},\n\t\t{\n\t\t\tname:        \"Deeply nested valid\",\n\t\t\tinputJSON:   `{\"a\": {\"b\": {\"c\": 4}}}`,\n\t\t\tkeys:        []string{\"a\", \"b\", \"c\"},\n\t\t\texpectedInt: 4,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := parseValue(tt.inputJSON, nil, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"parseValue() error = %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expectedInt {\n\t\t\t\tt.Errorf(\"GetInt() = %v, want %v\", result, tt.expectedInt)\n\t\t\t}\n\t\t})\n\t}\n}","31708e9592fc730726c6da06f0a4e763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttests := []struct {\n\t\tdescription string\n\t\tinputJSON   string\n\t\tkeys        []string\n\t\texpected    *Object\n\t\texpectNil   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"Valid object retrieval\",\n\t\t\tinputJSON:   `{\"key1\": {\"subKey1\": \"value1\"}}`,\n\t\t\tkeys:        []string{\"key1\"},\n\t\t\texpected:    \u0026Object{kvs: []kv{{k: \"subKey1\", v: \u0026Value{s: \"value1\", t: TypeString}}}},\n\t\t\texpectNil:   false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Non-existing key\",\n\t\t\tinputJSON:   `{\"key1\": {\"subKey1\": \"value1\"}}`,\n\t\t\tkeys:        []string{\"key2\"},\n\t\t\texpected:    nil,\n\t\t\texpectNil:   true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Valid nested object retrieval\",\n\t\t\tinputJSON:   `{\"key1\": {\"subKey1\": {\"subSubKey\": \"value2\"}}}`,\n\t\t\tkeys:        []string{\"key1\", \"subKey1\"},\n\t\t\texpected:    \u0026Object{kvs: []kv{{k: \"subSubKey\", v: \u0026Value{s: \"value2\", t: TypeString}}}},\n\t\t\texpectNil:   false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Invalid type retrieval\",\n\t\t\tinputJSON:   `{\"key1\": \"notAnObject\"}`,\n\t\t\tkeys:        []string{\"key1\"},\n\t\t\texpected:    nil,\n\t\t\texpectNil:   true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"Empty keys\",\n\t\t\tinputJSON:   `{\"key1\": {\"subKey1\": \"value1\"}}`,\n\t\t\tkeys:        []string{},\n\t\t\texpected:    \u0026Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: `{\"subKey1\": \"value1\"}`, t: TypeObject}}}},\n\t\t\texpectNil:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tvalue, err := Parse(test.inputJSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse input JSON %q: %v\", test.inputJSON, err)\n\t\t\t}\n\n\t\t\tresult := value.GetObject(test.keys...)\n\t\t\tif (result == nil) != test.expectNil {\n\t\t\t\tt.Fatalf(\"Expected nil: %v, got: %v\", test.expectNil, result)\n\t\t\t}\n\n\t\t\tif !test.expectNil \u0026\u0026 result != nil \u0026\u0026 !compareObjects(result, test.expected) {\n\t\t\t\tt.Fatalf(\"Expected: %+v, got: %+v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareObjects compares two Object instances for equality.\nfunc compareObjects(a, b *Object) bool {\n\tif a.Len() != b.Len() {\n\t\treturn false\n\t}\n\tfor i, kvA := range a.kvs {\n\t\tkvB := b.kvs[i]\n\t\tif kvA.k != kvB.k || !compareValues(kvA.v, kvB.v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// compareValues compares two Value instances for equality.\nfunc compareValues(a, b *Value) bool {\n\tif a.t != b.t {\n\t\treturn false\n\t}\n\tif a.s != b.s {\n\t\treturn false\n\t}\n\t// add more comparisons here as needed based on Value structure...\n\treturn true\n}","333e884dc25e2d7b7f3d4f1c2e529dc0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terrExpected bool\n\t}{\n\t\t{\n\t\t\tinput:      `\"Hello, world!\"`,\n\t\t\texpected:   \"Hello, world!\",\n\t\t\tremaining:  \"\",\n\t\t\terrExpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:      `\"Hello, \\\"world\\\"!\"`,\n\t\t\texpected:   \"Hello, \\\"world\\\"!\",\n\t\t\tremaining:  \"\",\n\t\t\terrExpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:      `\"Unclosed string`,\n\t\t\texpected:   \"\",\n\t\t\tremaining:  \"\",\n\t\t\terrExpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:      `\"Escaped\\\\\"`,\n\t\t\texpected:   \"Escaped\\\\\",\n\t\t\tremaining:  \"\",\n\t\t\terrExpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:      `\"\"Extra data\"`,\n\t\t\texpected:   \"\",\n\t\t\tremaining:  `Extra data\"`,\n\t\t\terrExpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:      `\"\\\\\\\"A complex string\\\\\\\" with backslashes \\\\\\\\\"`,\n\t\t\texpected:   `\\\"A complex string\\\" with backslashes \\\\`,\n\t\t\tremaining:  \"\",\n\t\t\terrExpected: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.errExpected {\n\t\t\tt.Errorf(\"parseRawString(%q) expected error: %v, got: %v\", test.input, test.errExpected, err != nil)\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) expected result: %q, got: %q\", test.input, test.expected, result)\n\t\t}\n\t\tif remaining != test.remaining {\n\t\t\tt.Errorf(\"parseRawString(%q) expected remaining: %q, got: %q\", test.input, test.remaining, remaining)\n\t\t}\n\t}\n}","33bbc286c9451caee7ebaaf46dcc21c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", nil},\n\t\t\t{\"key2\", nil},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Assert initial state\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Call reset method\n\tobj.reset()\n\n\t// Assert state after reset\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"expected kvs length to be 1 after reset, got %d\", len(obj.kvs))\n\t}\n\n\t// Assert keysUnescaped state remains unchanged\n\tif obj.keysUnescaped != true {\n\t\tt.Fatalf(\"expected keysUnescaped to be true, got %v\", obj.keysUnescaped)\n\t}\n\n\t// Reset again to check stability\n\tobj.reset()\n\n\t// Assert final state after second reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected kvs length to be 0 after second reset, got %d\", len(obj.kvs))\n\t}\n}","34b7165e20b8f325f1cd12eb03dfd9f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tvalue        *Value\n\t\texpected     int\n\t\texpectErr    bool\n\t}{\n\t\t// Test case: valid JSON number\n\t\t{\n\t\t\tvalue:     \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpected:  123,\n\t\t\texpectErr: false,\n\t\t},\n\t\t// Test case: valid JSON number (negative)\n\t\t{\n\t\t\tvalue:     \u0026Value{s: \"-123\", t: TypeNumber},\n\t\t\texpected:  -123,\n\t\t\texpectErr: false,\n\t\t},\n\t\t// Test case: value is not a number (TypeString)\n\t\t{\n\t\t\tvalue:     \u0026Value{s: `\"not a number\"`, t: TypeString},\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t// Test case: value is not a number (TypeNull)\n\t\t{\n\t\t\tvalue:     \u0026Value{s: \"null\", t: TypeNull},\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t\t// Test case: value that doesn't fit into int\n\t\t{\n\t\t\tvalue:     \u0026Value{s: \"12345678901234567890\", t: TypeNumber}, // too big for int\n\t\t\texpected:  0,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, err := test.value.Int()\n\t\tif (err != nil) != test.expectErr {\n\t\t\tt.Errorf(\"expected error: %v, got: %v\", test.expectErr, err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"for input %v, expected %d, got %d\", test.value.s, test.expected, result)\n\t\t}\n\t}\n}","34e720be16f6ed3adf8118013d3b1dfe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"invalidKey\": }`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%q) error: expected %v, got %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\n\t\t// Check if remaining string matches the expected remaining\n\t\tif len(remaining) \u003e 0 \u0026\u0026 len(test.input) \u003e len(remaining) {\n\t\t\texpectedRemaining := test.input[len(remaining):]\n\t\t\tif remaining != expectedRemaining {\n\t\t\t\tt.Errorf(\"parseObject(%q) remaining = %q, want %q\", test.input, remaining, expectedRemaining)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare Value objects for testing\nfunc compareValues(a, b *Value) bool {\n\t// Implement comparison logic based on Value structure\n\t// This is a simplified assumption due to the abstract nature of Value\n\treturn a.t == b.t \u0026\u0026 a.s == b.s // You might want to do a deeper comparison based on their types\n}","352054701a05c0ea76f056039ee028d9":"// unescape_string_best_effort_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Escape this: \\\\n\", \"Escape this: \\n\"},\n\t\t{\"Quotes: \\\\\\\"quoted text\\\\\\\"\", \"Quotes: \\\"quoted text\\\"\"},\n\t\t{\"Backslash: \\\\\\\\ and newline: \\\\n\", \"Backslash: \\\\ and newline: \\n\"},\n\t\t{\"Unicode: \\\\u03A9\", \"Unicode: Î©\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: ðŸ˜€\"},\n\t\t{\"Multiple escapes: \\\\\\\"test\\\\u003Ctest\\\\\\\"\", \"Multiple escapes: \\\"test\u003ctest\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","36b8bc01cb6a97aac3ef6a838c4f1a2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"New line\\\\nTest\", \"New line\\nTest\"},\n\t\t{\"Tab\\\\tTest\", \"Tab\\tTest\"},\n\t\t{\"Backslash\\\\\\\\Test\", \"Backslash\\\\Test\"},\n\t\t{\"Unicode\\\\u4F60\\\\u597D\", \"Unicodeä½ å¥½å—\"},\n\t\t{\"Invalid\\\\uXXXX\", \"Invalid\\\\uXXXX\"},\n\t\t{\"Valid but incomplete\\\\u4F\", \"Valid but incomplete\\\\u4F\"},\n\t\t{\"Backslash with unknown escape \\\\xTest\", \"Backslash with unknown escape \\\\xTest\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","387bddf6b1481bddeded9525ddd43a5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Line1\\\\nLine2\", \"Line1\\nLine2\"},\n\t\t{\"Tab\\\\tTab\", \"Tab\\tTab\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode\\\\u0031\", \"Unicode1\"},\n\t\t{\"Invalid escape \\\\x\", \"Invalid escape \\\\x\"},\n\t\t{\"Surrogate \\\\uD83D\\\\uDE00\", \"Surrogate ðŸ˜€\"},\n\t\t{\"Mixed \\\\uD83D\\\\uDE00\\\\ and \\\\nline\", \"Mixed ðŸ˜€ and \\nline\"},\n\t\t{\"Incomplete \\\\u\", \"Incomplete \\\\u\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","39322df48baace138a017c3d3bc1d3b5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\t// Test case 1: Valid JSON array\n\tv1 := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{\n\t\t\t{t: TypeNumber}, // Example Value\n\t\t\t{t: TypeString}, // Example Value\n\t\t},\n\t}\n\tresult := v1.GetArray()\n\tif len(result) != 2 {\n\t\tt.Fatalf(\"expected 2 elements, got %d\", len(result))\n\t}\n\n\t// Test case 2: Empty array\n\tv2 := \u0026Value{\n\t\tt: TypeArray,\n\t\ta: []*Value{},\n\t}\n\tresult = v2.GetArray()\n\tif len(result) != 0 {\n\t\tt.Fatalf(\"expected 0 elements, got %d\", len(result))\n\t}\n\n\t// Test case 3: Non-existing keys path\n\tv3 := \u0026Value{\n\t\tt: TypeObject,\n\t}\n\tresult = v3.GetArray() // Trying to get array from a non-array type\n\tif result != nil {\n\t\tt.Fatal(\"expected nil for non-array type, got a value\")\n\t}\n\n\t// Test case 4: Nil value\n\tvar v4 *Value\n\tresult = v4.GetArray() // Should return nil\n\tif result != nil {\n\t\tt.Fatal(\"expected nil for nil value, got a value\")\n\t}\n}","3a0ad62efe4f25d6536920f0034c4190":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\n// TestUnescapeStringBestEffort tests the unescapeStringBestEffort function.\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`,\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tCharacter\"`,\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u4F60\\u597D\"`,\n\t\t\texpected: \"Unicode: ä½ å¥½\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid escape: \\u G\"`,\n\t\t\texpected: \"Invalid escape: \\\\u G\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Double backslash: \\\\\\\\\"`,\n\t\t\texpected: \"Double backslash: \\\\\\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed \\u1234 and unescaped\"`,\n\t\t\texpected: \"Mixed áˆ´ and unescaped\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Empty string: \"\"`,\n\t\t\texpected: \"Empty string: \",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\\\\"`,\n\t\t\texpected: \"\\\\\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3a398eada6bb87a5c52c84d718887602":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Object(t *testing.T) {\n\t// Test cases\n\ttests := []struct {\n\t\tname        string\n\t\tinput       Value // The JSON Value to test with\n\t\texpectError bool   // Expecting an error if true\n\t}{\n\t\t{\n\t\t\tname: \"Valid Object\",\n\t\t\tinput: Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Type Null\",\n\t\t\tinput: Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Type Array\",\n\t\t\tinput: Value{\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpectError: true,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tobj, err := tt.input.Object()\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"Object() error = %v, expectError %v\", err, tt.expectError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.expectError \u0026\u0026 obj == nil {\n\t\t\t\tt.Errorf(\"Object() = nil, but expected non-nil object\")\n\t\t\t}\n\t\t})\n\t}\n}","3aaf7a1aae8189f0ac66ba79a7f3d3ae":"// marshaldto_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"nil value\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"boolean true\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"boolean false\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"string value\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"number value\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\texpected: \"42\",\n\t\t},\n\t\t{\n\t\t\tname: \"raw string\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw data\"},\n\t\t\texpected: \"\\\"raw data\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"array value\",\n\t\t\tvalue: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"object value\",\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"John\"}},\n\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo(nil)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","3b184aa717383a10e0642287c3ad0201":"// parse_array_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"foo\\\", \\\"bar\\\"]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeString, s: \"foo\"}, \u0026Value{t: TypeString, s: \"bar\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeTrue}, \u0026Value{t: TypeFalse}, \u0026Value{t: TypeNull}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil, // Expected to return error due to trailing comma\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil, // Expected to return error due to unexpected end of array\n\t\t\terr:      fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, invalid, 3]\",\n\t\t\texpected: nil, // Expected to return error for invalid value\n\t\t\terr:      fmt.Errorf(\"cannot parse array value:\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{vs: []Value{}}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != (test.err != nil) {\n\t\t\tt.Errorf(\"For input %s, unexpected error status: got %v, want %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"For input %s, unexpected error message: got %v, want %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expected) {\n\t\t\t\tt.Errorf(\"For input %s, unexpected length of result: got %d, want %d\", test.input, len(result.a), len(test.expected))\n\t\t\t}\n\t\t\tfor i, expectedVal := range test.expected {\n\t\t\t\tif result.a[i].t != expectedVal.t || result.a[i].s != expectedVal.s {\n\t\t\t\t\tt.Errorf(\"For input %s, unexpected value at index %d: got %+v, want %+v\", test.input, i, result.a[i], expectedVal)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3c43fd358c0d29f9399e5e3093638908":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"    Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, World!   \", \"Hello, World!   \"},\n\t\t{\"\\n\\tHello\", \"Hello\"},\n\t\t{\"\\t\\t  \\n\\n\", \"\"},\n\t\t{\"Normal string\", \"Normal string\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\r\\nLine with CR\", \"Line with CR\"},\n\t\t{\"No whitespace\", \"No whitespace\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3c5d58b5438759a28be54d5c21c2f82c":"","3c85e974218694a7de9cb13fa4be2f63":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true},\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false},\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false},\n\t\t{\"\\\"test\\\"\", \u0026Value{t: typeRawString, s: \"test\"}, false},\n\t\t{\"true\", valueTrue, false},\n\t\t{\"false\", valueFalse, false},\n\t\t{\"null\", valueNull, false},\n\t\t{\"42\", \u0026Value{t: TypeNumber, s: \"42\"}, false},\n\t\t{\"3.14\", \u0026Value{t: TypeNumber, s: \"3.14\"}, false},\n\t\t{\"nan\", \u0026Value{t: TypeNumber, s: \"nan\"}, false},\n\t\t{\"{}{}\", nil, true}, // invalid JSON\n\t\t{\"[1, 2, 3]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t}}, false},\n\t\t{\"[1, 2, \\\"three\\\"]\", \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t{t: typeRawString, s: \"three\"},\n\t\t}}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input: %q, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input: %q, got: %v\", test.input, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif result == nil || result.t != test.expected.t || result.s != test.expected.s {\n\t\t\t\tt.Errorf(\"unexpected result for input: %q, got: %v, want: %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\t\tif tail != \"\" \u0026\u0026 tail != test.input[len(test.input)-len(tail):] {\n\t\t\tt.Errorf(\"unexpected tail for input: %q, got: %q, want: the rest of input\", test.input, tail)\n\t\t}\n\t}\n}","3d1a0785dcf3d2378895c989662c217c":"// File: value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tkeys      []string\n\t\tjson      string\n\t\texpected  int\n\t}{\n\t\t{\n\t\t\tkeys:     []string{\"validPath\"},\n\t\t\tjson:     `{\"validPath\": 42}`,\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"validPath\"},\n\t\t\tjson:     `{\"validPath\": \"notAnInt\"}`,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"nonExistentPath\"},\n\t\t\tjson:     `{\"validPath\": 10}`,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"array\", \"0\"},\n\t\t\tjson:     `{\"array\": [99, 100]}`,\n\t\t\texpected: 99,\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"array\", \"invalidIndex\"},\n\t\t\tjson:     `{\"array\": [1, 2]}`,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"nested\", \"structure\", \"value\"},\n\t\t\tjson:     `{\"nested\": {\"structure\": {\"value\": 25}}}`,\n\t\t\texpected: 25,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.json, func(t *testing.T) {\n\t\t\tv, err := Parse(test.json)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetInt(test.keys...)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d; want %d\", test.keys, result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}","3d2d4a89f500c5677c5352bea33edf13":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedKeys []string\n\t\texpectedValues []string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedKeys:  []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"value1\", \"value2\"},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedKeys:  nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpectedKeys:  []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"value1\", \"2\"},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\",}`,\n\t\t\texpectedKeys:  []string{\"key\"},\n\t\t\texpectedValues: []string{\"value\"},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpectedKeys:  nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\t\t_, s, err := parseObject(test.input, c, depth)\n\n\t\tif test.expectError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q but got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for input %q: %s\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// You can further inspect the resulting object here if needed.\n\t\t// For example, checking if the parsed keys/values match the expected keys/values.\n\t\t// This would require implementing the logic to extract key-value pairs from the `cache` object.\n\t}\n}","3d6e3f3ce2b90894ed5585626a6d5265":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"normal string\", `\"normal string\"`},\n\t\t{\"string with newline\\n\", `\"string with newline\\n\"`},\n\t\t{\"string with tab\\t\", `\"string with tab\\t\"`},\n\t\t{\"string with backslash\\\\\", `\"string with backslash\\\\\"`},\n\t\t{\"string with quote\\\"\", `\"string with quote\\\"\"`},\n\t\t{\"string with multiple special chars\\n\\t\\\\\\\"\", `\"string with multiple special chars\\n\\t\\\\\\\"\"`},\n\t\t{\"empty string\", `\"\"`},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := escapeString(nil, test.input)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"escapeString(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","3d8f6ad0ab0bfb926e53c4a95ced9ccd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedLen int\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\texpectedLen: 0,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3]\",\n\t\t\texpectedLen: 3,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 'three']\",\n\t\t\texpectedLen: 3,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1,]\",\n\t\t\texpectedLen: 1,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[,]\",\n\t\t\texpectedLen: 0,\n\t\t\texpectError: true, // Expect an error due to missing value\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3,]\",\n\t\t\texpectedLen: 3,\n\t\t\texpectError: false, // trailing comma is generally acceptable in JSON parsing\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3,, 4]\",\n\t\t\texpectedLen: 0,\n\t\t\texpectError: true, // Expect an error due to extra comma\n\t\t},\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\texpectedLen: 0,\n\t\t\texpectError: true, // Expect an error due to unexpected end\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, [3, 4]]\",\n\t\t\texpectedLen: 3,\n\t\t\texpectError: false, // Nested arrays\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc := \u0026cache{} // Create a new cache for each test case\n\t\tresult, _, err := parseArray(tt.input, c, 0)\n\n\t\tif (err != nil) != tt.expectError {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got: %v\", tt.input, tt.expectError, err)\n\t\t}\n\n\t\tif !tt.expectError \u0026\u0026 len(result.a) != tt.expectedLen {\n\t\t\tt.Errorf(\"parseArray(%q) expected array length: %d, got: %d\", tt.input, tt.expectedLen, len(result.a))\n\t\t}\n\t}\n}","3f31a54f585efbbec2a16c87a8cbe8e0":"// fastjson_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput []*Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"[]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeArray, a: []*Value{}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[true, false, null]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeTrue},\n\t\t\t\t{t: TypeFalse},\n\t\t\t\t{t: TypeNull},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[\\\"string\\\", \\\"another string\\\"]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeString, s: \"string\"},\n\t\t\t\t{t: TypeString, s: \"another string\"},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, , 2]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[,]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\toutput, remaining, err := parseArray(tt.input, c, 0)\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, expectedError = %v\", tt.input, err, tt.expectedError)\n\t\t\tcontinue\n\t\t}\n\n\t\t// If no error is expected, check the output values\n\t\tif !tt.expectedError {\n\t\t\tif len(output.a) != len(tt.expectedOutput) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tt.input, output.a, tt.expectedOutput)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, expected := range tt.expectedOutput {\n\t\t\t\tif output.a[i].t != expected.t || output.a[i].s != expected.s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v at index %d\", tt.input, output.a[i], expected, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","3f357661c008ff56cdc0f9cfad225fac":"// bool_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected bool\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"Valid True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: true,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: false,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type: Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type: Object\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type: Array\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type: Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type: String\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: false,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := tt.value.Bool()\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","3f7572e75236edb893fcc23f31599964":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"this is a string\", \"this is a string\"},\n\t\t{\"escaped quote: \\\\\"\", \"escaped quote: \\\"\"},\n\t\t{\"new line character: \\\\n\", \"new line character: \\n\"},\n\t\t{\"tab character: \\\\t\", \"tab character: \\t\"},\n\t\t{\"backslash: \\\\\\\\ \", \"backslash: \\\\ \"},\n\t\t{\"invalid unicode: \\\\u123\", \"invalid unicode: \\\\u123\"},\n\t\t{\"valid unicode: \\\\u4F60\\\\u597D\", \"valid unicode: ä½ å¥½\"}, // \"ä½ å¥½\" in Chinese\n\t\t{\"multiple escapes: \\\\n and \\\\t and \\\\\\\\\", \"multiple escapes: \\n and \\t and \\\\\"},\n\t\t{\"known escape: \\\\\\\" and trailing text\", \"\\\" and trailing text\"},\n\t\t{\"mixed \\\\u003C\\\\u003E\", \"\u003c\u003e\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","40a195db240c45247c569f188288dc15":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" back`,\n\t\t\texpectedValue: \"hello\\\"world\",\n\t\t\texpectedRest:  \" back\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello \\\"world\" some more`,\n\t\t\texpectedValue: \"hello \\\"world\",\n\t\t\texpectedRest:  \" some more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"missing closing`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"missing closing\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: `no quotes here`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tvalue, rest, err := parseRawString(tt.input)\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantError %v\", tt.input, err, tt.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != tt.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) got value = %q, want %q\", tt.input, value, tt.expectedValue)\n\t\t}\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) got rest = %q, want %q\", tt.input, rest, tt.expectedRest)\n\t\t}\n\t}\n}","40bce8756653a7f7b2a826f9d1e70a02":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value // This will hold the expected result after parsing\n\t\texpectErr bool   // Whether we expect an error\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: // expected Value for the above input,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: // expected Value representing an empty object,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: // expected Value representing an object with one key-value pair,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil, // We expect an error here due to the invalid key\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2,}`,\n\t\t\texpected: nil, // Trailing comma should result in an error\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\"}`, // Missing colon\n\t\t\texpected: nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: // expected Value representing a nested object,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: // expected Value representing an object containing an array,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": true}`,\n\t\t\texpected: // expected Value representing an object with a boolean value,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: // expected Value representing an object with a null value,\n\t\t\texpectErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tresult, remaining, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectErr, err)\n\t\t\t}\n\n\t\t\t// Additional checks on result and remaining input can be done here\n\t\t\t// e.g. comparing the result with tt.expected value\n\t\t})\n\t}\n}","41702ffcac5eb63c344593da8804a2ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedString string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:              `\"Hello, World!\"`,\n\t\t\texpectedString:     \"Hello, World!\",\n\t\t\texpectedRemaining:  \"\",\n\t\t\texpectedError:      false,\n\t\t},\n\t\t{\n\t\t\tinput:              `\"Hello, \\\"World\\\"!\"`,\n\t\t\texpectedString:     \"Hello, \\\"World\\\"!\",\n\t\t\texpectedRemaining:  \"\",\n\t\t\texpectedError:      false,\n\t\t},\n\t\t{\n\t\t\tinput:              `\"Unclosed string`,\n\t\t\texpectedString:     \"\",\n\t\t\texpectedRemaining:  \"\",\n\t\t\texpectedError:      true,\n\t\t},\n\t\t{\n\t\t\tinput:              `\"Escaped quote \\\\\"`,\n\t\t\texpectedString:     \"Escaped quote \\\\\",\n\t\t\texpectedRemaining:  \"\",\n\t\t\texpectedError:      false,\n\t\t},\n\t\t{\n\t\t\tinput:              `\"First part\" and more\"`,\n\t\t\texpectedString:     \"First part\",\n\t\t\texpectedRemaining:  ` and more\"`,\n\t\t\texpectedError:      false,\n\t\t},\n\t\t{\n\t\t\tinput:              `\"Double escaped quotes \\\\\\\\\"`,\n\t\t\texpectedString:     \"Double escaped quotes \\\\\\\\\",\n\t\t\texpectedRemaining:  \"\",\n\t\t\texpectedError:      false,\n\t\t},\n\t\t{\n\t\t\tinput:              `\"Not escaped \\\\\"still escaped\\\\\" here\"`,\n\t\t\texpectedString:     \"Not escaped \\\\still escaped\\\\ here\",\n\t\t\texpectedRemaining:  \"\",\n\t\t\texpectedError:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresultString, resultRemaining, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) = error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif resultString != test.expectedString {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expected %q\", test.input, resultString, test.expectedString)\n\t\t}\n\t\tif resultRemaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawString(%q) remaining = %q, expected %q\", test.input, resultRemaining, test.expectedRemaining)\n\t\t}\n\t}\n}","418c69497f59b9f493827f62e95a9c11":"// file: fastjson/value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinputJSON    string\n\t\tkeys         []string\n\t\texpected     bool\n\t\tshouldExist  bool\n\t}{\n\t\t{\n\t\t\tname:         \"simple true\",\n\t\t\tinputJSON:    `{\"key\": true}`,\n\t\t\tkeys:         []string{\"key\"},\n\t\t\texpected:     true,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"simple false\",\n\t\t\tinputJSON:    `{\"key\": false}`,\n\t\t\tkeys:         []string{\"key\"},\n\t\t\texpected:     false,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"non-existent key\",\n\t\t\tinputJSON:    `{\"key\": true}`,\n\t\t\tkeys:         []string{\"non-existent\"},\n\t\t\texpected:     false,\n\t\t\tshouldExist:  false,\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid type\",\n\t\t\tinputJSON:    `{\"key\": 123}`,\n\t\t\tkeys:         []string{\"key\"},\n\t\t\texpected:     false,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"nested key\",\n\t\t\tinputJSON:    `{\"outer\": {\"inner\": true}}`,\n\t\t\tkeys:         []string{\"outer\", \"inner\"},\n\t\t\texpected:     true,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"array index true\",\n\t\t\tinputJSON:    `{\"keys\": [false, true]}`,\n\t\t\tkeys:         []string{\"keys\", \"1\"},\n\t\t\texpected:     true,\n\t\t\tshouldExist:  true,\n\t\t},\n\t\t{\n\t\t\tname:         \"array index out of bounds\",\n\t\t\tinputJSON:    `{\"keys\": [true]}`,\n\t\t\tkeys:         []string{\"keys\", \"2\"},\n\t\t\texpected:     false,\n\t\t\tshouldExist:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar v Value\n\t\t\t// Assume Parse is a function to parse JSON strings into Value\n\t\t\tif err := Parse(tt.inputJSON, \u0026v); err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tresult := v.GetBool(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\n\t\t\texists := v.Exists(tt.keys...)\n\t\t\tif exists != tt.shouldExist {\n\t\t\t\tt.Errorf(\"expected existence: %v, got %v\", tt.shouldExist, exists)\n\t\t\t}\n\t\t})\n\t}\n}","41eed9330e6f62c05d39e701011084a6":"// parse_raw_number_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      bool\n\t}{\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"-456def\", \"-456\", \"def\", false},\n\t\t{\"3.14moretext\", \"3.14\", \"moretext\", false},\n\t\t{\"NaNxyz\", \"NaN\", \"xyz\", false},\n\t\t{\"Inf more\", \"Inf\", \" more\", false},\n\t\t{\"-Inf\", \"-Inf\", \"\", false},\n\t\t{\"\", \"\", \"\", true}, // this may be an edge case depending on your handling for empty input\n\t\t{\"invalid\", \"\", \"invalid\", true},\n\t\t{\"1e10 extra\", \"1e10\", \" extra\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseRawNumber(test.input)\n\t\t\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t}\n\t\tif remainder != test.remaining {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remainder = %q, expected %q\", test.input, remainder, test.remaining)\n\t\t}\n\t}\n}","42a4581e9bcb47c9cae323e224321838":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"MarshalTypeNull\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeTrue\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeFalse\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeNumber\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\texpected: \"123.45\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeString\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeRawString\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\texpected: \"\\\"raw string\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeArray\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"two\"},\n\t\t\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,\\\"two\\\",true]\",\n\t\t},\n\t\t{\n\t\t\tname: \"MarshalTypeObject\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","4317dd94c9c81cdfc7394fab018fe2c2":"// parse_raw_number_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremains  string\n\t\terr      bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e-6more\", \"-123.45e-6\", \"more\", false},\n\t\t{\"3.14159xyz\", \"3.14159\", \"xyz\", false},\n\t\t{\"inf something\", \"inf\", \" something\", false},\n\t\t{\"nan something\", \"nan\", \" something\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"+nan\", \"+nan\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", false}, // This case assumes input must not be empty, hence remains empty.\n\t}\n\n\tfor _, test := range tests {\n\t\tgot, remains, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, want error = %v\", test.input, err != nil, test.err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", test.input, got, test.expected)\n\t\t}\n\n\t\tif remains != test.remains {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remains = %q, want %q\", test.input, remains, test.remains)\n\t\t}\n\t}\n}","438cdd38c430e24205d861b12ce862a1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedOut string\n\t\texpectedRemainder string\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tinput: `\"Hello, World!\"`, \n\t\t\texpectedOut: \"Hello, World!\", \n\t\t\texpectedRemainder: \"\", \n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"Hello, \\\"World!\\\"\"`, \n\t\t\texpectedOut: \"Hello, \\\"World!\\\"\", \n\t\t\texpectedRemainder: \"\", \n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `\"missing closing...`, \n\t\t\texpectedOut: \"\", \n\t\t\texpectedRemainder: \"\", \n\t\t\texpectedErr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput: `\"escaped quote \\\\\"`, \n\t\t\texpectedOut: \"escaped quote \\\\\",\n\t\t\texpectedRemainder: \"\", \n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: `no quotes`, \n\t\t\texpectedOut: \"no quotes\", \n\t\t\texpectedRemainder: \"\", \n\t\t\texpectedErr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tout, remainder, err := parseRawString(test.input)\n\n\t\t\tif out != test.expectedOut || remainder != test.expectedRemainder || (err != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), expected (%q, %q, %v)\", \n\t\t\t\t\ttest.input, out, remainder, err, test.expectedOut, test.expectedRemainder, test.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}","43f05169bea4b18464c3beff0572b019":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\"world\" more`,\n\t\t\texpected: \"hello\\\"world\",\n\t\t\trest:     \" more\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\\\\\"world\" trailing`,\n\t\t\texpected: \"hello\\\\\\\"world\",\n\t\t\trest:     \" trailing\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\"world\"`,\n\t\t\texpected: \"hello\\\"world\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\\\\\" quote\" after`,\n\t\t\texpected: \"escaped \\\\\\\" quote\",\n\t\t\trest:     \" after\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseRawString(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expected error = %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expected = %q\", test.input, result, test.expected)\n\t\t}\n\t\tif remainder != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) remainder = %q, expected = %q\", test.input, remainder, test.rest)\n\t\t}\n\t}\n}","446abaebeeef376ebc93226303f531ed":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedError string\n\t\texpectedValue *Value // or appropriate expected output\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedValue: \u0026Value{ /* expected Value initialization */ },\n\t\t\texpectedError: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{}`,\n\t\t\texpectedValue: \u0026Value{ /* expected empty Value initialization */ },\n\t\t\texpectedError: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpectedError: \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedError: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\"}`,\n\t\t\texpectedValue: \u0026Value{ /* expected Value initialization */ },\n\t\t\texpectedError: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedError: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\", \"key3\": }`,\n\t\t\texpectedError: \"cannot parse object value: unexpected end of object\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpectedError: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key1\": \"value1\", \"key2\": \"value2\",   }`,\n\t\t\texpectedError: \"missing ',' after object value\", // check for trailing comma\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tvalue, _, err := parseObject(test.input, c, 0)\n\t\t\n\t\tif err != nil {\n\t\t\tif err.Error() != test.expectedError {\n\t\t\t\tt.Errorf(\"expected error '%s', got '%s' for input '%s'\", test.expectedError, err.Error(), test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.expectedError != \"\" {\n\t\t\tt.Errorf(\"expected error '%s', got none for input '%s'\", test.expectedError, test.input)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Additional checks can be performed here for expectedValue\n\t\tif value == nil {\n\t\t\tt.Errorf(\"expected non-nil value for input '%s', got nil\", test.input)\n\t\t} else {\n\t\t\t// Add appropriate checks to verify if the output matches expectedValue\n\t\t}\n\t}\n}","45e9f90038c7ac1a7282335fc1180fe8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\t// Initialize a new Object\n\tobj := \u0026Object{}\n\n\t// Test case: acquiring the first kv\n\tkv1 := obj.getKV()\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected first kv to be empty, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Test case: acquiring a second kv\n\tkv2 := obj.getKV()\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected second kv to be empty, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n\n\t// Check if the length of kvs is correct\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Test case: Ensure that calling getKV again adds a new kv\n\tkv3 := obj.getKV()\n\tif kv3.k != \"\" || kv3.v != nil {\n\t\tt.Errorf(\"Expected third kv to be empty, got k: %s, v: %v\", kv3.k, kv3.v)\n\t}\n\tif len(obj.kvs) != 3 {\n\t\tt.Errorf(\"Expected kvs length to be 3 after third call, got %d\", len(obj.kvs))\n\t}\n\n\t// Test case: check capacity behavior\n\tinitialCap := cap(obj.kvs)\n\tfor i := 0; i \u003c initialCap; i++ {\n\t\tobj.getKV()\n\t}\n\tif cap(obj.kvs) \u003c= initialCap {\n\t\tt.Errorf(\"Expected capacity to increase after exceeding initial capacity, got %d\", cap(obj.kvs))\n\t}\n}","46016ef0a20258ffb65f7446c875b298":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\tparser := \u0026Parser{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"name\": \"Alice\", \"age\": 30}`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value object\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3, 4, 5]`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value object\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"invalidJson\":}`,\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"array\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value object\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `null`,\n\t\t\texpected: \u0026Value{}, // Replace with expected Value object\n\t\t\thasError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, err := parser.Parse(tt.input)\n\n\t\t\tif (err != nil) != tt.hasError {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.hasError, err)\n\t\t\t}\n\n\t\t\tif !tt.hasError \u0026\u0026 !valuesEqual(result, tt.expected) {\n\t\t\t\tt.Fatalf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Placeholder function for value comparison.\n// Actual implementation would depend on how *Value is structured.\nfunc valuesEqual(a, b *Value) bool {\n\t// Implement comparison logic based on the structure of Value\n\treturn false\n}","474587a46759d9c9af305ffe6abc10cf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tinputKvs      []kv\n\t\texpectedState bool\n\t}{\n\t\t{\n\t\t\tname: \"Test with initial keys unescaped\",\n\t\t\tinputKvs: []kv{\n\t\t\t\t{\"key1\", nil},\n\t\t\t\t{\"key2\", nil},\n\t\t\t},\n\t\t\texpectedState: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Test with keys already unescaped\",\n\t\t\tinputKvs: []kv{\n\t\t\t\t{\"key3\", nil},\n\t\t\t\t{\"key4\", nil},\n\t\t\t},\n\t\t\texpectedState: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tobj := \u0026Object{\n\t\t\t\tkvs:           tt.inputKvs,\n\t\t\t\tkeysUnescaped: false,\n\t\t\t}\n\n\t\t\tobj.unescapeKeys()\n\t\t\t\n\t\t\tif obj.keysUnescaped != tt.expectedState {\n\t\t\t\tt.Errorf(\"expected keysUnescaped to be %v, got %v\", tt.expectedState, obj.keysUnescaped)\n\t\t\t}\n\t\t})\n\t}\n}","4778417afe75368a35b2b6f4f35fc985":"// parse_array_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\n// TestParseArray tests the parseArray function for various scenarios\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput           string\n\t\texpectedLength  int\n\t\texpectError     bool\n\t}{\n\t\t{\"[1, 2, 3]\", 3, false}, // Valid array\n\t\t{\"[]\", 0, false},        // Empty array\n\t\t{\"[1, 2, 3,]\", 3, true}, // Trailing comma should produce error\n\t\t{\"[1, 2,, 3]\", 3, true}, // Two commas should produce error\n\t\t{\"[1, 2, 3\", 0, true},   // Missing closing bracket should produce error\n\t\t{\"[true, false, null]\", 3, false}, // Array with different types\n\t\t{\"[\\\"string\\\", 1.5]\", 2, false},    // Array with string and number\n\t}\n\n\tcache := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tdepth := 0\n\t\t\tvalue, remaining, err := parseArray(tt.input, cache, depth)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\t\t\tif value != nil \u0026\u0026 len(value.a) != tt.expectedLength {\n\t\t\t\tt.Errorf(\"expected length: %d, got: %d\", tt.expectedLength, len(value.a))\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 remaining == tt.input {\n\t\t\t\tt.Error(\"expected some consumption of input string, none found\")\n\t\t\t}\n\t\t})\n\t}\n}","47a7a73c5d932bf8413c1aa7692b5419":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\"\", nil, true}, // test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // test for empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false}, // test for empty array\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, false}, // test for string\n\t\t{\"true\", valueTrue, false}, // test for boolean true\n\t\t{\"false\", valueFalse, false}, // test for boolean false\n\t\t{\"null\", valueNull, false}, // test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // test for number\n\t\t{\"{\\\"key\\\": [1, 2, 3]}\", nil, false}, // more complex JSON\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot, tail, err := parseValue(tt.input, c, 0)\n\t\tif (err != nil) != tt.wantErr {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", tt.input, err, tt.wantErr)\n\t\t\tcontinue\n\t\t}\n\t\tif !tt.wantErr \u0026\u0026 (got == nil || got.t != tt.expected.t) {\n\t\t\tt.Errorf(\"parseValue(%q) = %+v, expected %+v\", tt.input, got, tt.expected)\n\t\t}\n\t\tif tail != \"\" { // If we need to check parsing remainder\n\t\t\tt.Errorf(\"parseValue(%q) did not consume the full input, tail = %q\", tt.input, tail)\n\t\t}\n\t}\n}","47b28de27696c7d835e66559172d7cdc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal Raw String\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"example\"},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Object\",\n\t\t\tvalue:    \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: typeRawString, s: \"value\"}}}}},\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Array\",\n\t\t\tvalue:    \u0026Value{t: TypeArray, a: []*Value{{t: typeRawString, s: \"value1\"}, {t: typeRawString, s: \"value2\"}}},\n\t\t\texpected: `[\"value1\",\"value2\"]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: `123`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0)\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","482458ac461af40cdb53b92e922369b7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedFirst  string\n\t\texpectedSecond string\n\t\texpectedErr    bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\"world`,\n\t\t\texpectedFirst:  \"hello\",\n\t\t\texpectedSecond: \"world\",\n\t\t\texpectedErr:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\"world\"`,\n\t\t\texpectedFirst:  \"hello\\\\\",\n\t\t\texpectedSecond: \"world\",\n\t\t\texpectedErr:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"\"world`,\n\t\t\texpectedFirst:  \"hello\",\n\t\t\texpectedSecond: \"\",\n\t\t\texpectedErr:    true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"he said \\\\\"hello\\\\\"\" there\"`,\n\t\t\texpectedFirst:  `he said \\`hello\\``,\n\t\t\texpectedSecond: ` there\"`,\n\t\t\texpectedErr:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"incomplete\",\n\t\t\texpectedFirst:  \"\",\n\t\t\texpectedSecond: \"\",\n\t\t\texpectedErr:    true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresultFirst, resultSecond, err := parseRawString(tt.input)\n\n\t\tif (err != nil) != tt.expectedErr {\n\t\t\tt.Errorf(\"parseRawString(%q) expected error: %v, got: %v\", tt.input, tt.expectedErr, err)\n\t\t}\n\t\tif resultFirst != tt.expectedFirst {\n\t\t\tt.Errorf(\"parseRawString(%q) expected first value: %q, got: %q\", tt.input, tt.expectedFirst, resultFirst)\n\t\t}\n\t\tif resultSecond != tt.expectedSecond {\n\t\t\tt.Errorf(\"parseRawString(%q) expected second value: %q, got: %q\", tt.input, tt.expectedSecond, resultSecond)\n\t\t}\n\t}\n}","48320e961bd2d8c9a3735fa076ff65ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput  Type\n\t\toutput string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.output, func(t *testing.T) {\n\t\t\tif got := test.input.String(); got != test.output {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, test.output)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // an arbitrary value that is not defined\n\t_ = unknownType.String()\n}","48615e4e0f80b59be18ffb71c44492a6":"// parse_value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedTail   string\n\t\texpectedErr    bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"42\",\n\t\t\texpectedValue: \u0026Value{s: \"42\", t: TypeNumber},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpectedValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nan\",\n\t\t\texpectedValue: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": true}\",\n\t\t\texpectedValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"invalid\\\": \",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"{\\\"invalid\\\": \",\n\t\t\texpectedErr:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpectedValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}}}}}},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgotValue, gotTail, err := parseValue(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.expectedErr {\n\t\t\t\tt.Fatalf(\"parseValue() error = %v, expectedErr %v\", err, tt.expectedErr)\n\t\t\t}\n\t\t\tif gotValue != nil \u0026\u0026 tt.expectedValue != nil \u0026\u0026 *gotValue != *tt.expectedValue {\n\t\t\t\tt.Errorf(\"parseValue() gotValue = %v, want %v\", gotValue, tt.expectedValue)\n\t\t\t}\n\t\t\tif gotTail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"parseValue() gotTail = %v, want %v\", gotTail, tt.expectedTail)\n\t\t\t}\n\t\t})\n\t}\n}","487b4d87b952e68219b21d44a1371cea":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedLen int\n\t\texpectErr   bool\n\t}{\n\t\t{\"[]\", 0, false},                          // Empty array\n\t\t{\"[1, 2, 3]\", 3, false},                   // Array of integers\n\t\t{\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\", 3, false},      // Array of strings\n\t\t{\"[true, false, null]\", 3, false},        // Array with boolean and null\n\t\t{\"[1, 2, 3, \", 0, true},                   // Incomplete array\n\t\t{\"[1, 2, 3]\", 3, false},                   // Valid array again to ensure reusability\n\t\t{\"[1, , 3]\", 0, true},                     // Invalid array with empty value\n\t\t{\"[1, 2, 3, 4, 5]\", 5, false},             // Larger array\n\t\t{\"[]\", 0, false},                          // Another empty array for good measure\n\t}\n\n\tfor _, tt := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseArray(tt.input, c, 0)\n\n\t\tif (err != nil) != tt.expectErr {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, expectErr %v\", tt.input, err, tt.expectErr)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 len(result.a) != tt.expectedLen {\n\t\t\tt.Errorf(\"parseArray(%q) length = %d, expected %d\", tt.input, len(result.a), tt.expectedLen)\n\t\t}\n\t\tif remainder != \"\" \u0026\u0026 !tt.expectErr {\n\t\t\tt.Errorf(\"parseArray(%q) unexpected remainder = %q\", tt.input, remainder)\n\t\t}\n\t}\n}","48c9e62e37da97e070e59a6c5e30e526":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput *Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"{}\",\n\t\t\texpectedOutput: \u0026Value{t: TypeObject},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\"}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpectedOutput: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"123\", t: TypeNumber}}}}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", key2: 123}`, // Error: Missing quotes around key2\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`, // Error: Missing value for key2\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\" \"value2\"}`, // Error: Missing colon\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`, // Error: Trailing comma\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\toutput, _, err := parseObject(tt.input, c, 0)\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantErr %v\", tt.input, err, tt.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif !compareValues(output, tt.expectedOutput) {\n\t\t\tt.Errorf(\"parseObject(%q) = %v, want %v\", tt.input, output, tt.expectedOutput)\n\t\t}\n\t}\n}\n\n// compareValues is a helper function to compare two Value instances.\nfunc compareValues(a, b *Value) bool {\n\t// Implement comparison logic based on Value's structure\n\t// This is a placeholder implementation. You need to expand it based on your requirements.\n\treturn a != nil \u0026\u0026 b != nil \u0026\u0026 a.s == b.s \u0026\u0026 a.t == b.t\n}","48d318ea87ed8fe26689b887bc8fd3c8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                            // empty string\n\t\t{\" \", \"\"},                           // string with a space\n\t\t{\"\\n\", \"\"},                          // string with a newline\n\t\t{\"\\t\", \"\"},                          // string with a tab\n\t\t{\"\\r\", \"\"},                          // string with a carriage return\n\t\t{\"  hello\", \"hello\"},               // leading spaces\n\t\t{\"\\n\\nhello\", \"hello\"},             // leading newlines\n\t\t{\"\\t\\thello\", \"hello\"},             // leading tabs\n\t\t{\"\\r\\rhello\", \"hello\"},             // leading carriage returns\n\t\t{\"   hello  \", \"hello  \"},          // leading spaces with trailing spaces\n\t\t{\"\\n   hello\\n\", \"hello\\n\"},        // mixed leading newlines and trailing newline\n\t\t{\"abc\", \"abc\"},                      // no whitespace\n\t\t{\"  \\t   \\n \\r xyz\", \"xyz\"},        // mixed whitespace before non-whitespace\n\t\t{\"\\n\\t\\t\\r\\n   xyz  abc\", \"xyz  abc\"}, // complex case\n\t\t{\"\\r\\n\\t  \\n  \\t \\t  \", \"\"},        // only whitespace\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := skipWSSlow(test.input)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, got, test.expected)\n\t\t}\n\t}\n}","49c1fd950447c90d34f273d87ba7c002":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      string\n\t}{\n\t\t// Valid object\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":2}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // You would replace this with the actual expected Value object\n\t\t\terr:      \"\",\n\t\t},\n\t\t// Empty object\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Actual expected Value should be set here\n\t\t\terr:      \"\",\n\t\t},\n\t\t// Invalid key format\n\t\t{\n\t\t\tinput:    `{key1:\"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      `cannot find opening '\"\" for object key`,\n\t\t},\n\t\t// Missing colon\n\t\t{\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ':' after object key\",\n\t\t},\n\t\t// Unexpected end of object\n\t\t{\n\t\t\tinput:    `{\"key1\":`,\n\t\t\texpected: nil,\n\t\t\terr:      \"unexpected end of object\",\n\t\t},\n\t\t// Trailing comma\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ',' after object value\",\n\t\t},\n\t\t// Invalid JSON\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ',' after object value\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.err != \"\" {\n\t\t\tif err == nil || err.Error() != test.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", test.err, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\t// Check equality of the expected Value; this logic will depend upon your Value structure\n\t\t\tif result == nil || result.t != test.expected.t {\n\t\t\t\tt.Errorf(\"expected value type: %v, got: %v\", test.expected.t, result.t)\n\t\t\t}\n\t\t}\n\t}\n}","4b129ab98d5c4c731411a79d4a5f508e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"\\n\\n\\nworld\", \"world\"},\n\t\t{\"\\t\\t\\tfoo\", \"foo\"},\n\t\t{\" \\r\\n\\t\\nbar\", \"bar\"},\n\t\t{\"\\n\\t  \\r baz\", \"baz\"},\n\t\t{\"justtext\", \"justtext\"},\n\t\t{\"\", \"\"},\n\t\t{\"     \", \"\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := skipWSSlow(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}","4b87cd4d52570dab9666b264f36b07db":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeNull, \"null\"},\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n\n\t// Check for unknown value type panic\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\n\t// Use a value that is not defined in the Type const\n\tvar unknownType Type = 8 // or any value not defined in the const\n\t_ = unknownType.String() // This should trigger the panic\n}","4bfd353ce394104c3e5e7330f2d8c37e":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    `\"test\" extra`,\n\t\t\texpected: \"test\",\n\t\t\trest:     \" extra\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped\\\\\" more\"`,\n\t\t\texpected: \"escaped\\\\\",\n\t\t\trest:     \" more\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"not escaped\"`,\n\t\t\texpected: \"not escaped\",\n\t\t\trest:     \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"double \\\\\" quote\"`,\n\t\t\texpected: \"double \\\\\",\n\t\t\trest:     \" quote\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped quote \\\\\"unexpected quote\"`,\n\t\t\texpected: \"escaped quote \\\\\",\n\t\t\trest:     \"unexpected quote\",\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, rest, err := parseRawString(tt.input)\n\n\t\t\tif got != tt.expected || rest != tt.rest || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q, %v; want %q, %q, %v\", tt.input, got, rest, err, tt.expected, tt.rest, tt.err)\n\t\t\t}\n\t\t})\n\t}\n}","4cdd623a302712e4419ad2c3a2c97876":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey   string\n\t\texpectedRest  string\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"key\" more data`,\n\t\t\texpectedKey:   \"key\",\n\t\t\texpectedRest:  \" more data\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with escaped \\\"quotes\\\" inside\" more data`,\n\t\t\texpectedKey:   \"key with escaped \\\"quotes\\\" inside\",\n\t\t\texpectedRest:  \" more data\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"no closing quote`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"another key with escaped \\\\\\\"quote\\\\\"\" and other text`,\n\t\t\texpectedKey:   \"another key with escaped \\\\\\\"quote\\\\\",\n\t\t\texpectedRest:  \" and other text\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\\\\\" before closing quote\"`,\n\t\t\texpectedKey:   \"escaped \\\\\\\" before closing quote\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, rest, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectErr {\n\t\t\tt.Errorf(\"parseRawString(%q) unexpected error status: got %v, want %v\", test.input, err != nil, test.expectErr)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawString(%q) key = %q, want %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","4d0122a553f10d32bc49513bf0d9a989":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"plain string\", \"plain string\"},\n\t\t{\"escaped quote: \\\\\"\", \"escaped quote: \\\"\"},\n\t\t{\"backslash: \\\\\\\\\", \"backslash: \\\\\"},\n\t\t{\"newline: \\\\n\", \"newline: \\n\"},\n\t\t{\"tab: \\\\t\", \"tab: \\t\"},\n\t\t{\"cr: \\\\r\", \"cr: \\r\"},\n\t\t{\"form feed: \\\\f\", \"form feed: \\f\"},\n\t\t{\"backspace: \\\\b\", \"backspace: \\b\"},\n\t\t{\"slash: \\\\/\", \"slash: /\"},\n\t\t{\"unicode: \\\\u0041\", \"unicode: A\"},\n\t\t{\"unexpected unicode: \\\\u003Z\", \"unexpected unicode: \\\\u003Z\"},\n\t\t{\"surrogate pair: \\\\uD83D\\\\uDE00\", \"surrogate pair: ðŸ˜€\"},\n\t\t{\"mixed escapes: \\\\n\\\\t\\\\u0021\", \"\\n\\t!\"},\n\t\t{\"invalid escape: \\\\uD83D\\\\u\", \"invalid escape: \\\\uD83D\\\\u\"},\n\t\t{\"nested escape: a\\\\b\\\\\\\"c\", \"nested escape: a\\b\\\"c\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := unescapeStringBestEffort(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}","4f4491cb7c5cc7f58615a05c592dd536":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect error for empty string\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string value\\\"\",\n\t\t\texpected: \u0026Value{s: \"string value\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [true, false, null]}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse, valueNull}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nested: {\\\"level1\\\": {\\\"level2\\\": {\\\"level3\\\": \\\"value\\\"}}}\",\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect error for unexpected format\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got none.\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !equalValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"expected result for input %q: %+v, got: %+v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\t\tt.Log(\"Remaining tail:\", tail)\n\t}\n}\n\nfunc equalValues(v1, v2 *Value) bool {\n\t// Implement this function to compare two Value instances for equivalence\n\t// You'll want to compare types, strings, and objects properly\n\t// For the sake of the example, we'll return false always\n\treturn false\n}","4fc89e3a630b8e550765596372d584cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\\world\"`,\n\t\t\texpected: \"hello\\\\world\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escape: \\\\\"`,\n\t\t\texpected: \"escape: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"newline:\\nline\"`,\n\t\t\texpected: \"newline:\\nline\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"tab:\\tchar\"`,\n\t\t\texpected: \"tab:\\tchar\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"unicode: \\u003C\"` , // \u003c in unicode\n\t\t\texpected: \"unicode: \u003c\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"surrogate: \\uD83D\\uDE00\"`, // ðŸ˜€\n\t\t\texpected: \"surrogate: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"invalid unicode: \\uD83D\"`,\n\t\t\texpected: \"invalid unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"too short: \\uD83D\"`,\n\t\t\texpected: \"too short: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"unknown escape: \\x\"`,\n\t\t\texpected: \"unknown escape: \\\\x\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"base case\"`, // no escapes\n\t\t\texpected: \"base case\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","503f3922e45e669920f6725150e5602b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{}, // You can set this to an expected Value instance\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{}, // You can set this to an expected Value instance\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse JSON: ...\"), // Expected error message\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{}, // You can set this to an expected Value instance\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{}, // You can set this to an expected Value instance\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, test := range tests {\n\t\tgot, err := p.Parse(test.input)\n\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"expected error for input %q but got none\", test.input)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.err != nil \u0026\u0026 err != nil \u0026\u0026 test.err.Error() != err.Error() {\n\t\t\tt.Errorf(\"expected error %v for input %q, got %v\", test.err, test.input, err)\n\t\t}\n\n\t\t// Comparison of expected Value and got Value should be done here\n\t\t// You can implement a function to compare Value instances if needed\n\t\tif !equalValues(test.expected, got) {\n\t\t\tt.Errorf(\"expected %v, got %v for input %q\", test.expected, got, test.input)\n\t\t}\n\t}\n}\n\n// Helper function to compare two Value instances\nfunc equalValues(expected, actual *Value) bool {\n\t// Implement the logic to compare expected and actual Value instances\n\treturn false // Placeholder\n}","507ed88071a072bb161e39e02811a740":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\nHello\", \"Hello\"},\n\t\t{\" \\t\\tWorld\", \"World\"},\n\t\t{\"\\r\\n\\r\\nGo\", \"Go\"},\n\t\t{\"   Multiple Spaces   \", \"Multiple Spaces   \"},\n\t\t{\"\\t  \\r\\n   Test\", \"Test\"},\n\t\t{\"NoLeadingWhitespace\", \"NoLeadingWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\n\\t\\t\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","51623eafceb80d06c6bf0fcefe4a047b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{}, // Expecting an empty array\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil, // Expecting an error\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,, 3]\",\n\t\t\texpected: nil, // Expecting an error\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil, // Expecting an error due to missing ']'\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc := \u0026cache{}\n\t\tv, remaining, err := parseArray(tt.input, c, 0)\n\n\t\tif (err != nil) != tt.err {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, wantErr %v\", tt.input, err, tt.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tif remaining != \"]\" \u0026\u0026 remaining != \"\" {\n\t\t\t\tt.Errorf(\"parseArray(%q) remaining = %q, want empty\", tt.input, remaining)\n\t\t\t}\n\n\t\t\tif len(v.a) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"parseArray(%q) = %v, want %v\", tt.input, v.a, tt.expected)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor i, expectedValue := range tt.expected {\n\t\t\t\tif v.a[i].t != expectedValue.t || v.a[i].s != expectedValue.s {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) at index %d = %v, want %v\", tt.input, i, v.a[i], expectedValue)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","51deb49920dfc6e510077a17df92cc0a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue *Value\n\t\texpectedTail  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull, // assuming valueNull is a predefined constant\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue, // assuming valueTrue is a predefined constant\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse, // assuming valueFalse is a predefined constant\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"test\"`,\n\t\t\texpectedValue: \u0026Value{s: \"test\", t: typeRawString}, // expecting a raw string\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"123\",\n\t\t\texpectedValue: \u0026Value{s: \"123\", t: TypeNumber}, // expecting a number\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\texpectedValue: nil, // the actual parsed value would need to be constructed\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: nil, // the actual parsed value would need to be constructed\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"nan\",\n\t\t\texpectedValue: nil, // the actual value representing NaN\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"nested\\\": [1, 2, {\\\"inner\\\": false}]}\",\n\t\t\texpectedValue: nil, // the actual parsed value would need to be constructed\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true, // expecting an error due to incomplete object\n\t\t},\n\t\t{\n\t\t\tinput:         \"{ \\\"key\\\": invalid }\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"invalid }\",\n\t\t\texpectedError: true, // expecting an error due to invalid value\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t}\n\t\t\tif (v != nil) != (tt.expectedValue != nil) {\n\t\t\t\tt.Errorf(\"expected value: %v, got: %v\", tt.expectedValue, v)\n\t\t\t}\n\t\t\tif tail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail: %q, got: %q\", tt.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","51eb580ec9a46535500e7d56e243aafa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello\\\\nWorld!\", \"Hello\\nWorld!\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Quote: \\\\\\\"Hello\\\\\\\" World\", \"Quote: \\\"Hello\\\" World\"},\n\t\t{\"Backslash: \\\\\\\\ It works!\", \"Backslash: \\\\ It works!\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: ä½ å¥½\"},\n\t\t{\"Incomplete Unicode: \\\\u\", \"\\\\u\"},\n\t\t{\"Invalid sequence: \\\\x\", \"\\\\x\"},\n\t\t{\"Invalid Unicode: \\\\uD800\\\\uDFFF\", \"Invalid Unicode: \\ud800\\udfff\"},\n\t\t{\"Mixed: \\\\nNewline and \\\\tTab\", \"\\nNewline and \\tTab\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := unescapeStringBestEffort(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}","5247ae134bd05d190a83b85d60a407ce":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedErr string\n\t}{\n\t\t{\"\", \"cannot parse empty string\"},\n\t\t{\"{}\", \"\", nil},\n\t\t{\"[]\", \"\", nil},\n\t\t{\"\\\"string\\\"\", \"\", nil},\n\t\t{\"true\", \"\", nil},\n\t\t{\"false\", \"\", nil},\n\t\t{\"null\", \"\", nil},\n\t\t{\"nan\", \"\", nil},\n\t\t{\"invalid\", \"unexpected value found: \\\"invalid\\\"\"},\n\t\t{\"{key: value}\", \"cannot parse object\"},\n\t\t{\"[1, 2, 3\", \"unexpected end of JSON input\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.input, c, 0)\n\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.expectedErr {\n\t\t\t\tt.Errorf(\"expected error %q, got %q\", tt.expectedErr, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseValueMaxDepth(t *testing.T) {\n\tc := \u0026cache{}\n\t// Simulate reaching max depth\n\toversizedInput := \"{\\\"key\\\": [\\\"value\\\", {\\\"key\\\": [\\\"value\\\", {\\\"key\\\": [\\\"value\\\", {\\\"key\\\": [\\\"value\\\"]}]}]}]}]}\"\n\t\n\t_, _, err := parseValue(oversizedInput, c, MaxDepth)\n\n\tif err == nil || err.Error() != \"too big depth for the nested JSON; it exceeds \"+string(MaxDepth) {\n\t\tt.Errorf(\"expected max depth error, got %v\", err)\n\t}\n}","526d23c85d09e89c801d9123b00e9a9b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`Hello, World!`, `Hello, World!`},\n\t\t{`This is a string with an escaped quote: \\\"quoted\\\"`, `This is a string with an escaped quote: \"quoted\"`},\n\t\t{`This is a backslash: \\\\`, `This is a backslash: \\`},\n\t\t{`New line character: \\n`, `New line character: \n`},\n\t\t{`Tab character: \\t`, `Tab character: ` + \"\\t\"},\n\t\t{`Form feed character: \\f`, `Form feed character: ` + \"\\f\"},\n\t\t{`Carriage return character: \\r`, `Carriage return character: ` + \"\\r\"},\n\t\t{`Unicode character: \\u0041`, `Unicode character: A`}, // A\n\t\t{`Incomplete Unicode: \\u00`, `Incomplete Unicode: \\u00`}, // should remain as is\n\t\t{`Invalid Unicode: \\uXYZ1`, `Invalid Unicode: \\uXYZ1`}, // should remain as is\n\t\t{`Surrogate pair: \\uD83D\\uDE00`, `Surrogate pair: ðŸ˜„`}, // ðŸ˜€\n\t\t{`Unknown escape sequence: \\x`, `Unknown escape sequence: \\x`}, // should remain as is\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","528a2d825a6aee6a7ac7a372fbecd8b5":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"marshal raw string\",\n\t\t\tinput:    \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\t\t\u0026Value{t: TypeFalse},\n\t\t\t\t\t\u0026Value{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[true,false,null]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal string\",\n\t\t\tinput:    \u0026Value{t: TypeString, s: \"string\"},\n\t\t\texpected: `\"string\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal number\",\n\t\t\tinput:    \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\texpected: `123.45`,\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal true\",\n\t\t\tinput:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal false\",\n\t\t\tinput:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal null\",\n\t\t\tinput:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := test.input.MarshalTo(dst)\n\t\t\tif string(result) != test.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", test.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","52b69c67d9b989e8d08cb882093db87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tobject    *Value\n\t\tkeys      []string\n\t\texpected  *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get existing string key\",\n\t\t\tobject: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get existing array index\",\n\t\t\tobject: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\tnil,\n\t\t\t\t\t\u0026Value{s: \"value2\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{s: \"value2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get non-existing key\",\n\t\t\tobject: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get with invalid array index\",\n\t\t\tobject: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value1\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get nested key\",\n\t\t\tobject: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"outer\", \u0026Value{\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\"inner\", \u0026Value{s: \"value3\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: \u0026Value{s: \"value3\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.object.Get(tt.keys...)\n\t\t\tif (got == nil) != (tt.expected == nil) {\n\t\t\t\tt.Fatalf(\"expected %v, got %v\", tt.expected, got)\n\t\t\t}\n\t\t\tif got != nil \u0026\u0026 got.s != tt.expected.s {\n\t\t\t\tt.Fatalf(\"expected %v, got %v\", tt.expected.s, got.s)\n\t\t\t}\n\t\t})\n\t}\n}","52d2cdb7fd59ff3333585b77492b3dac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput *Value\n\t\texpectedRest   string\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tinput:        `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpectedOutput: \u0026Value{\n\t\t\t\t// Fill with expected Value structure\n\t\t\t},\n\t\t\texpectedRest:   \"\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:        `{\"key1\": \"value1\", \"key2\":`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRest:   \"\",\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tinput:        `{\"key1\": value1\"}`,\n\t\t\texpectedOutput: nil,\n\t\t\texpectedRest:   \"\",\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tinput:        `}`,\n\t\t\texpectedOutput: \u0026Value{ // Assuming this is how an empty object is represented\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpectedRest:   \"\",\n\t\t\texpectError:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\toutput, rest, err := parseObject(test.input, c, 0)\n\n\t\tif test.expectError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %s, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %s: %v\", test.input, err)\n\t\t\t}\n\t\t\t// Compare output and rest against expected values\n\t\t\t// (this assumes you have a way to correctly compare Value objects)\n\t\t\tif output == nil \u0026\u0026 test.expectedOutput != nil {\n\t\t\t\tt.Errorf(\"expected output not to be nil for input %s\", test.input)\n\t\t\t}\n\t\t\tif rest != test.expectedRest {\n\t\t\t\tt.Errorf(\"expected rest to be %s, got %s\", test.expectedRest, rest)\n\t\t\t}\n\t\t}\n\t}\n}","52f0859c0121dc670dfa3c6394572777":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\toutput := test.input.String()\n\t\t\tif output != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, output)\n\t\t\t}\n\t\t})\n\t}\n\n\t// This case should trigger a panic due to unknown Value type.\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Value type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // This type doesn't exist\n\t_ = unknownType.String() // This should panic\n}","53998db868a67109c659274b129aa427":"// File: parse_array_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput []*Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"[]\",\n\t\t\texpectedOutput: []*Value{},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[true, false, null]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeTrue}, \u0026Value{t: TypeFalse}, \u0026Value{t: TypeNull}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[\\\"string\\\", 1, null]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeString, s: \"string\"}, \u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNull}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2,]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\texpectedError:  true, // should error due to trailing comma\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2 3]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true, // should error due to missing comma\n\t\t},\n\t\t{\n\t\t\tinput:          \"[]\",\n\t\t\texpectedOutput: []*Value{},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[,]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true, // should error for empty array value\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, , 2]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true, // should error for empty value in array\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, remaining, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t}\n\n\t\t\tif !tt.expectedError {\n\t\t\t\tif len(result.a) != len(tt.expectedOutput) {\n\t\t\t\t\tt.Fatalf(\"expected length: %d, got: %d\", len(tt.expectedOutput), len(result.a))\n\t\t\t\t}\n\t\t\t\tfor i, v := range tt.expectedOutput {\n\t\t\t\t\tif result.a[i].s != v.s || result.a[i].t != v.t {\n\t\t\t\t\t\tt.Fatalf(\"expected value: %v, got: %v\", v, result.a[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","53b23725d802bd896fea42c9c410de4c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput   string\n\t\tdepth   int\n\t\twantErr bool\n\t}{\n\t\t{\"\", 0, true},                          // Test for empty string\n\t\t{\"{}\", 0, false},                       // Test for empty JSON object\n\t\t{\"[]\", 0, false},                       // Test for empty JSON array\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", 0, false},     // Test for simple JSON object\n\t\t{\"[1, 2, 3]\", 0, false},                // Test for simple JSON array\n\t\t{\"\\\"string\\\"\", 0, false},               // Test for simple string\n\t\t{\"true\", 0, false},                     // Test for boolean true\n\t\t{\"false\", 0, false},                    // Test for boolean false\n\t\t{\"null\", 0, false},                     // Test for null\n\t\t{\"{\\\"key1\\\":true, \\\"key2\\\":42}\", 0, false}, // Test for mixed JSON object\n\t\t{\"{\\\"key1\\\": {\\\"nestedKey\\\": \\\"nestedValue\\\"}}\", 0, false}, // Test for nested objects\n\t\t{\"{\\\"key\\\":nan}\", 0, false},           // Test for NaN\n\t\t{\"{\\\"key\\\":\\\"value\\\"\", 0, true},        // Test for malformed JSON\n\t\t{\"[1, 2, 3,]\", 0, true},                // Test for trailing comma in array\n\t\t{\"{\\\"key\\\": [1, 2, 3,]}\", 0, true},     // Test for trailing comma in object\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", MaxDepth + 1, true}, // Test for exceeding max depth\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.input, c, tt.depth)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseValue(%q, %d) unexpected error: %v\", tt.input, tt.depth, err)\n\t\t\t}\n\t\t})\n\t}\n}","54d21dbd2f396078b3efb6b6942aa1c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectError    bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"escaped \\\\\\\" quote\\\"\", \"escaped \\\" quote\", \"\", false},\n\t\t{\"unquoted string\", \"unquoted string\", \"\", true},\n\t\t{\"\\\"missing closing quote\", \"\", \"\", true},\n\t\t{\"\\\"escaped \\\\\\\\\\\" quote\\\"\", \"escaped \\\\ quote\", \"\", false},\n\t\t{\"\\\"multiple \\\\\\\\\\\" escaped \\\\\\\" quotes\\\"\", \"multiple \\\\ escaped \\\" quotes\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\t\t\n\t\tif (err != nil) != test.expectError {\n\t\t\tt.Errorf(\"For input %q, expected error: %v, got: %v\", test.input, test.expectError, err != nil)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"For input %q, expected value: %q, got: %q\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"For input %q, expected rest: %q, got: %q\", test.input, test.expectedRest, rest)\n\t\t}\n\t}\n}","55ab33cd70885a9d7bec39d7c6952a4f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\t// Create a dummy cache to use in tests\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedType Type\n\t\texpectError   bool\n\t}{\n\t\t{\"\", TypeNull, true}, // Expect error for empty string\n\t\t{\"{}\", TypeObject, false},\n\t\t{\"[]\", TypeArray, false},\n\t\t{\"\\\"string\\\"\", TypeString, false},\n\t\t{\"123\", TypeNumber, false},\n\t\t{\"true\", TypeTrue, false},\n\t\t{\"false\", TypeFalse, false},\n\t\t{\"null\", TypeNull, false},\n\t\t{\"nan\", TypeNumber, false}, // Testing for NaN\n\t\t{\"[1, 2, 3]\", TypeArray, false},\n\t\t{\"{\\\"key\\\":\\\"value\\\"}\", TypeObject, false},\n\t\t{\"[\\\"string\\\", true, null]\", TypeArray, false},\n\t\t{\"{invalidJson\", TypeNull, true}, // Expect error for invalid JSON\n\t\t{\"[1, 2, [3, 4, 5]]\", TypeArray, false}, // Nested array\n\t\t{\"{\\\"key\\\": {\\\"subkey\\\": \\\"value\\\"}}\", TypeObject, false}, // Nested object\n\t\t{\"{\\\"key\\\": \\\"value\\\", \\\"key2\\\": true}\", TypeObject, false}, // Object with multiple types\n\t\t{\"{\\\"key\\\": null, \\\"key2\\\": [1, 2, 3]}\", TypeObject, false}, // Object with null and array\n\t\t{\"{\\\"key\\\": {\\\"subkey\\\": [true, false]}}\", TypeObject, false}, // Object with nested array in subkey\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tdepth := 0\n\t\t\tvalue, tail, err := parseValue(tt.input, c, depth)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"unexpected error status for input %q: got %v, want error: %v\", tt.input, err, tt.expectError)\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\tif value.Type() != tt.expectedType {\n\t\t\t\t\tt.Errorf(\"unexpected type for input %q: got %v, want %v\", tt.input, value.Type(), tt.expectedType)\n\t\t\t\t}\n\t\t\t\tif len(tail) \u003e 0 {\n\t\t\t\t\tt.Errorf(\"unexpected tail for input %q: got %q\", tt.input, tail)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","55ae7eb91da475c49df165ec95632208":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"two\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,\\\"two\\\"]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"one\", \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t{\"two\", \u0026Value{t: TypeString, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"one\\\":1,\\\"two\\\":\\\"2\\\"}\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw_string\"},\n\t\t\texpected: \"\\\"raw_string\\\"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t}\n\t}\n}","55c709ffad8143534ddeaf41a1e7bd19":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-12.34E10abc\", \"-12.34E10\", \"abc\", false},\n\t\t{\"nan and more\", \"nan\", \" and more\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"12.34.56\", \"12.34\", \".56\", false},\n\t\t{\"-12.34E\", \"-12.34E\", \"\", true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"input:%s\", tt.input), func(t *testing.T) {\n\t\t\tnum, rest, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.expectedErr {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedErr, err != nil)\n\t\t\t}\n\t\t\tif num != tt.expectedNum {\n\t\t\t\tt.Errorf(\"expected number: %v, got: %v\", tt.expectedNum, num)\n\t\t\t}\n\t\t\tif rest != tt.expectedRest {\n\t\t\t\tt.Errorf(\"expected rest: %v, got: %v\", tt.expectedRest, rest)\n\t\t\t}\n\t\t})\n\t}\n}","567dc1a07a611eae451a61af6d9ce469":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Initially the value slice is empty\n\tvalue := c.getValue()\n\tif value == nil {\n\t\tt.Fatalf(\"Expected a non-nil Value, got nil\")\n\t}\n\n\t// Verify that the value slice has grown\n\tif len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Retrieve another value\n\tvalue2 := c.getValue()\n\n\t// Verify we still have access to the first value\n\tif value == value2 {\n\t\tt.Fatalf(\"Expected unique values on consecutive calls to getValue\")\n\t}\n\n\t// Check the length again after a second call\n\tif len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected length of vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Fill the cache and test the cap scenario\n\tfor i := 0; i \u003c 10; i++ {\n\t\tc.getValue()\n\t}\n\n\t// Length of vs should match the number of times we've called getValue\n\tif len(c.vs) != 10 {\n\t\tt.Fatalf(\"Expected length of vs to be 10, got %d\", len(c.vs))\n\t}\n\n\t// Resetting the slice capacity\n\tc.vs = c.vs[:cap(c.vs)]\n\n\t// Ensure we still have access to the last value retrieved\n\tif len(c.vs) == 0 {\n\t\tt.Fatalf(\"Expected values to be present, got empty slice\")\n\t}\n}","569adecc916ae3f07b25462da44a89f4":"// marshal_to_test.go\npackage fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n    tests := []struct {\n        value    *Value\n        expected string\n    }{\n        {\n            value:    \u0026Value{s: \"hello\", t: TypeString},\n            expected: `\"hello\"`,\n        },\n        {\n            value:    \u0026Value{s: \"world\", t: typeRawString},\n            expected: `\"world\"`,\n        },\n        {\n            value:    \u0026Value{a: []*Value{}, t: TypeArray},\n            expected: `[]`,\n        },\n        {\n            value: \u0026Value{\n                o: Object{kvs: []kv{\n                    {k: \"name\", v: \u0026Value{s: \"John\", t: TypeString}},\n                    {k: \"age\", v: \u0026Value{s: \"30\", t: TypeNumber}},\n                }},\n                t: TypeObject,\n            },\n            expected: `{\"name\":\"John\",\"age\":30}`,\n        },\n        {\n            value: \u0026Value{s: \"example\", t: TypeTrue},\n            expected: \"true\",\n        },\n        {\n            value: \u0026Value{s: \"example\", t: TypeFalse},\n            expected: \"false\",\n        },\n        {\n            value: \u0026Value{s: \"example\", t: TypeNull},\n            expected: \"null\",\n        },\n    }\n\n    for _, test := range tests {\n        t.Run(test.expected, func(t *testing.T) {\n            result := test.value.MarshalTo(nil)\n            if string(result) != test.expected {\n                t.Errorf(\"expected %s, got %s\", test.expected, result)\n            }\n        })\n    }\n}","569ceb1896d923fc26f5c3de368f3449":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\n\\nHello\", \"Hello\"},\n\t\t{\"\\t\\tHello\", \"Hello\"},\n\t\t{\"\\r\\rHello\", \"Hello\"},\n\t\t{\"   \\t   World   \", \"World   \"},\n\t\t{\"   \\n   Line   \", \"Line   \"},\n\t\t{\"\\r\\n\\t   Test\", \"Test\"},\n\t\t{\"NoSpaces\", \"NoSpaces\"},\n\t\t{\"    \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","56d6cf5f0d301863de996118db5b3f31":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedChar      string\n\t\texpectedRest string\n\t\texpectedErr  bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello\\\\\\\"world\\\"\", \"hello\\\"world\", \"\", false},\n\t\t{\"\\\"hello\\\\\\\"world\\\\\\\" again\\\"\", \"hello\\\"world\", \" again\\\"\", false},\n\t\t{\"\\\"unclosed string\", \"\", \"\", true},\n\t\t{\"\\\"escaped \\\\\\\" quote\\\"\", \"escaped \\\" quote\", \"\", false},\n\t\t{\"\\\"multiple \\\\\\\\ backslashes\\\"\", \"multiple \\\\ backslashes\", \"\", false},\n\t\t{\"\\\"he said, \\\\\\\"hello\\\\\\\"!\\\"\", \"he said, \\\"hello\\\"!\", \"\", false},\n\t\t{\"invalid string\", \"\", \"\", true},\n\t\t{\"\\\"valid string with escape \\\\n and \\\\t\\\"\", \"valid string with escape \\n and \\t\", \"\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult, rest, err := parseRawString(tt.input)\n\n\t\tif (err != nil) != tt.expectedErr {\n\t\t\tt.Errorf(\"parseRawString(%q) expected error: %v, got: %v\", tt.input, tt.expectedErr, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != tt.expectedChar {\n\t\t\tt.Errorf(\"parseRawString(%q) expected result: %q, got: %q\", tt.input, tt.expectedChar, result)\n\t\t}\n\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) expected rest: %q, got: %q\", tt.input, tt.expectedRest, rest)\n\t\t}\n\t}\n}","5839b963b0f00d47ba1ea71416983cae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParser_Parse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\"}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\"}, {s: \"2\"}, {s: \"3\"}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeNull}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{} `,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\t\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\t\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Fatalf(\"Parse() error = %v, wantErr %v\", err, tt.err)\n\t\t\t}\n\t\t\tif tt.expected != nil \u0026\u0026 got == nil {\n\t\t\t\tt.Fatal(\"Expected a value, but got nil\")\n\t\t\t}\n\t\t\t// Further comparison with expected values can be added here depending on the Value structure\n\t\t})\n\t}\n}","5871d8de5bda10f9c2f0957142902f82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedType Type\n\t\texpectError  bool\n\t}{\n\t\t{\"\", TypeNull, true}, // Test empty string\n\t\t{\"{}\", TypeObject, false}, // Test simple empty object\n\t\t{\"[]\", TypeArray, false}, // Test simple empty array\n\t\t{\"\\\"test\\\"\", TypeString, false}, // Test simple string\n\t\t{\"true\", TypeTrue, false}, // Test boolean true\n\t\t{\"false\", TypeFalse, false}, // Test boolean false\n\t\t{\"null\", TypeNull, false}, // Test null value\n\t\t{\"123\", TypeNumber, false}, // Test number\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", TypeObject, false}, // Test object with key-value pair\n\t\t{\"[1, 2, 3]\", TypeArray, false}, // Test array of numbers\n\t\t{\"{\\\"key\\\": [1, 2, 3]}\", TypeObject, false}, // Test object with array as value\n\t\t{\"[true, false, null]\", TypeArray, false}, // Test array of mixed types\n\t\t{\"123.456\", TypeNumber, false}, // Test float number\n\t\t{\"{\\\"a\\\":{\\\"b\\\":true}}\", TypeObject, false}, // Nested object\n\t\t{\"{\\\"a\\\":[1,2,3]}\", TypeObject, false}, // Nested array\n\t\t{\"{\\\"a\\\": {\\\"b\\\": null}}\", TypeObject, false}, // Object with nested null\n\t\t{\"[\\\"string\\\", null, 5]\", TypeArray, false}, // Array with different types\n\t\t{\"{\\\"nested\\\": {\\\"array\\\": [1, 2, 3]}}\", TypeObject, false}, // Object with nested array\n\t\t{\"{\\\"depth\\\": {\\\"limit\\\": 1000}}\", TypeObject, false}, // Object with numbers\n\t}\n\n\tfor _, test := range tests {\n\t\t_, _, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.expectError {\n\t\t\tif test.expectError {\n\t\t\t\tt.Errorf(\"Expected error for input %q, but got none\", test.input)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t}\n\n\t\t// Additional checks for the type could be implemented \n\t\t// if returning the type of the value from parseValue.\n\t}\n}","58c7405e774342bc9822664969457783":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedOutput string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpectedOutput:    \"hello\",\n\t\t\texpectedRemaining: \" world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello \\\"escaped\\\" world\" more\",\n\t\t\texpectedOutput:    \"hello \\\"escaped\\\" world\",\n\t\t\texpectedRemaining: \" more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"not closed`,\n\t\t\texpectedOutput:    \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped quote \\\\\"`,\n\t\t\texpectedOutput:    \"escaped quote \\\\\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"multiple quotes \" here \" too\"`,\n\t\t\texpectedOutput:    \"multiple quotes \",\n\t\t\texpectedRemaining: \" here \\\" too\\\"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `no quotes`,\n\t\t\texpectedOutput:    \"no quotes\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput, remaining, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"input: %q, expected error: %v, got error: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif output != test.expectedOutput {\n\t\t\tt.Errorf(\"input: %q, expected output: %q, got output: %q\", test.input, test.expectedOutput, output)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"input: %q, expected remaining: %q, got remaining: %q\", test.input, test.expectedRemaining, remaining)\n\t\t}\n\t}\n}","58c88278ce1d66a2a2e9a8ffad165b22":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Adjust expected based on your implementation details\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: \u0026Value{ /* fill in expected structure based on implementation */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":123}`,\n\t\t\texpected: \u0026Value{ /* fill in expected structure based on implementation */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* fill in expected structure based on implementation */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\t\t\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%s) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseObject(%s) expected non-nil result, got nil\", test.input)\n\t\t}\n\t\tif err == nil \u0026\u0026 remaining != \"\" {\n\t\t\tt.Errorf(\"parseObject(%s) expected remaining input to be empty, got: %s\", test.input, remaining)\n\t\t}\n\t\t\n\t\t// Further comparison of result with expected can be done based on implementation specifics\n\t}\n}","5918e72973e48fabd54b0b57cef2017c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello \\\\n World\", \"Hello \\n World\"},\n\t\t{\"This is a \\\\\\\\ backslash\", \"This is a \\\\ backslash\"},\n\t\t{\"String with \\\\\\\"double quotes\\\\\\\"\", \"String with \\\"double quotes\\\"\"},\n\t\t{\"Incomplete unicode \\\\u0041\", \"Incomplete unicode A\"},\n\t\t{\"Invalid unicode \\\\uXYZ\", \"Invalid unicode \\\\uXYZ\"},\n\t\t{\"Surrogate pair \\\\uD83D\\\\uDE00\", \"Surrogate pair ðŸ˜€\"},\n\t\t{\"Mixed \\\\n escape and regular characters\", \"Mixed \\n escape and regular characters\"},\n\t\t{\"No escapes here\", \"No escapes here\"},\n\t\t{\"String with slash / and \\\\ backslash\", \"String with slash / and \\\\ backslash\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","59947fc5320ff2dac77bc86ecff32065":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"Hello, World!\"and some text`,\n\t\t\texpectedValue: \"Hello, World!\",\n\t\t\texpectedRest:  \"and some text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Escaped \\\"quote\\\" inside\" and text`,\n\t\t\texpectedValue: \"Escaped \\\"quote\\\" inside\",\n\t\t\texpectedRest:  \" and text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Unterminated string`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `No quotes here`,\n\t\t\texpectedValue: \"No quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Escaped \\\\\\\" quote\"`,\n\t\t\texpectedValue: \"Escaped \\\\\\\" quote\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tvalue, rest, err := parseRawString(tt.input)\n\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", tt.input, err, tt.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != tt.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", tt.input, value, tt.expectedValue)\n\t\t}\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", tt.input, rest, tt.expectedRest)\n\t\t}\n\t}\n}","59b8e71ef0b4aca2099db261e7678633":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      string\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}},\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\terr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      `cannot find opening '\"\" for object key`,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      `missing ':' after object key`,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": value}`,\n\t\t\texpected: nil,\n\t\t\terr:      \"cannot parse object value: invalid character 'v' looking for beginning of value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      \"missing '}'\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, remaining, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.err != \"\" {\n\t\t\t\tif err == nil || err.Error() != tt.err {\n\t\t\t\t\tt.Fatalf(\"expected error %q, got %v\", tt.err, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif !valuesEqual(result, tt.expected) {\n\t\t\t\tt.Fatalf(\"expected %+v, got %+v\", tt.expected, result)\n\t\t\t}\n\n\t\t\t// Additional check to ensure remaining string is processed correctly\n\t\t\tif remaining != \"\" {\n\t\t\t\tt.Fatalf(\"expected empty remaining string, got %q\", remaining)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare two Value types for equality\nfunc valuesEqual(v1, v2 *Value) bool {\n\t// Implement logic to compare Value objects\n\t// This can include comparing types, keys, values, etc.\n\treturn false // Placeholder\n}","5babdb3951265dc321e891198b96edd4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalstring\", false},\n\t\t{\"string with space\", false},\n\t\t{\"string with special char #\", false},\n\t\t{\"string with newline\\n\", true},\n\t\t{\"string with tab\\t\", true},\n\t\t{\"string with \\\"quotes\\\"\", true},\n\t\t{\"string with \\\\backslash\", true},\n\t\t{\"\", false},\n\t\t{\"string with null byte \\x00\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5cd64ad2aa4560244f16feafbdcdc631":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terrorMsg string\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{ /* populate with expected result */ },\n\t\t\terrorMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terrorMsg: \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terrorMsg: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terrorMsg: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* populate with expected result */ },\n\t\t\terrorMsg: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terrorMsg: \"cannot find opening '\\\"\\\"' for object key\",\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tresult, rest, err := parseObject(tt.input, c, 0)\n\n\t\tif tt.errorMsg != \"\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"For input %q, expected error but got none\", tt.input)\n\t\t\t} else if err.Error() != tt.errorMsg {\n\t\t\t\tt.Errorf(\"For input %q, expected error message %q but got %q\", tt.input, tt.errorMsg, err.Error())\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"For input %q, got unexpected error: %q\", tt.input, err)\n\t\t\t}\n\t\t\tif result == nil {\n\t\t\t\tt.Errorf(\"For input %q, expected result but got nil\", tt.input)\n\t\t\t}\n\t\t\t// Additional checks for the expected Value can be added here.\n\t\t}\n\t}\n}","5d423fabd7fd94b752240bfb62492b92":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\t// Test cases for the GetArray function\n\ttests := []struct {\n\t\tname     string\n\t\tjsonStr  string\n\t\tkeys     []string\n\t\texpected []*Value\n\t}{\n\t\t{\n\t\t\tname:     \"valid array path\",\n\t\t\tjsonStr:  `{\"data\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"data\"},\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, a: nil, s: \"1\"}, \u0026Value{t: TypeNumber, a: nil, s: \"2\"}, \u0026Value{t: TypeNumber, a: nil, s: \"3\"}},\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing path\",\n\t\t\tjsonStr:  `{\"data\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"missing\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty array\",\n\t\t\tjsonStr:  `{\"data\": []}`,\n\t\t\tkeys:     []string{\"data\"},\n\t\t\texpected: []*Value{},\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type\",\n\t\t\tjsonStr:  `{\"data\": \"not an array\"}`,\n\t\t\tkeys:     []string{\"data\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with mixed types\",\n\t\t\tjsonStr:  `{\"data\": [1, \"two\", true]}`,\n\t\t\tkeys:     []string{\"data\"},\n\t\t\texpected: []*Value{\n\t\t\t\t\u0026Value{t: TypeNumber, a: nil, s: \"1\"},\n\t\t\t\t\u0026Value{t: TypeString, a: nil, s: \"two\"},\n\t\t\t\t\u0026Value{t: TypeTrue, a: nil, s: \"\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tp := Parser{}\n\t\t\tv, err := p.Parse(tt.jsonStr)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tarr := v.GetArray(tt.keys...)\n\t\t\tif len(arr) != len(tt.expected) {\n\t\t\t\tt.Fatalf(\"expected %d elements, got %d\", len(tt.expected), len(arr))\n\t\t\t}\n\n\t\t\tfor i, expectedValue := range tt.expected {\n\t\t\t\tif arr[i].s != expectedValue.s || arr[i].t != expectedValue.t {\n\t\t\t\t\tt.Errorf(\"element %d mismatch: expected %v, got %v\", i, expectedValue, arr[i])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","5d50de60db0396b2d0bd0253f72fb162":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput      string\n\t\texpected   *Value\n\t\texpectedTail string\n\t\texpectedErr bool\n\t\tdepth      int\n\t}{\n\t\t{\n\t\t\tinput:      \"\",\n\t\t\texpected:   nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: true,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      \"true\",\n\t\t\texpected:   valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      \"false\",\n\t\t\texpected:   valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      \"null\",\n\t\t\texpected:   valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      `\"hello\"`,\n\t\t\texpected:   \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      \"123\",\n\t\t\texpected:   \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      \"[1, 2, 3]\",\n\t\t\texpected:   \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      `{\"key\": \"value\"}`,\n\t\t\texpected:   \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      `{\"key\": {\"innerKey\": \"innerValue\"}}`,\n\t\t\texpected:   \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{o: Object{kvs: []kv{{k: \"innerKey\", v: \u0026Value{s: \"innerValue\", t: typeRawString}}}}, t: TypeObject}}}}}, t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t\tdepth:      0,\n\t\t},\n\t\t{\n\t\t\tinput:      `{\"key\": \"value\"}`,\n\t\t\texpected:   nil,\n\t\t\texpectedTail: \"{'key': 'value'}\",\n\t\t\texpectedErr: true,\n\t\t\tdepth:      MaxDepth,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tc.input, c, tc.depth)\n\n\t\t\tif tc.expectedErr {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected error, got nil\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\n\t\t\tif !valueEqual(v, tc.expected) {\n\t\t\t\tt.Fatalf(\"expected value %v, got %v\", tc.expected, v)\n\t\t\t}\n\n\t\t\tif tail != tc.expectedTail {\n\t\t\t\tt.Fatalf(\"expected tail %q, got %q\", tc.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc valueEqual(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t // Simplified comparison, extend as necessary\n}","5d9ba318f485a038f98ce79add0f925e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedNum  string\n\t\texpectedRest string\n\t\texpectedErr  bool\n\t}{\n\t\t{\"123.456moredata\", \"123.456\", \"moredata\", false},\n\t\t{\"-123.45e+6rest\", \"-123.45e+6\", \"rest\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nanmore\", \"nan\", \"more\", false},\n\t\t{\"-infmore\", \"-inf\", \"more\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"1e10foo\", \"1e10\", \"foo\", false},\n\t\t{\"10.0.0rest\", \"10.0\", \".0rest\", true},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"+42andMore\", \"+42\", \"andMore\", false},\n\t\t{\"-42\", \"-42\", \"\", false},\n\t\t{\"0\", \"0\", \"\", false},\n\t}\n\n\tfor _, tt := range tests {\n\t\tnum, rest, err := parseRawNumber(tt.input)\n\n\t\tif (err != nil) != tt.expectedErr {\n\t\t\tt.Errorf(\"parseRawNumber(%q) unexpected error: %v\", tt.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif num != tt.expectedNum {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, want %q\", tt.input, num, tt.expectedNum)\n\t\t}\n\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, want %q\", tt.input, rest, tt.expectedRest)\n\t\t}\n\t}\n}","5da18abcb95e96380f9c8fd275d622fd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Simple string\", \"Simple string\"},\n\t\t{\"Line break\\\\nNew line\", \"Line break\\nNew line\"},\n\t\t{\"Tab\\\\tcharacter\", \"Tab\\tcharacter\"},\n\t\t{\"Backslash \\\\\\\\\", \"Backslash \\\\\"},\n\t\t{\"Unicode \\\\u0041\", \"Unicode A\"},\n\t\t{\"Invalid unicode \\\\uXYZ\", \"Invalid unicode \\\\uXYZ\"},\n\t\t{\"Mixed escapes: \\\\n\\\\t\\\\r\\\\\\\"\\\\'\", \"Mixed escapes: \\n\\t\\r\\\"\\'\"},\n\t\t{\"No escapes\", \"No escapes\"},\n\t\t{\"Escaped forward slash \\\\/\", \"Escaped forward slash /\"},\n\t\t{\"Surrogate pairs: \\\\uD83D\\\\uDC36\", \"Surrogate pairs: ðŸ¶\"},\n\t\t{\"Incomplete unicode \\\\u\", \"Incomplete unicode \\\\u\"},\n\t\t{\"Incomplete escape sequence \\\\u123\", \"Incomplete escape sequence \\\\u123\"},\n\t\t{\"Escaped character: \\\\xG1\", \"Escaped character: \\\\xG1\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","5ec1cf68f235fec45dbd1b9bba550fd2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t}{\n\t\t{\n\t\t\tinput:          `\"Hello, World!\"`,\n\t\t\texpectedOutput: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"This is a quote: \\\\\"`,\n\t\t\texpectedOutput: \"This is a quote: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Newline here:\\nNext line.\"`,\n\t\t\texpectedOutput: \"Newline here:\\nNext line.\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Tab here:\\tTab\"`,\n\t\t\texpectedOutput: \"Tab here:\\tTab\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Unicode: \\u00E9\"`,\n\t\t\texpectedOutput: \"Unicode: Ã©\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Invalid unicode: \\uZZZZ\"`,\n\t\t\texpectedOutput: \"Invalid unicode: \\\\uZZZZ\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Surrogate pair: \\uD83D\\uDE00\"`,\n\t\t\texpectedOutput: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Incomplete escape line: \\uD83D\"`,\n\t\t\texpectedOutput: \"Incomplete escape line: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Escape sequence: \\b\\f\\n\\r\\t\"`,\n\t\t\texpectedOutput: \"Escape sequence: \\b\\f\\n\\r\\t\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"\\\\\"`,\n\t\t\texpectedOutput: \"\\\\\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\toutput := unescapeStringBestEffort(test.input)\n\t\t\tif output != test.expectedOutput {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expectedOutput, output)\n\t\t\t}\n\t\t})\n\t}\n}","5f00dfe65b2cd06b1edd54aff1a38985":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput := test.input.String()\n\t\tif output != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", output, test.expected)\n\t\t}\n\t}\n\n\t// Test for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\n\t// Trigger the panic by calling String on an unknown type\n\tvar unknownType Type = 99 // Using a value not defined in the Type constants\n\t_ = unknownType.String()   // This should panic\n}","5f2d638daec8a7a43d52ea4a7cee1688":"// fastjson/value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tvalue     *Value\n\t\texpected  Type\n\t}{\n\t\t{\n\t\t\tname:     \"Test Type Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type Object\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type Array\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type String\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test Type Raw String\",\n\t\t\tvalue:    \u0026Value{t: typeRawString},\n\t\t\texpected: typeRawString,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tactual := test.value.Type()\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}","5f7e1b408299a5feceba48dcfcc3c3e6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\\\" world`,\n\t\t\texpectedValue:  \"hello\\\\\",\n\t\t\texpectedRemain: \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\" world \"goodbye\"`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemain: \" world \\\"goodbye\\\"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `hello\"world\"`,\n\t\t\texpectedValue:  `hello`,\n\t\t\texpectedRemain: `\"world\"`,\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"he said, \\\"hello\\\"`,\n\t\t\texpectedValue:  `he said, \"hello\"`,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"\" hello`,\n\t\t\texpectedValue:  ``,\n\t\t\texpectedRemain: ` hello`,\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) remain = %q, expectedRemain = %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","60373dd5eb43b7806c0c2d73a68b5a1f":"// parseValue_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \u0026Value{s: \"Hello, World!\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: \u0026Value{s: \"123.456\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{\u0026Value{s: \"1\", t: TypeNumber}, \u0026Value{s: \"2\", t: TypeNumber}, \u0026Value{s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"not_a_json\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [true, false, null]}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse, valueNull}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t// Add more tests as needed\n\t}\n\t\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected != nil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"parseValue(%q) = nil, want %v\", test.input, test.expected)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil \u0026\u0026 !result.Equals(test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif err == nil \u0026\u0026 tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, want empty\", test.input, tail)\n\t\t}\n\t}\n}","61b554d4a71f6eec4c4a774e11524106":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value // Adjust accordingly to what you expect\n\t\terr      bool   // Indicates whether an error is expected\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected result\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"simple object\",\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: /* expected Value setup corresponding to the input */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing closing brace\",\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing colon\",\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing key quote\",\n\t\t\tinput:    `{key1: \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: /* expected Value setup corresponding to the input */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tname:     \"trailing comma\",\n\t\t\tinput:    `{\"key1\": \"value1\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, rest, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Fatalf(\"Expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif err != nil \u0026\u0026 tt.err {\n\t\t\t\treturn // Error expected, skip the rest\n\t\t\t}\n\n\t\t\tif result == nil {\n\t\t\t\tt.Fatal(\"Expected a result but got nil.\")\n\t\t\t}\n\t\t\tif !result.Equals(tt.expected) { // Implement Equals() for Value for comparison\n\t\t\t\tt.Errorf(\"Expected %+v, got %+v\", tt.expected, result)\n\t\t\t}\n\t\t\tif rest == \"\" \u0026\u0026 tt.input != \"\" {\n\t\t\t\tt.Fatal(\"Expected non-empty remaining string, but got empty.\")\n\t\t\t}\n\t\t})\n\t}\n}","61c8116723a685d16e3b316f3a1002d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Test cases for normal unescaping\n\t\t{input: `Hello, \\\"World\\\"!`, expected: `Hello, \"World\"!`},\n\t\t{input: `New line:\\nThis is the second line.`, expected: `New line:\\nThis is the second line.`},\n\t\t{input: `Tab:\\tEnd of the line.`, expected: `Tab:    End of the line.`},\n\t\t{input: `JSON with backslash: \\\\`, expected: `JSON with backslash: \\`},\n\t\t{input: `Unicode: \\u0041`, expected: `Unicode: A`},\n\t\t{input: `Invalid Unicode: \\u004G`, expected: `Invalid Unicode: \\u004G`}, // Invalid escape should remain unchanged\n\t\t{input: `Surrogate Pair: \\uD83D\\uDE00`, expected: `Surrogate Pair: ðŸ˜€`}, // Valid surrogate pair\n\t\t// Edge cases\n\t\t{input: `No escape here!`, expected: `No escape here!`},\n\t\t{input: `\\`, expected: `\\`}, // Just a single backslash\n\t\t{input: `Escaped quotes: \\\" and \\\\`, expected: `Escaped quotes: \" and \\`}, \n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","61fabe52f811641e8d99fbb89579e7fe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\texpectedTail string\n\t\texpectedError string\n\t\tdepth    int\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"cannot parse empty string\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil, // Set to the expected value from parseArray\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\", // Set to any expected error from parseArray\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: nil, // Set to the expected object value\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\", // Set to any expected error from parseObject\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true more data\",\n\t\t\texpected: valueTrue,\n\t\t\texpectedTail: \" more data\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null and some more\",\n\t\t\texpected: valueNull,\n\t\t\texpectedTail: \" and some more\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": true } to many\",\n\t\t\texpected: nil, // Set to the expected object value\n\t\t\texpectedTail: \" to many\",\n\t\t\texpectedError: \"\", // Set to any expected error from parseObject\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nested {\\\"key\\\": {\\\"innerkey\\\": \\\"inner value\\\"}}\",\n\t\t\texpected: nil, // Set as needed for nested JSON\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    1,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [\\\"value1\\\", \\\"value2\\\"]}\",\n\t\t\texpected: nil, // Set as needed for the expected object value\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nested [[1, 2], [3, 4]]\",\n\t\t\texpected: nil, // Set as needed for nested array\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    1,\n\t\t},\n\t\t{\n\t\t\tinput:    \"long nested {\\\"key\\\": nested {\\\"key2\\\": \\\"value2\\\"}}\",\n\t\t\texpected: nil, // Set as needed for the expected object value\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"\",\n\t\t\tdepth:    MaxDepth, // Use the maximum depth\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\" with bad format}\",\n\t\t\texpected: nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"unexpected value found: \\\"{\\\"key\\\" with bad format}\\\"\",\n\t\t\tdepth:    0,\n\t\t},\n\t\t{\n\t\t\tinput:    \"too deep {\\\"key\\\": {\\\"innerkey\\\": {\\\"inscription\\\": {\\\"more\\\": \\\"data\\\"}}}}\",\n\t\t\texpected: nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedError: \"too big depth for the nested JSON; it exceeds 100\", // Assuming MaxDepth is 100\n\t\t\tdepth:    MaxDepth + 1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tresult, tail, err := parseValue(test.input, c, test.depth)\n\n\t\t\tif (err != nil \u0026\u0026 err.Error() != test.expectedError) || (err == nil \u0026\u0026 test.expectedError != \"\") {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", test.expectedError, err)\n\t\t\t}\n\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", test.expected, result)\n\t\t\t}\n\n\t\t\tif tail != test.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail %q, got %q\", test.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","621369ec062ba27fe0667dfb122818cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\ttests := []struct {\n\t\tjsonString   string\n\t\tkeys         []string\n\t\texpectedKeys []string\n\t\texpectedVals []interface{}\n\t}{\n\t\t{\n\t\t\tjsonString:   `{\"key1\":{\"subkey1\": \"value1\"},\"key2\":{\"subkey2\": \"value2\"}}`,\n\t\t\tkeys:         []string{\"key1\"},\n\t\t\texpectedKeys: []string{\"subkey1\"},\n\t\t\texpectedVals: []interface{}{\"value1\"},\n\t\t},\n\t\t{\n\t\t\tjsonString:   `{\"key1\":{\"subkey1\": \"value1\"}}`,\n\t\t\tkeys:         []string{\"key2\"},\n\t\t\texpectedKeys: nil,\n\t\t\texpectedVals: nil,\n\t\t},\n\t\t{\n\t\t\tjsonString:   `{\"array\":[{\"key\": \"value1\"},{\"key\": \"value2\"}]}`,\n\t\t\tkeys:         []string{\"array\", \"1\"},\n\t\t\texpectedKeys: []string{\"key\"},\n\t\t\texpectedVals: []interface{}{\"value2\"},\n\t\t},\n\t\t{\n\t\t\tjsonString:   `{\"invalid_key\": null}`,\n\t\t\tkeys:         []string{\"invalid_key\", \"subkey\"},\n\t\t\texpectedKeys: nil,\n\t\t\texpectedVals: nil,\n\t\t},\n\t\t{\n\t\t\tjsonString:   `{\"key1\": {\"subkey\": {\"nestedKey\": \"nestedValue\"}}}`,\n\t\t\tkeys:         []string{\"key1\", \"subkey\"},\n\t\t\texpectedKeys: []string{\"nestedKey\"},\n\t\t\texpectedVals: []interface{}{\"nestedValue\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tparser := \u0026Parser{}\n\t\tvalue, err := parser.Parse([]byte(test.jsonString))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to parse json: %v\", err)\n\t\t}\n\n\t\tobj := value.GetObject(test.keys...)\n\t\tif obj == nil \u0026\u0026 test.expectedKeys != nil {\n\t\t\tt.Errorf(\"expected an object for keys %v, got nil\", test.keys)\n\t\t\tcontinue\n\t\t}\n\n\t\tif obj != nil {\n\t\t\tfor i, key := range test.expectedKeys {\n\t\t\t\tv := obj.Get(key)\n\t\t\t\tif v == nil {\n\t\t\t\t\tt.Errorf(\"expected value for key %s, got nil\", key)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tactualVal := v.String()\n\t\t\t\tif actualVal != test.expectedVals[i] {\n\t\t\t\t\tt.Errorf(\"for key %s, expected %v, got %v\", key, test.expectedVals[i], actualVal)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","63402e102f86c86928aec807fb0479ab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tinput: \"123.456abc\",\n\t\t\texpectedNum: \"123.456\",\n\t\t\texpectedRest: \"abc\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"-123.456xyz\",\n\t\t\texpectedNum: \"-123.456\",\n\t\t\texpectedRest: \"xyz\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"inf123\",\n\t\t\texpectedNum: \"inf\",\n\t\t\texpectedRest: \"123\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"nan123\",\n\t\t\texpectedNum: \"nan\",\n\t\t\texpectedRest: \"123\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"abc123\",\n\t\t\texpectedNum: \"\",\n\t\t\texpectedRest: \"abc123\",\n\t\t\texpectedErr: fmt.Errorf(\"unexpected char: %q\", \"a\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"\",\n\t\t\texpectedNum: \"\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr: fmt.Errorf(\"unexpected char: %q\", \"\"),\n\t\t},\n\t\t{\n\t\t\tinput: \"NaN\",\n\t\t\texpectedNum: \"NaN\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput: \"Infinity23.45\",\n\t\t\texpectedNum: \"Infinity\",\n\t\t\texpectedRest: \"23.45\",\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\n\t\tif num != test.expectedNum || rest != test.expectedRest || (err != nil \u0026\u0026 test.expectedErr == nil) || (err == nil \u0026\u0026 test.expectedErr != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, num, rest, err, test.expectedNum, test.expectedRest, test.expectedErr)\n\t\t}\n\t}\n}","638aa3553dd719f069b9f6dffc648994":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tobj := \u0026Object{\n\t\tkvs:           []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}, {k: \"key2\", v: \u0026Value{s: \"value2\"}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Check initial state\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\tif !obj.keysUnescaped {\n\t\tt.Fatalf(\"expected keysUnescaped to be true\")\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Verify the state after reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected kvs length to be 0 after reset, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped {\n\t\tt.Fatalf(\"expected keysUnescaped to be false after reset\")\n\t}\n}","63cc792ba38391a1dc1494e0e4f7ffab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* populate expected Value based on your structure */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": 2}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": }`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value with array */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key1\": \"value1\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key1\": \"value1\", \"key2\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected Value with nested object */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tresult, remainder, err := parseObject(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"Unexpected error status: got %v, want %v\", err != nil, tt.err)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 result != nil {\n\t\t\t\t// Optionally compare the actual result with expected value\n\t\t\t\t// This is where you would check the contents of result against tt.expected\n\t\t\t}\n\n\t\t\t// Check if remainder is as expected\n\t\t\tif err == nil \u0026\u0026 remainder != \"\" {\n\t\t\t\tt.Errorf(\"Expected no remainder, got: %s\", remainder)\n\t\t\t}\n\t\t})\n\t}\n}","63d456ce66116ca7c6f98bdfaf7cb763":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectedError    bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e10\", \"-123.45e10\", \"\", false},\n\t\t{\"1.5abc\", \"1.5\", \"abc\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-Inf\", \"-Inf\", \"\", false},\n\t\t{\"NaN123\", \"NaN\", \"123\", false},\n\t\t{\"abc123\", \"\", \"abc123\", true}, // unexpected char\n\t\t{\"+\", \"\", \"+\", true},             // unexpected char\n\t\t{\"-\", \"\", \"-\", true},             // unexpected char\n\t\t{\"1.5e\", \"1.5\", \"e\", false},      // valid number, remaining is 'e'\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\t\tif (err != nil) != test.expectedError {\n\t\t\t\tt.Fatalf(\"Expected error: %v, got: %v\", test.expectedError, err)\n\t\t\t}\n\t\t\tif number != test.expectedNumber {\n\t\t\t\tt.Errorf(\"Expected number: %s, got: %s\", test.expectedNumber, number)\n\t\t\t}\n\t\t\tif remaining != test.expectedRemaining {\n\t\t\t\tt.Errorf(\"Expected remaining: %s, got: %s\", test.expectedRemaining, remaining)\n\t\t\t}\n\t\t})\n\t}\n}","6430a06526b6fe0eb984404080988e8a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"value\" more text`,\n\t\t\texpectedValue:  \"value\",\n\t\t\texpectedRemainder: \" more text\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped \\\" quote\" rest`,\n\t\t\texpectedValue:  \"escaped \\\" quote\",\n\t\t\texpectedRemainder: \" rest\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"another \\\"escaped\\\" string\" and so on`,\n\t\t\texpectedValue:  \"another \\\"escaped\\\" string\",\n\t\t\texpectedRemainder: \" and so on\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"unclosed string`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"string with \\\\\" escapes\"`,\n\t\t\texpectedValue:  \"string with \\\\\",\n\t\t\texpectedRemainder: \" escapes\\\"\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `no quotes`,\n\t\t\texpectedValue:  \"no quotes\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"multiple \\\\\"escaped\\\\\" quotes here\"`,\n\t\t\texpectedValue:  \"multiple \\\\\\\"escaped\\\\\\\" quotes here\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectError:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif test.expectError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Input: %q, expected error but got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Input: %q, got unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"Input: %q, expected value: %q, got: %q\", test.input, test.expectedValue, value)\n\t\t}\n\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"Input: %q, expected remainder: %q, got: %q\", test.input, test.expectedRemainder, remainder)\n\t\t}\n\t}\n}","645caff14b02a94bc8655b0b42b8bae0":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tinput:           `\"Hello, World!\"`,\n\t\t\texpectedValue:   \"Hello, World!\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:     nil,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"Escaped \\\" quotes\"`,\n\t\t\texpectedValue:   \"Escaped \\\" quotes\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:     nil,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"Unclosed string`,\n\t\t\texpectedValue:   \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:     fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:           `Text before \"Main string\" and after`,\n\t\t\texpectedValue:   \"Main string\",\n\t\t\texpectedRemainder: ` and after`,\n\t\t\texpectedErr:     nil,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"Multiple \\\"escaped\\\" characters\"`,\n\t\t\texpectedValue:   \"Multiple \\\"escaped\\\" characters\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:     nil,\n\t\t},\n\t\t{\n\t\t\tinput:           `Empty \"\" string`,\n\t\t\texpectedValue:   \"\",\n\t\t\texpectedRemainder: ` string`,\n\t\t\texpectedErr:     nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif value != test.expectedValue || remainder != test.expectedRemainder || (err != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), expected (%q, %q, %v)\", \n\t\t\t\ttest.input, value, remainder, err, test.expectedValue, test.expectedRemainder, test.expectedErr)\n\t\t}\n\t}\n}","649e83338fd51e1621a05feef82da083":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"simple string\", \"simple string\"},\n\t\t{\"string with \\\\n new line\", \"string with \\n new line\"},\n\t\t{\"string with \\\\t tab\", \"string with \\t tab\"},\n\t\t{\"string with \\\\\\\" quote\", \"string with \\\" quote\"},\n\t\t{\"string with \\\\\\\\ backslash\", \"string with \\\\ backslash\"},\n\t\t{\"string with \\\\/ slash\", \"string with / slash\"},\n\t\t{\"string with \\\\u0041 A\", \"string with A\"},\n\t\t{\"string with invalid \\\\u00\", \"string with invalid \\\\u00\"},\n\t\t{\"string with surrogate \\\\uD83D\\\\uDE00\", \"string with surrogate ðŸ˜€\"},\n\t\t{\"string with incomplete \\\\uD83D\", \"string with incomplete \\\\uD83D\"},\n\t\t{\"string with unknown escape \\\\x\", \"string with unknown escape \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6548e1529105cef09542af737bec500c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: /* a Value representation of the object */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: /* a Value representation of the array */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string\\\"\",\n\t\t\texpected: /* a Value representation of the string */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"12345\",\n\t\t\texpected: /* a Value representation of the number */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[{\\\"key\\\":\\\"value\\\"}]\",\n\t\t\texpected: /* a Value representation of the array containing an object */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: /* a Value representation of the object containing an array */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": null}\",\n\t\t\texpected: /* a Value representation of the object with null value */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": true}\",\n\t\t\texpected: /* a Value representation of the object with boolean value */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": {\\\"nestedKey\\\": 123}}\",\n\t\t\texpected: /* a Value representation of nested object */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif test.err \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"expected an error for input %q, but got none\", test.input)\n\t\t}\n\t\tif !test.err \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t}\n\n\t\tif test.expected != nil \u0026\u0026 v != nil \u0026\u0026 v.Type() != test.expected.Type() {\n\t\t\tt.Errorf(\"mismatched types for input %q: got %v, expected %v\", test.input, v.Type(), test.expected.Type())\n\t\t}\n\n\t\tif tail != \"\" \u0026\u0026 tail != \"\" {\n\t\t\tt.Errorf(\"unexpected tail for input %q: got %q\", test.input, tail)\n\t\t}\n\t}\n}","65d4ee93a3ee3af7d8087f02220faf12":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test initial state\n\tkvs := obj.getKV()\n\tif kvs == nil {\n\t\tt.Error(\"Expected kv to be non-nil after calling getKV on a new Object\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Verify the kv's initial values\n\tif kvs.k != \"\" {\n\t\tt.Errorf(\"Expected kv key to be empty, got %s\", kvs.k)\n\t}\n\tif kvs.v != nil {\n\t\tt.Errorf(\"Expected kv value to be nil, got %v\", kvs.v)\n\t}\n\n\t// Add another kv\n\tkvs2 := obj.getKV()\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Check the second kv\n\tif kvs2.k != \"\" {\n\t\tt.Errorf(\"Expected second kv key to be empty, got %s\", kvs2.k)\n\t}\n\tif kvs2.v != nil {\n\t\tt.Errorf(\"Expected second kv value to be nil, got %v\", kvs2.v)\n\t}\n\n\t// Test growing capacity handling\n\tobj.kvs = make([]kv, 0, 1) // set capacity\n\tkvs3 := obj.getKV()\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected kvs length to be 1 after capacity handling, got %d\", len(obj.kvs))\n\t}\n}","65fc2fe3ed6e0aadf459c8a6722c7911":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := \u0026cache{\n\t\tvs: make([]Value, 0),\n\t}\n\n\t// First call to getValue should add a new Value to the cache\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Fatal(\"Expected a non-nil Value\")\n\t}\n\n\t// Check that the length of vs has increased\n\tif len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected vs length to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Second call to getValue should return the same Value instance\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Fatal(\"Expected a non-nil Value\")\n\t}\n\n\tif val1 == val2 {\n\t\tt.Log(\"Success: The same Value instance is returned on subsequent calls\")\n\t} else {\n\t\tt.Fatal(\"Expected the same Value instance, got different instances\")\n\t}\n\n\t// Check that the length of vs has increased\n\tif len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected vs length to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Check that the capacity of vs has also increased\n\tif cap(c.vs) \u003c 2 {\n\t\tt.Fatalf(\"Expected capacity of vs to be at least 2, got %d\", cap(c.vs))\n\t}\n\n\t// Call getValue again and check the new instance\n\tval3 := c.getValue()\n\tif val3 == nil {\n\t\tt.Fatal(\"Expected a non-nil Value\")\n\t}\n\n\t// Ensure val3 is a new instance\n\tif val3 == val1 || val3 == val2 {\n\t\tt.Fatal(\"Expected a new Value instance, got a previously returned instance\")\n\t}\n\n\t// Ensure the length has now increased to 3\n\tif len(c.vs) != 3 {\n\t\tt.Fatalf(\"Expected vs length to be 3, got %d\", len(c.vs))\n\t}\n}","667c7903ac2f443de1f8b57d78b53346":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tcache := \u0026cache{}\n\n\t// Test cases\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\"\", nil, true}, // test for empty string\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false}, // test for an empty object\n\t\t{\"[]\", \u0026Value{t: TypeArray}, false},  // test for an empty array\n\t\t{\"\\\"test\\\"\", \u0026Value{s: \"test\", t: typeRawString}, false}, // test for a string\n\t\t{\"true\", valueTrue, false}, // test for true\n\t\t{\"false\", valueFalse, false}, // test for false\n\t\t{\"null\", valueNull, false}, // test for null\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, false}, // test for a number\n\t\t{\"invalid\", nil, true}, // test for unexpected value\n\t\t{\"[1, 2, 3]\", nil, false}, // more complex array input (depends on implementation)\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", nil, false}, // more complex object input (depends on implementation)\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(test.input, cache, 0)\n\n\t\t\tif (err != nil) != test.err {\n\t\t\t\tt.Fatalf(\"expected error: %v, got error: %v\", test.err, err)\n\t\t\t}\n\t\t\tif !test.err \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\t\tt.Fatalf(\"expected: %+v, got: %+v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues compares two Value structs for equality.\n// This function might need to be implemented depending on the structure of Value.\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == nil \u0026\u0026 v2 == nil\n\t}\n\treturn v1.t == v2.t \u0026\u0026 v1.s == v2.s \u0026\u0026 len(v1.a) == len(v2.a)\n}","668a856045bb7eb8bad1930a3275cef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    \"\\\"hello \\\\\\\"world\\\\\\\"\\\"\", // escaped quotes\n\t\t\texpected: `\"hello \"world\"\"`,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"line1\\\\nline2\\\"\", // newline\n\t\t\texpected: \"line1\\nline2\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"tab\\\\tcharacter\\\"\", // tab\n\t\t\texpected: \"tab\\tcharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"backslash \\\\\\\\\\\"\", // escaped backslash\n\t\t\texpected: \"backslash \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"unicode \\\\u3042\\\"\", // unicode escape (ã‚)\n\t\t\texpected: \"unicode ã‚\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"invalid \\\\uXYZ\\\"\", // invalid unicode escape\n\t\t\texpected: \"invalid \\\\uXYZ\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"surrogate \\\\uD83D\\\\uDE00\\\"\", // valid surrogate pair (ðŸ˜€)\n\t\t\texpected: \"surrogate ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"escaped\\\\/slash\\\"\", // escaped forward slash\n\t\t\texpected: \"escaped/slash\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"no escape sequence\\\"\", // no escape sequences\n\t\t\texpected: \"no escape sequence\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\\x42\", // unknown escape sequence\n\t\t\texpected: \"\\\\x42\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\", // empty string\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6731289aaef77b8400d83d46dbc76417":"package fastjson\n\nimport \"testing\"\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\texpect bool\n\t}{\n\t\t{\"normalString\", false},\n\t\t{\"stringWith\\\"Quote\", true},\n\t\t{\"stringWith\\\\Backslash\", true},\n\t\t{\"stringWith\\006\", true}, // Control character\n\t\t{\"anotherNormalString\", false},\n\t\t{\"stringWithNull\\000\", true}, // Null character\n\t\t{\"stringWithNewline\\n\", true}, // Newline character\n\t\t{\"stringWithTab\\t\", true},     // Tab character\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; want %v\", test.input, result, test.expect)\n\t\t}\n\t}\n}\n","67b025a3b6f0c6ae2fda197859e96ab1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\t// Create a new cache for testing.\n\tc := \u0026cache{vs: make([]Value, 0)}\n\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\texpected:    nil,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"null\",\n\t\t\texpected:    valueNull,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"true\",\n\t\t\texpected:    valueTrue,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"false\",\n\t\t\texpected:    valueFalse,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"example\"`,\n\t\t\texpected:    \u0026Value{s: \"example\", t: typeRawString},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"}`,\n\t\t\texpected:    \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, keysUnescaped: false},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `[1, 2, 3]`,\n\t\t\texpected:    \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"nested\": [1, 2, 3]}`,\n\t\t\texpected:    \u0026Value{o: Object{kvs: []kv{{k: \"nested\", v: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}}}}}, keysUnescaped: false},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key\": undefined}`,\n\t\t\texpected:    nil,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       `[{}`,\n\t\t\texpected:    nil,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       `1.23`,\n\t\t\texpected:    \u0026Value{s: \"1.23\", t: TypeNumber},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `-1.23`,\n\t\t\texpected:    \u0026Value{s: \"-1.23\", t: TypeNumber},\n\t\t\texpectedErr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, wantErr %v\", test.input, err, test.expectedErr)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.expectedErr \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper function to compare two Value instances.\nfunc compareValues(v1, v2 *Value) bool {\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\tif v1.s != v2.s || v1.t != v2.t {\n\t\treturn false\n\t}\n\t// Comparison logic for Object and Array should be added here if needed...\n\treturn true\n}","6804e2a188450095521d19251089a3cd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Escaped quote: \\\\\\\"example\\\\\\\"\", \"Escaped quote: \\\"example\\\"\"},\n\t\t{\"Line break: \\\\nNew line here.\", \"Line break: \\nNew line here.\"},\n\t\t{\"Tab character: \\\\tTabbed here.\", \"Tab character: \\tTabbed here.\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Invalid unicode: \\\\u123\", \"Invalid unicode: \\\\u123\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: ðŸ˜€\"}, // assuming the decoding is correct\n\t\t{\"Mixed: Hello \\\\n World \\\\t !\", \"Mixed: Hello \\n World \\t !\"},\n\t\t{\"Unescaped: Just a string\", \"Just a string\"},\n\t\t{\"Multiple \\\\u003C escape sequences\", \"Multiple \u003c escape sequences\"}, // assuming the unicode is decoded to '\u003c'\n\t\t{\"Not a valid escape \\\\x\", \"Not a valid escape \\\\x\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","682443aef2bd906bc6223297b5892cb3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Line 1\\\\nLine 2\", \"Line 1\\nLine 2\"},\n\t\t{\"Tab\\\\tCharacter\", \"Tab\\tCharacter\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Quote: \\\\\\\"\", \"Quote: \\\"\"},\n\t\t{\"Unicode \\\\u0041\", \"Unicode A\"},\n\t\t{\"Invalid Unicode \\\\u123\", \"Invalid Unicode \\\\u123\"},\n\t\t{\"Mixed \\\\n String with \\\\t Tab\", \"Mixed \\n String with \\t Tab\"},\n\t\t{\"Escape sequence: \\\\x\", \"Escape sequence: \\\\x\"}, // This should be stored unchanged\n\t\t{\"Surrogate: \\\\uD83D\\\\uDE00\", \"Surrogate: ðŸ˜€\"}, // Example of valid surrogate\n\t\t{\"Invalid Surrogate: \\\\uD83D\\\\uDE00\\\\uD83D\", \"Invalid Surrogate: \\\\uD83D\\\\uDE00\\\\uD83D\"}, // string ends without proper surrogate\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","687b07e488e0a192515ad3f89d12c2ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", \"Hello, \\\"World!\\\"\"},\n\t\t{\"Hello, \\\\\\\\World!\", \"Hello, \\\\World!\"},\n\t\t{\"Newline:\\\\nTest\", \"Newline:\\nTest\"},\n\t\t{\"Tab:\\\\tTest\", \"Tab:\\tTest\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: ä½ å¥½\"}, // \"ä½ å¥½\" is \"Hello\" in Chinese\n\t\t{\"Invalid unicode: \\\\uXYZ\", \"Invalid unicode: \\\\uXYZ\"},\n\t\t{\"Mixed: \\\\nText and \\\\uD83D\\\\uDE00\", \"Mixed: \\nText and ðŸ˜€\"}, // ðŸ˜€ is a smiley face\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"No escape seq\", \"No escape seq\"},\n\t\t{\"Incomplete: \\\\u\", \"Incomplete: \\\\u\"},\n\t\t{\"Multiple Lines: \\\\nFirst Line\\\\nSecond Line\", \"Multiple Lines: \\nFirst Line\\nSecond Line\"},\n\t\t{\"Escaped Characters: \\\\\\\"This is a test.\\\\\\\"\", \"Escaped Characters: \\\"This is a test.\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected unescapeStringBestEffort(%q) = %q, got %q\", test.input, test.expected, result)\n\t\t}\n\t}\n}","68808cd021a8ac028c0531f9704bfc29":"// file: getkv_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Initially, there should be no kvs\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected initial length of kvs to be 0, got %d\", len(obj.kvs))\n\t}\n\n\t// Call getKV once\n\tkv := obj.getKV()\n\tif kv == nil {\n\t\tt.Error(\"Expected kv not to be nil after calling getKV once\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs after one call to getKV to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Call getKV again\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Error(\"Expected kv2 not to be nil after calling getKV twice\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of kvs after two calls to getKV to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Check if kv points to the new item\n\tif kv == kv2 {\n\t\tt.Error(\"Expected different kv references for each call to getKV\")\n\t}\n\n\t// Ensure that the kvs slice is correctly populated\n\tif obj.kvs[0] == (kv{}) || obj.kvs[1] == (kv{}) {\n\t\tt.Error(\"Expected kvs to be properly populated after calls to getKV\")\n\t}\n}","68fecac4233379e0ee0add4e25802abc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedLen int\n\t\texpectError bool\n\t}{\n\t\t{\"[]\", 0, false},\n\t\t{\"[1, 2, 3]\", 3, false},\n\t\t{\"[true, false, null]\", 3, false},\n\t\t{\"[\\\"one\\\", \\\"two\\\", \\\"three\\\"]\", 3, false},\n\t\t{\"[1, 2, ]\", 0, true}, // Case with trailing comma\n\t\t{\"[1, , 3]\", 0, true}, // Case with missing value\n\t\t{\"[1, 2, 3\", 0, true}, // Case with missing closing bracket\n\t\t{\"[1, 2, 3,]\", 0, true}, // Case with comma after last value\n\t\t{\"[1, 2, [3, 4]]\", 3, false}, // Nested array\n\t\t{\"[1, 2, {\\\"key\\\": \\\"value\\\"}]\", 3, false}, // Array with object\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseArray(test.input, c, 0)\n\t\tif test.expectError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q but got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %s\", test.input, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(result.a) != test.expectedLen {\n\t\t\t\tt.Errorf(\"Expected array length %d for input %q but got %d\", test.expectedLen, test.input, len(result.a))\n\t\t\t}\n\t\t\tif remainder == test.input {\n\t\t\t\tt.Errorf(\"Expected remainder different from input for %q, got %q\", test.input, remainder)\n\t\t\t}\n\t\t}\n\t}\n}","691a36d7ea06c6aa770c81bab56634b6":"// unescapeStringBestEffort_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\nworld\", \"hello\\nworld\"},\n\t\t{\"quote: \\\\\\\"example\\\\\\\"\", `quote: \"example\"`},\n\t\t{\"backslash: \\\\\\\\\", \"backslash: \\\\\"},\n\t\t{\"unicode: \\\\u0041\\\\u0042\", \"unicode: AB\"},\n\t\t{\"invalid unicode: \\\\u123\", \"invalid unicode: \\\\u123\"},\n\t\t{\"surrogate: \\\\uD83D\\\\uDE00\", \"surrogate: ðŸ˜€\"},\n\t\t{\"mixed: \\\\n\\\\t\\\\u0021\", \"mixed: \\n\\t!\"},\n\t\t{\"escaped slashes: \\\\/\\\\/example\", \"escaped slashes: //example\"},\n\t\t{\"unescaped: \\n\\t\\\\\\\"\", \"\\n\\t\\\"\"},\n\t\t{\"complex: \\\\n\\\\uD83D\\\\uDE03 and \\\\t\", \"complex: \\nðŸ˜ƒ and \\t\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6978245fc46d5f25aaf2c8cac4473f73":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRemainder string\n\t\texpectedError   bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e10 more text\", \"-123.45e10\", \"more text\", false},\n\t\t{\"inf123\", \"inf\", \"123\", false},\n\t\t{\"nan45\", \"nan\", \"45\", false},\n\t\t{\"123.45e+6text\", \"123.45e+6\", \"text\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"invalid123\", \"\", \"invalid123\", true},\n\t\t{\"\", \"\", \"\", true}, // expecting error for empty string input\n\t\t{\"-12.34.56\", \"-12.34\", \".56\", false}, // valid but with extra '.', should return up to first invalid character\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remainder, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, number, test.expectedNumber)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remainder = %q, expected %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","69e14af1a1cf177e765068338ea97f04":"// bool_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Bool(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected bool\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"true value\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: true,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"false value\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: false,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"nil value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: false,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"number value\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber},\n\t\t\texpected: false,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"string value\",\n\t\t\tvalue:    \u0026Value{t: TypeString},\n\t\t\texpected: false,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"array value\",\n\t\t\tvalue:    \u0026Value{t: TypeArray},\n\t\t\texpected: false,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"object value\",\n\t\t\tvalue:    \u0026Value{t: TypeObject},\n\t\t\texpected: false,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, err := tt.value.Bool()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Bool() error = %v, wantErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Bool() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","6aca4cb03aca002182ddf53b78161961":"// file: hasSpecialChars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"hello\", false},                         // No special characters\n\t\t{\"hello world\", false},                   // No special characters\n\t\t{\"hello\\\"world\", true},                   // Contains double quote\n\t\t{\"hello\\\\world\", true},                   // Contains backslash\n\t\t{\"hello\\x00world\", true},                 // Contains null character\n\t\t{\"normal text\", false},                   // No special characters\n\t\t{\"text with\\033 escape\", true},           // Contains escape sequence\n\t\t{\"\\nnew line\", true},                     // Contains newline character\n\t\t{\"\\t tab character\", true},               // Contains tab character\n\t\t{\"!@#$%^\u0026*()\", true},                      // Contains special symbols\n\t\t{\"valid_string\", false},                  // Valid string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6b4af14a43e831b21c655ba7bacce0d5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Empty Array\",\n\t\t\tvalue:    \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\texpected: \"[]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Single Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"Simple Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Complex JSON\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"array\", v: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\t\t\t\u0026Value{t: TypeString, s: \"hello\"},\n\t\t\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\t\t\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"array\":[\"hello\",42,true]}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"example\",\n\t\t\t},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Null Value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Boolean True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Boolean False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo([]byte{})\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","6b82b35fcceba03b7e2a861d1ca8a1bc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\tdepth:    0,\n\t\t\texpected: /* expected Value for a JSON object */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\tdepth:    0,\n\t\t\texpected: /* expected Value for a JSON array */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"a string\\\"\",\n\t\t\tdepth:    0,\n\t\t\texpected: /* expected Value for a JSON string */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\tdepth:    0,\n\t\t\texpected: /* expected Value for a JSON number */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\tdepth:    0,\n\t\t\texpected: /* expected Value for NaN */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: /* expected Value for a nested JSON object */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\tdepth:    MaxDepth + 1,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, _, err := parseValue(test.input, c, test.depth)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q, %d) error: expected %v, got %v\", test.input, test.depth, test.err, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err \u0026\u0026 !compareValues(v, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = %v; expected %v\", test.input, test.depth, v, test.expected)\n\t\t}\n\t}\n}","6d3a5822e00fab03ff2f1d46789bc3de":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  error\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello world\" more text`,\n\t\t\texpectedValue: \"hello world\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\" quote\"` + ` other text`,\n\t\t\texpectedValue: `escaped \" quote`,\n\t\t\texpectedRest:  ` other text`,\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"simple\"`,\n\t\t\texpectedValue: \"simple\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\\\\\" quote\" trailing text`,\n\t\t\texpectedValue: `escaped \\` + `\\\" quote`,\n\t\t\texpectedRest:  ` trailing text`,\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"double escaped \\\\\\\\\"`,\n\t\t\texpectedValue: `double escaped \\\\`,\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"first part\\\" second part\\\"`,\n\t\t\texpectedValue: `first part\\\"`,\n\t\t\texpectedRest:  ` second part\\\"`,\n\t\t\texpectedError: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tactualValue, actualRest, actualError := parseRawString(test.input)\n\n\t\tif actualValue != test.expectedValue || actualRest != test.expectedRest || (actualError != nil) != (test.expectedError != nil) {\n\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, actualValue, actualRest, actualError, \n\t\t\t\ttest.expectedValue, test.expectedRest, test.expectedError)\n\t\t}\n\t}\n}","6d42cc491bb7931af5168fb29d450757":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t// Valid cases\n\t\t{\"123\", \"123\", \"\", false},\n\t\t{\"-456\", \"-456\", \"\", false},\n\t\t{\"3.14\", \"3.14\", \"\", false},\n\t\t{\"2e10\", \"2e10\", \"\", false},\n\t\t{\"-1.5e-10\", \"-1.5e-10\", \"\", false},\n\t\t{\"Inf123X\", \"Inf\", \"123X\", false},\n\t\t{\"NaNabc\", \"NaN\", \"abc\", false},\n\n\t\t// Edge cases\n\t\t{\"\", \"\", \"\", true},               // Empty string\n\t\t{\"abc\", \"\", \"abc\", true},        // Non-number prefix\n\t\t{\"-abc\", \"\", \"-abc\", true},      // Non-number after sign\n\t\t{\"0.12.34\", \"0.12\", \".34\", false}, // Multiple decimal points\n\t\t{\"123abc\", \"123\", \"abc\", false}, // Number followed by characters\n\t\t{\"+-123\", \"\", \"+-123\", true},    // Invalid sign combination\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawNumber(test.input)\n\t\t\n\t\t// Check expected error\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\t\n\t\t// Check expected value\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expectedValue %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\t\n\t\t// Check expected remainder\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remainder = %q, expectedRemainder %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","6d5a8b1708e96dcfd891f4e6f778b2eb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.456\", \"-123.456\", \"\", false},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"NaN\", \"NaN\", \"\", false},\n\t\t{\"1.5abc\", \"1.5\", \"abc\", false},\n\t\t{\"-1.5e+3xyz\", \"-1.5e+3\", \"xyz\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"\", \"\", \"\", true},  // this case requires len(s) \u003e 0\n\t\t{\"-inf3.14\", \"-inf\", \"3.14\", false},\n\t\t{\"++1\", \"\", \"++1\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remainder, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected = %q\", test.input, number, test.expectedNumber)\n\t\t}\n\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remainder = %q, expected = %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","6da65682ce259312ae9b4cdb1e73416a":"// File: parse_raw_number_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-1.23e+10xyz\", \"-1.23e+10\", \"xyz\", false},\n\t\t{\"inf more text\", \"inf\", \" more text\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan something\", \"nan\", \" something\", false},\n\t\t{\"123abc456\", \"123\", \"abc456\", false},\n\t\t{\"+3.14something\", \"+3.14\", \"something\", false},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"abc\", \"\", \"\", true},\n\t\t{\"++2\", \"\", \"++2\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresultNumber, resultRest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif resultNumber != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, resultNumber, test.expectedNumber)\n\t\t}\n\t\tif resultRest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", test.input, resultRest, test.expectedRest)\n\t\t}\n\t}\n}","6db00f06325b618d849dc56822ae75ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput     string\n\t\tdepth     int\n\t\texpected  *Value\n\t\twantErr   bool\n\t\terrMsg    string\n\t}{\n\t\t{\n\t\t\tinput:     \"\",\n\t\t\tdepth:     0,\n\t\t\texpected:  nil,\n\t\t\twantErr:   true,\n\t\t\terrMsg:    \"cannot parse empty string\",\n\t\t},\n\t\t{\n\t\t\tinput:     \"[]\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeArray},\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"{}\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeObject},\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"\\\"string\\\"\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeString, s: \"string\"},\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"true\",\n\t\t\tdepth:     0,\n\t\t\texpected:  valueTrue,\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"false\",\n\t\t\tdepth:     0,\n\t\t\texpected:  valueFalse,\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"null\",\n\t\t\tdepth:     0,\n\t\t\texpected:  valueNull,\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"123.45\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeNumber, s: \"123.45\"},\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"{}\",\n\t\t\tdepth:     MaxDepth,\n\t\t\texpected:  nil,\n\t\t\twantErr:   true,\n\t\t\terrMsg:    \"too big depth for the nested JSON; it exceeds 100\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(test.input, c, test.depth)\n\n\t\t\tif (err != nil) != test.wantErr {\n\t\t\t\tt.Errorf(\"unexpected error status for input %q: got %v, want %v\", test.input, err != nil, test.wantErr)\n\t\t\t\tif test.wantErr \u0026\u0026 err != nil \u0026\u0026 err.Error() != test.errMsg {\n\t\t\t\t\tt.Errorf(\"unexpected error message: got %v, want %v\", err.Error(), test.errMsg)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\tif result == nil \u0026\u0026 test.expected != nil {\n\t\t\t\t\tt.Errorf(\"expected non-nil Value for input %q, got nil\", test.input)\n\t\t\t\t} else if result != nil \u0026\u0026 test.expected == nil {\n\t\t\t\t\tt.Errorf(\"expected nil Value for input %q, got %v\", test.input, result)\n\t\t\t\t} else if result != nil \u0026\u0026 resulting.Type() != test.expected.t {\n\t\t\t\t\tt.Errorf(\"unexpected Value type for input %q: got %v, want %v\", test.input, result.Type(), test.expected.t)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","6df0d4e5d8c2ff606085628a104b67b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremains  string\n\t\thasError bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45abc\", \"-123.45\", \"abc\", false},\n\t\t{\"3.14 is pi\", \"3.14\", \" is pi\", false},\n\t\t{\"inf test\", \"inf\", \" test\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan more\", \"nan\", \" more\", false},\n\t\t{\"1.2e10\", \"1.2e10\", \"\", false},\n\t\t{\"1.2e+10\", \"1.2e+10\", \"\", false},\n\t\t{\"1.2e-10\", \"1.2e-10\", \"\", false},\n\t\t{\"+3.14 next\", \"+3.14\", \" next\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"1.23abc456\", \"1.23\", \"abc456\", false},\n\t\t{\"\", \"\", \"\", true}, // Edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remains, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.hasError {\n\t\t\tt.Fatalf(\"parseRawNumber(%q) returned unexpected error status: %v\", test.input, err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"expected result %q, got %q\", test.expected, result)\n\t\t}\n\t\tif remains != test.remains {\n\t\t\tt.Errorf(\"expected remains %q, got %q\", test.remains, remains)\n\t\t}\n\t}\n}","6e33d0d62a23a8721caad8b3e9af809d":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n\\nHello\", \"Hello\"},\n\t\t{\"\\tHello\", \"Hello\"},\n\t\t{\"\\r\\nHello\", \"Hello\"},\n\t\t{\"\\t \\n \\r Hello\", \"Hello\"},\n\t\t{\"   \\t\\n\\r\", \"\"},\n\t\t{\"NoSpaces\", \"NoSpaces\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\", \"\"},\n\t\t{\" \\n \\t \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6e8502e4888bb33c5d31d62ffdb69b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"abc\", \"abc\"},                                     // no escape characters\n\t\t{\"\\\\n\", \"\\n\"},                                     // newline escape\n\t\t{\"\\\\t\", \"\\t\"},                                     // tab escape\n\t\t{\"\\\\\\\"\", \"\\\"\"},                                   // double quote escape\n\t\t{\"\\\\\\\\\", \"\\\\\"},                                   // backslash escape\n\t\t{\"\\\\b\", \"\\b\"},                                    // backspace escape\n\t\t{\"\\\\f\", \"\\f\"},                                    // form feed escape\n\t\t{\"\\\\r\", \"\\r\"},                                    // carriage return escape\n\t\t{`hello \\u1234 world`, \"hello ð’´ world\"},         // valid Unicode escape\n\t\t{`hello \\u123G`, \"hello \\\\u123G\"},                // invalid Unicode escape\n\t\t{`hello \\uD83D\\uDE00`, \"hello ðŸ˜€\"},               // surrogate pair \n\t\t{`hello \\\\uD83D\\\\uDE00`, \"hello \\\\uD83D\\\\uDE00\"}, // stored unchanged\n\t\t{\"\", \"\"},                                          // empty string\n\t\t{\"Escaped \\\\n new line\", \"Escaped \\n new line\"}, // mixed content\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","6f19aa110e6aa422ecee615bd3adb1ca":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"test\", \"test\"},                                 // No escape sequences\n\t\t{\"\\\\\\\"\", \"\\\"\"},                                  // Escaped quote\n\t\t{\"\\\\n\", \"\\n\"},                                   // Escaped newline\n\t\t{\"test\\\\tstring\", \"test\\tstring\"},               // Tab escape\n\t\t{\"backslash\\\\\\\\\", \"backslash\\\\\"},                // Escaped backslash\n\t\t{\"utf8\\\\u03A9\", \"utf8Î©\"},                        // Unicode sequence\n\t\t{\"not\\\\uD83D\\\\uDE00escaped\", \"notðŸ˜€escaped\"},    // Valid surrogate pair\n\t\t{\"invalid\\\\uD83Dnot\", \"invalid\\\\uD83Dnot\"},     // Invalid surrogate\n\t\t{\"mixed\\\\uXXXXand\\\\uD83D\\\\uDE00\", \"mixed\\\\uXXXXandðŸ˜€\"}, // Mixed valid and invalid\n\t\t{\"\\\\uXYZ\", \"\\\\uXYZ\"},                            // Invalid unicode\n\t\t{\"string with no escape\", \"string with no escape\"}, // No escape\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","6f44ad38d1750d682e4dc5ccc8c22331":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\"{}\", \u0026Value{t: TypeObject}, false},\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\"}}}}}, false},\n\t\t{\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"}\", \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\"}}, {k: \"key2\", v: \u0026Value{s: \"value2\"}}}}}, false},\n\t\t{\"{key: \\\"value\\\"}\", nil, true},\n\t\t{\"{\\\"key\\\": value}\", nil, true},\n\t\t{\"{\\\"key\\\": \\\"value\\\",}\", nil, true},\n\t\t{\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"\", nil, true},\n\t\t{\"{}\", nil, true},\n\t\t{\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": }\", nil, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.hasError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %q but got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"did not expect an error for input %q but got: %v\", test.input, err)\n\t\t\t}\n\t\t\tif result == nil || result.t != test.expected.t || len(result.o.kvs) != len(test.expected.o.kvs) {\n\t\t\t\tt.Errorf(\"for input %q, expected %v but got %v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}","6f51b309595c1399dbabe55956e4e70a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue string\n\t\texpectedRest  string\n\t\texpectedError bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"escape \\\\\\\" quote\\\"\", \"escape \\\" quote\", \"\", false},\n\t\t{\"\\\"open string\", \"\", \"\", true}, // Missing closing quote\n\t\t{\"\\\"escaped \\\\\" , \"\", \"\", true}, // Invalid escape sequence\n\t\t{\"\\\\\\\"escaped string\\\\\\\"\", \"escaped string\\\"\", \"\", false},\n\t\t{\"\\\"multiple \\\\\\\"escaped quotes\\\\\\\" inside\\\"\", \"multiple \\\"escaped quotes\\\" inside\", \"\", false},\n\t\t{\"\\\"trailing text\\\" blah\", \"trailing text\", \" blah\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantError = %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) value = %q, want = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want = %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","6fab218b3923aaaeb15f025f2a5a7e40":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\"quote\\\" here\" and more`,\n\t\t\texpected: \"escaped \\\"quote\\\" here\",\n\t\t\trest:     \" and more\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"incomplete string`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"multiple \\\"escaped quotes\\\" in \\\"this string\\\" here\"`,\n\t\t\texpected: \"multiple \\\"escaped quotes\\\" in \\\"this string\\\" here\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"another \\\\\"escaped\\\\\" string\" continues here`,\n\t\t\texpected: \"another \\\\escaped\\\\ string\",\n\t\t\trest:     \" continues here\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected an error for input %q, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Did not expect an error for input %q, got: %v\", test.input, err)\n\t\t\t}\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"Expected %q, got %q for input %q\", test.expected, result, test.input)\n\t\t\t}\n\t\t\tif rest != test.rest {\n\t\t\t\tt.Errorf(\"Expected rest %q, got %q for input %q\", test.rest, rest, test.input)\n\t\t\t}\n\t\t}\n\t}\n}","6fd24ebeaee11084b0c385bb63aecac6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\t// Create a cache for use in the tests.\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedLen int\n\t\texpectError bool\n\t}{\n\t\t{\"[1, 2, 3]\", 3, false},\n\t\t{\"[]\", 0, false},\n\t\t{\"[1, 2, 3,]\", 0, true}, // Invalid due to trailing comma\n\t\t{\"[1, true, null, \\\"string\\\"]\", 4, false},\n\t\t{\"[\", 0, true},          // Invalid due to missing closing bracket\n\t\t{\"]\", 0, true},          // Invalid due to missing values\n\t}\n\n\tfor _, test := range tests {\n\t\t// Call parseArray with a depth of 0\n\t\tresult, remainder, err := parseArray(test.input, c, 0)\n\n\t\t// Check for errors\n\t\tif test.expectError \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"Expected error for input %q, got none\", test.input)\n\t\t}\n\t\tif !test.expectError \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t}\n\n\t\t// If no error is expected, verify the length of the array\n\t\tif !test.expectError {\n\t\t\tif result == nil {\n\t\t\t\tt.Errorf(\"Expected result not to be nil for input %q\", test.input)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(result.a) != test.expectedLen {\n\t\t\t\tt.Errorf(\"Expected length %d, got %d for input %q\", test.expectedLen, len(result.a), test.input)\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Check the remainder: it should be either empty or start with the closing bracket\n\t\tif (len(remainder) \u003e 0 \u0026\u0026 remainder[0] != ']') \u0026\u0026 !test.expectError {\n\t\t\tt.Errorf(\"Unexpected remainder for input %q: %q\", test.input, remainder)\n\t\t}\n\t}\n}","7058efd0c56b597cc2d9223ff1700ad9":"// visit_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestVisit(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tobject   *Object\n\t\texpected map[string]*Value // expected key-value pairs\n\t}{\n\t\t{\n\t\t\tname: \"single key-value pair\",\n\t\t\tobject: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\"key1\", \u0026Value{s: \"value1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: map[string]*Value{\"key1\": \u0026Value{s: \"value1\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple key-value pairs\",\n\t\t\tobject: \u0026Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\"key1\", \u0026Value{s: \"value1\"}},\n\t\t\t\t\t{\"key2\", \u0026Value{s: \"value2\"}},\n\t\t\t\t\t{\"key3\", \u0026Value{s: \"value3\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: map[string]*Value{\n\t\t\t\t\"key1\": \u0026Value{s: \"value1\"},\n\t\t\t\t\"key2\": \u0026Value{s: \"value2\"},\n\t\t\t\t\"key3\": \u0026Value{s: \"value3\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tobject: \u0026Object{\n\t\t\t\tkvs: []kv{},\n\t\t\t},\n\t\t\texpected: map[string]*Value{},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tcalls := make(map[string]*Value)\n\t\t\ttt.object.Visit(func(key []byte, v *Value) {\n\t\t\t\tcalls[string(key)] = v\n\t\t\t})\n\n\t\t\t// Verify that the expected map matches the calls made during Visit\n\t\t\tfor k, v := range tt.expected {\n\t\t\t\tif val, exists := calls[k]; !exists || val != v {\n\t\t\t\t\tt.Errorf(\"Expected key: %s with value: %v, got value: %v\", k, v, val)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(calls) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %d calls, got %d\", len(tt.expected), len(calls))\n\t\t\t}\n\t\t})\n\t}\n}","706865992798e2e97cf456a24af456c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escape\\\\nNewline\"`,\n\t\t\texpected: \"Escape\\nNewline\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\\\tCharacter\"`,\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash\\\\\\\\\"`,\n\t\t\texpected: \"Backslash\\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid\\\\uXYZ\"`,\n\t\t\texpected: \"Invalid\\\\uXYZ\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode\\\\u0041\"`,\n\t\t\texpected: \"UnicodeA\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate\\\\uD83D\\\\uDE00\"`, // ðŸ˜€ face emoji\n\t\t\texpected: \"SurrogateðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Incomplete\\\\u004\"`,\n\t\t\texpected: \"Incomplete\\\\u004\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed\\\\uD83D\\\\uDE00Characters\\\\uD83C\\\\uDF63\"`, // Mixed characters\n\t\t\texpected: \"MixedðŸ˜€CharactersðŸŒ³\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Normal string without escape\"`,\n\t\t\texpected: \"Normal string without escape\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","706e5a0147669f36804cbc0a3f095f5e":"// unescapeStringBestEffort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"hello\", \"hello\"},\n\t\t{\"\\\"hello\\\"\", \"hello\"},\n\t\t{\"hello\\\\nworld\", \"hello\\nworld\"},\n\t\t{\"hello\\\\tworld\", \"hello\\tworld\"},\n\t\t{\"hello\\\\\\\"world\\\"\", \"hello\\\"world\"},\n\t\t{\"hello\\\\\\\\world\", \"hello\\\\world\"},\n\t\t{\"hello\\\\bworld\", \"hello\\bworld\"},\n\t\t{\"hello\\\\fworld\", \"hello\\fworld\"},\n\t\t{\"hello\\\\rworld\", \"hello\\rworld\"},\n\t\t{\"hello\\\\uworld\", \"hello\\\\uworld\"}, // Testing invalid unicode\n\t\t{\"hello\\\\u0041world\", \"helloAworld\"}, // Valid unicode\n\t\t{\"\\\\uD83D\\\\uDE00\", \"ðŸ˜€\"}, // Valid surrogate pair\n\t\t{\"Hello\\\\uD83D\\\\uDC36world\", \"HelloðŸ¶world\"}, // Another valid surrogate\n\t\t{\"Invalid\\\\xXXescape\", \"Invalid\\\\xXXescape\"}, // Testing invalid escape sequence\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","70a38a44496c23ee87fb465becf29b01":"// file: marshal_to_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tv    *Value\n\t\tdst  []byte\n\t\twant []byte\n\t}{\n\t\t{\n\t\t\tname: \"Test Raw String\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test Number\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123\",\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test True\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test False\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test Null\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test String with Escape\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\\nworld\",\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: escapeString([]byte{}, \"hello\\nworld\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test Array\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tt: TypeNumber,\n\t\t\t\t\t\ts: \"2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:  []byte{'['},\n\t\t\twant: []byte(\"[1,2]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Test Object\",\n\t\t\tv: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:  []byte{},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.v.MarshalTo(tt.dst)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"got %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","71635dd415056a10080843df1cfc642f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\t\\tTabbed text\", \"Tabbed text\"},\n\t\t{\"\\n\\n\\nNew line\", \"New line\"},\n\t\t{\"   \", \"\"},\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\n\\r\\nCarriage return and new line\", \"Carriage return and new line\"},\n\t\t{\"\\t   Mixed whitespace  \\n\", \"Mixed whitespace  \\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","7230092514433d8801df7477caa09618":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRest string\n\t\texpectedError bool\n\t}{\n\t\t{\"\\\"key\\\"\", \"key\", \"\", false},\n\t\t{\"\\\"keyWithNoEscape\\\"\", \"keyWithNoEscape\", \"\", false},\n\t\t{\"\\\"keyWithEscape\\\\\\\"\\\"\", \"\", \"\", true}, // Should trigger the slow path\n\t\t{\"missingQuote\", \"\", \"\", true},           // No closing quote\n\t\t{\"\\\"keyWithTrailingText\\\"extra\", \"keyWithTrailingText\", \"extra\", false}, // Extra text after key\n\t\t{\"\\\"\\\"emptyKey\\\"\", \"\", \"emptyKey\\\"\", false}, // Edge case with empty key\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, rest, err := parseRawKey(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) expected key: %q, got: %q\", test.input, test.expectedKey, key)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawKey(%q) expected rest: %q, got: %q\", test.input, test.expectedRest, rest)\n\t\t}\n\t}\n}","724994c4227fea1f6874c6180fbf74e8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedError  bool\n\t\texpectedOutput *Value\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{}`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedError: true, // Trailing comma should result in an error\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\" \"key2\": \"value2\"}`, // Missing comma\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": :}`, // Incorrect value format\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\":}`,\n\t\t\texpectedError: true, // Incomplete value\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpectedError: true, // Missing colon for the second key\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": {\"nestedKey\":}}`, // Incomplete nested object\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\toutput, remaining, err := parseObject(tt.input, c, 0)\n\n\t\tif tt.expectedError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %s, but got none\", tt.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"did not expect an error for input %s, but got: %v\", tt.input, err)\n\t\t\t}\n\t\t\tif output == nil {\n\t\t\t\tt.Errorf(\"expected output for input %s to be non-nil, but got nil\", tt.input)\n\t\t\t}\n\t\t\tif remaining == \"\" {\n\t\t\t\tt.Errorf(\"expected remaining string for input %s to be non-empty, but got empty\", tt.input)\n\t\t\t}\n\t\t}\n\t}\n}","728d133d01cc468ecfd0317cc4c69179":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedType Type\n\t\texpectedValue string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedType: TypeObject,\n\t\t\texpectedValue: `{\"key\":\"value\"}`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `[\"value1\", \"value2\"]`,\n\t\t\texpectedType: TypeArray,\n\t\t\texpectedValue: `[\"value1\",\"value2\"]`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `123`,\n\t\t\texpectedType: TypeNumber,\n\t\t\texpectedValue: `123`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"a string\"`,\n\t\t\texpectedType: TypeString,\n\t\t\texpectedValue: `\"a string\"`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `true`,\n\t\t\texpectedType: TypeTrue,\n\t\t\texpectedValue: `true`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `false`,\n\t\t\texpectedType: TypeFalse,\n\t\t\texpectedValue: `false`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `null`,\n\t\t\texpectedType: TypeNull,\n\t\t\texpectedValue: `null`,\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\",}`,\n\t\t\texpectedType: TypeObject,\n\t\t\texpectedValue: \"\",\n\t\t\texpectError:   true, // Invalid JSON\n\t\t},\n\t}\n\n\tparser := \u0026Parser{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tvalue, err := parser.Parse(tt.input)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\n\t\t\tif !tt.expectError {\n\t\t\t\tif value.Type() != tt.expectedType {\n\t\t\t\t\tt.Errorf(\"expected type: %v, got: %v\", tt.expectedType, value.Type())\n\t\t\t\t}\n\n\t\t\t\tvalBytes, _ := value.StringBytes()\n\t\t\t\tif string(valBytes) != tt.expectedValue {\n\t\t\t\t\tt.Errorf(\"expected value: %v, got: %v\", tt.expectedValue, string(valBytes))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","73637f7e1e8efbc7668ced1b35bb1c13":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue     *Value\n\t\texpected  string\n\t}{\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw string\"},\n\t\t\texpected: \"\\\"raw string\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"For value %v, expected %s, but got %s\", test.value, test.expected, result)\n\t\t}\n\t}\n}","73e81573c1097aa5d3bc8873077efe2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"hello\\\\nworld\", \"hello\\nworld\"},\n\t\t{\"string with no escapes\", \"string with no escapes\"},\n\t\t{\"escaped quotes: \\\\\\\"quote\\\\\\\"\", \"escaped quotes: \\\"quote\\\"\"},\n\t\t{\"backslash: \\\\\\\\\", \"backslash: \\\\\"},\n\t\t{\"invalid unicode \\\\uGHIJ\", \"invalid unicode \\\\uGHIJ\"},\n\t\t{\"valid unicode \\\\u0041\", \"valid unicode A\"},\n\t\t{\"surrogate pair \\\\uD83D\\\\uDE00\", \"surrogate pair ðŸ˜€\"},\n\t\t{\"unknown escape \\\\x\", \"unknown escape \\\\x\"},\n\t\t{\"mixed escape \\\\n and normal text\", \"mixed escape \\n and normal text\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","73e9cfe5e08926c7976321a2a9cd9a45":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true, // expect error for empty string\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: \u0026Value{ /* populate expected Value from JSON */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{ /* populate expected Value from JSON */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true, // expect error for invalid JSON\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{ /* populate expected Value from string */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `123`,\n\t\t\texpected: \u0026Value{ /* populate expected Value from number */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"a\": {\"b\": {\"c\": {\"d\": {\"e\": {\"f\": \"deep\"}}}}}}`,\n\t\t\texpected: \u0026Value{ /* populate expected Value from deeply nested JSON */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 12345678901234567890}`,\n\t\t\texpected: \u0026Value{ /* populate expected Value for large number */ },\n\t\t\terr:      true, // expect error for overflow if applicable\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, want err: %v\", test.input, err, test.err)\n\t\t}\n\t\tif err == nil \u0026\u0026 v != test.expected {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want: %v\", test.input, v, test.expected)\n\t\t}\n\t}\n}","7401629604b0f70bcbc19d96baaedff5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{input: `\"Hello, World!\"`, expected: \"Hello, World!\"},\n\t\t{input: `\"Line1\\\\nLine2\"`, expected: \"Line1\\nLine2\"},\n\t\t{input: `\"Tab\\\\tTab\"`, expected: \"Tab\\tTab\"},\n\t\t{input: `\"Backslash\\\\\\\\\"`, expected: \"Backslash\\\\\"},\n\t\t{input: `\"Unicode\\\\u0041\"`, expected: \"UnicodeA\"},\n\t\t{input: `\"Invalid\\\\uXYZ\"`, expected: \"Invalid\\\\uXYZ\"},\n\t\t{input: `\"Incomplete\\\\u\"`, expected: \"Incomplete\\\\u\"},\n\t\t{input: `\"Surrogate\\\\uD83D\\\\uDE00\"`, expected: \"SurrogateðŸ˜€\"},\n\t\t{input: `\"Multiple escapes\\\\n\\\\t\\\\u0021\"`, expected: \"Multiple escapes\\n\\t!\"},\n\t\t{input: \"No escapes here\", expected: \"No escapes here\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","74d7cae76125b8d48ca978cf0f627552":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"   non-empty\", \"non-empty\"},\n\t\t{\"non-empty   \", \"non-empty   \"},\n\t\t{\"   leading and trailing   \", \"leading and trailing   \"},\n\t\t{\"\\n\\t  mixed whitespace\", \"mixed whitespace\"},\n\t\t{\"\\r\\n    end\", \"end\"},\n\t\t{\"no whitespace\", \"no whitespace\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","753a7a1e99cdb1733921791f2452aeb5":"// File: parse_array_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []interface{}\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []interface{}{1, 2, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []interface{}{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []interface{}{1, 2},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: []interface{}{1, 2, 3},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,, 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, abc]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3}]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tv, s, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif test.err {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We can further validate the Value `v` here if needed.\n\t\tif len(v.a) != len(test.expected) {\n\t\t\tt.Errorf(\"parseArray(%q) expected length: %d, got: %d\", test.input, len(test.expected), len(v.a))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, expectedValue := range test.expected {\n\t\t\tif v.a[i].Int() != expectedValue.(int) { // type assertion and assumption\n\t\t\t\tt.Errorf(\"parseArray(%q) at index %d: expected %v, got %v\", test.input, i, expectedValue, v.a[i].Int())\n\t\t\t}\n\t\t}\n\t}\n}","75777daeca0c7bd8df52b21d1b780eff":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Test Marshal Raw String\",\n\t\t\tinput:    \u0026Value{t: typeRawString, s: \"example\"},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal String\",\n\t\t\tinput: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal Number\",\n\t\t\tinput: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal True\",\n\t\t\tinput: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal False\",\n\t\t\tinput: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal Null\",\n\t\t\tinput: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal Array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Test Marshal Object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0)\n\t\t\tresult := tt.input.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","7687ecf07cfcfde6c5776872c4fb9d33":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\texpectedError string\n\t}{\n\t\t{\"\", 0, nil, \"cannot parse empty string\"},\n\t\t{\"{}\", 0, \u0026Value{t: TypeObject}, \"\"},\n\t\t{\"[1, 2, 3]\", 0, \u0026Value{t: TypeArray}, \"\"},\n\t\t{\"\\\"hello\\\"\", 0, \u0026Value{s: \"hello\", t: typeRawString}, \"\"},\n\t\t{\"true\", 0, valueTrue, \"\"},\n\t\t{\"false\", 0, valueFalse, \"\"},\n\t\t{\"null\", 0, valueNull, \"\"},\n\t\t{\"nan\", 0, \u0026Value{s: \"nan\", t: TypeNumber}, \"\"},\n\t\t{\"100\", 0, \u0026Value{s: \"100\", t: TypeNumber}, \"\"},\n\t\t{\"{invalid}\", 0, nil, \"cannot parse object: ...\"},\n\t\t{\"[invalid]\", 0, nil, \"cannot parse array: ...\"},\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", 0, \u0026Value{t: TypeObject}, \"\"},\n\t\t{\"{ \\\"key\\\": true }\", 0, \u0026Value{t: TypeObject}, \"\"},\n\t\t{\"{ \\\"key\\\": null }\", 0, \u0026Value{t: TypeObject}, \"\"},\n\t\t{\"{ \\\"key\\\": [1, 2, 3] }\", 0, \u0026Value{t: TypeObject}, \"\"},\n\t\t// Add more cases to test edge conditions and invalid formats\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult, tail, err := parseValue(tt.input, c, tt.depth)\n\t\tif err != nil \u0026\u0026 err.Error() != tt.expectedError {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = _, _, %v; want %v\", tt.input, tt.depth, err, tt.expectedError)\n\t\t}\n\t\tif !compareValue(result, tt.expected) {\n\t\t\tt.Errorf(\"parseValue(%q, %d) = %v; want %v\", tt.input, tt.depth, result, tt.expected)\n\t\t}\n\t}\n}\n\nfunc compareValue(v1, v2 *Value) bool {\n\tif v1 == nil || v2 == nil {\n\t\treturn v1 == v2\n\t}\n\treturn v1.s == v2.s \u0026\u0026 v1.t == v2.t // Extend for more comparisons based on Value's structure\n}","76c88dee15d18184fd5aae3fde728d6e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedKey string\n\t\texpectedRest string\n\t\texpectedErr  bool\n\t}{\n\t\t{\n\t\t\tinput:        `\"hello\"World`,\n\t\t\texpectedKey: \"hello\",\n\t\t\texpectedRest: \"World\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"he\\\"llo\"World`,\n\t\t\texpectedKey: \"he\\\"llo\",\n\t\t\texpectedRest: \"World\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"missing closing quote`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"escaped quote \\\\\"inside\\\\\" here\" and more text`,\n\t\t\texpectedKey: \"escaped quote \\\\inside\\\\ here\",\n\t\t\texpectedRest: \" and more text\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"\\\"another test\\\"\" and extra`,\n\t\t\texpectedKey: \"\\\"another test\\\"\",\n\t\t\texpectedRest: \" and extra\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tkey, rest, err := parseRawString(tt.input)\n\n\t\tif (err != nil) != tt.expectedErr {\n\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.expectedErr, err != nil)\n\t\t}\n\t\tif key != tt.expectedKey {\n\t\t\tt.Errorf(\"expected key: %q, got: %q\", tt.expectedKey, key)\n\t\t}\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"expected rest: %q, got: %q\", tt.expectedRest, rest)\n\t\t}\n\t}\n}","76f5fd995e906a4073d48604a7268b3e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput     string\n\t\tdepth     int\n\t\texpected  *Value\n\t\texpectedTail string\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tinput:     \"\",\n\t\t\tdepth:     0,\n\t\t\texpected:  nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:     \"true\",\n\t\t\tdepth:     0,\n\t\t\texpected:  valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"false\",\n\t\t\tdepth:     0,\n\t\t\texpected:  valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"null\",\n\t\t\tdepth:     0,\n\t\t\texpected:  valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"[1, 2, 3]\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeArray},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"\\\"string\\\"\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeString, s: \"string\"},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"12345\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeNumber, s: \"12345\"},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"[\\\"string with a quote \\\\\\\" inside\\\"]\",\n\t\t\tdepth:     0,\n\t\t\texpected:  \u0026Value{t: TypeArray},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\tdepth:     1,\n\t\t\texpected:  \u0026Value{t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\tdepth:     99, // Assuming MaxDepth is 100 and 99 is okay\n\t\t\texpected:  \u0026Value{t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\tdepth:     100, // Assuming MaxDepth is 100 and 100 exceeds\n\t\t\texpected:  nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(test.input, c, test.depth)\n\n\t\t\tif (err != nil) != test.expectErr {\n\t\t\t\tt.Fatalf(\"Expected error: %v, got: %v\", test.expectErr, err)\n\t\t\t}\n\n\t\t\tif result != nil \u0026\u0026 test.expected != nil {\n\t\t\t\tif result.t != test.expected.t || result.s != test.expected.s {\n\t\t\t\t\tt.Fatalf(\"Expected result: %+v, got: %+v\", test.expected, result)\n\t\t\t\t}\n\t\t\t} else if result != nil || test.expected != nil {\n\t\t\t\tt.Fatalf(\"Expected result to be nil but got: %+v\", result)\n\t\t\t}\n\n\t\t\tif tail != test.expectedTail {\n\t\t\t\tt.Fatalf(\"Expected tail: %q, got: %q\", test.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","77bce0e6590e4b18937b930f84c13ca1":"// file: parse_raw_string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\"world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \"world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\"world\"more`,\n\t\t\texpected: \"hello\\\"world\",\n\t\t\trest:     \"more\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \"\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\world`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"double \\\" escape\\\" test\" additional`,\n\t\t\texpected: \"double \\\" escape\",\n\t\t\trest:     \" test\\\" additional\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"unterminated`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err != nil)\n\t\t\t}\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif rest != tt.rest {\n\t\t\t\tt.Errorf(\"expected rest: %v, got: %v\", tt.rest, rest)\n\t\t\t}\n\t\t})\n\t}\n}","782108c696836cbdae2916bc481df792":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tvar c cache\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValues [][]*Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"[]\",\n\t\t\texpectedValues: [][]*Value{{}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          \"[1, 2, 3]\",\n\t\t\texpectedValues: [][]*Value{{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          \"[1, 2,]\",\n\t\t\texpectedValues: [][]*Value{{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1,, 2]\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[, 2]\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[]]\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[true, false, null]\",\n\t\t\texpectedValues: [][]*Value{\n\t\t\t\t{\n\t\t\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\t\t\u0026Value{t: TypeFalse},\n\t\t\t\t\t\u0026Value{t: TypeNull},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpectedValues: [][]*Value{{\u0026Value{t: TypeString, s: \"string1\"}, \u0026Value{t: TypeString, s: \"string2\"}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tdepth := 0\n\t\t\tresult, remaining, err := parseArray(tt.input, \u0026c, depth)\n\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t}\n\n\t\t\tif !tt.expectedError {\n\t\t\t\t// Add further validation here for expected values if needed\n\t\t\t\tif result == nil {\n\t\t\t\t\tt.Fatal(\"result is nil, expected a value\")\n\t\t\t\t}\n\n\t\t\t\tif len(result.a) != len(tt.expectedValues[0]) {\n\t\t\t\t\tt.Fatalf(\"expected %d values, got %d\", len(tt.expectedValues[0]), len(result.a))\n\t\t\t\t}\n\n\t\t\t\tfor i, v := range result.a {\n\t\t\t\t\tif v.t != tt.expectedValues[0][i].t {\n\t\t\t\t\t\tt.Errorf(\"expected type %v at index %d, got %v\", tt.expectedValues[0][i].t, i, v.t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","786947ac52c4718b1416b399695b5978":"package fastjson\n\nimport (\n    \"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n    cases := []struct {\n        input    string\n        expected []*Value\n        err      bool\n    }{\n        {\n            input:    \"[]\",\n            expected: []*Value{},\n            err:      false,\n        },\n        {\n            input:    \"[1, 2, 3]\",\n            expected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n            err:      false,\n        },\n        {\n            input:    \"[\\\"string\\\", true, false, null]\",\n            expected: []*Value{\u0026Value{t: TypeString, s: \"string\"}, \u0026Value{t: TypeTrue}, \u0026Value{t: TypeFalse}, \u0026Value{t: TypeNull}},\n            err:      false,\n        },\n        {\n            input:    \"[,]\",\n            expected: nil,\n            err:      true,\n        },\n        {\n            input:    \"[1, 2,, 3]\",\n            expected: nil,\n            err:      true,\n        },\n        {\n            input:    \"[1, 2\",\n            expected: nil,\n            err:      true,\n        },\n    }\n\n    for _, c := range cases {\n        cache := \u0026cache{}\n        result, remaining, err := parseArray(c.input, cache, 0)\n\n        // Check for expected error\n        if (err != nil) != c.err {\n            t.Errorf(\"parseArray(%q) unexpected error: %v\", c.input, err)\n            continue\n        }\n\n        if c.err {\n            continue\n        }\n\n        // Check the length of the result\n        if len(result.a) != len(c.expected) {\n            t.Errorf(\"parseArray(%q) expected length %d, got %d\", c.input, len(c.expected), len(result.a))\n            continue\n        }\n\n        // Check the contents of the result\n        for i := range result.a {\n            if result.a[i].t != c.expected[i].t || result.a[i].s != c.expected[i].s {\n                t.Errorf(\"parseArray(%q) expected value %v at index %d, got %v\", c.input, c.expected[i], i, result.a[i])\n            }\n        }\n\n        // Check that remaining input is correct\n        if remaining != \"\" {\n            t.Errorf(\"parseArray(%q) expected remaining input to be empty, got %q\", c.input, remaining)\n        }\n    }\n}","798be09ae942c932c643af314a791107":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello, \\\\\\\"World!\\\\\\\"\", `Hello, \"World!\"`}, // escapes double quotes\n\t\t{\"Hello, \\\\\\\\World!\", `Hello, \\World!`},      // escapes backslash\n\t\t{\"Hello, /World!\", \"Hello, /World!\"},          // escapes forward slash\n\t\t{\"Hello, \\\\bWorld!\", \"Hello, \\bWorld!\"},      // escapes backspace\n\t\t{\"Hello, \\\\fWorld!\", \"Hello, \\fWorld!\"},      // escapes form feed\n\t\t{\"Hello, \\\\nWorld!\", \"Hello, \\nWorld!\"},      // escapes newline\n\t\t{\"Hello, \\\\rWorld!\", \"Hello, \\rWorld!\"},      // escapes carriage return\n\t\t{\"Hello, \\\\tWorld!\", \"Hello, \\tWorld!\"},      // escapes tab\n\t\t{\"Hello, \\\\u0041World!\", \"Hello, AWorld!\"},   // unicode escape\n\t\t{\"Hello, \\\\uD83D\\\\uDE00World!\", \"Hello, ðŸ˜€World!\"}, // surrogate pair\n\t\t{\"Hello, \\\\uD83DWorld!\", \"Hello, \\\\uD83DWorld!\"}, // invalid unicode escape\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","79d8078e796dcbcc4dd823f358ec52aa":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{{t: TypeArray, a: []*Value{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false]\",\n\t\t\texpected: []*Value{{t: TypeArray, a: []*Value{{t: TypeTrue}, {t: TypeFalse}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[null, \\\"abc\\\"]\",\n\t\t\texpected: []*Value{{t: TypeArray, a: []*Value{{t: TypeNull}, {t: TypeString, s: \"abc\"}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.err {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected[0].a) {\n\t\t\tt.Errorf(\"Expected %d elements, got %d for input %q\", len(test.expected[0].a), len(result.a), test.input)\n\t\t}\n\n\t\tfor i, v := range result.a {\n\t\t\tif v.t != test.expected[0].a[i].t || v.s != test.expected[0].a[i].s {\n\t\t\t\tt.Errorf(\"Unexpected value at index %d for input %q: got %+v, want %+v\", i, test.input, v, test.expected[0].a[i])\n\t\t\t}\n\t\t}\n\t}\n}","7a92821e0adc82cb85ceea8247358d8a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":\"value\"}`,\n\t\t\texpected: createExpectedValue(`{\"key\":\"value\"}`), // Implement createExpectedValue\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":123}`,\n\t\t\texpected: createExpectedValue(`{\"key\":123}`), // Implement createExpectedValue\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: createExpectedValue(`{\"key1\": \"value1\", \"key2\": \"value2\"}`), // Implement createExpectedValue\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"malformed_key\": \"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key1\": \"value1\", \"key2\" }`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{vs: []Value{}}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected an error for input %s but got none\", test.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %s: %v\", test.input, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(result, test.expected) {\n\t\t\t\tt.Errorf(\"expected result %v for input %s, got %v\", test.expected, test.input, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc createExpectedValue(input string) *Value {\n\t// Convert the input JSON string into the expected Value structure,\n\t// you might need to implement actual parsing logic to create the expected Value.\n}","7ae139e99d6004412db527f5cec86730":"// parse_raw_key_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedKey    string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"key\"`,\n\t\t\texpectedKey:    \"key\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"anotherKey\"remaining`,\n\t\t\texpectedKey:    \"anotherKey\",\n\t\t\texpectedRemain: \"remaining\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWithEscape\\\"`,\n\t\t\texpectedKey:    \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"keyWithBackslash\\\\\"remaining`,\n\t\t\texpectedKey:    \"keyWithBackslash\\\\\",\n\t\t\texpectedRemain: \"remaining\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `missingQuote`,\n\t\t\texpectedKey:    \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remain, err := parseRawKey(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned error %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned key %q, expected key: %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned remaining %q, expected remaining: %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","7b0eb03b9c3c5c2a59058e32333f3f39":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedKey   string\n\t\texpectedRest  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"simpleKey\":`,\n\t\t\texpectedKey:   \"simpleKey\",\n\t\t\texpectedRest:  \":\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"keyWithSpace \":`,\n\t\t\texpectedKey:   \"keyWithSpace \",\n\t\t\texpectedRest:  \":\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"keyWithEscapedChars\\\\\"`,\n\t\t\texpectedKey:   \"keyWithEscapedChars\\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true, // should capture the escaped character case\n\t\t},\n\t\t{\n\t\t\tinput:         `\"keyWithoutClosing`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true, // missing closing quote\n\t\t},\n\t\t{\n\t\t\tinput:         `noQuotes`,\n\t\t\texpectedKey:   \"noQuotes\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false, // handled as a raw key without quotes\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tkey, rest, err := parseRawKey(tt.input)\n\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Fatalf(\"parseRawKey(%q) unexpected error: got %v, want error: %v\", tt.input, err, tt.expectedError)\n\t\t}\n\n\t\tif key != tt.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", tt.input, key, tt.expectedKey)\n\t\t}\n\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, want %q\", tt.input, rest, tt.expectedRest)\n\t\t}\n\t}\n}","7be990ce79cb1a8b124a128d9ab3387a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedString string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\"world`,\n\t\t\texpectedString: \"hello\",\n\t\t\texpectedRemain: \"world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"foo\\\"bar\"baz`,\n\t\t\texpectedString: \"foo\\\"bar\",\n\t\t\texpectedRemain: \"baz\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped quote: \\\"\"remaining`,\n\t\t\texpectedString: \"escaped quote: \\\"\",\n\t\t\texpectedRemain: \"remaining\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `no quotes here`,\n\t\t\texpectedString: \"no quotes here\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"unclosed string`,\n\t\t\texpectedString: \"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"nested \\\"quotes\\\" inside\" and more`,\n\t\t\texpectedString: \"nested \\\"quotes\\\" inside\",\n\t\t\texpectedRemain: \" and more\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remain, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif result != test.expectedString {\n\t\t\tt.Errorf(\"parseRawString(%q) expected string: %q, got: %q\", test.input, test.expectedString, result)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) expected remaining: %q, got: %q\", test.input, test.expectedRemain, remain)\n\t\t}\n\t}\n}","7c09caf0ea87aa843bac1becd45191fc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\"\", nil, fmt.Errorf(\"cannot parse empty string\")},\n\t\t{\"{}\", \u0026Value{t: TypeObject}, nil},\n\t\t{\"[]\", \u0026Value{t: TypeArray}, nil},\n\t\t{\"\\\"string\\\"\", \u0026Value{s: \"string\", t: TypeString}, nil},\n\t\t{\"true\", valueTrue, nil},\n\t\t{\"false\", valueFalse, nil},\n\t\t{\"null\", valueNull, nil},\n\t\t{\"123\", \u0026Value{s: \"123\", t: TypeNumber}, nil},\n\t\t{\"nan\", \u0026Value{s: \"nan\", t: TypeNumber}, nil},\n\t\t{\"{\\\"key\\\": \\\"value\\\"}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}, nil},\n\t\t{\"[1, 2, 3]\", \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray}, nil},\n\t\t{\"{\\\"key\\\": true}\", \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueTrue}}}, t: TypeObject}, nil},\n\t\t{\"{\\\"array\\\": [4, 5, 6]}\", \u0026Value{o: Object{kvs: []kv{{k: \"array\", v: \u0026Value{a: []*Value{{s: \"4\", t: TypeNumber}, {s: \"5\", t: TypeNumber}, {s: \"6\", t: TypeNumber}}, t: TypeArray}}}}}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) returned error %v, expected %v\", test.input, err, test.err)\n\t\t}\n\n\t\tif v != nil \u0026\u0026 test.expected != nil {\n\t\t\tif v.t != test.expected.t || v.s != test.expected.s {\n\t\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", test.input, v, test.expected)\n\t\t\t}\n\t\t} else if (v == nil) != (test.expected == nil) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, expected %v\", test.input, v, test.expected)\n\t\t}\n\n\t\t// Additional checks for tail if needed can be added here.\n\t}\n}","7ca549d288828fbe5328bbd86e0db62a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremains  string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"hello\\\\\\\"world\\\"\", \"hello\\\"world\", \"\", false},\n\t\t{\"\\\"hello\\\\\\\\world\\\"\", \"hello\\\\world\", \"\", false},\n\t\t{\"no quotes here\", \"no quotes here\", \"\", true},\n\t\t{\"\\\"not closed\", \"\", \"\", true},\n\t\t{\"\\\"escaped \\\\\\\" quote\\\"\", \"escaped \\\" quote\", \"\", false},\n\t\t{\"\\\"double \\\\\\\"escaped\\\\\\\" quotes\\\"\", \"double \\\"escaped\\\" quotes\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remains, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, want error = %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif remains != test.remains {\n\t\t\tt.Errorf(\"parseRawString(%q) remains = %q, want %q\", test.input, remains, test.remains)\n\t\t}\n\t}\n}","7dad3b1c46ec53aac2f667a5953c1862":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"Hello, World!\"`, \"Hello, World!\"},\n\t\t{`\"Line1\\nLine2\"`, \"Line1\\nLine2\"},\n\t\t{`\"Tabbed\\tText\"`, \"Tabbed\\tText\"},\n\t\t{`\"Backslash: \\\\\"`, \"Backslash: \\\\\"},\n\t\t{`\"Unicode: \\u1234\"`, \"Unicode: \\u1234\"},\n\t\t{`\"Invalid Unicode: \\uXXXX\"`, \"Invalid Unicode: \\\\uXXXX\"},\n\t\t{`\"Mixed \\\\u1234 and \\\\u\"` , \"Mixed \\\\u1234 and \\\\u\"},\n\t\t{`\"Escaped quotes: \\\"\"`, `Escaped quotes: \"`},\n\t\t{`\"Just a regular string\"`, \"Just a regular string\"},\n\t\t{`\"\"`, \"\"},\n\t\t{`\"Special characters: \\b\\f\\n\\r\\t\"`, \"Special characters: \\b\\f\\n\\r\\t\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","7db1f88e3c96395375451e83de16c5b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.456xyz\", \"-123.456\", \"xyz\", nil},\n\t\t{\"3.14\", \"3.14\", \"\", nil},\n\t\t{\"inf more text\", \"inf\", \"more text\", nil},\n\t\t{\"nan and more\", \"nan\", \"and more\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"+5.67suffix\", \"+5.67\", \"suffix\", nil},\n\t\t{\"--1.2abc\", \"\", \"--1.2abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", nil}, // edge case as caller ensures len(s) \u003e 0\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawNumber(test.input)\n\t\tif result != test.expected || rest != test.rest || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", test.input, result, rest, err, test.expected, test.rest, test.err)\n\t\t}\n\t}\n}","7dcd4b2020590e522e3b8a940cc501f3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"   Leading spaces\", \"Leading spaces\"},\n\t\t{\"\\nNew line at start\", \"New line at start\"},\n\t\t{\"\\tTab at start\", \"Tab at start\"},\n\t\t{\"\\rCarriage return at start\", \"Carriage return at start\"},\n\t\t{\"  \\nMixed whitespace\", \"Mixed whitespace\"},\n\t\t{\"Only spaces     \", \"Only spaces     \"},\n\t\t{\"\", \"\"},\n\t\t{\"       \", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","7dd7034a21a9529c961f608a308225ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t},\n\t\t{\n\t\t\tname:     \"single key-value pair\",\n\t\t\tinput:    `{\"key1\":\"value1\"}`,\n\t\t\texpected: newValueWithKeyValue(\"key1\", \"value1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple key-value pairs\",\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\texpected: newValueWithKeyValue(\"key1\", \"value1\", \"key2\", \"value2\"),\n\t\t},\n\t\t{\n\t\t\tname:        \"missing closing brace\",\n\t\t\tinput:       `{\"key1\":\"value1\"`,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"missing colon after key\",\n\t\t\tinput:       `{\"key1\" \"value1\"}`,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"missing key\",\n\t\t\tinput:       `{\"\":\"value\"}`,\n\t\t\texpectedErr: false, // Accept empty string as a key\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid object\",\n\t\t\tinput:       `\"{key1:value1}\"`,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"key1\":{\"nestedKey\":\"nestedValue\"}}`,\n\t\t\texpected: newValueWithKeyValue(\"key1\", newValueWithKeyValue(\"nestedKey\", \"nestedValue\")),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tcache := \u0026cache{}\n\t\t\tresult, remainder, err := parseObject(tt.input, cache, 0)\n\n\t\t\tif (err != nil) != tt.expectedErr {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedErr, err)\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\t// Compare the result with expected Value here as needed.\n\t\t\t\tif !compareValues(result, tt.expected) {\n\t\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc newValueWithKeyValue(pairs ...string) *Value {\n\tobj := \u0026Object{}\n\tfor i := 0; i \u003c len(pairs); i += 2 {\n\t\tk := pairs[i]\n\t\tv := \u0026Value{s: pairs[i+1], t: TypeString} // Simplified for testing\n\t\tobj.kvs = append(obj.kvs, kv{k: k, v: v})\n\t}\n\treturn \u0026Value{o: *obj, t: TypeObject}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement the logic to compare two Value instances for equality.\n\treturn true // Placeholder for actual comparison logic\n}","7e8e562ef2d27c182d546cf4c9a07086":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetArray(t *testing.T) {\n\t// Sample JSON value for testing\n\tjsonStr := `{\"key1\": [1, 2, 3], \"key2\": {\"subkey\": [4, 5, 6]}, \"key3\": \"not an array\"}`\n\t\n\tp := \u0026Parser{}\n\tv, err := p.Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys  []string\n\t\twant  []*Value\n\t\twantN bool // whether no value (nil) is expected\n\t}{\n\t\t{keys: []string{\"key1\"}, want: []*Value{{s: \"1\"}, {s: \"2\"}, {s: \"3\"}}, wantN: false}, // Valid array\n\t\t{keys: []string{\"key2\", \"subkey\"}, want: []*Value{{s: \"4\"}, {s: \"5\"}, {s: \"6\"}}, wantN: false}, // Nested array\n\t\t{keys: []string{\"key3\"}, want: nil, wantN: true}, // Invalid type (string)\n\t\t{keys: []string{\"key4\"}, want: nil, wantN: true}, // Non-existing key\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.keys[0], func(t *testing.T) {\n\t\t\tgot := v.GetArray(tt.keys...)\n\t\t\tif (got == nil) != tt.wantN {\n\t\t\t\tt.Errorf(\"GetArray(%v) = %v; want nil: %v\", tt.keys, got, tt.wantN)\n\t\t\t} else if !tt.wantN {\n\t\t\t\tif len(got) != len(tt.want) {\n\t\t\t\t\tt.Errorf(\"GetArray(%v) length = %d; want length = %d\", tt.keys, len(got), len(tt.want))\n\t\t\t\t}\n\t\t\t\tfor i, val := range got {\n\t\t\t\t\tif val.s != tt.want[i].s {\n\t\t\t\t\t\tt.Errorf(\"GetArray(%v)[%d] = %v; want %v\", tt.keys, i, val.s, tt.want[i].s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","7f4ba0b171c71cd762dba9c2e617f4ff":"package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tkeys      []string\n\t\tinput     *Value\n\t\texpected  uint\n\t}{\n\t\t{\n\t\t\tname:     \"existing uint\",\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\tinput:    \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpected: 123,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tkeys:     []string{\"nonExistingKey\"},\n\t\t\tinput:    \u0026Value{s: \"\", t: TypeNull},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with invalid type\",\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\tinput:    \u0026Value{s: `\"string\"`, t: TypeString},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"key with large number exceeding uint range\",\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\tinput:    \u0026Value{s: \"99999999999999999999\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"correct key but invalid underType number\",\n\t\t\tkeys:     []string{\"key4\"},\n\t\t\tinput:    \u0026Value{s: \"250.5\", t: TypeNumber},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty value\",\n\t\t\tkeys:     []string{\"key5\"},\n\t\t\tinput:    \u0026Value{s: \"\", t: TypeNull},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.GetUint(tt.keys...)\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}","7f60f1b39103ded7daa1b75a4ee76a2d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\twantErr  bool\n\t\terrMsg   string\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t\terrMsg:   \"cannot parse empty string\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    0,\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"hello\\\"\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{}, // add appropriate expected value once parseArray is implemented\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\tdepth:    0,\n\t\t\texpected: \u0026Value{}, // add appropriate expected value once parseObject is implemented\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalid\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t\terrMsg:   `unexpected value found: \"invalid\"`,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"nested\\\": {\\\"key\\\": \\\"value\\\"}}\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: \u0026Value{}, // add appropriate expected value once parseObject is implemented\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"deep\\\": {\\\"nested\\\": {\\\"key\\\": \\\"value\\\"}}}\",\n\t\t\tdepth:    MaxDepth - 1,\n\t\t\texpected: \u0026Value{}, // add appropriate expected value once parseObject is implemented\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"deep\\\": {\\\"nested\\\": {\\\"key\\\": \\\"value\\\"}}}\",\n\t\t\tdepth:    MaxDepth,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t\terrMsg:   \"too big depth for the nested JSON; it exceeds 100\", // substitute 100 with actual MaxDepth value\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc := \u0026cache{}\n\t\tgot, tail, err := parseValue(tt.input, c, tt.depth)\n\n\t\tif (err != nil) != tt.wantErr {\n\t\t\tt.Errorf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 err.Error() != tt.errMsg {\n\t\t\tt.Errorf(\"parseValue() error message = %v, want %v\", err.Error(), tt.errMsg)\n\t\t}\n\n\t\tif got != nil \u0026\u0026 tt.expected != nil {\n\t\t\tif got.s != tt.expected.s || got.t != tt.expected.t {\n\t\t\t\tt.Errorf(\"parseValue() got = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t}\n\t}\n}","807d013abe86474680c99a8397c44ef9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Sample JSON for testing\n\tjsonData := `{\"name\": \"John\", \"age\": 30, \"contacts\": [{\"type\": \"email\", \"value\": \"john@example.com\"}, {\"type\": \"phone\", \"value\": \"123-456-7890\"}]}`\n\tv, err := Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys      []string\n\t\texpected  *Value\n\t\tshouldNil bool\n\t}{\n\t\t{\n\t\t\tkeys:     []string{\"name\"},\n\t\t\texpected: v.Get(\"name\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"age\"},\n\t\t\texpected: v.Get(\"age\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"contacts\", \"0\", \"value\"},\n\t\t\texpected: v.Get(\"contacts\", \"0\", \"value\"),\n\t\t},\n\t\t{\n\t\t\tkeys:     []string{\"contacts\", \"1\", \"value\"},\n\t\t\texpected: v.Get(\"contacts\", \"1\", \"value\"),\n\t\t},\n\t\t{\n\t\t\tkeys:      []string{\"contacts\", \"2\", \"value\"},\n\t\t\texpected:  nil,\n\t\t\tshouldNil: true,\n\t\t},\n\t\t{\n\t\t\tkeys:      []string{\"nonexistent\"},\n\t\t\texpected:  nil,\n\t\t\tshouldNil: true,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tresult := v.Get(test.keys...)\n\t\tif test.shouldNil \u0026\u0026 result != nil {\n\t\t\tt.Errorf(\"Test case %d failed: expected nil but got %v\", i, result)\n\t\t} else if !test.shouldNil \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v but got nil\", i, test.expected)\n\t\t} else if result != nil \u0026\u0026 result != test.expected {\n\t\t\tt.Errorf(\"Test case %d failed: expected %v but got %v\", i, test.expected, result)\n\t\t}\n\t}\n}","80eb4c1412d255ee46292aae604c32df":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum   string\n\t\texpectedRest  string\n\t\texpectedErr error\n\t}{\n\t\t// Test cases with expected outputs\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"-123.45e+6 more text\", \"-123.45e+6\", \" more text\", nil},\n\t\t{\"0.12345E-10 next\", \"0.12345E-10\", \" next\", nil},\n\t\t{\"inf extra chars\", \"inf\", \" extra chars\", nil},\n\t\t{\"-nan something\", \"-nan\", \" something\", nil},\n\t\t{\"invalid_input\", \"\", \"invalid_input\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\n\t\tif num != test.expectedNum || rest != test.expectedRest {\n\t\t\tt.Errorf(\"For input '%s', expected num: '%s', rest: '%s', got num: '%s', rest: '%s'\",\n\t\t\t\ttest.input, test.expectedNum, test.expectedRest, num, rest)\n\t\t}\n\n\t\tif (err != nil \u0026\u0026 test.expectedErr == nil) || (err == nil \u0026\u0026 test.expectedErr != nil) {\n\t\t\tt.Errorf(\"For input '%s', expected error: '%v', got error: '%v'\",\n\t\t\t\ttest.input, test.expectedErr, err)\n\t\t}\n\t}\n}","813b6cc65bfab253187227574002ee26":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tinput      *Value\n\t\tkeys       []string\n\t\texpected   *Value\n\t}{\n\t\t{\n\t\t\tname:     \"Test case 1: valid object path\",\n\t\t\tinput:    createTestValueWithObject(), // Assume function creates a test Value with specific object\n\t\t\tkeys:     []string{\"key1\", \"key2\"},\n\t\t\texpected: createExpectedValue(), // Assume this value matches the expected output\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 2: valid array path\",\n\t\t\tinput:    createTestValueWithArray(), // Assume function creates a test Value with specific array\n\t\t\tkeys:     []string{\"0\"},\n\t\t\texpected: createExpectedValueForArray(), // Example expected value for array access\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 3: non-existing path\",\n\t\t\tinput:    createTestValueWithObject(),\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 4: invalid index\",\n\t\t\tinput:    createTestValueWithArray(),\n\t\t\tkeys:     []string{\"10\"}, // Assuming index 10 does not exist\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 5: non-object and non-array type\",\n\t\t\tinput:    createTestValueWithString(), // Assume it creates a Value of TypeString\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Test case 6: empty keys\",\n\t\t\tinput:    createTestValueWithObject(),\n\t\t\tkeys:     []string{},\n\t\t\texpected: createExpectedValueForEmptyKeys(), // Handle case where no keys are supplied\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.input.Get(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Implement createTestValueWithObject, createTestValueWithArray, \n// createExpectedValue, createExpectedValueForArray, and createExpectedValueForEmptyKeys \n// as needed to create valid test values and expected outputs.","8177a350d4c4cce2597cc004623711f5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      string\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" world\",\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\"world\" rest`,\n\t\t\texpected: \"hello\\\"world\",\n\t\t\trest:     \" rest\",\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \"\",\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"world\"`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \"world\\\"\",\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      `missing closing '\"'`,\n\t\t},\n\t\t{\n\t\t\tinput:    `no quotes`,\n\t\t\texpected: \"no quotes\",\n\t\t\trest:     \"\",\n\t\t\terr:      \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped\\\\\"quote\" text`,\n\t\t\texpected: \"escaped\\\\quote\",\n\t\t\trest:     \" text\",\n\t\t\terr:      \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\n\t\tif result != test.expected || rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, %q; expected %q, %q\", test.input, result, rest, test.expected, test.rest)\n\t\t}\n\n\t\tif (err != nil \u0026\u0026 test.err == \"\") || (err == nil \u0026\u0026 test.err != \"\") || (err != nil \u0026\u0026 err.Error() != test.err) {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v; expected %v\", test.input, err, test.err)\n\t\t}\n\t}\n}","829f3bee55cc6c18e8df104328bf5e2b":"// parse_raw_string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\tremaining: \" world\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\\\" quote\" next\",\n\t\t\texpected: \"escaped \\\\ quote\",\n\t\t\tremaining: \" next\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"incomplete string`,\n\t\t\texpected: \"\",\n\t\t\tremaining: \"\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped \\\\\" more \\\\\" strings\" and more`,\n\t\t\texpected: \"escaped \\\\ more \\\\ strings\",\n\t\t\tremaining: \" and more\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"another \"example\"`,\n\t\t\texpected: \"another \",\n\t\t\tremaining: `\"example\"`,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `no quotes here`,\n\t\t\texpected: \"no quotes here\",\n\t\t\tremaining: \"\",\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawString(test.input)\n\t\tif test.expectErr {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t\tif remaining != test.remaining {\n\t\t\t\tt.Errorf(\"expected remaining %q, got %q\", test.remaining, remaining)\n\t\t\t}\n\t\t}\n\t}\n}","8357f5d24e1cdb9aefc22a135c1b9466":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Add test cases for various input string scenarios.\n\t\t{\"simple string\", \"simple string\"},\n\t\t{\"string with escaped \\\\n newline\", \"string with escaped \\n newline\"},\n\t\t{\"string with escaped \\\\\\\"quote\", \"string with escaped \\\"quote\"},\n\t\t{\"unescaped forward slash /\", \"unescaped forward slash /\"},\n\t\t{\"string with invalid escape \\\\x\", \"string with invalid escape \\\\x\"},\n\t\t{\"string with unicode \\\\u0041\", \"string with unicode A\"},\n\t\t{\"string with surrogate \\\\uD83D\\\\uDE03\", \"string with surrogate ðŸ˜ƒ\"},\n\t\t{\"trailing backslash \\\\ \", \"trailing backslash \\\\ \"},\n\t\t{\"starting backslash \\\\back\", \"starting backslash \\\\back\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","846b5a8936b60cdcefab9152a8a78e08":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+10\", \"-123.45e+10\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"1.5.2\", \"1.5\", \".2\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawNumber(test.input)\n\t\tif result != test.expected || rest != test.rest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q; expected %q, %q\", test.input, result, rest, test.expected, test.rest)\n\t\t}\n\t\tif (err != nil) != (test.err != nil) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v; expected error = %v\", test.input, err, test.err)\n\t\t}\n\t\tif err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v; expected error = %v\", test.input, err, test.err)\n\t\t}\n\t}\n}","85860e752a54f3e60b619400d8ea0e22":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string // expected number\n\t\tremaining string // expected remaining string\n\t\texpectErr bool   // expect an error\n\t}{\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"-123.45xyz\", \"-123.45\", \"xyz\", false},\n\t\t{\"0.1234xyz\", \"0.1234\", \"xyz\", false},\n\t\t{\"+1e10rest\", \"+1e10\", \"rest\", false},\n\t\t{\"infabc\", \"inf\", \"abc\", false},\n\t\t{\"-infxyz\", \"-inf\", \"xyz\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-xyz\", \"\", \"-xyz\", true},\n\t\t{\"\", \"\", \"\", false}, // Assuming we consider empty input valid for no number.\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tnumber, remaining, err := parseRawNumber(tt.input)\n\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.expectErr, err)\n\t\t\t}\n\t\t\tif number != tt.expected {\n\t\t\t\tt.Fatalf(\"expected number: %s, got: %s\", tt.expected, number)\n\t\t\t}\n\t\t\tif remaining != tt.remaining {\n\t\t\t\tt.Fatalf(\"expected remaining: %s, got: %s\", tt.remaining, remaining)\n\t\t\t}\n\t\t})\n\t}\n}","867153df9b6a69ea618b77a3fc27945c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedNum string\n\t\texpectedRem string\n\t\texpectedErr error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-3.14 more text\", \"-3.14\", \" more text\", nil},\n\t\t{\"inf more text\", \"inf\", \" more text\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"-inf something\", \"-inf\", \" something\", nil},\n\t\t{\"42\", \"42\", \"\", nil},\n\t\t{\"\", \"\", \"\", nil}, // edge case where input is empty\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-abc\", \"\", \"-abc\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rem, err := parseRawNumber(test.input)\n\t\tif num != test.expectedNum || rem != test.expectedRem || (err != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", \n\t\t\t\ttest.input, num, rem, err, test.expectedNum, test.expectedRem, test.expectedErr)\n\t\t}\n\t}\n}","8717eb40e7c5b1502a86c46aec6f0a2f":"// unescapeStringBestEffort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t}{\n\t\t{\n\t\t\tinput:          `\"Hello, World!\"`,\n\t\t\texpectedOutput: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Backslash: \\\\\"`,\n\t\t\texpectedOutput: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Newline:\\nEnd\"`,\n\t\t\texpectedOutput: \"Newline:\\nEnd\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Tab:\\tEnd\"`,\n\t\t\texpectedOutput: \"Tab:\\tEnd\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Unicode: \\u4f60\\u597d\"`, // \"ä½ å¥½\"\n\t\t\texpectedOutput: \"Unicode: ä½ å¥½\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Invalid Unicode: \\uD83D\"`, // Incomplete sequence\n\t\t\texpectedOutput: \"Invalid Unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Surrogate pair: \\uD83D\\uDE00\"`, // ðŸ˜€ (smiley)\n\t\t\texpectedOutput: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Escape sequence: \\\\n\\\\t\\\\\"`,\n\t\t\texpectedOutput: \"Escape sequence: \\n\\t\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"No Escape\"`,\n\t\t\texpectedOutput: \"No Escape\",\n\t\t},\n\t\t{\n\t\t\tinput:          `\"\"`,\n\t\t\texpectedOutput: \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput := unescapeStringBestEffort(test.input)\n\t\tif output != test.expectedOutput {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, output, test.expectedOutput)\n\t\t}\n\t}\n}","871e93cc734c52c098de30486d1c84ef":"// file: value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\n// TestGetFloat64 tests the GetFloat64 function.\nfunc TestGetFloat64(t *testing.T) {\n\t// Create a JSON Value for testing\n\ttests := []struct {\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tjson:     `{\"key1\": 1.23}`,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: 1.23,\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key2\": \"not a number\"}`,\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key3\": null}`,\n\t\t\tkeys:     []string{\"key3\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key4\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"key4\", \"0\"},\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key5\": \"3.14\"}`,\n\t\t\tkeys:     []string{\"key5\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key6\": {}}`,\n\t\t\tkeys:     []string{\"key6\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key7\": [true, false]}`,\n\t\t\tkeys:     []string{\"key7\", \"0\"},\n\t\t\texpected: 0, // boolean values should return 0\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key8\": 4}`,\n\t\t\tkeys:     []string{\"key8\", \"1\"},\n\t\t\texpected: 0, // array index out of range\n\t\t},\n\t\t{\n\t\t\tjson:     `{\"key9\": 1.5}`,\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: 0, // non-existing path\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tv, err := Parse(test.json)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t}\n\n\t\tresult := v.GetFloat64(test.keys...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"GetFloat64(%v) = %v; want %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","880ea0b271ad5f9e12e05cf9dcf137a3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"Hello, World!\"`, \"Hello, World!\"},\n\t\t{`\"Newline:\\nTab:\\tBackslash:\\\\\"`, \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{`\"Invalid: \\uD800\"`, \"Invalid: \\\\uD800\"},\n\t\t{`\"Unicode: \\u03A9\"`, \"Unicode: Î©\"},\n\t\t{`\"Mixed: \\u03A9 and backslash: \\\\\"`, \"Mixed: Î© and backslash: \\\\\"},\n\t\t{`\"Escaped\\/Slash\"`, \"Escaped/Slash\"},\n\t\t{`\"Not escaped: /\"`, \"Not escaped: /\"},\n\t\t{`\"Incomplete: \\u\"`, \"Incomplete: \\\\u\"},\n\t\t{`\"Surrogate pair: \\uD83D\\uDE00\"`, \"Surrogate pair: ðŸ˜€\"},\n\t\t{`\"Unknown escape: \\q\"`, \"Unknown escape: \\\\q\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","88843da73a4c0686070c97ea98d37280":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedLen int\n\t\texpectError bool\n\t}{\n\t\t{\"[1, 2, 3]\", 3, false},\n\t\t{\"[]\", 0, false},\n\t\t{\"[true, false, null]\", 3, false},\n\t\t{\"[1, 2, 3,]\", 3, true}, // trailing comma\n\t\t{\"[1, 2,, 3]\", 0, true}, // double commas\n\t\t{\"[1, 2, 3\", 0, true},   // missing closing bracket\n\t\t{\"[1, 2, [3, 4]]\", 3, false}, // nested array\n\t\t{\"[1, \\\"string\\\", null, false]\", 4, false}, // mixed types\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tresult, remaining, err := parseArray(tt.input, c, 0)\n\n\t\tif (err != nil) != tt.expectError {\n\t\t\tt.Errorf(\"parseArray(%q) error = %v, expectError %v\", tt.input, err, tt.expectError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif result != nil \u0026\u0026 len(result.a) != tt.expectedLen {\n\t\t\tt.Errorf(\"parseArray(%q) returned length = %d, expected %d\", tt.input, len(result.a), tt.expectedLen)\n\t\t}\n\n\t\tif remaining != \"\" {\n\t\t\tt.Errorf(\"parseArray(%q) returned remaining string = %q, expected empty\", tt.input, remaining)\n\t\t}\n\t}\n}","88b3d88545e7b71fef3f2ddd387f7e6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\"`,\n\t\t\texpectedOutput: \"hello\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello world\"`,\n\t\t\texpectedOutput: \"hello world\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\"`,\n\t\t\texpectedOutput: \"hello\\\"world\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello \\\\\"world\"`,\n\t\t\texpectedOutput: \"hello \\\\\",\n\t\t\texpectedRest:   \"world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"`,\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\\\"escaped quotes\\\" and more\"`,\n\t\t\texpectedOutput: \"\\\"escaped quotes\\\" and more\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"this has an escape \\\\ and more\"`,\n\t\t\texpectedOutput: \"this has an escape \\\\ and more\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"multiple\\\"\\\"quotes\\\"inside\"`,\n\t\t\texpectedOutput: \"multiple\\\"\",\n\t\t\texpectedRest:   \"\\\"quotes\\\"inside\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\toutput, rest, err := parseRawString(tt.input)\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"Unexpected error status for input %q: got %v, want error: %v\", tt.input, err, tt.expectedError)\n\t\t\t}\n\t\t\tif output != tt.expectedOutput {\n\t\t\t\tt.Errorf(\"Expected output %q, got %q\", tt.expectedOutput, output)\n\t\t\t}\n\t\t\tif rest != tt.expectedRest {\n\t\t\t\tt.Errorf(\"Expected rest %q, got %q\", tt.expectedRest, rest)\n\t\t\t}\n\t\t})\n\t}\n}","88bc848125f2ad9eae9f374f797cdd6d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"abc\", \"abc\"},\n\t\t{\"\\\\n\", \"\\n\"},\n\t\t{\"\\\\t\", \"\\t\"},\n\t\t{\"\\\\\\\\\", \"\\\\\"},\n\t\t{\"\\\\\\\"\", \"\\\"\"},\n\t\t{\"\\\\u0041\", \"A\"},\n\t\t{\"\\\\u0041\\\\u0042\\\\u0043\", \"ABC\"},\n\t\t{\"string with no escapes\", \"string with no escapes\"},\n\t\t{\"incomplete \\\\u\", \"incomplete \\\\u\"},\n\t\t{\"incomplete \\\\u004\", \"incomplete \\\\u004\"},\n\t\t{\"surrogate \\\\uD800\\\\uDC00\", string([]rune{0x10000})},\n\t\t{\"unknown \\\\z\", \"unknown \\\\z\"},\n\t\t{\"mixed \\\\uD800\\\\uDC00 and regular \\\\n\", string([]rune{0x10000}) + \"\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","8a73b2899763b71a1e7be8fdde02f4a4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedError bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e+10xyz\", \"-123.45e+10\", \"xyz\", false},\n\t\t{\"+inf123\", \"\", \"123\", false},\n\t\t{\"NaNabc\", \"\", \"abc\", false},\n\t\t{\"notANumber\", \"\", \"notANumber\", true},\n\t\t{\"-0.12345\", \"-0.12345\", \"\", false},\n\t\t{\"123abc456\", \"123\", \"abc456\", false},\n\t\t{\"-inf\", \"\", \"\", false},\n\t\t{\"3.14xyz\", \"3.14\", \"xyz\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif num != test.expectedNum {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, num, test.expectedNum)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expected %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","8a92d6cf40fb9967c46b22a97cd7d74c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"    Hello\", \"Hello\"},\n\t\t{\"\\n\\t\\r Hello\", \"Hello\"},\n\t\t{\"\\n\\t\\r\", \"\"},\n\t\t{\"\\n\\t\\r Hello World\", \"Hello World\"},\n\t\t{\"\\t   \", \"\"},\n\t\t{\"   \\n\\n\\n   \", \"\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"\\r\\nSome text\", \"Some text\"},\n\t\t{\"Leading space\", \"Leading space\"},\n\t\t{\"     \\t \\n Trailing whitespace\", \"Trailing whitespace\"},\n\t\t{\"Normal string\", \"Normal string\"},\n\t\t{\"Mixed \\n\\t spaces\", \"Mixed \\n\\t spaces\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","8bd5ac54a8d97cb3498cac05c38ebb21":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45\", \"-123.45\", \"\", false},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", false},\n\t\t{\"-3.14E-10\", \"-3.14E-10\", \"\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"abc123\", \"\", \"abc123\", true},\n\t\t{\"-abcd\", \"\", \"-abcd\", true},\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"+123abc\", \"+123\", \"abc\", false},\n\t\t{\"\", \"\", \"\", true}, // assuming this case could trigger an error\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawNumber(test.input)\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif result != test.expected || rest != test.rest {\n\t\t\t\tt.Errorf(\"for input %q, expected (%q, %q), got (%q, %q)\", test.input, test.expected, test.rest, result, rest)\n\t\t\t}\n\t\t}\n\t}\n}","8cebbaf56eed54ae7ac1f41dc7bca55a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t// Test cases with valid inputs\n\t\t{`\"hello\" world`, \"hello\", \" world\", false},\n\t\t{`\"escaped \\\" quote\" and more`, \"escaped \\\" quote\", \" and more\", false},\n\t\t{`\"quote at the end\"`, \"quote at the end\", \"\", false},\n\t\t\n\t\t// Test cases with escaped quotes\n\t\t{`\"this is a \\\"test\\\"\" for parsing`, \"this is a \\\"test\\\"\", \" for parsing\", false},\n\t\t{`\"nested \\\"escaped \\\" quotes\\\"\" in string`, \"nested \\\"escaped \\\" quotes\\\"\", \" in string\", false},\n\n\t\t// Test cases with errors\n\t\t{`\"missing closing quote`, \"\", \"\", true},\n\t\t{`\"unclosed backslash \\`, \"\", \"\", true},\n\t\t{`no quotes`, \"\", \"\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawString(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantErr %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.rest)\n\t\t}\n\t}\n}","8e7a2d1d824892a379375c34369f029f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tinput:     \"{}\",\n\t\t\texpected:  \u0026Value{t: TypeObject, o: Object{keysUnescaped: false, kvs: []kv{}}},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\"}`,\n\t\t\texpected:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}}}}},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": 100}`,\n\t\t\texpected:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"100\", t: TypeNumber}},\n\t\t\t}}},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected:    nil,\n\t\t\texpectedErr: fmt.Errorf(\"cannot parse object value: %s\", \"missing value\"),\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\"}`,\n\t\t\texpected:    nil,\n\t\t\texpectedErr: fmt.Errorf(\"cannot find opening '\\\"\\\" for object key\"),\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected:  \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": 100,}`,\n\t\t\texpected:    nil,\n\t\t\texpectedErr: fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tactual, _, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.expectedErr != nil {\n\t\t\t\tif err == nil || err.Error() != tt.expectedErr.Error() {\n\t\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedErr, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !compareValues(actual, tt.expected) {\n\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(a, b *Value) bool {\n\t// Implement a comparison logic here that fits your Value structure\n\t// This function should return true if 'a' and 'b' are equivalent in structure and values\n\treturn false // Placeholder; replace with actual comparison logic\n}","8eae25ac5e53288751b9137800585cf9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\tdepth:    0,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{ /* Expected Value structure */ },\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{ /* Expected Value structure */ },\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string\\\"\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{ /* Expected Value structure */ },\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\tdepth:    1,\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\tdepth:    1,\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\tdepth:    1,\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{ /* Expected Value structure */ },\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, \\\"string\\\"]}\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{ /* Expected Value structure */ },\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[{\\\"key\\\": \\\"value\\\"}]\",\n\t\t\tdepth:    1,\n\t\t\texpected: \u0026Value{ /* Expected Value structure */ },\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{invalid json}\",\n\t\t\tdepth:    1,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse object: %s\", \"invalid json\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\tdepth:    MaxDepth + 1,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, test.depth)\n\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseValue(%q) returned error %v; want %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"parseValue(%q) expected error %v; got none\", test.input, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif result == nil \u0026\u0026 test.expected != nil {\n\t\t\tt.Errorf(\"parseValue(%q) returned nil; expected %v\", test.input, test.expected)\n\t\t}\n\t\t// Add additional checks for expected values based on your implementation.\n\t}\n}","8f3577abc1e9b4953cc10e31b104475d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello World\", \"Hello World\"},\n\t\t{\"\\n\\nHello\", \"Hello\"},\n\t\t{\"\\t\\tHello\", \"Hello\"},\n\t\t{\"   \\t Hello   \", \"Hello   \"},\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\"NoLeadingWS\", \"NoLeadingWS\"},\n\t\t{\"\\r\\n\\r\\nGoodbye\\r\\n\", \"Goodbye\\r\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","8f686768662947d3b2eeeb2bfd5865e5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello World\", \"Hello World\"},\n\t\t{\"This is a quote: \\\"\", \"This is a quote: \\\"\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"New line: \\\\n\", \"New line: \\n\"},\n\t\t{\"Tab: \\\\t\", \"Tab: \\t\"},\n\t\t{\"Form feed: \\\\f\", \"Form feed: \\f\"},\n\t\t{\"Carriage return: \\\\r\", \"Carriage return: \\r\"},\n\t\t{\"Backspace: \\\\b\", \"Backspace: \\b\"},\n\t\t{\"Slash: \\\\/\", \"Slash: /\"},\n\t\t{\"Unicode: \\\\u003C\", \"Unicode: \u003c\"},\n\t\t{\"Invalid unicode: \\\\uZZZZ\", \"Invalid unicode: \\\\uZZZZ\"},\n\t\t{\"Incomplete unicode: \\\\u123\", \"Incomplete unicode: \\\\u123\"},\n\t\t{\"Multiple escapes: \\\\n\\\\t\\\\\", \"\\n\\t\\\\\"},\n\t\t{\"No escapes\", \"No escapes\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9077a4076d664e3c106ffc6a35892930":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr  error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e10 more text\", \"-123.45e10\", \" more text\", nil},\n\t\t{\"nan something\", \"nan\", \" something\", nil},\n\t\t{\"inf next\", \"inf\", \" next\", nil},\n\t\t{\"-inf more\", \"-inf\", \" more\", nil},\n\t\t{\"+inf and more\", \"+inf\", \" and more\", nil},\n\t\t{\"42\", \"42\", \"\", nil},\n\t\t{\"3.14 more\", \"3.14\", \" more\", nil},\n\t\t{\"-1.5\", \"-1.5\", \"\", nil},\n\t\t{\"+2.71e+5\", \"+2.71e+5\", \"\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"- invalid\", \"\", \" invalid\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tnum, rest, err := parseRawNumber(tt.input)\n\n\t\tif num != tt.expectedNum || rest != tt.expectedRest || (err != nil \u0026\u0026 err.Error() != tt.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", \n\t\t\t\ttt.input, num, rest, err, tt.expectedNum, tt.expectedRest, tt.expectedErr)\n\t\t}\n\t}\n}","90accc99b0223bbeeeeba3f4b5a0306c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tobj := \u0026Object{\n\t\tkvs:           []kv{{k: \"key1\", v: \u0026Value{}}},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Assert the initial state\n\tif len(obj.kvs) != 1 || obj.keysUnescaped != true {\n\t\tt.Errorf(\"Expected initial state to be (1, true), got (%d, %v)\", len(obj.kvs), obj.keysUnescaped)\n\t}\n\n\t// Call the reset method\n\tobj.reset()\n\n\t// Assert the state after reset\n\tif len(obj.kvs) != 1 || obj.keysUnescaped != false {\n\t\tt.Errorf(\"Expected state after reset to be (1, false), got (%d, %v)\", len(obj.kvs), obj.keysUnescaped)\n\t}\n\n\t// Add more test cases if necessary\n}","927442f535b7e4a37d3a499635756263":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello, World\", \"Hello, World\"},\n\t\t{\"\\n\\t   Leading whitespace\", \"Leading whitespace\"},\n\t\t{\"NoLeadingWhitespace\", \"NoLeadingWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\\n\\n\", \"\"},\n\t\t{\"\\t\\t\\t\", \"\"},\n\t\t{\"   TrailingWhitespace   \", \"TrailingWhitespace   \"},\n\t\t{\"\\r\\n\\tMixed \\t\\nWhitespaces\", \"Mixed \\t\\nWhitespaces\"},\n\t\t{\"\\rLastCharCR\\r\", \"LastCharCR\\r\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","931de4c9bc95fb1424329131cacd818c":"package fastjson\n\nimport \"testing\"\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n    tests := []struct {\n        input    string\n        expected string\n    }{\n        {\"normal string\", \"normal string\"},\n        {\"escaped \\\\\\\"quotes\\\\\\\"\", \"escaped \\\"quotes\\\"\"},\n        {\"backslash \\\\\\\\ character\", \"backslash \\\\ character\"},\n        {\"newline\\\\ncharacter\", \"newline\\ncharacter\"},\n        {\"tab\\\\tcharacter\", \"tab\\tcharacter\"},\n        {\"formfeed\\\\fcharacter\", \"formfeed\\fcharacter\"},\n        {\"carriage return\\\\rcharacter\", \"carriage return\\rcharacter\"},\n        {\"unicode\\\\u003c\u0026\\\\u003e;\", \"unicode\u003c\u003e\u0026\"},\n        {\"invalid escape \\\\u not a hex\", \"invalid escape \\\\u not a hex\"},\n        {\"incomplete unicode\\\\u003\", \"incomplete unicode\\\\u003\"},\n        {\"surrogate pair \\\\uD83D\\\\uDE00\", \"surrogate pair ðŸ˜€\"},\n        {\"unknown escape \\\\xAB\", \"unknown escape \\\\xAB\"},\n        {\"mixed \\\\u003C and normal\", \"mixed \u003c and normal\"},\n        {\"just a backslash \\\\\", \"just a backslash \\\\\"},\n    }\n\n    for _, test := range tests {\n        result := unescapeStringBestEffort(test.input)\n        if result != test.expected {\n            t.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n        }\n    }\n}","944cf59ea2ceb697831d45af4347d2e0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"escaped \\\\\\\"quote\\\\\\\"\\\"\", \"escaped \\\"quote\\\"\", \"\", false},\n\t\t{\"\\\"unescaped quote\\\"\", \"unescaped quote\", \"\", false},\n\t\t{\"\\\"incomplete string\", \"\", \"\", true},\n\t\t{\"\\\"escaped \\\\\" , \"\", \"\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawString(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, want error = %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, result, test.expected)\n\t\t}\n\t\tif remaining != test.remaining {\n\t\t\tt.Errorf(\"parseRawString(%q) remaining = %q, want %q\", test.input, remaining, test.remaining)\n\t\t}\n\t}\n}","95389a6837d9eb3a84111077fcf4a879":"// parse_raw_number_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedNum  string\n\t\texpectedRemainder string\n\t\texpectedErr  error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-123.45e+6moretext\", \"-123.45e+6\", \"moretext\", nil},\n\t\t{\"0.999\", \"0.999\", \"\", nil},\n\t\t{\"NaNmore\", \"NaN\", \"more\", nil},\n\t\t{\"+Infinity\", \"+Infinity\", \"\", nil},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-nan123\", \"-nan\", \"123\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, remainder, err := parseRawNumber(test.input)\n\n\t\tif num != test.expectedNum || remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", \n\t\t\t\ttest.input, num, remainder, err, test.expectedNum, test.expectedRemainder, test.expectedErr)\n\t\t}\n\n\t\tif (err != nil) != (test.expectedErr != nil) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v; expected error = %v\", test.input, err, test.expectedErr)\n\t\t}\n\t}\n}","962a6598fdf73728f2ed67799af5edd1":"// parse_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid JSON object\",\n\t\t\tinput:    `{\"key\": \"value\", \"number\": 123}`,\n\t\t\texpected: /* expected Value structure */,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid JSON array\",\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: /* expected Value structure */,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid JSON\",\n\t\t\tinput:    `{\"key\": \"value\", \"number\": }`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty JSON\",\n\t\t\tinput:    `{}`,\n\t\t\texpected: /* expected empty Value structure */,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"JSON with special characters\",\n\t\t\tinput:    `{\"escaped\": \"some \\\\\"escaped\\\\\" text\"}`,\n\t\t\texpected: /* expected Value structure */,\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Here we would typically compare the expected and got values,\n\t\t\t// but due to the nature of the Value type, you'd implement\n\t\t\t// a method to check for equality to test against.\n\t\t\tif !valuesEqual(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Parse() got = %v, expected %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// valuesEqual is a placeholder function to check equality of Value types.\nfunc valuesEqual(v1, v2 *Value) bool {\n\t// Implement appropriate comparison logic for Value types.\n\treturn false // Replace with actual comparison\n}","973c84c52e171785247ca35616aa1d1f":"// skipWS_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                     // Empty string\n\t\t{\" \", \"\"},                   // Single space\n\t\t{\"  \\t\\n\", \"\"},              // Multiple whitespace characters\n\t\t{\"abc\", \"abc\"},              // No whitespace\n\t\t{\" a b \", \"a b \"},           // Leading whitespace\n\t\t{\"\\t c d\", \"c d\"},           // Leading tab\n\t\t{\" e f \", \"e f \"},           // Trailing whitespace\n\t\t{\" \\t times \", \"times\"},      // Mixed whitespace\n\t\t{\"  \\t  fastjson  \\n\", \"fastjson\"}, // Multiple whitespace around words\n\t\t{\" \\x1F\\x1F\\x1Fabc\", \"abc\"}, // Non-whitespace characters\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","97f2c7add671ebe3902cf2bb0b7a7f33":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedKeys []string\n\t\texpectedValues []string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedKeys: []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"value1\", \"value2\"},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedKeys: []string{},\n\t\t\texpectedValues: []string{},\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": 123, \"key2\": false}`,\n\t\t\texpectedKeys: []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"123\", \"false\"},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{} `,\n\t\t\texpectedKeys: []string{},\n\t\t\texpectedValues: []string{},\n\t\t\texpectError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedKeys: []string{},\n\t\t\texpectedValues: []string{},\n\t\t\texpectError:   true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpectedKeys: []string{\"key1\"},\n\t\t\texpectedValues: []string{`{\"nestedKey\": \"nestedValue\"}`},\n\t\t\texpectError:   false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\t\t_, rem, err := parseObject(test.input, c, depth)\n\n\t\tif (err != nil) != test.expectError {\n\t\t\tif test.expectError {\n\t\t\t\tt.Errorf(\"Expected an error for input %q but got none.\", test.input)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Did not expect an error for input %q but got %v.\", test.input, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Additional checks can be performed on the parsed object if necessary.\n\t\tif len(rem) \u003e 0 {\n\t\t\tt.Errorf(\"Parser did not consume all input. Remaining: %q\", rem)\n\t\t}\n\n\t\t// Further testing of the constructed Value/Objects can be added here.\n\t}\n}","988e774d0c9bbf8ebec69401aa6197ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello,\\\\nWorld!\", \"Hello,\\nWorld!\"},\n\t\t{\"Quote: \\\\\\\"Test\\\\\\\"\", \"Quote: \\\"Test\\\"\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Slash: \\\\/\", \"Slash: /\"},\n\t\t{\"Tab: \\\\t\", \"Tab: \\t\"},\n\t\t{\"Unicode: \\\\u4F60\\\\u597D\", \"Unicode: ä½ å¥½\"}, // Unicode for \"Hello\"\n\t\t{\"Invalid unicode: \\\\uXYZ1\", \"Invalid unicode: \\\\uXYZ1\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: ðŸ˜€\"}, // Grinning face emoji\n\t\t{\"Broken escape: \\\\uD83D\\\\u\", \"Broken escape: \\\\uD83D\\\\u\"},\n\t\t{\"Mixed: A\\\\nB\\\\tC\\\\\\\"D\\\\\\\\E\", \"Mixed: A\\nB\\tC\\\"D\\\\E\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","98c795bf1798c0c906aef3710ac7839f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"normalString\", false},           // Regular string with no special chars\n\t\t{\"contains\\\\backslash\", true},     // Contains a backslash\n\t\t{\"newline\\n\", true},                // Contains a newline character\n\t\t{\"tab\\tcharacter\", true},           // Contains a tab character\n\t\t{\"string with spaces\", false},      // String with spaces only\n\t\t{\"special@char$\", true},            // Contains special characters\n\t\t{\"\", false},                        // Empty string\n\t\t{\"non-printable\\x01character\", true}, // Contains non-printable character\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; want %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9914998199e4809edead0dd3661441c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"Hello, World!\" more text`,\n\t\t\texpectedValue:  \"Hello, World!\",\n\t\t\texpectedRemainder: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"This is a test\\\" string\" with more text`,\n\t\t\texpectedValue:  \"This is a test\\\" string\",\n\t\t\texpectedRemainder: \" with more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"This string is missing a closing quote`,\n\t\t\texpectedValue:  \"This string is missing a closing quote\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Escaped quotes here: \\\\\"\"\",\n\t\t\texpectedValue:  \"Escaped quotes here: \\\\\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"Just some text\"`,\n\t\t\texpectedValue:  \"Just some text\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) returned value: %q, expected: %q\", test.input, value, test.expectedValue)\n\t\t}\n\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawString(%q) returned remainder: %q, expected: %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","99f957235d301b83e920e28e6e699f3b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,, 3]\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[{\\\"key\\\": \\\"value\\\"}]\",\n\t\t\texpected: nil, // You would need to create expected structure if parsing an object\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, remainder, err := parseArray(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 len(result.a) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, expected %v\", result.a, tt.expected)\n\t\t\t}\n\t\t\t// You can add more checks for the values inside `result.a` compared to `tt.expected` here.\n\t\t\t_ = remainder // Optionally check if remaining input is valid based on your requirements\n\t\t})\n\t}\n}","9a400049bc667439078b6f295edaa514":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terrMsg   string\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeString, s: \"hello\"}, \u0026Value{t: TypeString, s: \"world\"}},\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeTrue}, \u0026Value{t: TypeFalse}, \u0026Value{t: TypeNull}},\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,]\",\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"missing ',' after array value\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"unexpected end of array\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[,]\",\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"cannot parse array value: missing value\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"]\",\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"missing '['\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseArray(test.input, c, 0)\n\t\tif test.errMsg != \"\" {\n\t\t\tif err == nil || err.Error() != test.errMsg {\n\t\t\t\tt.Errorf(\"For input %q, expected error message: %q, got: %v\", test.input, test.errMsg, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"For input %q, unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"For input %q, expected length: %d, got: %d\", test.input, len(test.expected), len(result.a))\n\t\t} else {\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\t\tt.Errorf(\"For input %q, expected value: %v, got: %v\", test.input, test.expected[i], v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif remainder != \"\" {\n\t\t\tt.Errorf(\"For input %q, expected empty remainder, got: %q\", test.input, remainder)\n\t\t}\n\t}\n}","9b380eec8fa2e09aba0eeacd0f8da3ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\nworld\", \"hello\\nworld\"},\n\t\t{\"quote: \\\\\\\"value\\\\\\\"\", \"quote: \\\"value\\\"\"},\n\t\t{\"backslash: \\\\\\\\\", \"backslash: \\\\\"},\n\t\t{\"invalid\\\\uX\", \"invalid\\\\uX\"}, // Invalid unicode should be unchanged\n\t\t{\"surrogate: \\\\uD83D\\\\uDE00\", \"surrogate: ðŸ˜€\"}, // Valid surrogate pair\n\t\t{\"empty: \\\\u\", \"empty: \\\\u\"}, // Should remain unchanged as it's invalid\n\t\t{\"multiple\\\\escapes\\\\n\\\\t\", \"multiple escapes\\n\\t\"},\n\t\t{\"\\\\uD83D\\\\uDE02 incorrect\", \"ðŸ˜‚ incorrect\"}, // Example with valid emojis\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9c63bb399dab302f6903eab6bf141443":"package fastjson\n\nimport \"testing\"\n\nfunc TestGetValue(t *testing.T) {\n    c := \u0026cache{}\n\n    // Test 1: Verify getValue returns a pointer to Value\n    val := c.getValue()\n    if val == nil {\n        t.Error(\"Expected non-nil Value from getValue\")\n    }\n\n    // Test 2: Verify consecutive calls to getValue increase the slice length\n    initialLen := len(c.vs)\n    _ = c.getValue()\n    if len(c.vs) != initialLen+1 {\n        t.Errorf(\"Expected slice length %d, got %d\", initialLen+1, len(c.vs))\n    }\n\n    // Test 3: Verify that the new Value can be used and is properly initialized\n    newValue := c.getValue()\n    newValue.s = \"test\"\n    if c.vs[len(c.vs)-1].s != \"test\" {\n        t.Errorf(\"Expected Value.s to be 'test', got '%s'\", c.vs[len(c.vs)-1].s)\n    }\n\n    // Test 4: Check the capacity behavior of the slice\n    initialCap := cap(c.vs)\n    for i := 0; i \u003c initialCap; i++ {\n        c.getValue()\n    }\n    if cap(c.vs) \u003c= initialCap {\n        t.Errorf(\"Expected capacity to be greater than %d after multiple getValue calls, got %d\", initialCap, cap(c.vs))\n    }\n}","9d1c733b765c6e5bb2e318b7bf7b1f1d":"package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\t// Prepare test cases\n\ttestCases := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Valid float\",\n\t\t\tjson:     `{\"number\": 42.5}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 42.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjson:     `{\"number\": 42.5}`,\n\t\t\tkeys:     []string{\"missing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tjson:     `{\"number\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (array)\",\n\t\t\tjson:     `{\"number\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested valid float\",\n\t\t\tjson:     `{\"nested\": {\"number\": 3.14}}`,\n\t\t\tkeys:     []string{\"nested\", \"number\"},\n\t\t\texpected: 3.14,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index\",\n\t\t\tjson:     `{\"numbers\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"numbers\", \"1\"},\n\t\t\texpected: 2.2,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of bounds\",\n\t\t\tjson:     `{\"numbers\": [1.1, 2.2, 3.3]}`,\n\t\t\tkeys:     []string{\"numbers\", \"10\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tc.json)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tresult := v.GetFloat64(tc.keys...)\n\t\t\tassert.Equal(t, tc.expected, result)\n\t\t})\n\t}\n}","9d722c9775b36fd5ffebc9644db7afd5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemaining string\n\t\texpectedError     bool\n\t}{\n\t\t{\"\\\"key\\\"\", \"key\", \"\", false},\n\t\t{\"\\\"complex\\\\key\\\"\", \"complex\\\\key\", \"\", false},\n\t\t{\"\\\"key1\\\"somevalue\", \"key1\", \"\\\"somevalue\\\"\", false},\n\t\t{\"simplekey\", \"simplekey\", \"\", false},\n\t\t{\"\\\"missing-close\", \"\", \"\", true},\n\t\t{\"\\\"with\\\\escape\\\"\", \"with\\\\escape\", \"\", false},\n\t\t{\"\\\"another\\\\example\\\"more\", \"another\\\\example\", \"\\\"more\\\"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remaining, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned error: %v, want error: %v\", test.input, err, test.expectedError)\n\t\t}\n\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", test.input, key, test.expectedKey)\n\t\t}\n\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawKey(%q) remaining = %q, want %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","9ded4cbbfb091b99193517a3125351b6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t// Add your test cases here\n\t\t{\"Hello\\\\nWorld\", \"Hello\\nWorld\"},\n\t\t{\"Escaped quote: \\\\\\\"This is a quote\\\\\\\"\", \"Escaped quote: \\\"This is a quote\\\"\"},\n\t\t{\"Invalid unicode: \\\\uD800\\\\uDC00\", \"Invalid unicode: ðŸ˜„\"}, // U+10000\n\t\t{\"Just a plain string\", \"Just a plain string\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Mixed: \\\\n and \\\\t\", \"Mixed: \\n and \\t\"},\n\t\t{\"Incomplete escape: \\\\u123\", \"Incomplete escape: \\\\u123\"},\n\t\t{\"Invalid escape: \\\\x7\", \"Invalid escape: \\\\x7\"},\n\t\t{\"No escape here\", \"No escape here\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9e07e1684a9175571829fc4b6c2848ae":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"strconv\"\n)\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t{\n\t\t\tname: \"Get from object\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeInt, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"value1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Get from array\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"10\"},\n\t\t\t\t\t{t: TypeNumber, s: \"20\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"1\"},\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"20\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid key\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"10\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-existing key\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"key2\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Nil input\",\n\t\t\tinput: nil,\n\t\t\tkeys:     []string{\"key1\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Get nested value\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"outer\", \u0026Value{\n\t\t\t\t\t\t\tt: TypeObject,\n\t\t\t\t\t\t\to: Object{\n\t\t\t\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t\t\t\t{\"inner\", \u0026Value{t: TypeString, s: \"inner_value\"}},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: \u0026Value{t: TypeString, s: \"inner_value\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Get(tt.keys...)\n\t\t\tif (got == nil) != (tt.expected == nil) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, got)\n\t\t\t} else if got != nil \u0026\u0026 got.s != tt.expected.s {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected.s, got.s)\n\t\t\t}\n\t\t})\n\t}\n}","9e0ed56369c9670fc81d5c33642bb3d0":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"hello   \", \"hello\"},\n\t\t{\"   hello   \", \"hello\"},\n\t\t{\"\", \"\"},\n\t\t{\" \\t \\n \\r \", \"\"},\n\t\t{\"  \\t hello world  \\n\\t \", \"hello world\"},\n\t\t{\"noWhitespace\", \"noWhitespace\"},\n\t\t{\"   \\t   \", \"\"},\n\t\t{\" \\n \\t\\n    \", \"\"},\n\t\t{\"leading space\", \"leading space\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWS(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9e524aa14aefac4ab3ed67beab293c90":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                          // Test with empty string\n\t\t{\"   hello\", \"hello\"},            // Test with leading spaces\n\t\t{\"world   \", \"world   \"},         // Test with trailing spaces\n\t\t{\"  leading and trailing  \", \"leading and trailing  \"}, // Test with leading and trailing spaces\n\t\t{\"\\nnew line\", \"new line\"},       // Test with new line character\n\t\t{\"\\t tabbed\", \"tabbed\"},           // Test with tab character\n\t\t{\"hello world\", \"hello world\"},    // Test with no white space\n\t\t{\"   \", \"\"},                       // Test with only spaces\n\t\t{\"\\n\\t     \", \"\"},                // Test with new lines and tabs\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","9ecd12b15090c9fb41c1b44b254548bd":"// parse_raw_string_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t\texpectedRemaining string\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedOutput: \"hello\",\n\t\t\texpectedRemaining: \" world\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\" more text`,\n\t\t\texpectedOutput: \"hello\\\"world\",\n\t\t\texpectedRemaining: \" more text\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello\\\"world\"`,\n\t\t\texpectedOutput: \"hello\\\"world\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello`,\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedErr:    fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:          `hello\"world`,\n\t\t\texpectedOutput: `hello`,\n\t\t\texpectedRemaining: `\"world`,\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"\" extra string`,\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedRemaining: \" extra string\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput, remaining, err := parseRawString(test.input)\n\n\t\tif output != test.expectedOutput || remaining != test.expectedRemaining || !isErrorEqual(err, test.expectedErr) {\n\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v), expected (%q, %q, %v)\", test.input, output, remaining, err, test.expectedOutput, test.expectedRemaining, test.expectedErr)\n\t\t}\n\t}\n}\n\n// Helper function to compare errors\nfunc isErrorEqual(a, b error) bool {\n\tif a == nil \u0026\u0026 b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\treturn a.Error() == b.Error()\n}","9f53176c39cd51e97ea861dcb0f5391f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,2,3]\",\n\t\t\texpected: \u0026Value{t: TypeArray, a: []*Value{\u0026Value{s: \"1\", t: TypeNumber}, \u0026Value{s: \"2\", t: TypeNumber}, \u0026Value{s: \"3\", t: TypeNumber}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"n\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"n\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"a\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) \u0026\u0026 (tt.err == nil || err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif result != nil \u0026\u0026 tt.expected != nil {\n\t\t\t\tif result.s != tt.expected.s || result.t != tt.expected.t {\n\t\t\t\t\tt.Errorf(\"Expected: %v, got: %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t} else if (result != nil) || (tt.expected != nil) {\n\t\t\t\tt.Errorf(\"Expected: %v, got: %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","9f91440c10436878372c66e4c407c431":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    \"Hello, World!\",\n\t\t\texpected: \"\\\"Hello, World!\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"Special characters: \\n \\t \\\\ \\\"\",\n\t\t\texpected: \"\\\"Special characters: \\\\n \\\\t \\\\\\\\ \\\\\\\"\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: \"\\\"\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\u2022 Bullet\",\n\t\t\texpected: \"\\\"\\\\u2022 Bullet\\\"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := escapeString(nil, test.input)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"escapeString(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","9fedd9038220768c2bac39e510f99dc1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Test case 1: Initial retrieval from an empty cache\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Error(\"Expected to get a Value, got nil\")\n\t}\n\n\t// Test case 2: Ensure the cache grows correctly\n\tval2 := c.getValue()\n\tif cap(c.vs) != 2 {\n\t\tt.Errorf(\"Expected capacity to be 2 after second getValue, got %d\", cap(c.vs))\n\t}\n\n\t// Test case 3: Check the length of the cache\n\tif len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected length of vs to be 2, got %d\", len(c.vs))\n\t}\n\n\t// Test case 4: Ensure we get the last value\n\tval3 := c.getValue()\n\tif len(c.vs) != 3 {\n\t\tt.Errorf(\"Expected length of vs to be 3, got %d\", len(c.vs))\n\t}\n\tif val3 != \u0026c.vs[2] {\n\t\tt.Error(\"Expected to get the last Value from the cache\")\n\t}\n\n\t// Test case 5: Ensure values in cache are initialized\n\tif val1.t != TypeNull {\n\t\tt.Errorf(\"Expected TypeNull for the first value, got %v\", val1.t)\n\t}\n}","a0373d3677e79e645b6cf3ae1430e524":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ']'\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, ]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1 2]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\t\tresult, remaining, err := parseArray(test.input, c, depth)\n\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Errorf(\"parseArray(%q) returned unexpected error: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got none\", test.input, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"parseArray(%q) expected %d values, got %d\", test.input, len(test.expected), len(result.a))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i := range result.a {\n\t\t\tif result.a[i].s != test.expected[i].s || result.a[i].t != test.expected[i].t {\n\t\t\t\tt.Errorf(\"parseArray(%q) expected value %v, got %v\", test.input, test.expected[i], result.a[i])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif test.input != remaining {\n\t\t\tt.Errorf(\"parseArray(%q) expected remaining input to be %q, got %q\", test.input, test.input, remaining)\n\t\t}\n\t}\n}","a0be294fe6b017709180cd40c5a0fee5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"existing float key\",\n\t\t\tinput:    `{\"value\": 10.5}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 10.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"missing key\",\n\t\t\tinput:    `{\"value\": 10.5}`,\n\t\t\tkeys:     []string{\"missing\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"wrong type (string)\",\n\t\t\tinput:    `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"wrong type (object)\",\n\t\t\tinput:    `{\"value\": {}}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with float\",\n\t\t\tinput:    `{\"values\": [5.5, 10.5]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 10.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"array with non-float\",\n\t\t\tinput:    `{\"values\": [5.5, \"not_a_number\"]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"data\": {\"value\": 7.2}}`,\n\t\t\tkeys:     []string{\"data\", \"value\"},\n\t\t\texpected: 7.2,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested and non-existing key\",\n\t\t\tinput:    `{\"data\": {\"value\": 7.2}}`,\n\t\t\tkeys:     []string{\"data\", \"missing\"},\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse input: %v\", err)\n\t\t\t}\n\t\t\tresult := v.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"GetFloat64() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","a182a5363911766a168f3e7aaec2dfd7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValueMarshalTo(t *testing.T) {\n\t// Test cases for each JSON value type.\n\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"String\",\n\t\t\tvalue:    \u0026Value{s: \"hello\", t: TypeString},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Number\",\n\t\t\tvalue:    \u0026Value{s: \"42\", t: TypeNumber},\n\t\t\texpected: \"42\",\n\t\t},\n\t\t{\n\t\t\tname:     \"True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{s: \"value1\", t: TypeString},\n\t\t\t\t\t\u0026Value{s: \"value2\", t: TypeString},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpected: \"[\\\"value1\\\",\\\"value2\\\"]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\",\n\t\t},\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\tvalue: \u0026Value{s: \"raw string\", t: typeRawString},\n\t\t\texpected: \"\\\"raw string\\\"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","a1999ce8c66e2667b511eb94b5a41394":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.456\", \"-123.456\", \"\", nil},\n\t\t{\"3.14159e10\", \"3.14159e10\", \"\", nil},\n\t\t{\"2.71E+5\", \"2.71E+5\", \"\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"-nan\", \"-nan\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"-x\", \"\", \"-x\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"123.45.67\", \"123.45\", \".67\", nil},\n\t\t{\"-123.abc\", \"-123\", \".abc\", nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawNumber(test.input)\n\t\tif result != test.expected || remaining != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", test.input, result, remaining, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","a1df8c3e567b7b354393345c6fe5b1af":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Setup test cases\n\ttests := []struct {\n\t\tinput    *Value\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t// Test cases for existing keys\n\t\t{\n\t\t\tinput:    parseJSON(`{\"name\": {\"first\": \"John\", \"last\": \"Doe\"}}`),\n\t\t\tkeys:     []string{\"name\", \"first\"},\n\t\t\texpected: parseJSON(`\"John\"`),\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"numbers\": [1, 2, 3]}`),\n\t\t\tkeys:     []string{\"numbers\", \"1\"},\n\t\t\texpected: parseJSON(`2`),\n\t\t},\n\t\t// Test cases for non-existing keys\n\t\t{\n\t\t\tinput:    parseJSON(`{\"name\": {\"first\": \"John\"}}`),\n\t\t\tkeys:     []string{\"name\", \"middle\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    parseJSON(`{\"numbers\": [1, 2, 3]}`),\n\t\t\tkeys:     []string{\"numbers\", \"3\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    nil,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\t// Run tests\n\tfor _, test := range tests {\n\t\tresult := test.input.Get(test.keys...)\n\t\tif !valuesEqual(result, test.expected) {\n\t\t\tt.Errorf(\"Get(%v) = %v, want %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}\n\n// Helper functions (if needed for parsing)\nfunc parseJSON(s string) *Value {\n\t// Simulate JSON parsing (you can implement your own parsing logic)\n\tv, _ := new(Parser).Parse(s)\n\treturn v\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\t// Implement comparison between Value instances\n\tif v1 == nil \u0026\u0026 v2 == nil {\n\t\treturn true\n\t}\n\tif v1 == nil || v2 == nil {\n\t\treturn false\n\t}\n\t// Check the type and value equivalence.\n\treturn v1.String() == v2.String() // Adapt the comparison as necessary.\n}","a235cfa8a800f97d978cf0010f204605":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"string\\\"\",\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.45\",\n\t\t\texpected: \u0026Value{s: \"123.45\", t: TypeNumber},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"3.14e-10\",\n\t\t\texpected: \u0026Value{s: \"3.14e-10\", t: TypeNumber},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [true, false]}\",\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueTrue, valueFalse}, t: TypeArray}}}}, t: TypeObject},\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Fatalf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t\tif tt.wantErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result == nil \u0026\u0026 tt.expected != nil {\n\t\t\t\tt.Fatalf(\"expected non-nil result, got nil\")\n\t\t\t}\n\t\t\tif result != nil \u0026\u0026 tt.expected == nil {\n\t\t\t\tt.Fatalf(\"expected nil result, got non-nil\")\n\t\t\t}\n\t\t\t// Further comparisons for expected Value should be added here.\n\t\t})\n\t}\n}","a25d25f02f8b86580274389aa74aef8f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\texpectedErr: \"cannot parse empty string\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: // expected Value from parsing the object,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: // expected Value from parsing the array,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"escaped\\\\\\\"string\\\"\",\n\t\t\texpected: // expected Value from parsing the string,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalidjson\",\n\t\t\texpected: nil,\n\t\t\texpectedErr: \"unexpected value found: \\\"invalidjson\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"nested\\\":{\\\"key\\\":\\\"value\\\"}}\",\n\t\t\texpected: // expected Value from parsing nested object,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: // expected Value from parsing number,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"    {\\\"key\\\": \\\"value\\\"}\", // testing whitespace\n\t\t\texpected: // expected Value from parsing the object,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpected: // expected Value from parsing object with array,\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t// Add more test cases as needed.\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, tail, err := parseValue(test.input, c, 0)\n\n\t\t// Check for expected error\n\t\tif test.expectedErr != \"\" {\n\t\t\tif err == nil || err.Error() != test.expectedErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) expected error: %v, got: %v\", test.input, test.expectedErr, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check result and tail\n\t\tif err != nil {\n\t\t\tt.Errorf(\"parseValue(%q) unexpected error: %v\", test.input, err)\n\t\t}\n\t\tif result == nil || !result.Equals(test.expected) { // Assuming an Equals method exists for Value\n\t\t\tt.Errorf(\"parseValue(%q) expected: %v, got: %v\", test.input, test.expected, result)\n\t\t}\n\t\tif tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) expected empty tail, got: %q\", test.input, tail)\n\t\t}\n\t}\n}","a26b80d5cf03fc8984eb5057109c119c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedType Type\n\t\texpectError  bool\n\t}{\n\t\t{\n\t\t\tinput:        \"\",\n\t\t\texpectedType: TypeNull,\n\t\t\texpectError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:        \"null\",\n\t\t\texpectedType: TypeNull,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        \"true\",\n\t\t\texpectedType: TypeTrue,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        \"false\",\n\t\t\texpectedType: TypeFalse,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"string\"`,\n\t\t\texpectedType: TypeString,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        \"123.456\",\n\t\t\texpectedType: TypeNumber,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        \"[1, 2, 3]\",\n\t\t\texpectedType: TypeArray,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        `{\"key\": \"value\"}`,\n\t\t\texpectedType: TypeObject,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        \"t\",\n\t\t\texpectedType: TypeNull,\n\t\t\texpectError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:        \"f\",\n\t\t\texpectedType: TypeNull,\n\t\t\texpectError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:        \"random_string\",\n\t\t\texpectedType: TypeNull,\n\t\t\texpectError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:        `[{ \"k\": 1 }, {}, {}]`, // valid array of objects\n\t\t\texpectedType: TypeArray,\n\t\t\texpectError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:        `{\"key\": [1, 2, 3]}`, // valid object with array\n\t\t\texpectedType: TypeObject,\n\t\t\texpectError:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t_, _, err := parseValue(tt.input, c, 0)\n\n\t\t\tif tt.expectError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected an error but got none\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"expected no error but got: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","a26ff4e2909ed2e5edc90ee00447e0ab":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"a\", v: \u0026Value{t: TypeNumber, s: \"1\"}},\n\t\t\t\t\t\t{k: \"b\", v: \u0026Value{t: TypeString, s: \"two\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"a\":1,\"b\":\"two\"}`,\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNull},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t\t{t: TypeFalse},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[null,true,false]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"empty\", v: \u0026Value{t: TypeArray, a: []*Value{}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"empty\":[]}`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"MarshalTo(%v) = %s; expected %s\", test.value, string(result), test.expected)\n\t\t}\n\t}\n}","a2c3d304cfd86c61fd58859dae8a49a4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a quote: \\\"\", \"This is a quote: \\\"\"},\n\t\t{\"Escape backslash: \\\\\\\\\", \"Escape backslash: \\\\\"},\n\t\t{\"Newline\\ncharacter\", \"Newline\\ncharacter\"},\n\t\t{\"Tab\\tcharacter\", \"Tab\\tcharacter\"},\n\t\t{\"Carriage return\\rcharacter\", \"Carriage return\\rcharacter\"},\n\t\t{\"Form feed\\fcharacter\", \"Form feed\\fcharacter\"},\n\t\t{\"Backspace\\bcharacter\", \"Backspace\\bcharacter\"},\n\t\t{\"Unicode: \\u1234\", \"Unicode: \\u1234\"},\n\t\t{\"Invalid Unicode: \\\\uZZZZ\", \"Invalid Unicode: \\\\uZZZZ\"},\n\t\t{\"Surrogate pair: \\\\uD83D\\\\uDE00\", \"Surrogate pair: ðŸ˜€\"},\n\t\t{\"Normal string with invalid escape: \\\\xFF\", \"Normal string with invalid escape: \\\\xFF\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a2f4f8f4570d0c7dbc3af7e259d2ec73":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"Hello, World!\"`, \"Hello, World!\"},\n\t\t{`\"Newline:\\nTab:\\tBackslash:\\\\\"`, \"Newline:\\nTab:\\tBackslash:\\\\\"},\n\t\t{`\"Quote:\\\"Test\\\" and Slash:/\"`, `Quote:\"Test\" and Slash:/`},\n\t\t{`\"Invalid Unicode: \\uXYZ\"`, \"Invalid Unicode: \\\\uXYZ\"},\n\t\t{`\"Valid Unicode: \\u0041\"`, \"Valid Unicode: A\"},\n\t\t{`\"Surrogate: \\uD83D\\uDE00\"`, \"Surrogate: ðŸ˜€\"},\n\t\t{`\"Incomplete Escape: \\uD83D\"`, \"Incomplete Escape: \\\\uD83D\"},\n\t\t{`\"Escape Unknown: \\k\"`, \"Escape Unknown: \\\\k\"},\n\t\t{`\"No Escape\"`, \"No Escape\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a31ab6e2a85edb4433203a49ee3c665e":"// file: unescape_string_best_effort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\\"quote\\\"\", \"\\\"quote\\\"\"},\n\t\t{\"\\\\backslash\", \"\\\\backslash\"},\n\t\t{\"new\\\\nline\", \"new\\nline\"},\n\t\t{\"tab\\\\tcharacter\", \"tab\\tcharacter\"},\n\t\t{\"unicode\\\\u0041\", \"unicodeA\"},\n\t\t{\"surrogate\\\\uD83D\\\\uDE00\", \"surrogateðŸ˜€\"},\n\t\t{\"invalid\\\\uXYZ\", \"invalid\\\\uXYZ\"},\n\t\t{\"not special \\b backspace\", \"not special \\b backspace\"},\n\t\t{\"double backslash \\\\\\\\\", \"double backslash \\\\\"},\n\t\t{\"mixed\\\\u0022case\\\\u0061\\\\u006e\", \"mixed\\\"casean\"},\n\t\t{\"no escape here\", \"no escape here\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a33528d332979ee2e87754f0c86d20ab":"// parse_array_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedLen  int\n\t\texpectedError bool\n\t}{\n\t\t{\"[1, 2, 3]\", 3, false},\n\t\t{\"[ ]\", 0, false},\n\t\t{\"[   ]\", 0, false},\n\t\t{\"[1, 2, 3, ]\", 3, true}, // trailing comma\n\t\t{\"[1, 2, 3, 4, 5]\", 5, false},\n\t\t{\"[1, , 3]\", 0, true}, // invalid value\n\t\t{\"[1, 2, [3, 4]]\", 3, false}, // nested array\n\t\t{\"[1, true, false, null, \\\"string\\\"]\", 5, false}, // mixed types\n\t\t{\"[1, 2, 3, 4,]}\", 0, true}, // invalid closing bracket\n\t\t{\"[1, 2, 3, , 5]\", 0, true}, // invalid middle value\n\t\t{\"[1, 2, 3] extra\", 0, true}, // extra text after array\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif test.expectedError \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"Expected error for input %q but got none\", test.input)\n\t\t}\n\n\t\tif !test.expectedError \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"Did not expect error for input %q but got: %v\", test.input, err)\n\t\t}\n\n\t\tif !test.expectedError \u0026\u0026 result != nil \u0026\u0026 len(result.a) != test.expectedLen {\n\t\t\tt.Errorf(\"Expected len %d for input %q but got %d\", test.expectedLen, test.input, len(result.a))\n\t\t}\n\t}\n}","a3df68aeb767bb59890390b17452dac4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* expected Value properties */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* expected Value properties for empty object */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\texpected: \u0026Value{ /* expected nested Value properties */ },\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* expected Value properties for object with array */ },\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q, but got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"Expected result for input %q to be %+v, but got %+v\", test.input, test.expected, result)\n\t\t\t}\n\t\t}\n\n\t\t// Additional checks for remaining string after parsing could be added here if needed.\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement comparison logic based on Value fields\n\treturn false // return comparison result\n}","a3e48b7e8794256346743472b05097d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"This is a backslash: \\\\\"`,\n\t\t\texpected: \"This is a backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Newline: \\n and Tab: \\t\"`,\n\t\t\texpected: \"Newline: \\n and Tab: \\t\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Quote: \\\"\"`,\n\t\t\texpected: \"Quote: \\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid escape: \\x\"`,\n\t\t\texpected: \"Invalid escape: \\\\x\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate: ðŸ˜€\", // Assuming that utf16.DecodeRune converts these correctly.\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\u0041\"` , // ASCII \"A\"\n\t\t\texpected: \"A\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Complete escape: \\b\\f\\n\\r\\t\\\"\\\\\\/\"`,\n\t\t\texpected: \"Complete escape: \\b\\f\\n\\r\\t\\\"\\\\/\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a4fba82f647f277618decc132ad6bbbd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"plain string\", \"plain string\"},\n\t\t{\"escaped quote: \\\\\\\"\", \"escaped quote: \\\"\"},\n\t\t{\"escaped backslash: \\\\\\\\\", \"escaped backslash: \\\\\"},\n\t\t{\"newline\\\\ncharacter\", \"newline\\ncharacter\"},\n\t\t{\"tab\\\\tcharacter\", \"tab\\tcharacter\"},\n\t\t{\"carriage return\\\\rcharacter\", \"carriage return\\rcharacter\"},\n\t\t{\"form feed\\\\fcharacter\", \"form feed\\fcharacter\"},\n\t\t{\"backspace\\\\bcharacter\", \"backspace\\bcharacter\"},\n\t\t{\"slash\\\\character\", \"slash/character\"},\n\t\t{\"valid unicode \\\\u0041\", \"valid unicode A\"},\n\t\t{\"invalid unicode \\\\uXYZ\", \"invalid unicode \\\\uXYZ\"},\n\t\t{\"surrogate pair \\\\uD83D\\\\uDE00\", \"surrogate pair ðŸ˜€\"},\n\t\t{\"incomplete escape \\\\uDE00\", \"incomplete escape \\\\uDE00\"},\n\t\t{\"mixed \\\\uD83D\\\\uDE00 text\", \"mixed ðŸ˜€ text\"},\n\t\t{\"no escape sequences\", \"no escape sequences\"},\n\t\t{\"empty string\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","a5b8556bdc21d1ed32652816cb936193":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"nil value\",\n\t\t\tinput:    \u0026Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"true value\",\n\t\t\tinput:    \u0026Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"false value\",\n\t\t\tinput:    \u0026Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"string value\",\n\t\t\tinput:    \u0026Value{t: TypeString, s: \"test\"},\n\t\t\texpected: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"number value\",\n\t\t\tinput:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array value\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"[1,\\\"two\\\",true]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object value\",\n\t\t\tinput: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tgot := tt.input.MarshalTo(dst)\n\t\t\tif string(got) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","a5e01f7b9aa5ec2f7147d5827f47b853":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Testing the default case (this test will panic if the code is correct)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar unknownType Type = 8 // Assuming 8 is not a valid type\n\t_ = unknownType.String() // This should cause a panic\n}","a5e6d71fa8c194773dae5aec918f7650":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedKey string\n\t\texpectedVal string\n\t\texpectErr   bool\n\t}{\n\t\t{\n\t\t\tinput:       `{\"key1\": \"value1\"}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"value1\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedKey: \"key1\",\n\t\t\texpectedVal: \"value1\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", key2: \"value2\"}`,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:     `{}`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot, _, err := parseObject(tt.input, c, 0)\n\n\t\tif (err != nil) != tt.expectErr {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, expectErr = %v\", tt.input, err, tt.expectErr)\n\t\t\tcontinue\n\t\t}\n\t\tif tt.expectErr {\n\t\t\tcontinue\n\t\t}\n\n\t\tif kvs := got.o.kvs; len(kvs) \u003e 0 {\n\t\t\tif kvs[0].k != tt.expectedKey || kvs[0].v.s != tt.expectedVal {\n\t\t\t\tt.Errorf(\"parseObject(%q) = (%q, %q), want (%q, %q)\", tt.input, kvs[0].k, kvs[0].v.s, tt.expectedKey, tt.expectedVal)\n\t\t\t}\n\t\t}\n\t}\n}","a68b8acf83004d4b6f250b3f0d6d4899":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terrMsg   string\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":2}`,\n\t\t\texpected: /* expected Value for valid input */,\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":} `,\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: /* expected Value for empty object */,\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 2,}`,\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\" \"value1\"}`,\n\t\t\texpected: nil,\n\t\t\terrMsg:   \"cannot find opening '\\\"\\\" for object key\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\",\"key2\":{}}`,\n\t\t\texpected: /* expected Value for nested empty object */,\n\t\t\terrMsg:   \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":2,\"key2\":[\"value1\", \"value2\"]}`,\n\t\t\texpected: /* expected Value for object with array value */,\n\t\t\terrMsg:   \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif test.errMsg != \"\" {\n\t\t\tif err == nil || err.Error() != test.errMsg {\n\t\t\t\tt.Errorf(\"expected error message: %s, got: %v\", test.errMsg, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\n\t\tif result == nil || remainder == \"\" { // Use appropriate comparison for Value.\n\t\t\tt.Fatalf(\"expected non-nil result and non-empty remainder, got result: %+v, remainder: %s\", result, remainder)\n\t\t}\n\n\t\t// Add detailed comparisons between expected and actual Value if necessary.\n\t}\n}","a70e42d00ffb9791be3db5ccdfec5efc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tvalue        *Value\n\t\tdst          []byte\n\t\texpected     []byte\n\t}{\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"boolean true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"boolean false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt:  TypeNumber,\n\t\t\t\ts:  []byte(\"123\"),\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname: \"string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: []byte(\"1\")},\n\t\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"[1,\\\"two\\\",true]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: []byte(\"42\")}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo(tt.dst)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","a811fb62916e790dd566077bd6a35109":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.expected, func(t *testing.T) {\n\t\t\tgot := tt.input.String()\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"String() = %q, want %q\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic scenario\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type, got none\")\n\t\t}\n\t}()\n\t\n\tvar unknownType Type = 999 // Using a value that should not be valid\n\t_ = unknownType.String()    // This should cause a panic\n}","a9e232b93b484e6e3469207334efc237":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_getValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Initial state: empty cache\n\tif val := c.getValue(); val == nil {\n\t\tt.Errorf(\"Expected a non-nil value, got nil\")\n\t}\n\n\t// Adding a value to the cache\n\tc.vs = append(c.vs, Value{})\n\tval1 := c.getValue()\n\tif val1 == nil {\n\t\tt.Errorf(\"Expected a non-nil value after appending, got nil\")\n\t}\n\n\t// The value returned should point to the last item\n\tif \u0026c.vs[0] != val1 {\n\t\tt.Errorf(\"Expected returned value to be the last added value, got different reference\")\n\t}\n\n\t// Adding another value to the cache\n\tc.vs = append(c.vs, Value{})\n\tval2 := c.getValue()\n\tif val2 == nil {\n\t\tt.Errorf(\"Expected a non-nil value after appending, got nil\")\n\t}\n\n\t// The value returned should point to the last added value\n\tif \u0026c.vs[1] != val2 {\n\t\tt.Errorf(\"Expected returned value to be the last added value, got different reference\")\n\t}\n\t\n\t// Test capacity growth\n\tinitialCap := cap(c.vs)\n\tfor i := 0; i \u003c initialCap; i++ {\n\t\tc.vs = append(c.vs, Value{})\n\t}\n\t\n\tval3 := c.getValue()\n\tif \u0026c.vs[initialCap] != val3 {\n\t\tt.Errorf(\"Expected returned value to point to newly added value after capacity growth, got different reference\")\n\t}\n}","aa6b9126a55855fa7d61ff927be5d07b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinputKvs    []kv\n\t\texpectedKvs []kv\n\t}{\n\t\t{\n\t\t\tname: \"simple unescape\",\n\t\t\tinputKvs: []kv{\n\t\t\t\t{k: \"key\\\\u0021\", v: \u0026Value{}},\n\t\t\t\t{k: \"anotherKey\\\\u0022\", v: \u0026Value{}},\n\t\t\t},\n\t\t\texpectedKvs: []kv{\n\t\t\t\t{k: \"key!\", v: \u0026Value{}},\n\t\t\t\t{k: \"anotherKey\\\"\", v: \u0026Value{}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no unescaping needed\",\n\t\t\tinputKvs: []kv{\n\t\t\t\t{k: \"simpleKey\", v: \u0026Value{}},\n\t\t\t},\n\t\t\texpectedKvs: []kv{\n\t\t\t\t{k: \"simpleKey\", v: \u0026Value{}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple keys with different escapes\",\n\t\t\tinputKvs: []kv{\n\t\t\t\t{k: \"key\\\\n1\", v: \u0026Value{}},\n\t\t\t\t{k: \"key\\\\t2\", v: \u0026Value{}},\n\t\t\t},\n\t\t\texpectedKvs: []kv{\n\t\t\t\t{k: \"key\\n1\", v: \u0026Value{}},\n\t\t\t\t{k: \"key\\t2\", v: \u0026Value{}},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\to := \u0026Object{kvs: tt.inputKvs}\n\t\t\to.unescapeKeys()\n\n\t\t\tfor i, kv := range o.kvs {\n\t\t\t\tif kv.k != tt.expectedKvs[i].k {\n\t\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expectedKvs[i].k, kv.k)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !o.keysUnescaped {\n\t\t\t\tt.Error(\"keysUnescaped should be true after unescaping\")\n\t\t\t}\n\t\t})\n\t}\n}","aadbb8a32afe4362ea210a5afd1631b3":"// file: get_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Creating a test JSON structure\n\tjsonStr := `{\"name\": \"John\", \"age\": 30, \"friends\": [\"Alice\", \"Bob\"], \"address\": {\"city\": \"NY\", \"zip\": \"10001\"}}`\n\tvalue, err := Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys     []string\n\t\texpected *Value\n\t}{\n\t\t// Test for existing keys\n\t\t{[]string{\"name\"}, value.Get(\"name\")},\n\t\t{[]string{\"age\"}, value.Get(\"age\")},\n\t\t{[]string{\"friends\", \"0\"}, value.Get(\"friends\", \"0\")},\n\t\t{[]string{\"address\", \"city\"}, value.Get(\"address\", \"city\")},\n\n\t\t// Test for non-existing keys\n\t\t{[]string{\"nonexistent\"}, nil},\n\t\t{[]string{\"friends\", \"3\"}, nil},\n\t\t{[]string{\"address\", \"country\"}, nil},\n\t\t{[]string{\"address\", \"zip\", \"extra\"}, nil},\n\n\t\t// Test for invalid array index\n\t\t{[]string{\"friends\", \"-1\"}, nil},\n\t\t{[]string{\"friends\", \"2\"}, nil},\n\n\t\t// Test for nested objects\n\t\t{[]string{\"address\"}, value.Get(\"address\")},\n\t\t{[]string{\"address\", \"zip\"}, value.Get(\"address\", \"zip\")},\n\n\t\t// Test for multiple keys\n\t\t{[]string{\"name\", \"friends\", \"1\"}, nil}, // Invalid because of multiple keys\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := value.Get(test.keys...)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Get(%v) = %v; expected %v\", test.keys, result, test.expected)\n\t\t}\n\t}\n}","ab7254c63d697a2098f1843de7716d02":"// file: get_float64_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tjsonData string\n\t\tkeys     []string\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tname:     \"Valid float64\",\n\t\t\tjsonData: `{\"value\": 42.42}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 42.42,\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing key\",\n\t\t\tjsonData: `{\"value\": 42.42}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (string)\",\n\t\t\tjsonData: `{\"value\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid type (object)\",\n\t\t\tjsonData: `{\"value\": {\"nested\": 21}}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Valid float in array\",\n\t\t\tjsonData: `{\"values\": [10, 20.5, 30]}`,\n\t\t\tkeys:     []string{\"values\", \"1\"},\n\t\t\texpected: 20.5,\n\t\t},\n\t\t{\n\t\t\tname:     \"Array index out of range\",\n\t\t\tjsonData: `{\"values\": [10, 20.5]}`,\n\t\t\tkeys:     []string{\"values\", \"5\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty JSON object\",\n\t\t\tjsonData: `{}`,\n\t\t\tkeys:     []string{\"value\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Parse the JSON data into a Value.\n\t\t\tvalue, err := Parse(tc.jsonData)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error parsing JSON: %v\", err)\n\t\t\t}\n\n\t\t\t// Call GetFloat64 with the specified keys.\n\t\t\tresult := value.GetFloat64(tc.keys...)\n\n\t\t\t// Check if the result matches the expectation.\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","abaa0a9b4a1101f0ffe6fbdd0d47f13e":"package fastjson\n\nimport \"testing\"\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"\\n\\nhello\", \"hello\"},\n\t\t{\"\\thello\", \"hello\"},\n\t\t{\"\\r\\nhello\", \"hello\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\", \"\"},\n\t\t{\"hello\", \"hello\"},\n\t\t{\"    world   \", \"world   \"},\n\t\t{\"\\n\\n\\n\", \"\"},\n\t\t{\"\\t\\t\\t\", \"\"},\n\t\t{\"\\r\\r\\r\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","abc7cd4d914a92eeb50b3ac0d0168973":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum  string\n\t\texpectedRest string\n\t\texpectedErr   error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-3.14 more text\", \"-3.14\", \" more text\", nil},\n\t\t{\"3e10 trailing\", \"3e10\", \" trailing\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan extra text\", \"nan\", \" extra text\", nil},\n\t\t{\"-123.45e+6 additional\", \"-123.45e+6\", \" additional\", nil},\n\t\t{\"not a number\", \"\", \"not a number\", fmt.Errorf(\"unexpected char: %q\", \"n\")},\n\t\t{\"--1\", \"\", \"--1\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")}, // Edge case: empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\n\t\tif num != test.expectedNum || rest != test.expectedRest || fmt.Sprint(err) != fmt.Sprint(test.expectedErr) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, num, rest, err, test.expectedNum, test.expectedRest, test.expectedErr)\n\t\t}\n\t}\n}","abf55f53ceb89bc55eca47b43f24c5c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": 123}`,\n\t\t\texpected: // expected Value for valid input,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: // expected Value for empty object,\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tresult, _, err := parseObject(tt.input, c, depth)\n\n\t\t\tif tt.err != nil \u0026\u0026 (err == nil || err.Error() != tt.err.Error()) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t} else if tt.expected != nil \u0026\u0026 !result.Equals(tt.expected) { // Assuming Value has an Equals method\n\t\t\t\tt.Errorf(\"expected value %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","ac3e7c0295a352264e9924a302df5bfd":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedKey string\n\t\texpectedRemainder string\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tinput:    `\"key\"`,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"anotherKey\"`,\n\t\t\texpectedKey: \"anotherKey\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with spaces\"`,\n\t\t\texpectedKey: \"key with spaces\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedErr: nil,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\ \"escaped quotes\\\" and more\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:    `\"key with \\ and other characters\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:    `key without quotes`,\n\t\t\texpectedKey: \"key without quotes\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr: fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRemainder: `\"`,\n\t\t\texpectedErr: nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, remainder, err := parseRawKey(test.input)\n\n\t\tif key != test.expectedKey || remainder != test.expectedRemainder || \n\t\t\t(err == nil \u0026\u0026 test.expectedErr != nil) || \n\t\t\t(err != nil \u0026\u0026 test.expectedErr == nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawKey(%q) = %q, %q, %v; expected %q, %q, %v\", \n\t\t\t\ttest.input, key, remainder, err, \n\t\t\t\ttest.expectedKey, test.expectedRemainder, test.expectedErr)\n\t\t}\n\t}\n}","ac7b78a14ebcaa3e2da32258ce951a82":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e10\", \"-123.45e10\", \"\", false},\n\t\t{\"+3.14xyz\", \"3.14\", \"xyz\", false},\n\t\t{\"-.1.23\", \"-.1\", \".23\", false},\n\t\t{\"42abc\", \"42\", \"abc\", false},\n\t\t{\"-abc\", \"\", \"-abc\", true},\n\t\t{\"+xyz\", \"\", \"+xyz\", true},\n\t\t{\"\", \"\", \"\", true}, // testing empty input\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedErr %v\", test.input, err, test.expectedErr)\n\t\t}\n\t\tif num != test.expectedNum {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expectedNum %q\", test.input, num, test.expectedNum)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","adf277bf36616eaa81aa73858644bb63":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type(%d).String() = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test an invalid type to ensure it panics (this should be caught by the test framework)\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"Expected panic for unknown Type, but did not get one.\")\n\t\t}\n\t}()\n\n\t// Since typeRawString is skipped in String(), we directly cast to it\n\tvar invalidType Type = typeRawString\n\t_ = invalidType.String() // This should panic\n}","ae0b572cc88c22817952f3cafbbcef57":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{t: typeRawString, s: \"string\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{t: TypeArray}, // Expecting a complex value, this should ideally match a constructed expected value\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expecting a complex value, this should ideally match a constructed expected value\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3,]\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"unclosed\"`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(tt.input, c, 0)\n\t\t\t\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Fatalf(\"parseValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 v != nil \u0026\u0026 !(v.Type() == tt.expected.Type() \u0026\u0026 v.s == tt.expected.s) {\n\t\t\t\tt.Fatalf(\"parseValue() = %v, expected %v\", v, tt.expected)\n\t\t\t}\n\t\t\tif err == nil \u0026\u0026 tail != tt.input[len(tt.input)-1:] {\n\t\t\t\tt.Fatalf(\"parseValue() tail = %v, expected tail for input %v\", tail, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}","ae4d8039b488babc11d0ff7d99cdce09":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\t\n\t// Test the first call to getKV\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Fatalf(\"Expected non-nil kv, got nil\")\n\t}\n\t\n\t// Check the initial state of the kv\n\tif kv1.k != \"\" {\n\t\tt.Errorf(\"Expected key to be empty, got %q\", kv1.k)\n\t}\n\tif kv1.v != nil {\n\t\tt.Errorf(\"Expected value to be nil, got %v\", kv1.v)\n\t}\n\n\t// Test adding another KV pair\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Fatalf(\"Expected non-nil kv, got nil\")\n\t}\n\n\t// Check both kvs are different\n\tif kv1 == kv2 {\n\t\tt.Error(\"Expected kv1 and kv2 to be different instances\")\n\t}\n}","ae9123f503428ba5692e3ea27ac17461":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedValue string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput: `\"hello world\"`,\n\t\t\texpectedValue: \"hello world\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"a string with an escaped \\\" character\"`,\n\t\t\texpectedValue: `a string with an escaped \" character`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"an unclosed string`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: `\"escaped \\\\\"`,\n\t\t\texpectedValue: `escaped \\`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"multiple escaped characters: \\\\\"`,\n\t\t\texpectedValue: `multiple escaped characters: \\`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"a string with a quote \\\" and another one \\\"`,\n\t\t\texpectedValue: `a string with a quote \" and another one `,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `no quotes here`,\n\t\t\texpectedValue: `no quotes here`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remaining, err := parseRawString(test.input)\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, wantError %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"parseRawString(%q) remaining = %q, want %q\", test.input, remaining, test.expectedRemaining)\n\t\t}\n\t}\n}","ae9693e983789f3217631b97120308a1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedNum string\n\t\texpectedRemainder string\n\t\texpectedErr error\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", nil},\n\t\t{\"-12345\", \"-12345\", \"\", nil},\n\t\t{\"3.14moretext\", \"3.14\", \"moretext\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"123E10suffix\", \"123E10\", \"suffix\", nil},\n\t\t{\"+12.34\", \"+12.34\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"\", \"\", \"\", nil}, // should add handling for empty input if needed\n\t\t{\"0x123\", \"\", \"0x123\", fmt.Errorf(\"unexpected char: %q\", \"0x123\")}, // invalid hex input\n\t}\n\n\tfor _, tt := range tests {\n\t\tnum, remainder, err := parseRawNumber(tt.input)\n\n\t\tif num != tt.expectedNum || remainder != tt.expectedRemainder || (err != nil \u0026\u0026 err.Error() != nil) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; expected %q, %q, %v\",\n\t\t\t\ttt.input, num, remainder, err, tt.expectedNum, tt.expectedRemainder, tt.expectedErr)\n\t\t}\n\t}\n}","af10a7f04b7057fbe477a26022125bc6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemain string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"test\"`,\n\t\t\texpectedValue:  \"test\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"test\\\\\"`,\n\t\t\texpectedValue:  \"test\\\\\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"a string with \\\"escaped quotes\\\"\"`,\n\t\t\texpectedValue:  \"a string with \\\"escaped quotes\\\"\",\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `this string is missing a closing quote`,\n\t\t\texpectedValue: `this string is missing a closing quote`,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"string with an escaped quote \\\\\"`,\n\t\t\texpectedValue: `string with an escaped quote \\`,\n\t\t\texpectedRemain: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remain, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) unexpected error: %v\", test.input, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remain != test.expectedRemain {\n\t\t\tt.Errorf(\"parseRawString(%q) remainder = %q, want %q\", test.input, remain, test.expectedRemain)\n\t\t}\n\t}\n}","afef6c05b46268a259be59a5a9fca661":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tv        *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"null value\",\n\t\t\tv:        \u0026Value{t: TypeNull},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"true value\",\n\t\t\tv:        \u0026Value{t: TypeTrue},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"false value\",\n\t\t\tv:        \u0026Value{t: TypeFalse},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"number value\",\n\t\t\tv:        \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpected: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"string value\",\n\t\t\tv:        \u0026Value{s: \"hello\", t: TypeString},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"array value\",\n\t\t\tv: \u0026Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpected: []byte(\"[1,2,3]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"object value\",\n\t\t\tv: \u0026Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"raw string value\",\n\t\t\tv:    \u0026Value{s: \"raw string\", t: typeRawString},\n\t\t\texpected: []byte(\"\\\"raw string\\\"\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := make([]byte, 0)\n\t\t\tresult := tt.v.MarshalTo(dst)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","b04b74319d940f0635ec6c3ab0c4f8db":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput []*Value\n\t\texpectedErr    bool\n\t}{\n\t\t{\n\t\t\tinput:       \"[]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeArray, a: nil}},\n\t\t\texpectedErr:    false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeNumber},\n\t\t\t\t{t: TypeNumber},\n\t\t\t\t{t: TypeNumber},\n\t\t\t},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[true, false, null]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeTrue},\n\t\t\t\t{t: TypeFalse},\n\t\t\t\t{t: TypeNull},\n\t\t\t},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[\\\"hello\\\", \\\"world\\\"]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeString},\n\t\t\t\t{t: TypeString},\n\t\t\t},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, , 3]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2,]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t{t: TypeNumber},\n\t\t\t\t{t: TypeNumber},\n\t\t\t},\n\t\t\texpectedErr: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"Expected error: %v, got: %v\", test.expectedErr, err)\n\t\t}\n\t\tif err == nil {\n\t\t\tif len(result.a) != len(test.expectedOutput) {\n\t\t\t\tt.Errorf(\"Expected length: %d, got: %d\", len(test.expectedOutput), len(result.a))\n\t\t\t}\n\t\t}\n\t}\n}","b0b5fd686ad16fef8e8d59f74a9f67c4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Sample JSON data for testing\n\tjsonData := `{\n\t\t\"key1\": {\n\t\t\t\"key2\": [\n\t\t\t\t\"value1\",\n\t\t\t\t\"value2\"\n\t\t\t]\n\t\t},\n\t\t\"array\": [\n\t\t\t{\"key3\": \"value3\"},\n\t\t\t{\"key4\": \"value4\"}\n\t\t],\n\t\t\"emptyArray\": []\n\t}`\n\n\t// Parse the JSON data\n\tp := \u0026Parser{}\n\tv, err := p.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys       []string\n\t\texpected   *Value\n\t\tshouldFail bool\n\t}{\n\t\t{[]string{\"key1\", \"key2\", \"0\"}, v.Get(\"key1\", \"key2\", \"0\"), false}, // should return \"value1\"\n\t\t{[]string{\"key1\", \"key2\", \"1\"}, v.Get(\"key1\", \"key2\", \"1\"), false}, // should return \"value2\"\n\t\t{[]string{\"array\", \"0\", \"key3\"}, v.Get(\"array\", \"0\", \"key3\"), false}, // should return \"value3\"\n\t\t{[]string{\"array\", \"1\", \"key4\"}, v.Get(\"array\", \"1\", \"key4\"), false}, // should return \"value4\"\n\t\t{[]string{\"emptyArray\", \"0\"}, nil, false}, // should return nil\n\t\t{[]string{\"key1\", \"key2\", \"2\"}, nil, false}, // out of bounds, should return nil\n\t\t{[]string{\"nonexistent\", \"key\"}, nil, false}, // nonexistent path, should return nil\n\t\t{[]string{\"key1\", \"nonexistent\"}, nil, false}, // should return nil\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := v.Get(test.keys...)\n\t\tif test.shouldFail \u0026\u0026 result != nil {\n\t\t\tt.Errorf(\"Expected nil for keys %v, got %v\", test.keys, result)\n\t\t} else if !test.shouldFail \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"Expected value for keys %v, got nil\", test.keys)\n\t\t}\n\t}\n}","b19489aa7c40cead98db30a214543112":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNum string\n\t\texpectedRemainder string\n\t\texpectedErr error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45e+6abc\", \"-123.45e+6\", \"abc\", nil},\n\t\t{\"3.14159xyz\", \"3.14159\", \"xyz\", nil},\n\t\t{\"nan_extra\", \"nan\", \"_extra\", nil},\n\t\t{\"inf\", \"inf\", \"\", nil},\n\t\t{\"-inf extra\", \"-inf\", \" extra\", nil},\n\t\t{\"invalid\", \"\", \"invalid\", fmt.Errorf(\"unexpected char: %q\", \"i\")},\n\t\t{\"- invalid\", \"\", \"- invalid\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"e3\", \"\", \"e3\", fmt.Errorf(\"unexpected char: %q\", \"e\")},\n\t\t{\"12.3.4\", \"12.3\", \".4\", nil},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tnum, remainder, err := parseRawNumber(tt.input)\n\t\t\tif num != tt.expectedNum || remainder != tt.expectedRemainder || !errorEqual(err, tt.expectedErr) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), want (%q, %q, %v)\",\n\t\t\t\t\ttt.input, num, remainder, err, tt.expectedNum, tt.expectedRemainder, tt.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc errorEqual(err1, err2 error) bool {\n\tif err1 == nil {\n\t\treturn err2 == nil\n\t}\n\tif err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","b23f165790dec92592a71e74e8fd8fd3":"// file: parse_array_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false, null]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeTrue}, \u0026Value{t: TypeFalse}, \u0026Value{t: TypeNull}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeString, s: \"string1\"}, \u0026Value{t: TypeString, s: \"string2\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      nil, // This is just to describe a case for illustrative purposes.\n\t\t},\n\t\t{\n\t\t\tinput:    \"[[1, 2], [3, 4]]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeArray}, \u0026Value{t: TypeArray}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[[1, 2],3]\",\n\t\t\texpected: nil,\n\t\t\terr:      nil, // This is just a placeholder and should be adjusted based on expected behavior.\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 test.err == nil {\n\t\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t\t}\n\t\tif err == nil \u0026\u0026 test.err != nil {\n\t\t\tt.Fatalf(\"expected error %v, got none\", test.err)\n\t\t}\n\t\tif err != nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error() {\n\t\t\tt.Fatalf(\"expected error %v, got %v\", test.err, err)\n\t\t}\n\t\t\n\t\t// Validate the result values\n\t\tif len(result.a) != len(test.expected) {\n\t\t\tt.Fatalf(\"expected %d values, got %d\", len(test.expected), len(result.a))\n\t\t}\n\t\tfor i, v := range result.a {\n\t\t\tif v.t != test.expected[i].t || v.s != test.expected[i].s {\n\t\t\t\tt.Fatalf(\"expected value type %d and string %s, got type %d and string %s\", test.expected[i].t, test.expected[i].s, v.t, v.s)\n\t\t\t}\n\t\t}\n\t}\n}","b274ce25e34f5619bedd4d1f51c52eb9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[null, true, false]\",\n\t\t\texpected: []*Value{{t: TypeNull}, {t: TypeTrue}, {t: TypeFalse}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"a\"}, {t: TypeString, s: \"b\"}, {t: TypeString, s: \"c\"}},\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected end of array\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1 2]\", // Invalid JSON array\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after array value\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseArray(test.input, c, 0)\n\n\t\tif !equalValues(result.a, test.expected) || (err != nil \u0026\u0026 test.err == nil) || (err == nil \u0026\u0026 test.err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseArray(%q) = (%v, %q, %v), expected (%v, _, %v)\", test.input, result, remainder, err, test.expected, test.err)\n\t\t}\n\t}\n}\n\nfunc equalValues(a, b []*Value) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i].t != b[i].t || a[i].s != b[i].s {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","b2c1c16f19f788e01adcb94f55cad0b0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\n// TestParseObject tests the parseObject function for various scenarios.\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\t\n\ttests := []struct {\n\t\tinput         string\n\t\texpected      *Value\n\t\texpectedError string\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key1\":\"value1\", \"key2\":42}`,\n\t\t\texpected: \u0026Value{ /* fill with expected Value structure */ },\n\t\t\texpectedError: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\texpectedError: \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpected: nil,\n\t\t\texpectedError: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"`,\n\t\t\texpected: nil,\n\t\t\texpectedError: \"unexpected end of object\",\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{ /* fill with expected empty Value structure */ },\n\t\t\texpectedError: \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 err.Error() != test.expectedError {\n\t\t\tt.Errorf(\"For input %q, expected error %q but got %q\", test.input, test.expectedError, err.Error())\n\t\t}\n\n\t\tif test.expectedError == \"\" \u0026\u0026 result == nil {\n\t\t\tt.Errorf(\"For input %q, expected non-nil result but got nil\", test.input)\n\t\t}\n\t\t\n\t\t// Additional checks for the expected output can be added here\n\t}\n}","b2cf84a6aeb0b423ad46a2a92b4babdf":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue   *Value\n\t\twant    []byte\n\t}{\n\t\t{\n\t\t\tvalue:   \u0026Value{t: TypeNull},\n\t\t\twant:    []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tvalue:   \u0026Value{t: TypeTrue},\n\t\t\twant:    []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tvalue:   \u0026Value{t: TypeFalse},\n\t\t\twant:    []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tvalue:   \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\twant:    []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tvalue:   \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\twant:    []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tvalue:   \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\twant:    []byte(\"[1,2,3]\"),\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\twant: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\"),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(string(tt.want), func(t *testing.T) {\n\t\t\tgot := tt.value.MarshalTo(nil)\n\t\t\tif string(got) != string(tt.want) {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}","b450486b468a9852733fdb3976569a3c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\t// Define a sample JSON object for testing\n\tjsonData := `{\n\t\t\"validNumber\": 123.45,\n\t\t\"nested\": {\n\t\t\t\"anotherLevel\": {\n\t\t\t\t\"floatValue\": 67.89\n\t\t\t}\n\t\t},\n\t\t\"notANumber\": \"I am a string\",\n\t\t\"emptyObject\": {}\n\t}`\n\n\t// Parse the sample JSON data\n\tparser := Parser{}\n\tvalue, err := parser.Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys   []string\n\t\texpVal float64\n\t}{\n\t\t{[]string{\"validNumber\"}, 123.45},\n\t\t{[]string{\"nested\", \"anotherLevel\", \"floatValue\"}, 67.89},\n\t\t{[]string{\"notANumber\"}, 0},\n\t\t{[]string{\"emptyObject\"}, 0},\n\t\t{[]string{\"nonExistentKey\"}, 0},\n\t\t{[]string{\"nested\", \"anotherLevel\", \"nonExistentKey\"}, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := value.GetFloat64(tt.keys...)\n\t\tif got != tt.expVal {\n\t\t\tt.Errorf(\"GetFloat64(%v) = %v; want %v\", tt.keys, got, tt.expVal)\n\t\t}\n\t}\n}","b514df76d6af14fc4f444c942cde5ac8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\r\\t   World\", \"World\"},\n\t\t{\"   Test String   \", \"Test String   \"},\n\t\t{\"\\n   \\t  \\r\\n \\t \", \"\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"  Multiple   Spaces  \", \"Multiple   Spaces  \"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","b5ba9e305ed271a13086bb75c92eeb74":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"\\\"Test String\\\"\",\n\t\t\texpected: \u0026Value{t: typeRawString, s: \"Test String\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{t: TypeArray},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key1\\\": [1, 2, 3], \\\"key2\\\": {\\\"innerKey\\\": \\\"innerValue\\\"}}\",\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"invalid string\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"key\\\": \\\"value\\\", \\\"key2\\\":{}}\",\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"nested\\\": {\\\"deeply\\\": {\\\"nested\\\": \\\"value\\\"}}}\",\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\t\tresult, tail, err := parseValue(test.input, c, depth)\n\t\t\n\t\tif test.err \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"parseValue(%q) expected an error, got none\", test.input)\n\t\t}\n\t\tif !test.err \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"parseValue(%q) expected no error, got: %v\", test.input, err)\n\t\t}\n\t\tif result != nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, result, test.expected)\n\t\t}\n\t\tif err == nil \u0026\u0026 tail != \"\" {\n\t\t\tt.Errorf(\"parseValue(%q) = %s, expected empty tail\", test.input, tail)\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement this function to compare the structure of expected and actual Value objects.\n\t// This is a placeholder function and needs to be properly implemented based on Value structure.\n\treturn false // Replace with actual comparison logic.\n}","b649516c92ed84646401f9a0c8be1b42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\t// Sample JSON data for testing\n\tjsonStr := `{\"name\": \"John\", \"age\": 30, \"friends\": [\"Doe\", \"Smith\"], \"nested\": {\"key\": \"value\"}}`\n\tparser := new(Parser)\n\tvalue, err := parser.Parse(jsonStr)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys       []string\n\t\texpected   *Value\n\t\texpectNil  bool\n\t}{\n\t\t{[]string{\"name\"}, value.Get(\"name\"), false},\n\t\t{[]string{\"age\"}, value.Get(\"age\"), false},\n\t\t{[]string{\"friends\", \"1\"}, value.Get(\"friends\", \"1\"), false},          // 1-based index\n\t\t{[]string{\"nested\", \"key\"}, value.Get(\"nested\", \"key\"), false},\n\t\t{[]string{\"nonexistent\"}, value.Get(\"nonexistent\"), true},            // key not present\n\t\t{[]string{\"friends\", \"3\"}, value.Get(\"friends\", \"3\"), true},          // invalid index\n\t\t{[]string{\"nested\", \"nonexistent\"}, value.Get(\"nested\", \"nonexistent\"), true}, // inner key not present\n\t\t{[]string{}, value, false}, // root value\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.keys[0], func(t *testing.T) {\n\t\t\tresult := value.Get(test.keys...)\n\t\t\tif test.expectNil {\n\t\t\t\tif result != nil {\n\t\t\t\t\tt.Errorf(\"Expected nil, got: %v\", result)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif result == nil {\n\t\t\t\t\tt.Errorf(\"Expected a value, got nil\")\n\t\t\t\t} else if result.String() != test.expected.String() {\n\t\t\t\t\tt.Errorf(\"Expected %v, got: %v\", test.expected.String(), result.String())\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","b677050dbcec629c8d29f82e2c3f2fd6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Type(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *Value\n\t\texpected Type\n\t}{\n\t\t{\n\t\t\tname:     \"TypeNull\",\n\t\t\tinput:    \u0026Value{t: TypeNull},\n\t\t\texpected: TypeNull,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeObject\",\n\t\t\tinput:    \u0026Value{t: TypeObject},\n\t\t\texpected: TypeObject,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeArray\",\n\t\t\tinput:    \u0026Value{t: TypeArray},\n\t\t\texpected: TypeArray,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeString\",\n\t\t\tinput:    \u0026Value{t: TypeString},\n\t\t\texpected: TypeString,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeNumber\",\n\t\t\tinput:    \u0026Value{t: TypeNumber},\n\t\t\texpected: TypeNumber,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeTrue\",\n\t\t\tinput:    \u0026Value{t: TypeTrue},\n\t\t\texpected: TypeTrue,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeFalse\",\n\t\t\tinput:    \u0026Value{t: TypeFalse},\n\t\t\texpected: TypeFalse,\n\t\t},\n\t\t{\n\t\t\tname:     \"TypeRawString\",\n\t\t\tinput:    \u0026Value{t: typeRawString, s: \"escaped\\\\nstring\"},\n\t\t\texpected: typeRawString,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.input.Type(); got != tt.expected {\n\t\t\t\tt.Errorf(\"Type() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","b702b7f64b16cbf5e64694750a7a6b86":"// parse_raw_key_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedKey   string\n\t\texpectedRest  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"key\"`,\n\t\t\texpectedKey:   \"key\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"anotherKey\" more text`,\n\t\t\texpectedKey:   \"anotherKey\",\n\t\t\texpectedRest:  \" more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"key with space\"`,\n\t\t\texpectedKey:   \"key with space\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"key with \\\" escaped quotes\"`,\n\t\t\texpectedKey:   \"key with \\\" escaped quotes\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true, // since it would go to slow path\n\t\t},\n\t\t{\n\t\t\tinput:          `\"key with \\u003c escaped unicode\"`,\n\t\t\texpectedKey:   \"key with \u003c escaped unicode\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true, // since it would go to slow path\n\t\t},\n\t\t{\n\t\t\tinput:          `\"missing closing quote`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, rest, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawKey(%q) returned error: %v, expected error: %v\", test.input, err, test.expectedError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) key = %q, expected %q\", test.input, key, test.expectedKey)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawKey(%q) rest = %q, expected %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","b77435e569aff9b55cf6558a968f476c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\"world`,\n\t\t\texpectedValue: \"hello\",\n\t\t\texpectedRest:  \"world\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"he said \\\"hi\\\" to you\" and left`,\n\t\t\texpectedValue: `he said \"hi\" to you`,\n\t\t\texpectedRest:  \" and left\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped quote \\\\\"`,\n\t\t\texpectedValue: \"escaped quote \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unmatched quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedValue: \"no quotes here\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"another test with an unmatched quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"Expected error: %v, but got: %v for input: %q\", test.expectedError, err, test.input)\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"Expected value: %q, but got: %q for input: %q\", test.expectedValue, value, test.input)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"Expected rest: %q, but got: %q for input: %q\", test.expectedRest, rest, test.input)\n\t\t}\n\t}\n}","b7a19dad9f8dc44de63625c70135f9cb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedNum string\n\t\texpectedRest string\n\t\texpectedErr bool\n\t}{\n\t\t{\"123.45abc\", \"123.45\", \"abc\", false},\n\t\t{\"-123.456\", \"-123.456\", \"\", false},\n\t\t{\"3.14e10 more\", \"3.14e10\", \" more\", false},\n\t\t{\"-inf some text\", \"-inf\", \" some text\", false},\n\t\t{\"NaN text\", \"NaN\", \" text\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"invalid123\", \"\", \"invalid123\", true},\n\t\t{\"\", \"\", \"\", true},\n\t\t{\"0x1F\", \"\", \"0x1F\", true},\n\t\t{\"+2.5\", \"+2.5\", \"\", false},\n\t\t{\"123--\", \"123\", \"--\", false},\n\t\t{\"--123\", \"\", \"--123\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"parseRawNumber(%q) =\u003e unexpected error status: %v\", test.input, err)\n\t\t}\n\t\tif num != test.expectedNum {\n\t\t\tt.Errorf(\"parseRawNumber(%q) =\u003e num = %q; expected %q\", test.input, num, test.expectedNum)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) =\u003e rest = %q; expected %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","b820683300c14c36357582b48bac4df3":"// parse_raw_string_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\"world`,\n\t\t\texpectedValue:  \"hello\",\n\t\t\texpectedRemainder: \"world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped \\\" quote\" and more`,\n\t\t\texpectedValue:  \"escaped \\\" quote\",\n\t\t\texpectedRemainder: \" and more\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"missing closing quote`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped \\\\\"string\"`,\n\t\t\texpectedValue:  \"escaped \\\\\",\n\t\t\texpectedRemainder: \"string\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `not a json string`,\n\t\t\texpectedValue:  \"not a json string\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\t\tif (err != nil) != test.expectedError {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", test.expectedError, err)\n\t\t\t}\n\t\t\tif value != test.expectedValue {\n\t\t\t\tt.Errorf(\"expected value: %s, got: %s\", test.expectedValue, value)\n\t\t\t}\n\t\t\tif remainder != test.expectedRemainder {\n\t\t\t\tt.Errorf(\"expected remainder: %s, got: %s\", test.expectedRemainder, remainder)\n\t\t\t}\n\t\t})\n\t}\n}","b9027e608afcd64bdeefc42196d68462":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Marshal raw string\",\n\t\t\tvalue:    \u0026Value{s: \"foo\", t: typeRawString},\n\t\t\texpected: `\"foo\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal object\",\n\t\t\tvalue:    \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}, t: TypeObject},\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal array\",\n\t\t\tvalue:    \u0026Value{a: []*Value{{s: \"one\", t: TypeString}, {s: \"two\", t: TypeString}}, t: TypeArray},\n\t\t\texpected: `[\"one\",\"two\"]`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal string\",\n\t\t\tvalue:    \u0026Value{s: \"Hello, World!\", t: TypeString},\n\t\t\texpected: `\"Hello, World!\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal number\",\n\t\t\tvalue:    \u0026Value{s: \"12345\", t: TypeNumber},\n\t\t\texpected: `12345`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Marshal null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tdst = tt.value.MarshalTo(dst)\n\t\t\tif string(dst) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(dst))\n\t\t\t}\n\t\t})\n\t}\n}","b94c8a675ca01c0e5705f4898a327a1f":"package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValues []*Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          \"[]\",\n\t\t\texpectedValues: []*Value{{t: TypeArray, a: []*Value{}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          \"[1, 2, 3]\",\n\t\t\texpectedValues: []*Value{{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}}}},\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[true, false, null]\",\n\t\t\texpectedValues: []*Value{{t: TypeArray, a: []*Value{{t: TypeTrue}, {t: TypeFalse}, {t: TypeNull}}}},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1,]\",\n\t\t\texpectedValues: nil,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[,]\",\n\t\t\texpectedValues: nil,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3,\",\n\t\t\texpectedValues: nil,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"1, 2, 3\",\n\t\t\texpectedValues: nil,\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseArray(test.input, c, 0)\n\t\tif test.expectedError {\n\t\t\tassert.Error(t, err)\n\t\t} else {\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, test.expectedValues[0].t, result.t)\n\t\t\tassert.Equal(t, len(test.expectedValues[0].a), len(result.a))\n\t\t\tfor i, expectedValue := range test.expectedValues[0].a {\n\t\t\t\tassert.Equal(t, expectedValue.s, result.a[i].s)\n\t\t\t\tassert.Equal(t, expectedValue.t, result.a[i].t)\n\t\t\t}\n\t\t}\n\t}\n}","b986d4c589f56a16c52eb378505a2e52":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() for input %v = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Test for unknown Value type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Value type, but did not panic\")\n\t\t}\n\t}()\n\t\n\t// Assuming we have a way to create an unknown Type\n\tvar unknownType Type = 999 // This is an arbitrary value that should cause a panic\n\tunknownType.String()\n}","bae59786f5c861d477ca897b14a101e7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue  *Value\n\t\tdst    []byte\n\t\texpect []byte\n\t}{\n\t\t{\n\t\t\tvalue:  \u0026Value{t: TypeNull},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tvalue:  \u0026Value{t: TypeTrue},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tvalue:  \u0026Value{t: TypeFalse},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tvalue:  \u0026Value{t: TypeNumber, s: \"42\"},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"42\"),\n\t\t},\n\t\t{\n\t\t\tvalue:  \u0026Value{t: typeRawString, s: \"hello\"},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"[1,2,3]\"),\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t}}},\n\t\t\tdst:    []byte{},\n\t\t\texpect: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.value.MarshalTo(test.dst)\n\t\tif string(result) != string(test.expect) {\n\t\t\tt.Errorf(\"expected %s, got %s\", test.expect, result)\n\t\t}\n\t}\n}","bae6aaeb6d2dde466a9d225e8b25689e":"package fastjson\n\nimport (\n\t\"testing\"\n\t\"bytes\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeArray, a: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}}},\n\t\t\texpected: \"[1,2]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}}, {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}}}}},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"rawString\"},\n\t\t\texpected: `\"rawString\"`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"expected %s but got %s\", test.expected, result)\n\t\t}\n\t}\n}","bba33bd45299023ca8b7a83a78d12329":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput []*Value\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"[]\",\n\t\t\texpectedOutput: []*Value{\u0026Value{t: TypeArray, a: []*Value{}}},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"3\"},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[true, false, null]\",\n\t\t\texpectedOutput: []*Value{\n\t\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\t\u0026Value{t: TypeFalse},\n\t\t\t\t\u0026Value{t: TypeNull},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, , 3]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[, 2, 3]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"]\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedOutput: nil,\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseArray(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 !test.expectedError {\n\t\t\tt.Errorf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t}\n\t\tif err == nil \u0026\u0026 test.expectedError {\n\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t}\n\n\t\tif err == nil \u0026\u0026 test.expectedOutput != nil {\n\t\t\t// Check if the parsed values match the expected output\n\t\t\tif len(result.a) != len(test.expectedOutput) {\n\t\t\t\tt.Errorf(\"expected %d values, got %d for input %q\", len(test.expectedOutput), len(result.a), test.input)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i, v := range result.a {\n\t\t\t\tif v.Type() != test.expectedOutput[i].Type() {\n\t\t\t\t\tt.Errorf(\"expected type %v, got %v for input %q at index %d\", test.expectedOutput[i].Type(), v.Type(), test.input, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif remainder != \"\" {\n\t\t\tt.Logf(\"remainder for input %q: %s\", test.input, remainder)\n\t\t}\n\t}\n}","bbd4aacd501b5510c301e28e2c99a7a2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\t// Define test cases\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tkeys     []string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"Valid String\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: []byte(\"value\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Non-existing Key\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"nonexistent\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Nested Valid String\",\n\t\t\tinput:    `{\"key\": {\"nestedKey\": \"nestedValue\"}}`,\n\t\t\tkeys:     []string{\"key\", \"nestedKey\"},\n\t\t\texpected: []byte(\"nestedValue\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Key with Array Index\",\n\t\t\tinput:    `{\"key\": [\"value0\", \"value1\"]}`,\n\t\t\tkeys:     []string{\"key\", \"1\"},\n\t\t\texpected: []byte(\"value1\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Type\",\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Invalid Keys Format\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\tkeys:     []string{\"key\", \"0\"}, // Invalid path\n\t\t\texpected: nil,\n\t\t},\n\t}\n\n\t// Iterate through test cases\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Parse the input JSON\n\t\t\tp := \u0026Parser{}\n\t\t\tvalue, err := p.Parse(tt.input)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error parsing input: %v\", err)\n\t\t\t}\n\n\t\t\t// Get string bytes from the value\n\t\t\tresult := value.GetStringBytes(tt.keys...)\n\t\t\t\n\t\t\t// Compare result with expected output\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare byte slices\nfunc equalSlices(a, b []byte) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","bbe3e673670e6d1a8100b95f3f3b6604":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tinput         string\n\t\texpectedValue *Value\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname:          \"empty object\",\n\t\t\tinput:         \"{}\",\n\t\t\texpectedValue: \u0026Value{t: TypeObject},\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"simple object with one key-value\",\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedValue: \u0026Value{t: TypeObject}, // Adjust this based on the actual expected Value structure\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"object with multiple key-value pairs\",\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpectedValue: \u0026Value{t: TypeObject}, // Adjust this based on the actual expected Value structure\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tname:          \"missing closing brace\",\n\t\t\tinput:         `{\"key\": \"value\"`,\n\t\t\texpectedValue: nil,\n\t\t\texpectedError: \u0026json.SyntaxError{}, // Adjust based on actual error type\n\t\t},\n\t\t{\n\t\t\tname:          \"missing colon after key\",\n\t\t\tinput:         `{\"key\" \"value\"}`,\n\t\t\texpectedValue: nil,\n\t\t\texpectedError: \u0026json.SyntaxError{}, // Adjust based on actual error type\n\t\t},\n\t\t{\n\t\t\tname:          \"missing comma between key-value pairs\",\n\t\t\tinput:         `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpectedValue: nil,\n\t\t\texpectedError: \u0026json.SyntaxError{}, // Adjust based on actual error type\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{} // You might need proper initialization for cache\n\t\t\tresult, _, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.expectedError != nil \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"expected an error but got none\")\n\t\t\t}\n\n\t\t\tif tt.expectedError == nil \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"expected no error but got %v\", err)\n\t\t\t}\n\n\t\t\tif result != nil \u0026\u0026 tt.expectedValue != nil {\n\t\t\t\t// Compare the expected and actual result,\n\t\t\t\t// This may require implementing or utilizing an equality function for the Value type\n\t\t\t}\n\t\t})\n\t}\n}","bc32bb4bd7cd7c280d27c80f1da62f5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemaining string\n\t\texpectError bool\n\t}{\n\t\t{\"1234\", \"1234\", \"\", false},\n\t\t{\"-123.45\", \"-123.45\", \"\", false},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", false},\n\t\t{\"0.0\", \"0.0\", \"\", false},\n\t\t{\"nanxyz\", \"nan\", \"xyz\", false},\n\t\t{\"infabc\", \"inf\", \"abc\", false},\n\t\t{\"invalid123\", \"\", \"invalid123\", true},\n\t\t{\"+inf123\", \"+inf\", \"123\", false},\n\t\t{\"-nan\", \"-nan\", \"\", false},\n\t\t{\"12.3.4\", \"12.3\", \".4\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, remaining, err := parseRawNumber(test.input)\n\n\t\tif test.expectError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif number != test.expectedNumber {\n\t\t\t\tt.Errorf(\"For input %q, expected number %q, got %q\", test.input, test.expectedNumber, number)\n\t\t\t}\n\t\t\tif remaining != test.expectedRemaining {\n\t\t\t\tt.Errorf(\"For input %q, expected remaining %q, got %q\", test.input, test.expectedRemaining, remaining)\n\t\t\t}\n\t\t}\n\t}\n}","bc5d285469a1c0d8fc4ef44b5183d6ea":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedLen int\n\t\texpectError  bool\n\t}{\n\t\t{input: \"[]\", expectedLen: 0, expectError: false},\n\t\t{input: \"[1, 2, 3]\", expectedLen: 3, expectError: false},\n\t\t{input: \"[true, false, null]\", expectedLen: 3, expectError: false},\n\t\t{input: \"[\\\"string\\\", 123, false]\", expectedLen: 3, expectError: false},\n\t\t{input: \"[,]\", expectedLen: 0, expectError: true}, // Missing value\n\t\t{input: \"[1, 2,, 3]\", expectedLen: 0, expectError: true}, // Extra comma\n\t\t{input: \"[1, 2, 3\", expectedLen: 0, expectError: true}, // Missing closing bracket\n\t\t{input: \"[]]\", expectedLen: 0, expectError: true}, // Extra closing bracket\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Parsing array: %s\", tt.input), func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tresult, remaining, err := parseArray(tt.input, c, depth)\n\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 result != nil \u0026\u0026 len(result.a) != tt.expectedLen {\n\t\t\t\tt.Errorf(\"expected length: %d, got: %d\", tt.expectedLen, len(result.a))\n\t\t\t}\n\n\t\t\tif err == nil \u0026\u0026 remaining != \"\" {\n\t\t\t\tt.Errorf(\"expected no remaining string, got: %s\", remaining)\n\t\t\t}\n\t\t})\n\t}\n}","bd08cdc2e23161062627047e003b8850":"// unescape_string_best_effort_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"normal string\"`,\n\t\t\texpected: \"normal string\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped quote: \\\" and backslash: \\\\\"`,\n\t\t\texpected: \"escaped quote: \\\" and backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"new line \\n and tab \\t\"`,\n\t\t\texpected: \"new line \\n and tab \\t\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"unicode: \\u4F60\\u597D\"`,\n\t\t\texpected: \"unicode: ä½ å¥½\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"invalid unicode: \\uD83D\"`,\n\t\t\texpected: \"invalid unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"surrogate pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\uD83D\\xZZ\"`, // Invalid hex escape sequence\n\t\t\texpected: \"\\\\uD83D\\\\xZZ\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"just a backslash \\\\\"`,\n\t\t\texpected: \"just a backslash \\\\\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","bd43f4fafcaeeba798c3f402040ffc31":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escape quotes: \\\\\"`,\n\t\t\texpected: `Escape quotes: \\`,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Newline: \\nTest\"`,\n\t\t\texpected: \"Newline: \\nTest\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab: \\tEnd\"`,\n\t\t\texpected: \"Tab: \\tEnd\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u4F60\\u597D\"`, // \"ä½ å¥½\" in Chinese\n\t\t\texpected: \"Unicode: ä½ å¥½\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Bad unicode: \\uXYZ\"`,\n\t\t\texpected: \"Bad unicode: \\\\uXYZ\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate: \\uD83D\\ude00\"`, // Smiley face\n\t\t\texpected: \"Surrogate: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Incomplete: \\uD83D\"`,\n\t\t\texpected: \"Incomplete: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\\\\"`,\n\t\t\texpected: `\\`,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Various Escapes: \\t\\n\\\"\\\\/\"`,\n\t\t\texpected: \"Various Escapes: \\t\\n\\\"\\\\/\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","be3fef38b753fb00b2dd27df1c22fb9f":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tgot := test.input.String()\n\t\t\tif got != test.expected {\n\t\t\t\tt.Errorf(\"Type.String() = %v; want %v\", got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"unknown type\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for unknown Type\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 999 // An unknown type\n\t\t_ = unknownType.String()\n\t})\n}","bfd9bf47990529b6e2f1fe69b5593909":"// has_special_chars_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHasSpecialChars(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\"hello\", false},\n\t\t{\"hello world\", false},\n\t\t{\"hello@world\", true},\n\t\t{\"hello\\\"world\", true},\n\t\t{\"hello\\\\world\", true},\n\t\t{\"hello\\x00world\", true}, // null byte\n\t\t{\"\", false},               // empty string\n\t\t{\"\\n\", true},             // newline\n\t\t{\"\\t\", true},             // tab\n\t\t{\"normal string\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := hasSpecialChars(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"hasSpecialChars(%q) = %v; expected %v\", test.input, result, test.expected)\n\t\t}\n\t}\n}","bfff9a81256b0c60aeeaa312fc7ea322":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{newValueInt(1), newValueInt(2), newValueInt(3)},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false]\",\n\t\t\texpected: []*Value{newValueBool(true), newValueBool(false)},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[null]\",\n\t\t\texpected: []*Value{newValueNull()},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, , 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, ]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[, 2, 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseArray(test.input, c, 0)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseArray(%q) returned error: %v, expected error: %v\", test.input, err, test.err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.expected == nil \u0026\u0026 result != nil {\n\t\t\tt.Errorf(\"parseArray(%q) expected nil result; got: %v\", test.input, result)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.err \u0026\u0026 len(result.a) != len(test.expected) {\n\t\t\tt.Errorf(\"parseArray(%q) expected %d values; got: %d\", test.input, len(test.expected), len(result.a))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor i, v := range test.expected {\n\t\t\tif result.a[i].Type() != v.Type() {\n\t\t\t\tt.Errorf(\"parseArray(%q) expected value type %v; got: %v\", test.input, v.Type(), result.a[i].Type())\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc newValueInt(i int) *Value {\n\t// Implement this function to create a Value representing an integer\n}\n\nfunc newValueBool(b bool) *Value {\n\t// Implement this function to create a Value representing a boolean\n}\n\nfunc newValueNull() *Value {\n\t// Implement this function to create a Value representing null\n}","c0874c7164c921c92d5c73b5e96f2adc":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRest   string\n\t\texpectedError  error\n\t}{\n\t\t{\"123.456abc\", \"123.456\", \"abc\", nil},\n\t\t{\"-42\", \"-42\", \"\", nil},\n\t\t{\"3.14e10moreText\", \"3.14e10\", \"moreText\", nil},\n\t\t{\"+inf123\", \"+inf\", \"123\", nil},\n\t\t{\"nan123\", \"nan\", \"123\", nil},\n\t\t{\"123error\", \"123\", \"error\", nil},\n\t\t{\"-nanValue\", \"-nan\", \"Value\", nil},\n\t\t{\"infTest\", \"inf\", \"Test\", nil},\n\t\t{\"unexpected\", \"\", \"unexpected\", fmt.Errorf(\"unexpected char: %q\", \"u\")},\n\t\t{\"-unexpected\", \"\", \"-unexpected\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"input:%s\", tt.input), func(t *testing.T) {\n\t\t\tnumber, rest, err := parseRawNumber(tt.input)\n\n\t\t\tif number != tt.expectedNumber || rest != tt.expectedRest || (err != nil \u0026\u0026 err.Error() != tt.expectedError.Error()) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\", tt.input, number, rest, err, tt.expectedNumber, tt.expectedRest, tt.expectedError)\n\t\t\t}\n\t\t})\n\t}\n}","c139b8b840fd95c233cf58a5b0b8e307":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"hello \\\\\\\"world\\\\\\\"\\\"\", \"hello \\\"world\\\"\", \"\", false},\n\t\t{\"\\\"unclosed string\", \"\", \"\", true},\n\t\t{\"string with no quotes\", \"string with no quotes\", \"\", false},\n\t\t{\"\\\"escaped\\\\\\\\\\\"\", \"escaped\\\\\", \"\", false},\n\t\t{\"\\\"multi\\\\\\\"quote\\\\\\\"example\\\"\", \"multi\\\"quote\\\"example\", \"\", false},\n\t\t{\"\\\"complex \\\\\\\"escapes\\\\\\\\ here\\\\\\\"\\\"\", \"complex \\\"escapes\\\\ here\\\"\", \"\", false},\n\t\t{\"\\\"\\\"hello\", \"\", \"\", true},\n\t\t{\"\\\"two quotes at the end\\\" and more\", \"two quotes at the end\", \" and more\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseRawString(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"Input: %q - Expected error: %v, got: %v\", test.input, test.err, err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Input: %q - Expected: %q, got: %q\", test.input, test.expected, result)\n\t\t}\n\t\tif remaining != test.remaining {\n\t\t\tt.Errorf(\"Input: %q - Expected remaining: %q, got: %q\", test.input, test.remaining, remaining)\n\t\t}\n\t}\n}","c2da5751cd2c5398838167b28b6919cf":"// marshal_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"marshal raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"example\"},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,2,true]\",\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":42}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected: %s, got: %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","c32a429bd8165819c0e2efc39c6b825a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedValue string\n\t\texpectedRemaining string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput: `{\"key\": \"value\"}`,\n\t\t\texpectedValue: `{\"key\": `,\n\t\t\texpectedRemaining: `\"value\"}`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"escaped\\\\\"quote\"`,\n\t\t\texpectedValue: `escaped\\`,\n\t\t\texpectedRemaining: `quote\"`,\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"unescaped quote`,\n\t\t\texpectedValue: `\"unescaped quote`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: `\"another \\\"escaped quote\\\" test\"`,\n\t\t\texpectedValue: `another \\\"escaped quote\\\" test`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `no quotes here`,\n\t\t\texpectedValue: `no quotes here`,\n\t\t\texpectedRemaining: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remaining, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"For input %q, expected error: %v, got error: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"For input %q, expected value: %q, got value: %q\", test.input, test.expectedValue, value)\n\t\t}\n\t\tif remaining != test.expectedRemaining {\n\t\t\tt.Errorf(\"For input %q, expected remaining: %q, got remaining: %q\", test.input, test.expectedRemaining, remaining)\n\t\t}\n\t}\n}","c3af1e47e08002ea2a66ba4555dc8b2c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetStringBytes(t *testing.T) {\n\t// Test case 1: Valid JSON with existing string key\n\tjsonData := `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`\n\tv, err := Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tresult := v.GetStringBytes(\"key1\")\n\texpected := []byte(\"value1\")\n\tif string(result) != string(expected) {\n\t\tt.Errorf(\"Expected %s, got %s\", expected, result)\n\t}\n\n\t// Test case 2: Valid JSON, non-existing key\n\tresult = v.GetStringBytes(\"nonExistingKey\")\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %s\", result)\n\t}\n\n\t// Test case 3: Valid JSON with path to nested key\n\tresult = v.GetStringBytes(\"key2\", \"key3\")\n\texpected = []byte(\"value3\")\n\tif string(result) != string(expected) {\n\t\tt.Errorf(\"Expected %s, got %s\", expected, result)\n\t}\n\n\t// Test case 4: Valid JSON, key with number as index\n\tjsonData = `{\"array\": [\"value0\", \"value1\", \"value2\"]}`\n\tv, err = Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tresult = v.GetStringBytes(\"array\", \"1\")\n\texpected = []byte(\"value1\")\n\tif string(result) != string(expected) {\n\t\tt.Errorf(\"Expected %s, got %s\", expected, result)\n\t}\n\n\t// Test case 5: Valid JSON but wrong type (expecting string)\n\tjsonData = `{\"key1\": 123}`\n\tv, err = Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tresult = v.GetStringBytes(\"key1\")\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %s\", result)\n\t}\n\n\t// Test case 6: Nil value for a key path\n\tjsonData = `{\"key1\": null}`\n\tv, err = Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\tresult = v.GetStringBytes(\"key1\")\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %s\", result)\n\t}\n}","c3ca300ea3ef3c2d58924dcfd3e7b4d8":"package fastjson\n\nimport \"testing\"\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello \\n World\"`,\n\t\t\texpected: \"Hello \\n World\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"JSON with \\u003C and \\u003E and \\u0026\"`,\n\t\t\texpected: \"JSON with \u003c and \u003e and \u0026\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escape: \\\\/ \\b \\f \\n \\r \\t\"`,\n\t\t\texpected: \"Escape: / \\b \\f \\n \\r \\t\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid unicode: \\uXYZ\"`,\n\t\t\texpected: \"Invalid unicode: \\\\uXYZ\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escape characters\"`,\n\t\t\texpected: \"No escape characters\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed \\u003C and literal \\s\"`,\n\t\t\texpected: \"Mixed \u003c and literal \\\\s\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c3d3743fdc801655ec63135d7bb59672":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{\n\t\tvs: make([]Value, 0),\n\t}\n\n\t// Test the initial condition\n\tval := c.getValue()\n\tif val == nil {\n\t\tt.Error(\"Expected non-nil Value from getValue, but got nil\")\n\t}\n\n\t// Test adding first value\n\tval1 := c.getValue()\n\tif cap(c.vs) \u003c 1 || len(c.vs) != 1 {\n\t\tt.Errorf(\"Expected len(1) and cap(1), but got len(%d) and cap(%d)\", len(c.vs), cap(c.vs))\n\t}\n\n\t// Test adding a second value\n\tval2 := c.getValue()\n\tif cap(c.vs) \u003c 2 || len(c.vs) != 2 {\n\t\tt.Errorf(\"Expected len(2) and cap(2), but got len(%d) and cap(%d)\", len(c.vs), cap(c.vs))\n\t}\n\n\t// Check if val1 and val2 are different\n\tif val1 == val2 {\n\t\tt.Error(\"Expected different Value instances from getValue, but got the same instance\")\n\t}\n}","c3f9de78bc4ab5f2c224c68fe6a512d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tjsonStr     string\n\t\tkeys        []string\n\t\texpected    *Object\n\t\texpectNil   bool\n\t}{\n\t\t{\n\t\t\tname:     \"valid object path\",\n\t\t\tjsonStr:  `{\"foo\": {\"bar\": {}}}`,\n\t\t\tkeys:     []string{\"foo\", \"bar\"},\n\t\t\texpected: \u0026Object{kvs: []kv{}}, // Adjust as needed for expected object\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"non-existing path\",\n\t\t\tjsonStr:   `{\"foo\": {\"bar\": {}}}`,\n\t\t\tkeys:      []string{\"foo\", \"baz\"},\n\t\t\texpected:  nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid type at path\",\n\t\t\tjsonStr:   `{\"foo\": 123}`,\n\t\t\tkeys:      []string{\"foo\"},\n\t\t\texpected:  nil,\n\t\t\texpectNil: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"path with array index\",\n\t\t\tjsonStr: `{\"foo\": [{\"bar\": {}}]}`,\n\t\t\tkeys:    []string{\"foo\", \"0\", \"bar\"},\n\t\t\texpected: \u0026Object{kvs: []kv{}}, // Adjust as needed for expected object\n\t\t\texpectNil: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid array index\",\n\t\t\tjsonStr:   `{\"foo\": [{\"bar\": {}}]}`,\n\t\t\tkeys:      []string{\"foo\", \"1\", \"bar\"},\n\t\t\texpected:  nil,\n\t\t\texpectNil: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, err := (new(Parser)).Parse(tt.jsonStr)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tobj := v.GetObject(tt.keys...)\n\t\t\t\n\t\t\tif tt.expectNil \u0026\u0026 obj != nil {\n\t\t\t\tt.Errorf(\"expected nil but got non-nil object\")\n\t\t\t}\n\t\t\tif !tt.expectNil \u0026\u0026 obj == nil {\n\t\t\t\tt.Errorf(\"expected non-nil object but got nil\")\n\t\t\t}\n\n\t\t\t// Additional checks can be done here to compare the actual 'obj' with 'tt.expected'\n\t\t\t// depending on your comparison logic for Object.\n\t\t})\n\t}\n}","c41fada46f28a36a945f14b1dabf43f8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},                      // Test with empty string\n\t\t{\"   leading space\", \"   leading space\"},\n\t\t{\"\\n\\nnewline before\", \"\\n\\nnewline before\"},\n\t\t{\"\\t\\ttab before\", \"\\t\\ttab before\"},\n\t\t{\"\\r\\rcarriage return\", \"\\r\\rcarriage return\"},\n\t\t{\"   no leading whitespace\", \"   no leading whitespace\"},\n\t\t{\"   mixed \\n spaces\\t\", \"   mixed \\n spaces\\t\"},\n\t\t{\"\\n   mixed\\n   whitespace\\t\", \"\\n   mixed\\n   whitespace\\t\"},\n\t\t{\"text with leading spaces   \", \"text with leading spaces   \"},\n\t\t{\"    \\n   \\t   text with leading whitespace\", \"text with leading whitespace\"},\n\t\t{\"\\t\\t  text with tabs\", \"text with tabs\"},\n\t\t{\"\\n   \\t   \\r text with mixed whitespace\", \"text with mixed whitespace\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c4ca0fa3d11b72162681fabfbab58d61":"// cache_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCacheGetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Expecting the initial allocation of 'vs' to be empty\n\tif len(c.vs) != 0 {\n\t\tt.Fatalf(\"Expected initial length of vs to be 0, got %d\", len(c.vs))\n\t}\n\n\tvalue := c.getValue()\n\tif value == nil {\n\t\tt.Fatal(\"Expected to get a non-nil Value from getValue()\")\n\t}\n\n\t// Check that the length of vs is now 1\n\tif len(c.vs) != 1 {\n\t\tt.Fatalf(\"Expected length of vs to be 1, got %d\", len(c.vs))\n\t}\n\n\t// Check if the returned value is a pointer to the last slice element\n\tif value != \u0026c.vs[0] {\n\t\tt.Fatal(\"Expected to receive a pointer to the first Value in vs\")\n\t}\n\n\t// Retrieve another value\n\tvalue2 := c.getValue()\n\t\n\t// Ensure the new value is returned correctly and keeps the previous one intact\n\tif value2 == nil {\n\t\tt.Fatal(\"Expected to get a non-nil Value from getValue() second call\")\n\t}\n\tif len(c.vs) != 2 {\n\t\tt.Fatalf(\"Expected length of vs to be 2 after second getValue(), got %d\", len(c.vs))\n\t}\n\tif value2 != \u0026c.vs[1] {\n\t\tt.Fatal(\"Expected to receive a pointer to the second Value in vs\")\n\t}\n}","c5586c4ceae5d3f167bcc3ee23c33dbe":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput      string\n\t\texpected   string\n\t\tremainder  string\n\t\texpectErr  bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e+10\", \"-123.45e+10\", \"\", false},\n\t\t{\"3.14159xyz\", \"3.14159\", \"xyz\", false},\n\t\t{\"NaNabc\", \"NaN\", \"abc\", false},\n\t\t{\"Infinity\", \"Infinity\", \"\", false},\n\t\t{\"-Infinityxyz\", \"-Infinity\", \"xyz\", false},\n\t\t{\"abc\", \"\", \"abc\", true},\n\t\t{\"-123xyz\", \"-123\", \"xyz\", false},\n\t\t{\"123abc\", \"123\", \"abc\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseRawNumber(test.input)\n\n\t\tif test.expectErr {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input %q, but got none.\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"For input %q, expected result %q, but got %q.\", test.input, test.expected, result)\n\t\t\t}\n\t\t\tif remainder != test.remainder {\n\t\t\t\tt.Errorf(\"For input %q, expected remainder %q, but got %q.\", test.input, test.remainder, remainder)\n\t\t\t}\n\t\t}\n\t}\n}","c55ae409893aa760b6837960ae6d3139":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline: \\\\n and a tab: \\\\t\", \"This is a string with a newline: \\n and a tab: \\t\"},\n\t\t{\"Escaped quotes: \\\\\"+\"\\\"\"+\", \\\\\"+\"\\\"\", \"Escaped quotes: \\\" and \\\"\"},\n\t\t{\"Invalid escape: \\\\x not valid\", \"Invalid escape: \\\\x not valid\"},\n\t\t{\"Unicode: \\\\u0041\\\\u0042\\\\u0043\", \"Unicode: ABC\"},\n\t\t{\"Surrogate pairs: \\\\uD83D\\\\uDE00\", \"Surrogate pairs: ðŸ˜€\"},\n\t\t{\"Mixed: escaped \\\\\\\"quotes\\\\\\\" and new line \\\\n\", \"Mixed: escaped \\\"quotes\\\" and new line \\n\"},\n\t\t{\"No escape here: hello\", \"No escape here: hello\"},\n\t\t{\"A backslash: \\\\\\\\\", \"A backslash: \\\\\"},\n\t\t{\"Incomplete unicode: \\\\u\", \"Incomplete unicode: \\\\u\"},\n\t\t{\"Invalid Unicode: \\\\uXYZ\", \"Invalid Unicode: \\\\uXYZ\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c5cb7d728cb8fdc34f85c406b961cc9e":"package fastjson\n\nimport \"testing\"\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{`\"Hello, world!\"`, \"Hello, world!\"},\n\t\t{`\"Line1\\nLine2\"`, \"Line1\\nLine2\"},\n\t\t{`\"Tab\\tCharacter\"`, \"Tab\\tCharacter\"},\n\t\t{`\"\\\\\"`, \"\\\\\"},\n\t\t{`\"Unicode: \\u0041\\u0042\\u0043\"`, \"Unicode: ABC\"},\n\t\t{`\"Invalid unicode: \\uXYZ\"`, \"Invalid unicode: \\\\uXYZ\"},\n\t\t{`\"Surrogate pair: \\uD83D\\uDE00\"`, \"Surrogate pair: ðŸ˜€\"},\n\t\t{`\"Line1\\\\Line2\"`, \"Line1\\\\Line2\"},\n\t\t{`\"String with slash: /\"`, \"String with slash: /\"},\n\t\t{`\"Special chars: \\b\\f\\n\\r\\t\"`, \"Special chars: \\b\\f\\n\\r\\t\"},\n\t\t{`\"Escaped double quotes: \\\"\"`, \"Escaped double quotes: \\\"\"},\n\t\t{`\"Incomplete escape sequence: \\u\"`, \"Incomplete escape sequence: \\\\u\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For input %q, expected %q but got %q\", test.input, test.expected, result)\n\t\t}\n\t}\n}","c5cdd5f26f85c8b4f71fd4ad327b5a2e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\t// Create a new Object\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", \u0026Value{}},\n\t\t\t{\"key2\", \u0026Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Ensure Object has some data\n\tif len(obj.kvs) == 0 || !obj.keysUnescaped {\n\t\tt.Errorf(\"Object should initially contain data.\")\n\t}\n\n\t// Call reset method\n\tobj.reset()\n\n\t// Check if kvs slice is empty\n\tif len(obj.kvs) != 0 {\n\t\tt.Errorf(\"Expected kvs to be empty after reset, got length %d\", len(obj.kvs))\n\t}\n\n\t// Check if keysUnescaped is set to false\n\tif obj.keysUnescaped {\n\t\tt.Errorf(\"Expected keysUnescaped to be false after reset, but got true\")\n\t}\n}","c6faba2bbfc994b9485296bddc91361b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tinput      string\n\t\texpected   *Value\n\t\texpectErr  bool\n\t}{\n\t\t{\n\t\t\tname:      \"Valid object with one key-value pair\",\n\t\t\tinput:     `{\"key1\": \"value1\"}`,\n\t\t\texpected:  // expected Value structure, assume you fill this based on your definition,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Valid object with multiple key-value pairs\",\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": 123, \"key3\": true}`,\n\t\t\texpected:  // expected Value structure, assume you fill this based on your definition,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid object - missing key\",\n\t\t\tinput:     `{\"key1\": \"value1\", : 123}`,\n\t\t\texpected:  nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid object - missing value\",\n\t\t\tinput:     `{\"key1\":}`,\n\t\t\texpected:  nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid object - not a JSON object\",\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpected:  nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"Empty object\",\n\t\t\tinput:     `{}`,\n\t\t\texpected:  // expected Value structure for an empty object,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Whitespace around object\",\n\t\t\tinput:     `   {\"key1\": \"value1\"}   `,\n\t\t\texpected:  // expected Value structure, assume you fill this based on your definition,\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"Invalid JSON string\",\n\t\t\tinput:     `{\"key1\": \"value1\", \"key2\": \"missing comma\" \"key3\": \"value3\"}`,\n\t\t\texpected:  nil,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tres, remaining, err := parseObject(tt.input, c, 0)\n\n\t\t\tif tt.expectErr \u0026\u0026 err == nil {\n\t\t\t\tt.Errorf(\"expected an error, got none\")\n\t\t\t}\n\t\t\tif !tt.expectErr \u0026\u0026 err != nil {\n\t\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t\t}\n\t\t\tif res != nil \u0026\u0026 !tt.expectErr {\n\t\t\t\t// Compare res with expected, you might need to serialize to JSON strings\n\t\t\t\t// or implement a function to compare Values\n\t\t\t}\n\t\t\t// Further assertions can be done on 'remaining' \n\t\t})\n\t}\n}","c764ce35ca14ae6a72207278122d0d5b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tdst      []byte\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"marshal raw string\",\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"\\\"test\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"[1,2]\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal string\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal true\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal false\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"marshal null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo(tt.dst)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", string(tt.expected), string(result))\n\t\t\t}\n\t\t})\n\t}\n}","c7df6ab3486acf816f4a9b764f6a03d8":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedFirst  string\n\t\texpectedSecond string\n\t\texpectErr      bool\n\t}{\n\t\t{\"\\\"hello\\\"world\", \"hello\", \"world\", false},\n\t\t{\"\\\"hello\\\\\\\"world\\\"\", \"hello\\\\\\\"world\", \"\", false},\n\t\t{\"\\\"hello\\\\\\\"world\\\"more text\", \"hello\\\\\\\"world\", \"more text\", false},\n\t\t{\"no quotes here\", \"no quotes here\", \"\", true},\n\t\t{\"\\\"unmatched string\", \"\", \"\", true},\n\t\t{\"\\\"escaped \\\\\\\"quote\\\\\\\" here\\\"\", \"escaped \\\\\\\"quote\\\\\\\" here\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tfirst, second, err := parseRawString(test.input)\n\t\t\n\t\tif test.expectErr {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"expected error for input %q, got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif first != test.expectedFirst {\n\t\t\t\tt.Errorf(\"for input %q, expected first %q, got %q\", test.input, test.expectedFirst, first)\n\t\t\t}\n\t\t\tif second != test.expectedSecond {\n\t\t\t\tt.Errorf(\"for input %q, expected second %q, got %q\", test.input, test.expectedSecond, second)\n\t\t\t}\n\t\t}\n\t}\n}","c8009aa53c1b79da028713d43677a10e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{c.getValue(), c.getValue(), c.getValue()},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"hello\\\", 42, true]\",\n\t\t\texpected: []*Value{c.getValue(), c.getValue(), c.getValue()},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, , 3]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2,]\",\n\t\t\texpected: []*Value{c.getValue(), c.getValue()},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tdepth := 0\n\t\t\tresult, _, err := parseArray(tt.input, c, depth)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tt.expected != nil \u0026\u0026 result != nil {\n\t\t\t\tif len(result.a) != len(tt.expected) {\n\t\t\t\t\tt.Errorf(\"expected length %d, got %d\", len(tt.expected), len(result.a))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","c80f450b5ed4b0fa2ce024b7f69bb8fc":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput      string\n\t\twantKeys   []string\n\t\twantValues []string\n\t\twantErr    bool\n\t}{\n\t\t{\n\t\t\tinput:      `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t\twantKeys:   []string{\"key1\", \"key2\"},\n\t\t\twantValues: []string{\"value1\", \"value2\"},\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tinput:   `{\"key1\":}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:   `{}`,\n\t\t\twantKeys:   []string{},\n\t\t\twantValues: []string{},\n\t\t\twantErr:    false,\n\t\t},\n\t\t{\n\t\t\tinput:   `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\twantKeys:   []string{\"key1\", \"key2\"},\n\t\t\twantValues: []string{\"value1\", \"value2\"},\n\t\t\twantErr:    true, // Check trailing comma error\n\t\t},\n\t\t{\n\t\t\tinput:   `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\twantErr: true, // Check missing comma error\n\t\t},\n\t\t{\n\t\t\tinput:   `{\"key1\": true, \"key2\": null}`,\n\t\t\twantKeys:   []string{\"key1\", \"key2\"},\n\t\t\twantValues: []string{\"true\", \"null\"},\n\t\t\twantErr:    false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tgot, remaining, err := parseObject(tt.input, c, depth)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Fatalf(\"parseObject() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\t// Assuming you have a method in Value to check keys and values.\n\t\t\t\tvar keys []string\n\t\t\t\tvar values []string\n\t\t\t\tgot.o.Visit(func(key []byte, v *Value) {\n\t\t\t\t\tkeys = append(keys, string(key))\n\t\t\t\t\tvalues = append(values, string(v.StringBytes())) // Collecting string representation of values.\n\t\t\t\t})\n\n\t\t\t\tif len(keys) != len(tt.wantKeys) {\n\t\t\t\t\tt.Fatalf(\"keys = %v, wantKeys %v\", keys, tt.wantKeys)\n\t\t\t\t}\n\n\t\t\t\tfor i, key := range tt.wantKeys {\n\t\t\t\t\tif keys[i] != key {\n\t\t\t\t\t\tt.Errorf(\"key at index %d = %s, want %s\", i, keys[i], key)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor i, value := range tt.wantValues {\n\t\t\t\t\tif values[i] != value {\n\t\t\t\t\t\tt.Errorf(\"value at index %d = %s, want %s\", i, values[i], value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","c862c57bfd6664eb3772ddfd9cc5ec8c":"// unescapeStringBestEffort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"This is a string with a newline\\\\ncharacter.\", \"This is a string with a newline\\ncharacter.\"},\n\t\t{\"Tab\\\\tcharacter.\", \"Tab\\tcharacter.\"},\n\t\t{\"Backslash\\\\\\\\\", \"Backslash\\\\\"},\n\t\t{\"Unicode \\\\u0041\", \"Unicode A\"},\n\t\t{\"Invalid unicode \\\\u00G1\", \"Invalid unicode \\\\u00G1\"},\n\t\t{\"Surrogate \\\\uD83D\\\\uDE00\", \"Surrogate ðŸ˜€\"},\n\t\t{\"Escaped double quote: \\\\\\\" and escaped slash: \\\\\\\\\", \"Escaped double quote: \\\" and escaped slash: \\\\\"},\n\t\t{\"No escape\", \"No escape\"},\n\t\t{\"Partial escape sequence \\\\u\", \"Partial escape sequence \\\\u\"},\n\t\t{\"Mixed sequences: \\\\nNewline, \\\\tTab, and \\\\u003A\", \"\\nNewline, \\tTab, and :\"}, \n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","c89109383f77829fd96d34eb2ecc83ef":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\", // Note the escaped quotes\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeString, s: \"two\"},\n\t\t\t\t\t{t: TypeTrue},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"[1,\\\"two\\\",true]\",\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.expected, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tdst = tt.value.MarshalTo(dst)\n\t\t\tif string(dst) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(dst))\n\t\t\t}\n\t\t})\n\t}\n}","c9f4acd3cb04b2ed994e2e7099cc5b41":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"}, // Currently, this case is not handled in the function.\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tif got := test.input.String(); got != test.expected {\n\t\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"UnknownType\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Expected panic for unknown Type\")\n\t\t\t}\n\t\t}()\n\t\tvar unknownType Type = 100 // A value not defined in the Type enum\n\t\tunknownType.String()\n\t})\n}","cac4f04680835dd843013cfc1b730880":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestEscapeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", `\"Hello, World!\"`},\n\t\t{\"Line 1\\nLine 2\", `\"Line 1\\nLine 2\"`},\n\t\t{\"Tab\\tCharacter\", `\"Tab\\tCharacter\"`},\n\t\t{\"Quotation \\\" marks\", `\"Quotation \\\" marks\"`},\n\t\t{\"Backslash \\\\ character\", `\"Backslash \\\\ character\"`},\n\t\t{\"Simple String\", `\"Simple String\"`},\n\t\t{\"\", `\"\"`},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := escapeString(nil, test.input)\n\t\tif string(dst) != test.expected {\n\t\t\tt.Errorf(\"escapeString(%q) = %q; expected %q\", test.input, dst, test.expected)\n\t\t}\n\t}\n}","cb85710523cfb04cdcdf04451f7449d2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput           string\n\t\texpectedValue   string\n\t\texpectedRemainder string\n\t\texpectedError   bool\n\t}{\n\t\t{\n\t\t\tinput:           `\"value\" remaining`,\n\t\t\texpectedValue:   \"value\",\n\t\t\texpectedRemainder: \" remaining\",\n\t\t\texpectedError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"escaped \\\" chars\"`,\n\t\t\texpectedValue:   \"escaped \\\" chars\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"unclosed`,\n\t\t\texpectedValue:   \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   true,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"value with \\\"escaped quotes\\\" inside\" remaining`,\n\t\t\texpectedValue:   \"value with \\\"escaped quotes\\\" inside\",\n\t\t\texpectedRemainder: \" remaining\",\n\t\t\texpectedError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:           `\"multiple \\\"escaped\\\" \\\"quotes\\\" inside\" another`,\n\t\t\texpectedValue:   \"multiple \\\"escaped\\\" \\\"quotes\\\" inside\",\n\t\t\texpectedRemainder: \" another\",\n\t\t\texpectedError:   false,\n\t\t},\n\t\t{\n\t\t\tinput:           `no quotes here`,\n\t\t\texpectedValue:   \"no quotes here\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Fatalf(\"expected error: %v, got: %v for input: %q\", test.expectedError, err != nil, test.input)\n\t\t}\n\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"for input %q, expected value: %q, got: %q\", test.input, test.expectedValue, value)\n\t\t}\n\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"for input %q, expected remainder: %q, got: %q\", test.input, test.expectedRemainder, remainder)\n\t\t}\n\t}\n}","cb8b337a5da945f53db16b6db1e7cef5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\terr      bool\n\t}{\n\t\t{\"\\\"key\\\"\", \"key\", false},              // simple key\n\t\t{\"\\\"anotherKey\\\"\", \"anotherKey\", false}, // another simple key\n\t\t{\"\\\"keyWithEscaped\\\\\\\"Quotes\\\"\", \"keyWithEscaped\\\"Quotes\", true}, // key with escaped quotes should trigger slow path\n\t\t{\"\\\"keyWithoutClosingQuote\", \"\", true},   // missing closing quote\n\t\t{\"keyWithoutQuotes\", \"keyWithoutQuotes\", false}, // unquoted key\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseRawKey(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"Expected error status for input %q to be %v, got %v\", test.input, test.err, err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Expected result for input %q to be %q, got %q\", test.input, test.expected, result)\n\t\t}\n\t}\n}","cbef8bb22fee92b10afa87f54f0a53b0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"parse empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"parse simple object\",\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: /* expected Value for object */,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse simple array\",\n\t\t\tinput:    `[\"value1\", \"value2\"]`,\n\t\t\texpected: /* expected Value for array */,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse boolean true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse boolean false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"parse number\",\n\t\t\tinput:    \"123.456\",\n\t\t\texpected: /* expected Value for number */,\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"deep nesting error\",\n\t\t\tinput:    `{\"key\": {\"nested\": {\"another\": {\"deep\": {\"structure\": true}}}}}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"too big depth for the nested JSON; it exceeds %d\", MaxDepth),\n\t\t},\n\t\t{\n\t\t\tname:     \"unexpected value\",\n\t\t\tinput:    \"unexpectedValue\",\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected value found: %q\", \"unexpectedValue\"),\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tactual, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif err != nil \u0026\u0026 !errors.Is(err, tt.err) {\n\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.err, err)\n\t\t\t}\n\t\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, actual)\n\t\t\t}\n\t\t\t// Additional checks on 'tail' can be added as needed.\n\t\t})\n\t}\n}","cc2ca3ffb95a189c0927b89f2ea28794":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello world\"`,\n\t\t\texpectedValue: \"hello world\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"escaped \\\" quote\"`,\n\t\t\texpectedValue: \"escaped \\\" quote\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"mixed \\\"escaped\\\" parts\" and more`,\n\t\t\texpectedValue: \"mixed \\\"escaped\\\" parts\",\n\t\t\texpectedRest:  \" and more\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"unterminated string`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Quote \\\\\\\" not escaped\"`,\n\t\t\texpectedValue: \"Quote \\\\\\\" not escaped\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\t// Check if the returned value is as expected\n\t\tif value != test.expectedValue || rest != test.expectedRest {\n\t\t\tt.Errorf(\"For input %q, expected value: %q, rest: %q; got value: %q, rest: %q\", test.input, test.expectedValue, test.expectedRest, value, rest)\n\t\t}\n\n\t\t// Check if the error status is as expected\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"For input %q, expected error: %v; got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t}\n}","cc89c1bed9800d39da5e4dc1a0fd47ba":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\"42 is the answer\", \"42\", \" is the answer\", false},\n\t\t{\"-3.14 and some text\", \"-3.14\", \" and some text\", false},\n\t\t{\"3.14e10 more text\", \"3.14e10\", \" more text\", false},\n\t\t{\"inf is infinity\", \"inf\", \" is infinity\", false},\n\t\t{\"nan is not a number\", \"nan\", \" is not a number\", false},\n\t\t{\"- not a number\", \"\", \"- not a number\", true}, // invalid input\n\t\t{\"++ is not valid\", \"\", \"++ is not valid\", true}, // invalid input\n\t\t{\"\", \"\", \"\", true}, // empty input\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected error: %v, got: %v\", test.input, test.err, err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected result: %q, got: %q\", test.input, test.expected, result)\n\t\t}\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected rest: %q, got: %q\", test.input, test.rest, rest)\n\t\t}\n\t}\n}","cd096a26bec96244813fa324ca0118d3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\tdepth    int\n\t\texpected *Value\n\t\terr      string\n\t}{\n\t\t{\"\", 0, nil, \"cannot parse empty string\"}, // Test for empty input\n\n\t\t{\"{}\", 0, \u0026Value{t: TypeObject}, \"\"}, // Test for empty object\n\t\t{\"[]\", 0, \u0026Value{t: TypeArray}, \"\"}, // Test for empty array\n\n\t\t{\"\\\"test\\\"\", 0, \u0026Value{s: \"test\", t: typeRawString}, \"\"}, // Test for simple string\n\t\t{\"true\", 0, valueTrue, \"\"}, // Test for boolean true\n\t\t{\"false\", 0, valueFalse, \"\"}, // Test for boolean false\n\t\t{\"null\", 0, valueNull, \"\"}, // Test for null\n\n\t\t{\"123\", 0, \u0026Value{s: \"123\", t: TypeNumber}, \"\"}, // Test for number\n\t\t{\"12.34\", 0, \u0026Value{s: \"12.34\", t: TypeNumber}, \"\"}, // Test for float number\n\n\t\t// Test for parsing with excessive depth\n\t\t{\"{}\", MaxDepth, nil, \"too big depth for the nested JSON; it exceeds 10\"}, // Adjust MaxDepth as necessary\n        \n\t\t// Error cases\n\t\t{\"{invalid}\", 0, nil, \"cannot parse object: expected '{' at begin of object\"}, // Invalid object\n\t\t{\"[invalid]\", 0, nil, \"cannot parse array: expected '[' at begin of array\"}, // Invalid array\n\t\t{\"\\\"unclosed\", 0, nil, \"cannot parse string: unexpected end of input\"}, // Unclosed string\n\t\t{\"tru\", 0, nil, \"unexpected value found: \\\"tru\\\"\"}, // Invalid boolean\n\t\t{\"nul\", 0, nil, \"unexpected value found: \\\"nul\\\"\"}, // Invalid null\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseValue(test.input, c, test.depth)\n\n\t\t\tif test.err == \"\" \u0026\u0026 err != nil {\n\t\t\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t\t\t}\n\n\t\t\tif test.err != \"\" {\n\t\t\t\tif err == nil || err.Error() != test.err {\n\t\t\t\t\tt.Fatalf(\"expected error %q, got %v\", test.err, err)\n\t\t\t\t}\n\t\t\t\treturn // error case, skip further checks\n\t\t\t}\n\n\t\t\tif result == nil \u0026\u0026 test.expected != nil {\n\t\t\t\tt.Fatalf(\"expected %v, got nil\", test.expected)\n\t\t\t}\n\n\t\t\tif result != nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\t\tt.Fatalf(\"expected %v, got %v\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues compares two Value objects for equality\nfunc compareValues(a, b *Value) bool {\n\t// Implement comparison logic based on your Value structure\n\treturn a.s == b.s \u0026\u0026 a.t == b.t\n}","cd09872ff98ed51df9fc60253203ac1c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRemainder string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"simple\" more text`,\n\t\t\texpectedValue:  \"simple\",\n\t\t\texpectedRemainder: \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"string with escaped quote \\\\\"more text\"`,\n\t\t\texpectedValue:  \"string with escaped quote \\\\\",\n\t\t\texpectedRemainder: \"more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"incomplete string`,\n\t\t\texpectedValue:  \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped quote \\\\\"`,\n\t\t\texpectedValue:  \"escaped quote \\\\\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"multiple escaped quotes \\\\\"quote\\\\\" inside\" and some text`,\n\n\t\t\texpectedValue:  \"multiple escaped quotes \\\\\"quote\\\\\" inside\",\n\t\t\texpectedRemainder: \" and some text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `no quotes here`,\n\t\t\texpectedValue:  \"no quotes here\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remainder, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError = %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) value = %q, expectedValue = %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif remainder != test.expectedRemainder {\n\t\t\tt.Errorf(\"parseRawString(%q) remainder = %q, expectedRemainder = %q\", test.input, remainder, test.expectedRemainder)\n\t\t}\n\t}\n}","cd6cb6e8218d1f8c8539694471a3eebe":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"plain string\", \"plain string\"},\n\t\t{\"escaped \\\\n new line\", \"escaped \\n new line\"},\n\t\t{\"tab\\\\tcharacter\", \"tab\\tcharacter\"},\n\t\t{\"backslash\\\\\\\\\", \"backslash\\\\\"},\n\t\t{\"quote\\\\\\\"character\", \"quote\\\"character\"},\n\t\t{\"mixed \\\\u0041\\\\u0042\\\\u0043\", \"mixed ABC\"},\n\t\t{\"incomplete \\\\u004\", \"incomplete \\\\u004\"}, // malformed unicode\n\t\t{\"surrogates \\\\uD83D\\\\uDE00\", \"surrogates ðŸ˜€\"},\n\t\t{\"invalid sequence \\\\xG\", \"invalid sequence \\\\xG\"}, // invalid hex\n\t\t{\"complex \\\\uD83D\\\\uDE00\\\\uD83D\\\\uDC38\", \"complex ðŸ˜€ðŸˆ\"}, // valid surrogate pair\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := unescapeStringBestEffort(test.input)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, got, test.expected)\n\t\t}\n\t}\n}","ce19768ad4ca3977d0976120357c68d6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   \", \"\"},\n\t\t{\" \\n\\t\\rabc\", \"abc\"},\n\t\t{\"\\r\\n\\t  def\", \"def\"},\n\t\t{\"\\r    \\n ghi\", \"ghi\"},\n\t\t{\"jk \\r\\n\\t \", \"jk \"},\n\t\t{\"\\n  \", \"\"},\n\t\t{\"single\", \"single\"},\n\t\t{\"    multiple spaces    \", \"multiple spaces    \"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","ce393aeae9568082d69d7a6c00ded17e":"// parse_value_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectValue *Value\n\t\texpectTail  string\n\t\texpectErr   bool\n\t}{\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\texpectValue: nil,\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"true\",\n\t\t\texpectValue: valueTrue,\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"false\",\n\t\t\texpectValue: valueFalse,\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"null\",\n\t\t\texpectValue: valueNull,\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"\\\"hello\\\"\",\n\t\t\texpectValue: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"123\",\n\t\t\texpectValue: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3]\",\n\t\t\texpectValue: \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpectValue: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}, t: TypeObject},\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"123.456\",\n\t\t\texpectValue: \u0026Value{s: \"123.456\", t: TypeNumber},\n\t\t\texpectTail:  \"\",\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"a\",\n\t\t\texpectValue: nil,\n\t\t\texpectTail:  \"a\",\n\t\t\texpectErr:   true,\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, test := range tests {\n\t\tval, tail, err := parseValue(test.input, c, 0)\n\t\tif (err != nil) != test.expectErr {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, expectErr %v\", test.input, err, test.expectErr)\n\t\t}\n\t\tif err == nil \u0026\u0026 !valuesEqual(val, test.expectValue) {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, expectValue %v\", test.input, val, test.expectValue)\n\t\t}\n\t\tif tail != test.expectTail {\n\t\t\tt.Errorf(\"parseValue(%q) tail = %q, expectTail %q\", test.input, tail, test.expectTail)\n\t\t}\n\t}\n}\n\nfunc valuesEqual(v1, v2 *Value) bool {\n\t// Implement a comparison logic for Value struct\n\t// This is a placeholder. \n\t// Real implementation should compare all fields of Value\n\treturn v1 == v2\n}","cee6ab93546cb62c80fb31265cc0b0c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRest    string\n\t\texpectedError   bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6 more\", \"-123.45e+6\", \" more\", false},\n\t\t{\"3.14159\", \"3.14159\", \"\", false},\n\t\t{\"nan stuff\", \"nan\", \" stuff\", false},\n\t\t{\"inf something\", \"inf\", \" something\", false},\n\t\t{\"-.12345\", \"-.12345\", \"\", false},\n\t\t{\"invalid number\", \"\", \"invalid number\", true},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"-nan123\", \"-nan\", \"123\", false},\n\t\t{\"42\", \"42\", \"\", false},\n\t\t{\"\", \"\", \"\", true}, // edge case: empty string\n\t\t{\"-42.0.0 more\", \"-42.0\", \".0 more\", false}, // Invalid format\n\t}\n\n\tfor _, test := range tests {\n\t\tresultNumber, resultRest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"for input %q, expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\n\t\tif resultNumber != test.expectedNumber {\n\t\t\tt.Errorf(\"for input %q, expected number: %q, got: %q\", test.input, test.expectedNumber, resultNumber)\n\t\t}\n\n\t\tif resultRest != test.expectedRest {\n\t\t\tt.Errorf(\"for input %q, expected rest: %q, got: %q\", test.input, test.expectedRest, resultRest)\n\t\t}\n\t}\n}","cf569eccca807a583e3e1abb4542ed42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedString string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:          `\"hello\" world`,\n\t\t\texpectedString: \"hello\",\n\t\t\texpectedRest:   \" world\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"hello with \\\"escaped\\\" quotes\" more text`,\n\t\t\texpectedString: \"hello with \\\"escaped\\\" quotes\",\n\t\t\texpectedRest:   \" more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"missing closing quote`,\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: `\"escaped \\\\\" quotes\" and some more text`,\n\t\t\texpectedString: \"escaped \\\\ quotes\",\n\t\t\texpectedRest:   \" and some more text\",\n\t\t\texpectedError:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `just some text without quotes`,\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresultString, resultRest, err := parseRawString(tt.input)\n\n\t\tif tt.expectedError {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected error for input '%s' but got none\", tt.input)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error for input '%s': %v\", tt.input, err)\n\t\t}\n\n\t\tif resultString != tt.expectedString {\n\t\t\tt.Errorf(\"For input '%s', expected string '%s', got '%s'\", tt.input, tt.expectedString, resultString)\n\t\t}\n\n\t\tif resultRest != tt.expectedRest {\n\t\t\tt.Errorf(\"For input '%s', expected rest '%s', got '%s'\", tt.input, tt.expectedRest, resultRest)\n\t\t}\n\t}\n}","cfc916037e0bc9ef8c3ad68cd5ccc315":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Get(t *testing.T) {\n\t// Create a mock JSON value for testing\n\tjsonData := []byte(`{\n\t\t\"key1\": {\n\t\t\t\"key2\": \"value\"\n\t\t},\n\t\t\"array\": [\n\t\t\t\"zero\",\n\t\t\t\"one\",\n\t\t\t{\n\t\t\t\t\"key3\": \"value3\"\n\t\t\t}\n\t\t]\n\t}`)\n\tv, err := ParseBytes(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t}\n\n\ttests := []struct {\n\t\tkeys   []string\n\t\texpect *Value\n\t}{\n\t\t{[]string{\"key1\", \"key2\"}, v.Get(\"key1\", \"key2\")},\n\t\t{[]string{\"array\", \"1\"}, v.Get(\"array\", \"1\")},\n\t\t{[]string{\"array\", \"2\", \"key3\"}, v.Get(\"array\", \"2\", \"key3\")},\n\t\t{[]string{\"nonexistent\"}, nil}, // Testing for non-existing key\n\t\t{[]string{\"array\", \"3\"}, nil},  // Testing invalid array index\n\t\t{[]string{\"key1\", \"invalid\"}, nil}, // Testing invalid key path\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.keys[0], func(t *testing.T) {\n\t\t\tresult := v.Get(tt.keys...)\n\t\t\tif result != tt.expect {\n\t\t\t\tt.Errorf(\"Get(%v) = %v; want %v\", tt.keys, result, tt.expect)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Clean up\n\tv.Release()\n}","d022cd027712a505cb7c482afa838bb6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  *Value\n\t\texpectedTail   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"123\",\n\t\t\texpectedValue: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: // expected Value for array,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\"}`,\n\t\t\texpectedValue: // expected Value for object,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"more data\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"more data\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key\": \"value\", \"nested\": {\"key2\": \"value2\"}}`,\n\t\t\texpectedValue: // expected Value for nested object,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tvalue, tail, err := parseValue(tt.input, c, 0)\n\t\t\t\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t}\n\t\t\t\n\t\t\tif value != tt.expectedValue {\n\t\t\t\tt.Errorf(\"expected value: %v, got: %v\", tt.expectedValue, value)\n\t\t\t}\n\t\t\t\n\t\t\tif tail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail: %v, got: %v\", tt.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","d08a0b4bda078a33a560fef033579209":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput  string\n\t\toutput string\n\t}{\n\t\t{\n\t\t\tinput:  `\"Hello, World!\"`,\n\t\t\toutput: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Backslash: \\\\\"`,\n\t\t\toutput: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Newline:\\nSecond line\"`,\n\t\t\toutput: \"Newline:\\nSecond line\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Tab:\\tTabbed\"`,\n\t\t\toutput: \"Tab:\\tTabbed\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Unicode: \\u0041\\u0042\\u0043\"`,\n\t\t\toutput: \"Unicode: ABC\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Invalid Unicode: \\uXYZ\"`,\n\t\t\toutput: \"Invalid Unicode: \\\\uXYZ\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Surrogate: \\uD83D\\uDE00\"`, // Grinning Face emoji\n\t\t\toutput: \"Surrogate: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Mixed: \\\\uD83D\\\\uDE00\\\\uZZZZ\"`,\n\t\t\toutput: \"Mixed: ðŸ˜€\\\\uZZZZ\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"Empty: '' \"`,\n\t\t\toutput: \"Empty: '' \",\n\t\t},\n\t\t{\n\t\t\tinput:  `\"\\\\\"`,\n\t\t\toutput: \"\\\\\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot := unescapeStringBestEffort(tt.input)\n\t\t\tif got != tt.output {\n\t\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", tt.input, got, tt.output)\n\t\t\t}\n\t\t})\n\t}\n}","d17936696f61395fe3f9b52667ef3ece":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"    \", \"\"},\n\t\t{\"   hello\", \"hello\"},\n\t\t{\"\\n   world\", \"world\"},\n\t\t{\"goodbye   \", \"goodbye   \"},\n\t\t{\"   mixed\\n   spaces \\n\", \"mixed\\n   spaces \\n\"},\n\t\t{\" leading space\", \"leading space\"},\n\t\t{\" trailing newline\\n\", \"trailing newline\\n\"},\n\t\t{\"\\t tab\\n\", \"tab\\n\"},\n\t\t{\"\\r\\n   carriage return\", \"carriage return\"},\n\t\t{\"   \\t\\n\\r\\ntext with whitespace\", \"text with whitespace\"},\n\t\t{\"text with whitespace   \", \"text with whitespace   \"},\n\t\t{\"text without leading spaces\", \"text without leading spaces\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","d19552cb4a85b8bdc7ee59d416f1defb":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"nil value\",\n\t\t\tvalue: \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"boolean true\",\n\t\t\tvalue: \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"boolean false\",\n\t\t\tvalue: \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"string value\",\n\t\t\tvalue: \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\texpected: \"\\\"hello\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"number value\",\n\t\t\tvalue: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname: \"array of numbers\",\n\t\t\tvalue: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"object with properties\",\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"42\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":42}\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\tvalue: \u0026Value{t: TypeArray, a: []*Value{}},\n\t\t\texpected: \"[]\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty object\",\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\texpected: \"{}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo([]byte{})\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","d1c42aa0ff9a668dfcf23c9f797c946e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{vs: make([]Value, 0)}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{}, // Expect structure to be filled correctly\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect error due to missing value\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect error due to missing colon\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: \u0026Value{}, // Check if trailing comma is handled\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"anotherKey\": \"anotherValue\"}`,\n\t\t\texpected: \u0026Value{}, // Check structure for multiple keys\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"badKey\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect error due to missing colon\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\": \"value\", \"key2\": { \"subKey\": \"subValue\" }}`,\n\t\t\texpected: \u0026Value{}, // Expect proper handling of nested objects\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`,\n\t\t\texpected: nil,\n\t\t\terr:      true, // Expect error due to premature ending\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseObject(tt.input, c, 0)\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"Expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif tt.expected != nil \u0026\u0026 result != nil {\n\t\t\t\t// Here, you'd have to check the structure of result against tt.expected.\n\t\t\t\t// This is simplified as the expected structure verification \n\t\t\t\t// would depend on the implementation of Value and Object.\n\t\t\t}\n\t\t})\n\t}\n}","d2756c18d2278ae148d9b3426eb9553b":"// parse_object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"keyWithoutValue\":}`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"nested\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}},\n\t\t\t\t{k: \"nested\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"subkey\", v: \u0026Value{s: \"subvalue\", t: TypeString}}}}}},\n\t\t\t}}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid JSON\"`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tresult, remaining, err := parseObject(tt.input, c, depth)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.wantErr, err)\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 result == nil {\n\t\t\t\tt.Fatal(\"expected a resulting value but got nil\")\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !compareValues(result, tt.expected) {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t\tif remaining != \"\" {\n\t\t\t\tt.Errorf(\"expected empty remaining string, got: %s\", remaining)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Custom comparison logic between Value types goes here.\n\t// You need to implement this based on how you want to compare the structure and data of Value instances.\n\t// This may involve recursion and checking types, keys, etc.\n\n\treturn false // Implement the actual comparison logic\n}","d37f73f2514549345a227ae9b96d41ee":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawKey(t *testing.T) {\n\ttests := []struct {\n\t\tinput      string\n\t\texpectedKey string\n\t\texpectedRest string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tinput:       `\"key\"123`,\n\t\t\texpectedKey: \"key\",\n\t\t\texpectedRest: \"123\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"simple_key\"`,\n\t\t\texpectedKey: \"simple_key\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"key_with_escape\\\\n\"more`,\n\t\t\texpectedKey: \"key_with_escape\",\n\t\t\texpectedRest: \"more\",\n\t\t\texpectedErr: true, // Expects to trigger slow path for escape sequence\n\t\t},\n\t\t{\n\t\t\tinput:       `\"another_key\"test`,\n\t\t\texpectedKey: \"another_key\",\n\t\t\texpectedRest: \"test\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"missing_closing`,\n\t\t\texpectedKey: \"\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr: true, // Missing closing quote\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, rest, err := parseRawKey(test.input)\n\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"parseRawKey(%q) produced error: %v, expectedErr: %v\", test.input, err, test.expectedErr)\n\t\t}\n\t\tif key != test.expectedKey {\n\t\t\tt.Errorf(\"parseRawKey(%q) = %q, want %q\", test.input, key, test.expectedKey)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawKey(%q) = rest %q, want rest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","d384e78a0455b8094e0cc981c2bfffd0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_unescapeKeys(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    Object\n\t\texpected Object\n\t}{\n\t\t{\n\t\t\tname: \"Test with escaped keys\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\\\\u003Avalue1\", v: nil},\n\t\t\t\t\t{k: \"key2\\\\u003Avalue2\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1:value1\", v: nil},\n\t\t\t\t\t{k: \"key2:value2\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Test with already unescaped keys\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1:value1\", v: nil},\n\t\t\t\t\t{k: \"key2:value2\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1:value1\", v: nil},\n\t\t\t\t\t{k: \"key2:value2\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Test with mixed keys\",\n\t\t\tinput: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\\\\u003Avalue1\", v: nil},\n\t\t\t\t\t{k: \"key2:value2\", v: nil},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1:value1\", v: nil},\n\t\t\t\t\t{k: \"key2:value2\", v: nil},\n\t\t\t\t},\n\t\t\t\tkeysUnescaped: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt.input.unescapeKeys()\n\t\t\tif !equalObjects(tt.input, tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, tt.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc equalObjects(o1, o2 Object) bool {\n\tif o1.keysUnescaped != o2.keysUnescaped || len(o1.kvs) != len(o2.kvs) {\n\t\treturn false\n\t}\n\tfor i := range o1.kvs {\n\t\tif o1.kvs[i].k != o2.kvs[i].k {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","d4399876666ac672c67f3ad25ddf2cf4":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\"`,\n\t\t\texpected: \u0026Value{s: \"hello\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{a: []*Value{\u0026Value{s: \"1\", t: TypeNumber}, \u0026Value{s: \"2\", t: TypeNumber}, \u0026Value{s: \"3\", t: TypeNumber}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: typeRawString}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: valueNull}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [null, true, false]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{valueNull, valueTrue, valueFalse}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[[1, 2], [3, 4]]`,\n\t\t\texpected: \u0026Value{a: []*Value{\n\t\t\t\t\u0026Value{a: []*Value{\u0026Value{s: \"1\", t: TypeNumber}, \u0026Value{s: \"2\", t: TypeNumber}}},\n\t\t\t\t\u0026Value{a: []*Value{\u0026Value{s: \"3\", t: TypeNumber}, \u0026Value{s: \"4\", t: TypeNumber}}},\n\t\t\t}},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, \"value\", null, true]}`,\n\t\t\texpected: \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{a: []*Value{\u0026Value{s: \"1\", t: TypeNumber}, \u0026Value{s: \"value\", t: typeRawString}, valueNull, valueTrue}}}}}}},\n\t\t\terr:      false,\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q, got nil\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %s\", test.input, err)\n\t\t\t}\n\t\t\tif !compareValues(v, test.expected) {\n\t\t\t\tt.Errorf(\"for input %q, expected %#v, got %#v\", test.input, test.expected, v)\n\t\t\t}\n\t\t}\n\t\t// Additional checks can be made for 'tail' if necessary\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement a comparison function to verify the expected and actual Value structure\n\t// This should compare the type, string, and nested values properly\n\treturn false // Placeholder for actual comparison logic\n}","d4b604f7b013fd7cbb085e5d0f4c170d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedNumber string\n\t\texpectedRemainder string\n\t\texpectedError error\n\t}{\n\t\t{\"123\", \"123\", \"\", nil},\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-42\", \"-42\", \"\", nil},\n\t\t{\"3.14159extra\", \"3.14159\", \"extra\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"+nan\", \"+nan\", \"\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"++10\", \"\", \"10\", fmt.Errorf(\"unexpected char: %q\", \"+\")},\n\t\t{\"foo\", \"\", \"foo\", fmt.Errorf(\"unexpected char: %q\", \"f\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tgotNumber, gotRemainder, gotError := parseRawNumber(test.input)\n\n\t\tif gotNumber != test.expectedNumber || gotRemainder != test.expectedRemainder || (gotError != nil \u0026\u0026 test.expectedError == nil) || (gotError == nil \u0026\u0026 test.expectedError != nil \u0026\u0026 gotError.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\",\n\t\t\t\ttest.input, gotNumber, gotRemainder, gotError, test.expectedNumber, test.expectedRemainder, test.expectedError)\n\t\t}\n\t}\n}","d5afcbd21334131754f319a21296c8e1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[true, false]\",\n\t\t\texpected: []*Value{{t: TypeTrue}, {t: TypeFalse}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"string1\\\", \\\"string2\\\"]\",\n\t\t\texpected: []*Value{{t: TypeString, s: \"string1\"}, {t: TypeString, s: \"string2\"}},\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[1,,3]\",\n\t\t\twantErr: true, // Missing value between commas\n\t\t},\n\t\t{\n\t\t\tinput:   \"[1, 2, 3\",\n\t\t\twantErr: true, // Missing closing bracket\n\t\t},\n\t\t{\n\t\t\tinput:   \"1, 2, 3]\",\n\t\t\twantErr: true, // Invalid JSON array format\n\t\t},\n\t}\n\n\tcache := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\t// Call the function being tested\n\t\t\tresult, remaining, err := parseArray(tt.input, cache, 0)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\tif err == nil {\n\t\t\t\tif len(result.a) != len(tt.expected) {\n\t\t\t\t\tt.Errorf(\"parseArray() = %v, expected %v\", result.a, tt.expected)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Compare the contents of the arrays\n\t\t\t\tfor i := range result.a {\n\t\t\t\t\tif result.a[i].s != tt.expected[i].s || result.a[i].t != tt.expected[i].t {\n\t\t\t\t\t\tt.Errorf(\"parseArray() = %v, expected %v\", result.a, tt.expected)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","d6b58a3300f6f0aa3be4fdc50d3224d9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestStringBytes(t *testing.T) {\n\ttests := []struct {\n\t\tinput    *Value\n\t\texpected []byte\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    \u0026Value{s: \"example\", t: TypeString},\n\t\t\texpected: []byte(\"example\"),\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \u0026Value{s: \"\", t: TypeString},\n\t\t\texpected: []byte(\"\"),\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \u0026Value{s: \"another example\", t: TypeString},\n\t\t\texpected: []byte(\"another example\"),\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    \u0026Value{s: \"invalid\", t: TypeNumber}, // Invalid type\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    \u0026Value{s: \"yet another example\", t: TypeBoolean}, // Invalid type\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input.s, func(t *testing.T) {\n\t\t\tresult, err := tt.input.StringBytes()\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"StringBytes() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"StringBytes() = %v, want %v\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","d82823f69afa030b585520cf90bdf567":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v; want %v\", result, test.expected)\n\t\t}\n\t}\n}","db61f8c8bafafa3f785b8278370ea805":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedValue  string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"Hello, world!\"`,\n\t\t\texpectedValue: \"Hello, world!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Hello, \\\"world\\\"!\"`,\n\t\t\texpectedValue: \"Hello, \\\"world\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Hello, world!`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Escape \\\\\"`,\n\t\t\texpectedValue: \"Escape \\\\\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Coding \\\\\"is fun!\"`,\n\t\t\texpectedValue: \"Coding \\\\\",\n\t\t\texpectedRest:  \"is fun!\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"a\"trailing\"`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"a\\\"trailing\",\n\t\t\texpectedError: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tvalue, rest, err := parseRawString(tt.input)\n\t\tif (err != nil) != tt.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedError %v\", tt.input, err, tt.expectedError)\n\t\t\tcontinue\n\t\t}\n\t\tif value != tt.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedValue %q\", tt.input, value, tt.expectedValue)\n\t\t}\n\t\tif rest != tt.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest %q\", tt.input, rest, tt.expectedRest)\n\t\t}\n\t}\n}","dc8534c514a95ac790249388b3fb0c86":"// file: parse_raw_number_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trem      string\n\t\terr      bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+6 more data\", \"-123.45e+6\", \" more data\", false},\n\t\t{\"inf something\", \"inf\", \" something\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"-inf\", \"-inf\", \"\", false},\n\t\t{\"+inf\", \"+inf\", \"\", false},\n\t\t{\"na something\", \"\", \"na something\", true}, // Invalid number\n\t\t{\"- 12\", \"\", \"- 12\", true}, // Unexpected char\n\t\t{\"\", \"\", \"\", false}, // Edge case: empty string (not expected to happen as per function contract)\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, remainder, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawNumber(%q) returned error: %v, expected error: %v\", test.input, err, test.err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, expected %q\", test.input, result, test.expected)\n\t\t}\n\t\tif remainder != test.rem {\n\t\t\tt.Errorf(\"parseRawNumber(%q) remainder = %q, expected %q\", test.input, remainder, test.rem)\n\t\t}\n\t}\n}","dc8ba8ea3d6e15a7873c4367652b2c60":"// skipWSSlow_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"   Hello\", \"Hello\"},\n\t\t{\"\\n\\n\\nWorld\", \"World\"},\n\t\t{\"\\t\\t\\tTabs\", \"Tabs\"},\n\t\t{\"\\r\\r\\rCarriage\", \"Carriage\"},\n\t\t{\"   \\t \\n \\r  Mixed\", \"Mixed\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   LeadingSpaces\", \"LeadingSpaces\"},\n\t\t{\"TrailingSpaces   \", \"TrailingSpaces\"},\n\t\t{\"  \\n  \\t \\r \\n\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","dca2d006634fa60407c962b9f0af8fda":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedError  bool\n\t\texpectedObject *Value\n\t}{\n\t\t{\n\t\t\tinput:         `{ \"key\": \"value\" }`,\n\t\t\texpectedError: false,\n\t\t\texpectedObject: \u0026Value{ /* expected Value contents */ },\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key\": \"value\", \"anotherKey\": \"anotherValue\" }`,\n\t\t\texpectedError: false,\n\t\t\texpectedObject: \u0026Value{ /* expected Value contents */ },\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key\" \"value\" }`, // missing colon\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key\": \"value\", \"anotherKey\": }`, // missing value\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{}`, // empty object\n\t\t\texpectedError: false,\n\t\t\texpectedObject: \u0026Value{ /* expected Value contents for empty object */ },\n\t\t},\n\t\t{\n\t\t\tinput:         `}`, // invalid starting\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key\": 123, \"nested\": { \"nestedKey\": \"nestedValue\" } }`, // nested object\n\t\t\texpectedError: false,\n\t\t\texpectedObject: \u0026Value{ /* expected Value contents */ },\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\t\tif test.expectedError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected an error but got none\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Perform assertions on the result and remaining string as needed\n\t\t\t// For example, you can compare result with test.expectedObject,\n\t\t\t// although you'll need to implement a way to check for Value equality\n\t\t\t// and assert that remaining is as expected.\n\t\t})\n\t}\n}","dd219a2aa44bcb66c6744f5b2ba36ce9":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, \\\"World\\\"!\"`,\n\t\t\texpected: \"Hello, \\\"World\\\"!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"New line:\\nTab:\\tBackslash:\\\\\"`,\n\t\t\texpected: \"New line:\\nTab:\\tBackslash:\\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u4F60\\u597D\"`,\n\t\t\texpected: \"Unicode: ä½ å¥½\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Incomplete unicode: \\u\"`,\n\t\t\texpected: \"Incomplete unicode: \\\\u\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped backslash: \\\\\\\\\"`,\n\t\t\texpected: \"Escaped backslash: \\\\\\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escape\"`,\n\t\t\texpected: \"No escape\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed: \\nText with escape: others \\x00 and \\b\"`,\n\t\t\texpected: \"Mixed: \\nText with escape: others \\x00 and \\b\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := unescapeStringBestEffort(test.input)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, got, test.expected)\n\t\t}\n\t}\n}","dde25cf643e56e97e53ca4ead8c2e7f0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      error\n\t}{\n\t\t{\"123.45someText\", \"123.45\", \"someText\", nil},\n\t\t{\"-123.45e10moreText\", \"-123.45e10\", \"moreText\", nil},\n\t\t{\"+inf and more\", \"+inf\", \" and more\", nil},\n\t\t{\"nan more data\", \"nan\", \" more data\", nil},\n\t\t{\"12abc\", \"12\", \"abc\", nil},\n\t\t{\"inf123\", \"inf\", \"123\", nil},\n\t\t{\"-nan123\", \"-nan\", \"123\", nil},\n\t\t{\"\", \"\", \"\", nil}, // This case may need to be handled properly if len(s) must be \u003e 0\n\t\t{\"abc\", \"\", \"abc\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"--123\", \"\", \"--123\", fmt.Errorf(\"unexpected char: %q\", \"-\")},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult, rest, err := parseRawNumber(test.input)\n\n\t\t\tif result != test.expected || rest != test.rest || !isErrorEqual(err, test.err) {\n\t\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v), expected (%q, %q, %v)\",\n\t\t\t\t\ttest.input, result, rest, err, test.expected, test.rest, test.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc isErrorEqual(err1, err2 error) bool {\n\tif err1 == nil {\n\t\treturn err2 == nil\n\t}\n\tif err2 == nil {\n\t\treturn false\n\t}\n\treturn err1.Error() == err2.Error()\n}","de1d09d9d4effb17d78a1263560aee71":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n  Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\t\\tHello, World!\", \"Hello, World!\"},\n\t\t{\"\\r\\nHello, World!\", \"Hello, World!\"},\n\t\t{\"  \\t\\n\\r   \", \"\"},\n\t\t{\"No leading spaces\", \"No leading spaces\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := skipWSSlow(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","df4c44fc41f3659b59dbb32405ad0613":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetBool(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tjsonInput  string\n\t\tkeys       []string\n\t\texpectBool bool\n\t}{\n\t\t{\n\t\t\tname:       \"existing true value\",\n\t\t\tjsonInput:  `{\"key\": true}`,\n\t\t\tkeys:       []string{\"key\"},\n\t\t\texpectBool: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"existing false value\",\n\t\t\tjsonInput:  `{\"key\": false}`,\n\t\t\tkeys:       []string{\"key\"},\n\t\t\texpectBool: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"non-existing key\",\n\t\t\tjsonInput:  `{}`,\n\t\t\tkeys:       []string{\"nonExistingKey\"},\n\t\t\texpectBool: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid type (string)\",\n\t\t\tjsonInput:  `{\"key\": \"true\"}`,\n\t\t\tkeys:       []string{\"key\"},\n\t\t\texpectBool: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"invalid type (number)\",\n\t\t\tjsonInput:  `{\"key\": 1}`,\n\t\t\tkeys:       []string{\"key\"},\n\t\t\texpectBool: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"nested key true\",\n\t\t\tjsonInput:  `{\"outer\": {\"inner\": true}}`,\n\t\t\tkeys:       []string{\"outer\", \"inner\"},\n\t\t\texpectBool: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"nested key false\",\n\t\t\tjsonInput:  `{\"outer\": {\"inner\": false}}`,\n\t\t\tkeys:       []string{\"outer\", \"inner\"},\n\t\t\texpectBool: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"array index true\",\n\t\t\tjsonInput:  `{\"array\": [true, false]}`,\n\t\t\tkeys:       []string{\"array\", \"0\"},\n\t\t\texpectBool: true,\n\t\t},\n\t\t{\n\t\t\tname:       \"array index false\",\n\t\t\tjsonInput:  `{\"array\": [true, false]}`,\n\t\t\tkeys:       []string{\"array\", \"1\"},\n\t\t\texpectBool: false,\n\t\t},\n\t\t{\n\t\t\tname:       \"array index out of range\",\n\t\t\tjsonInput:  `{\"array\": [true]}`,\n\t\t\tkeys:       []string{\"array\", \"1\"},\n\t\t\texpectBool: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tparser := new(Parser)\n\t\t\tvalue, err := parser.Parse(test.jsonInput)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %s\", err)\n\t\t\t}\n\t\t\tgotBool := value.GetBool(test.keys...)\n\t\t\tif gotBool != test.expectBool {\n\t\t\t\tt.Errorf(\"got %v, want %v\", gotBool, test.expectBool)\n\t\t\t}\n\t\t})\n\t}\n}","e08540605cae6ed9a666d3cee7b412f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, \\u4F60\\u597D\"`, // \"Hello, ä½ å¥½\"\n\t\t\texpected: \"Hello, ä½ å¥½\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`, // contains newline\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tCharacter\"`, // contains tab\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`, // contains backslash\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid unicode: \\u123\"`, // invalid unicode sequence\n\t\t\texpected: \"Invalid unicode: \\\\u123\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\uD83D\\uDE00\"`, // valid UTF-16 surrogate pair\n\t\t\texpected: \"\\U0001F600\",   // ðŸ˜€ (grinning face)\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped quotes: \\\"Example\\\" \"`, // contains escaped quotes\n\t\t\texpected: \"Escaped quotes: \\\"Example\\\" \",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`, // empty string\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult := unescapeStringBestEffort(tt.input)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"unexpected result: got %q, expected %q\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","e0c44423b42e12e4986c689637048fc2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\nTab\\tNewline\\rCarriage\"`,\n\t\t\texpected: \"\\nTab\\tNewline\\rCarriage\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escape: \\\\n and \\\\\"`,\n\t\t\texpected: \"Escape: \\\\n and \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u0041\\u00C1\\u1F600\"`,\n\t\t\texpected: \"Unicode: AÃðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Incomplete escape: \\u\"`,\n\t\t\texpected: \"Incomplete escape: \\\\u\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Multiple \\\\\" plus end\"`,\n\t\t\texpected: \"Multiple \\\\ plus end\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e21671345d404e178d58a9be757c585b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput   string\n\t\twant    []*Value\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tinput:   \"[]\",\n\t\t\twant:    []*Value{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[1, 2, 3]\",\n\t\t\twant:    []*Value{{t: TypeNumber, s: \"1\"}, {t: TypeNumber, s: \"2\"}, {t: TypeNumber, s: \"3\"}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[true, false]\",\n\t\t\twant:    []*Value{{t: TypeTrue, s: \"\"}, {t: TypeFalse, s: \"\"}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[\\\"string\\\", null]\",\n\t\t\twant:    []*Value{{t: TypeString, s: \"string\"}, {t: TypeNull, s: \"\"}},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[1,]\",\n\t\t\twant:    nil, // This input is malformed\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[,[1, 2]]\",\n\t\t\twant:    nil, // This input is malformed\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:   \"[1,,2]\",\n\t\t\twant:    nil, // This input is malformed\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:   \"\",\n\t\t\twant:    nil, // This input is malformed\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tgot, _, err := parseArray(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseArray() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !tt.wantErr \u0026\u0026 !equalValues(got.a, tt.want) {\n\t\t\t\tt.Errorf(\"parseArray() = %v, want %v\", got.a, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// equalValues compares two slices of Value pointers for equality.\nfunc equalValues(got, want []*Value) bool {\n\tif len(got) != len(want) {\n\t\treturn false\n\t}\n\tfor i := range got {\n\t\tif got[i].s != want[i].s || got[i].t != want[i].t {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","e23f2363915a7f8671a8500fbf19be5d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"String\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"example\"},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname:     \"Number\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpected: \"123\",\n\t\t},\n\t\t{\n\t\t\tname:     \"True\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname:     \"False\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Null\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Array\",\n\t\t\tvalue: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t{t: TypeNumber, s: \"3\"},\n\t\t\t}},\n\t\t\texpected: \"[1,2,3]\",\n\t\t},\n\t\t{\n\t\t\tname: \"Object\",\n\t\t\tvalue: \u0026Value{t: TypeObject, o: Object{\n\t\t\t\tkvs: []kv{\n\t\t\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":2}`,\n\t\t},\n\t\t{\n\t\t\tname: \"RawString\",\n\t\t\tvalue: \u0026Value{t: typeRawString, s: \"raw_value\"},\n\t\t\texpected: `\"raw_value\"`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := tt.value.MarshalTo(dst)\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","e29ea33cab5b9f9fb4523fdea62a7bfd":"// parse_raw_number_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNum   string\n\t\texpectedRest   string\n\t\texpectedError   bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+10xyz\", \"-123.45e+10\", \"xyz\", false},\n\t\t{\"3.14159\", \"3.14159\", \"\", false},\n\t\t{\"NaN more text\", \"NaN\", \" more text\", false},\n\t\t{\"-INF\", \"-INF\", \"\", false},\n\t\t{\"-inf123\", \"-inf\", \"123\", false},\n\t\t{\"--5\", \"\", \"--5\", true}, // Double negative\n\t\t{\"++5\", \"\", \"++5\", true}, // Double positive\n\t\t{\"abc123\", \"\", \"abc123\", true}, // Invalid starting character\n\t\t{\"\", \"\", \"\", true}, // Empty string\n\t}\n\n\tfor _, test := range tests {\n\t\tnum, rest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) error = %v, expectedError %v\", test.input, err, test.expectedError)\n\t\t}\n\t\tif num != test.expectedNum {\n\t\t\tt.Errorf(\"parseRawNumber(%q) num = %q, expectedNum %q\", test.input, num, test.expectedNum)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) rest = %q, expectedRest %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","e2f1c5765c1a8aba24c0ebf5d434d945":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedKeys  []string\n\t\texpectedValues []string\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedKeys:   []string{\"key1\", \"key2\"},\n\t\t\texpectedValues: []string{\"value1\", \"value2\"},\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"singleKey\": \"singleValue\"}`,\n\t\t\texpectedKeys:   []string{\"singleKey\"},\n\t\t\texpectedValues: []string{\"singleValue\"},\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"missingColon\" \"value\"}`,\n\t\t\texpectedKeys:   nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\":}`,\n\t\t\texpectedKeys:   nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:    true,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key\": \"value\",}`,\n\t\t\texpectedKeys:   []string{\"key\"},\n\t\t\texpectedValues: []string{\"value\"},\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tinput:          `{}`,\n\t\t\texpectedKeys:   nil,\n\t\t\texpectedValues: nil,\n\t\t\texpectError:    false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tcache := \u0026cache{}\n\t\tresult, remainder, err := parseObject(test.input, cache, 0)\n\n\t\tif test.expectError \u0026\u0026 err == nil {\n\t\t\tt.Errorf(\"Expected error for input %q, but got none\", test.input)\n\t\t\tcontinue\n\t\t}\n\t\tif !test.expectError \u0026\u0026 err != nil {\n\t\t\tt.Errorf(\"Did not expect error for input %q, but got: %v\", test.input, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tfor i, kv := range result.o.kvs {\n\t\t\t\tif kv.k != test.expectedKeys[i] {\n\t\t\t\t\tt.Errorf(\"For input %q expected key %q, got %q\", test.input, test.expectedKeys[i], kv.k)\n\t\t\t\t}\n\t\t\t\tif kv.v.s != test.expectedValues[i] {\n\t\t\t\t\tt.Errorf(\"For input %q expected value %q for key %q, got %q\", test.input, test.expectedValues[i], kv.k, kv.v.s)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(remainder) != 0 {\n\t\t\t\tt.Errorf(\"Did not expect any remainder, but got: %q for input %q\", remainder, test.input)\n\t\t\t}\n\t\t}\n\t}\n}","e310404b1d11354d4286fbf82a7a9788":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\"}`,\n\t\t\texpected: // populate with expected structure,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: // populate with expected structure,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: // populate with expected structure,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key1\": \"value1\", \"key2\": \"value2\",  }`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": 123, \"key2\": true}`,\n\t\t\texpected: // populate with expected structure,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": null}`,\n\t\t\texpected: // populate with expected structure,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": { \"nestedKey\": \"nestedValue\" }}`,\n\t\t\texpected: // populate with expected structure for nested object,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{t: TypeObject},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tresult, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseObject(%v) got err %v, want err %v\", test.input, err, test.err)\n\t\t}\n\n\t\tif !test.err {\n\t\t\tif result == nil || !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"parseObject(%v) = result %v, want %v\", test.input, result, test.expected)\n\t\t\t}\n\t\t}\n\n\t\t// You would also check if remainder is empty or matches expected remainder based on your use case\n\t}\n}\n\n// compareValues is a helper function to recursively compare expected and actual Value types.\n// It would need to be implemented to compare the expected and actual values properly.\nfunc compareValues(actual, expected *Value) bool {\n\t// Implement comparison logic here\n\treturn true // Placeholder implementation\n}","e32f3799b5fb1bcda0719fd195661530":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"C:\\\\Program Files\\\\\"`,\n\t\t\texpected: \"C:\\\\Program Files\\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\nTab\\tNewline\\n\"`,\n\t\t\texpected: \"\\nTab\\tNewline\\n\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u2602\"`, // umbrella emoji\n\t\t\texpected: \"Unicode: â˜‚\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate pair: \\uD83D\\uDE00\"`, // grinning face emoji\n\t\t\texpected: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid unicode: \\uD83D\"`,\n\t\t\texpected: \"Invalid unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\uD83D\"`, // incomplete surrogate\n\t\t\texpected: \"\\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab: \\t and Newline: \\n\"`,\n\t\t\texpected: \"Tab: \\t and Newline: \\n\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Escaped quotes: \\\"Hello\\\" World!\"`,\n\t\t\texpected: \"Escaped quotes: \\\"Hello\\\" World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escapes here!\"`,\n\t\t\texpected: \"No escapes here!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed escapes: \\n \\t \\\" \\\\\"`,\n\t\t\texpected: \"Mixed escapes: \\n \\t \\\" \\\\\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e367c07855bfa56e25589782286ec8b7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedStr  string\n\t\texpectedRest string\n\t\texpectedErr  bool\n\t}{\n\t\t{\"\\\"hello\\\"\", \"hello\", \"\", false},\n\t\t{\"\\\"hello world\\\"\", \"hello world\", \"\", false},\n\t\t{\"\\\"escaped \\\\\\\"quote\\\\\\\"\\\"\", \"escaped \\\"quote\\\"\", \"\", false},\n\t\t{\"\\\"incomplete string\", \"\", \"\", true},\n\t\t{\"\\\"double \\\\\\\" escaped \\\\\\\" quotes\\\"\", \"double \\\" escaped \\\" quotes\", \"\", false},\n\t\t{\"\\\"non-escaped quote\\\"\", \"non-escaped quote\", \"\", false},\n\t\t{\"\\\"mixed \\\\\\\" escape \\\\\\\" with text\\\"\", \"mixed \\\" escape \\\" with text\", \"\", false},\n\t\t{\"\\\"unmatched quote at end\", \"\", \"\", true},\n\t\t{\"string without quotes\", \"string without quotes\", \"\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tresultStr, resultRest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedErr {\n\t\t\tt.Errorf(\"parseRawString(%q) error = %v, expectedErr = %v\", test.input, err, test.expectedErr)\n\t\t\tcontinue\n\t\t}\n\n\t\tif resultStr != test.expectedStr {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, expectedStr = %q\", test.input, resultStr, test.expectedStr)\n\t\t}\n\n\t\tif resultRest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, expectedRest = %q\", test.input, resultRest, test.expectedRest)\n\t\t}\n\t}\n}","e3b625c10b9083a177ee75bf2554ab5a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected []*Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"[]\",\n\t\t\texpected: []*Value{},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}, \u0026Value{t: TypeNumber, s: \"3\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n\t\t\texpected: []*Value{\u0026Value{t: TypeString, s: \"a\"}, \u0026Value{t: TypeString, s: \"b\"}, \u0026Value{t: TypeString, s: \"c\"}},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3, ]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1,,2]\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tc := \u0026cache{}\n\t\t\tdepth := 0\n\t\t\tresult, _, err := parseArray(tt.input, c, depth)\n\n\t\t\tif (err != nil) != tt.err {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\n\t\t\tif !tt.err {\n\t\t\t\tif len(result.a) != len(tt.expected) {\n\t\t\t\t\tt.Errorf(\"expected length: %d, got: %d\", len(tt.expected), len(result.a))\n\t\t\t\t}\n\n\t\t\t\tfor i, expectedVal := range tt.expected {\n\t\t\t\t\tif result.a[i].s != expectedVal.s || result.a[i].t != expectedVal.t {\n\t\t\t\t\t\tt.Errorf(\"expected: %v, got: %v\", expectedVal, result.a[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}","e3eb0620aefa4f7a91429e17a5df1d87":"// unescape_string_best_effort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Line1\\nLine2\"`,\n\t\t\texpected: \"Line1\\nLine2\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab\\tCharacter\"`,\n\t\t\texpected: \"Tab\\tCharacter\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash\\\\Character\"`,\n\t\t\texpected: \"Backslash\\\\Character\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode: \\u03A9\"`, // Î© character\n\t\t\texpected: \"Unicode: Î©\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode: \\uD800\"`,\n\t\t\texpected: \"Invalid Unicode: \\\\uD800\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Some Unknown Escape \\x01\"`, // \\x01 is unknown\n\t\t\texpected: \"Some Unknown Escape \\\\x01\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Complex escape sequences: \\n \\t \\\\ \\\" \"`,\n\t\t\texpected: \"Complex escape sequences: \\n \\t \\\\ \\\" \",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escape characters here\"`,\n\t\t\texpected: \"No escape characters here\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed escaping: \\u003C\\u003E\"`, // \u003c and \u003e\n\t\t\texpected: \"Mixed escaping: \u003c\u003e\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","e3f590dbf2ba58be97e9c05ed05fbb1a":"// file: string_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.expected, func(t *testing.T) {\n\t\t\tresult := test.input.String()\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Testing the panic case for unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not panic\")\n\t\t}\n\t}()\n\tvar invalidType Type = -1 // An invalid type that is not defined\n\t_ = invalidType.String()\n}","e51e94608dd11bf35b4e80233aad4416":"// File: marshal_test.go\n\npackage fastjson\n\nimport \"testing\"\n\nfunc TestValue_MarshalTo(t *testing.T) {\n    tests := []struct {\n        value    *Value\n        expected string\n    }{\n        {\n            value:    \u0026Value{t: TypeNull},\n            expected: \"null\",\n        },\n        {\n            value:    \u0026Value{t: TypeTrue},\n            expected: \"true\",\n        },\n        {\n            value:    \u0026Value{t: TypeFalse},\n            expected: \"false\",\n        },\n        {\n            value:    \u0026Value{t: TypeString, s: \"hello\"},\n            expected: \"\\\"hello\\\"\",\n        },\n        {\n            value:    \u0026Value{t: TypeNumber, s: \"123\"},\n            expected: \"123\",\n        },\n        {\n            value: \u0026Value{\n                t: TypeArray,\n                a: []*Value{\n                    \u0026Value{t: TypeNumber, s: \"1\"},\n                    \u0026Value{t: TypeNumber, s: \"2\"},\n                    \u0026Value{t: TypeNumber, s: \"3\"},\n                },\n            },\n            expected: \"[1,2,3]\",\n        },\n        {\n            value: \u0026Value{\n                t: TypeObject,\n                o: Object{\n                    kvs: []kv{\n                        {k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n                        {k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"2\"}},\n                    },\n                },\n            },\n            expected: \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":2}\",\n        },\n    }\n\n    for _, test := range tests {\n        // Prepare the destination byte slice\n        dst := make([]byte, 0)\n\n        // Marshal the value\n        result := test.value.MarshalTo(dst)\n\n        // Convert the result to string for comparison\n        actual := string(result)\n\n        if actual != test.expected {\n            t.Errorf(\"expected %q, got %q\", test.expected, actual)\n        }\n    }\n}","e5485be886fbf998b404fd9392355eb6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetFloat64(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinputJSON    string\n\t\tkeys         []string\n\t\texpected     float64\n\t\texpectingErr bool\n\t}{\n\t\t{\n\t\t\tname:      \"basic float64 retrieval\",\n\t\t\tinputJSON: `{\"a\": {\"b\": 3.14}}`,\n\t\t\tkeys:      []string{\"a\", \"b\"},\n\t\t\texpected:  3.14,\n\t\t},\n\t\t{\n\t\t\tname:      \"float64 retrieval with non-existing key\",\n\t\t\tinputJSON: `{\"a\": {\"b\": 3.14}}`,\n\t\t\tkeys:      []string{\"a\", \"c\"},\n\t\t\texpected:  0,\n\t\t},\n\t\t{\n\t\t\tname:      \"non-float64 value\",\n\t\t\tinputJSON: `{\"a\": {\"b\": \"not a float\"}}`,\n\t\t\tkeys:      []string{\"a\", \"b\"},\n\t\t\texpected:  0,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty input\",\n\t\t\tinputJSON: `{}`,\n\t\t\tkeys:      []string{\"a\", \"b\"},\n\t\t\texpected:  0,\n\t\t},\n\t\t{\n\t\t\tname:      \"complex nested keys\",\n\t\t\tinputJSON: `{\"a\": {\"b\": {\"c\": 2.71}}}`,\n\t\t\tkeys:      []string{\"a\", \"b\", \"c\"},\n\t\t\texpected:  2.71,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparser := new(Parser)\n\t\t\tvalue, err := parser.Parse(tt.inputJSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\tresult := value.GetFloat64(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","e5859f88ecff2e15e312b6c54fde32c3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tvalue:    \u0026Value{t: typeRawString, s: \"test\"},\n\t\t\texpected: `\"test\"`,\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{ // create an example object\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\"}`,\n\t\t},\n\t\t{\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{ // create an example array\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: []byte(\"1\")},\n\t\t\t\t\t\u0026Value{t: TypeString, s: \"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,\"string\"]`,\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\texpected: `null`,\n\t\t},\n\t\t{\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: []byte(\"42\")},\n\t\t\texpected: `42`,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tdst := []byte{}\n\t\tresult := test.value.MarshalTo(dst)\n\t\tif string(result) != test.expected {\n\t\t\tt.Errorf(\"expected %s, got %s\", test.expected, string(result))\n\t\t}\n\t}\n}","e59539ec2cf73eea40662f8b045e72c5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObject_Visit(t *testing.T) {\n\tobject := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\"}},\n\t\t\t{k: \"key3\", v: \u0026Value{s: \"value3\"}},\n\t\t},\n\t}\n\n\tcalledKeys := [][]byte{}\n\tcalledValues := []*Value{}\n\n\t// Define the function to be called during Visit\n\tf := func(key []byte, v *Value) {\n\t\tcalledKeys = append(calledKeys, key)\n\t\tcalledValues = append(calledValues, v)\n\t}\n\n\t// Call Visit\n\tobject.Visit(f)\n\n\t// Check that the called keys and values are as expected\n\texpectedKeys := [][]byte{[]byte(\"key1\"), []byte(\"key2\"), []byte(\"key3\")}\n\texpectedValues := []*Value{\n\t\t\u0026Value{s: \"value1\"},\n\t\t\u0026Value{s: \"value2\"},\n\t\t\u0026Value{s: \"value3\"},\n\t}\n\n\tfor i := range expectedKeys {\n\t\tif string(calledKeys[i]) != string(expectedKeys[i]) {\n\t\t\tt.Errorf(\"expected key %s, got %s\", expectedKeys[i], calledKeys[i])\n\t\t}\n\t\tif calledValues[i].s != expectedValues[i].s {\n\t\t\tt.Errorf(\"expected value %s, got %s\", expectedValues[i].s, calledValues[i].s)\n\t\t}\n\t}\n}","e68dfded8d2b26a44da71ff5e78c83dd":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedNum string\n\t\texpectedRem string\n\t\texpectError bool\n\t}{\n\t\t{\"12345abc\", \"12345\", \"abc\", false},\n\t\t{\"-123.45e+10 more\", \"-123.45e+10\", \" more\", false},\n\t\t{\"3.14\", \"3.14\", \"\", false},\n\t\t{\"-inf some text\", \"-inf\", \" some text\", false},\n\t\t{\"nan something\", \"nan\", \" something\", false},\n\t\t{\"abc\", \"\", \"abc\", true}, // error case with unexpected character\n\t\t{\"-xyz\", \"\", \"-xyz\", true}, // error case with unexpected character\n\t\t{\"+inf and more\", \"+inf\", \" and more\", false},\n\t\t{\"456.78.90\", \"456.78\", \".90\", false}, // valid float, but has trailing dot\n\t\t{\"123e-5something\", \"123e-5\", \"something\", false},\n\t\t{\"+12e+4 more text\", \"+12e+4\", \" more text\", false},\n\t\t{\"\", \"\", \"\", true}, // error case for empty string\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tnum, rem, err := parseRawNumber(tt.input)\n\t\t\tif (err != nil) != tt.expectError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectError, err)\n\t\t\t}\n\t\t\tif num != tt.expectedNum {\n\t\t\t\tt.Errorf(\"expected number: %q, got: %q\", tt.expectedNum, num)\n\t\t\t}\n\t\t\tif rem != tt.expectedRem {\n\t\t\t\tt.Errorf(\"expected remainder: %q, got: %q\", tt.expectedRem, rem)\n\t\t\t}\n\t\t})\n\t}\n}","e6b2976f720156be6211fd77b2f75c07":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"example\",\n\t\t\t},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key\", \u0026Value{t: TypeString, s: \"value\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,2]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal complex structure\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"name\", \u0026Value{t: TypeString, s: \"John\"}},\n\t\t\t\t\t\t{\"age\", \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t\t{\"isStudent\", \u0026Value{t: TypeFalse}},\n\t\t\t\t\t\t{\"grades\", \u0026Value{\n\t\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"90\"},\n\t\t\t\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"85\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `{\"name\":\"John\",\"age\":30,\"isStudent\":false,\"grades\":[90,85]}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo([]byte{})\n\t\t\tif string(result) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, string(result))\n\t\t\t}\n\t\t})\n\t}\n}","e6cb490bb2c0d83ed347c3d9f08ba14a":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWS(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   hello\", \"hello\"},        // leading whitespace\n\t\t{\"   world   \", \"world   \"},  // leading and trailing whitespace\n\t\t{\"no whitespace\", \"no whitespace\"}, // no whitespace\n\t\t{\"\\t\\t\\t\", \"\"},               // only tabs\n\t\t{\"\\n\\nhello\", \"hello\"},       // new lines before text\n\t\t{\"\", \"\"},                     // empty string\n\t\t{\" \\t \\n \", \"\"},              // only whitespace\n\t\t{\"hello \\n world\", \"hello \\n world\"}, // characters followed by whitespace\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult := skipWS(tt.input)\n\t\tif result != tt.expected {\n\t\t\tt.Errorf(\"skipWS(%q) = %q; want %q\", tt.input, result, tt.expected)\n\t\t}\n\t}\n}","e7400b10fb6d7115b93dba7c2dfd9129":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, World!\"`,\n\t\t\texpected: \"Hello, World!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\\nHello\\tWorld\\f!\"`,\n\t\t\texpected: \"\\nHello\\tWorld\\f!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"A string with a backslash: \\\\\"`,\n\t\t\texpected: \"A string with a backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode test: \\u0041\"`,\n\t\t\texpected: \"Unicode test: A\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate pair: \\uD83D\\uDE00\"`,\n\t\t\texpected: \"Surrogate pair: ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode: \\uD83D\"`, // Incomplete Unicode escape\n\t\t\texpected: \"Invalid Unicode: \\\\uD83D\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed Escapes: \\\\\\\"\"` ,\n\t\t\texpected: \"Mixed Escapes: \\\\\\\"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"No escapes here\"`,\n\t\t\texpected: \"No escapes here\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`,\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","e74702fd6fc7d1ac731ed0c5591cd278":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedObject *Value\n\t\texpectedRemainder string\n\t\texpectedError   error\n\t}{\n\t\t{\n\t\t\tinput:          `{}`,\n\t\t\texpectedObject: \u0026Value{t: TypeObject},\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpectedObject: \u0026Value{t: TypeObject},\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError: nil, // Expect to populate object properly\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedObject: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   fmt.Errorf(\"cannot parse object value: missing value for key 'key2'\"),\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\"}`,\n\t\t\texpectedObject: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedObject: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tinput:          `{\"key1\", \"value1\"}`,\n\t\t\texpectedObject: nil,\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedError:   fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tcache := \u0026cache{}\n\t\tresult, remainder, err := parseObject(test.input, cache, 0)\n\n\t\t// Check if we got the expected output\n\t\tif test.expectedError != nil {\n\t\t\tif err == nil || err.Error() != test.expectedError.Error() {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", test.expectedError, err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"expected no error, got: %v\", err)\n\t\t\t}\n\n\t\t\tif result != nil {\n\t\t\t\t// Add logic here to compare expectedObject with result\n\t\t\t}\n\t\t\tif remainder != test.expectedRemainder {\n\t\t\t\tt.Errorf(\"expected remainder: %q, got: %q\", test.expectedRemainder, remainder)\n\t\t\t}\n\t\t}\n\t}\n}","e7490200a8c15ff50bab2c7d5fde9cac":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escape \\\" quote\" more text`,\n\t\t\texpected: \"escape \\\" quote\",\n\t\t\trest:     \" more text\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped quote: \\\\\" and text\" end`,\n\t\t\texpected: \"escaped quote: \\\\\",\n\t\t\trest:     \" and text\\\" end\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `just some text`,\n\t\t\texpected: \"just some text\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"multiple \\\"escaped\\\" quotes\\\" continue`,\n\t\t\texpected: \"multiple \\\"escaped\\\" quotes\",\n\t\t\trest:     \" continue\",\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Fatalf(\"For input %q, expected error: %v, got error: %v\", test.input, test.err, err)\n\t\t}\n\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"For input %q, expected: %q, got: %q\", test.input, test.expected, got)\n\t\t}\n\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"For input %q, expected rest: %q, got rest: %q\", test.input, test.rest, rest)\n\t\t}\n\t}\n}","e783a3e5d0076d408007be0cbdc07566":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestObjectReset(t *testing.T) {\n\tobj := \u0026Object{\n\t\tkvs: []kv{\n\t\t\t{\"key1\", \u0026Value{}},\n\t\t\t{\"key2\", \u0026Value{}},\n\t\t},\n\t\tkeysUnescaped: true,\n\t}\n\n\t// Check the initial state of the Object\n\tif len(obj.kvs) != 2 {\n\t\tt.Fatalf(\"expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\tif !obj.keysUnescaped {\n\t\tt.Fatalf(\"expected keysUnescaped to be true, got false\")\n\t}\n\n\t// Call reset\n\tobj.reset()\n\n\t// Check the state after reset\n\tif len(obj.kvs) != 0 {\n\t\tt.Fatalf(\"expected kvs length to be 0 after reset, got %d\", len(obj.kvs))\n\t}\n\tif obj.keysUnescaped {\n\t\tt.Fatalf(\"expected keysUnescaped to be false after reset, got true\")\n\t}\n}","e7853b1995be2a7e0f2c932045cca477":"// This file is named `parse_value_test.go`\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput       string\n\t\texpectedVal *Value\n\t\texpectedTail string\n\t\texpectedErr  bool\n\t}{\n\t\t{\n\t\t\tinput:       \"\", // Test empty input\n\t\t\texpectedVal: nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"{}\", // Test an empty object\n\t\t\texpectedVal: \u0026Value{t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[]\", // Test an empty array\n\t\t\texpectedVal: \u0026Value{t: TypeArray},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"string\"`, // Test a raw string\n\t\t\texpectedVal: \u0026Value{t: typeRawString, s: \"string\"},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"true\", // Test boolean true\n\t\t\texpectedVal: valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"false\", // Test boolean false\n\t\t\texpectedVal: valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"null\", // Test null\n\t\t\texpectedVal: valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"123\", // Test a number\n\t\t\texpectedVal: \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"{invalid}\", // Test invalid object\n\t\t\texpectedVal: nil,\n\t\t\texpectedTail: \"{invalid}\",\n\t\t\texpectedErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[\" + string('x') + \"]\", // Test invalid array\n\t\t\texpectedVal: nil,\n\t\t\texpectedTail: \"[\" + string('x') + \"]\",\n\t\t\texpectedErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"tooDeep\", // Test invalid input for depth\n\t\t\texpectedVal: nil,\n\t\t\texpectedTail: \"tooDeep\",\n\t\t\texpectedErr:  true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tval, tail, err := parseValue(test.input, c, 0)\n\t\t\tif (err != nil) != test.expectedErr {\n\t\t\t\tt.Errorf(\"parseValue(%q) got err = %v, want err = %v\", test.input, err, test.expectedErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif val != test.expectedVal {\n\t\t\t\tt.Errorf(\"parseValue(%q) got val = %+v, want val = %+v\", test.input, val, test.expectedVal)\n\t\t\t}\n\t\t\tif tail != test.expectedTail {\n\t\t\t\tt.Errorf(\"parseValue(%q) got tail = %q, want tail = %q\", test.input, tail, test.expectedTail)\n\t\t\t}\n\t\t})\n\t}\n}","e83bb0b3a53e8c49660f6e11d35138f1":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput      string\n\t\texpected   *Value\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tinput:      `{}`,\n\t\t\texpected:   \u0026Value{t: TypeObject, o: Object{}},\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}}, {k: \"key2\", v: \u0026Value{s: \"2\", t: TypeNumber}}}}},\n\t\t\texpectedErr: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      `{\"key\":}`,\n\t\t\texpected:   nil,\n\t\t\texpectedErr: `missing ':' after object key`,\n\t\t},\n\t\t{\n\t\t\tinput:      `{\"key\": \"value\", \"key2\"}`,\n\t\t\texpected:   nil,\n\t\t\texpectedErr: `missing ',' after object value`,\n\t\t},\n\t\t{\n\t\t\tinput:      `{ \"missingValue\": }`,\n\t\t\texpected:   nil,\n\t\t\texpectedErr: `cannot find opening '\"\" for object key`,\n\t\t},\n\t\t{\n\t\t\tinput:      `{ \"key\": \"value\",  }`,\n\t\t\texpected:   nil,\n\t\t\texpectedErr: `missing ',' after object value`,\n\t\t},\n\t\t{\n\t\t\tinput:      `{ \"key\": { \"nestedKey\": \"nestedValue\" }}`,\n\t\t\texpected:   \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{{k: \"nestedKey\", v: \u0026Value{s: \"nestedValue\", t: TypeString}}}}}}}}}},\n\t\t\texpectedErr: \"\",\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\tfor _, test := range tests {\n\t\tresult, remaining, err := parseObject(test.input, c, 0)\n\n\t\tif err != nil \u0026\u0026 err.Error() != test.expectedErr {\n\t\t\tt.Errorf(\"expected error '%s', got '%s'\", test.expectedErr, err.Error())\n\t\t}\n\t\tif err == nil \u0026\u0026 test.expectedErr != \"\" {\n\t\t\tt.Errorf(\"expected error '%s', got none\", test.expectedErr)\n\t\t}\n\t\tif result != nil \u0026\u0026 !reflect.DeepEqual(result, test.expected) {\n\t\t\tt.Errorf(\"for input '%s', expected '%+v', got '%+v'\", test.input, test.expected, result)\n\t\t}\n\t}\n}","e897c35ec322a812216cfd3f5ff03ffd":"// File: getint_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   string\n\t\tkeys    []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid integer path\",\n\t\t\tinput:    `{\"number\": 42}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 42,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid zero path\",\n\t\t\tinput:    `{\"number\": 0}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type - string\",\n\t\t\tinput:    `{\"number\": \"notANumber\"}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type - array\",\n\t\t\tinput:    `{\"number\": [1, 2, 3]}`,\n\t\t\tkeys:     []string{\"number\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tinput:    `{}`,\n\t\t\tkeys:     []string{\"missing\"},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested object\",\n\t\t\tinput:    `{\"outer\": {\"inner\": 100}}`,\n\t\t\tkeys:     []string{\"outer\", \"inner\"},\n\t\t\texpected: 100,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tinput:    `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 20,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid array index\",\n\t\t\tinput:    `{\"array\": [10, 20, 30]}`,\n\t\t\tkeys:     []string{\"array\", \"invalid\"},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Assuming a function to parse JSON string to Value object exists\n\t\t\tv, err := ParseBytes([]byte(tt.input))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to parse JSON input: %v\", err)\n\t\t\t}\n  \n\t\t\tresult := v.GetInt(tt.keys...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %d, got %d\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","ea1af124e3f14fce95ff74dac77cb87e":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{\n\t\tkvs: make([]kv, 0),\n\t}\n\n\t// Test when kvs is initially empty\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Fatal(\"Expected non-nil kv, got nil\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Fatalf(\"Expected kvs length to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Test that the kv is properly initialized\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Fatalf(\"Expected kv to be initialized with empty k and nil v, got k: %s, v: %v\", kv1.k, kv1.v)\n\t}\n\n\t// Test the case when kvs is partially filled\n\tfor i := 0; i \u003c 5; i++ {\n\t\tobj.getKV()\n\t}\n\tif len(obj.kvs) != 6 {\n\t\tt.Fatalf(\"Expected kvs length to be 6, got %d\", len(obj.kvs))\n\t}\n\n\t// Further test the capacity behavior\n\toldCap := cap(obj.kvs)\n\tkv2 := obj.getKV()\n\tif len(obj.kvs) != 7 {\n\t\tt.Fatalf(\"Expected kvs length to be 7 after appending, got %d\", len(obj.kvs))\n\t}\n\tif cap(obj.kvs) != oldCap {\n\t\tt.Fatalf(\"Expected capacity to remain the same, got %d\", cap(obj.kvs))\n\t}\n\n\t// Test that the last kv is initialized\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Fatalf(\"Expected new kv to be initialized with empty k and nil v, got k: %s, v: %v\", kv2.k, kv2.v)\n\t}\n}","eb071f816583aa7cfc1e96a4582d81f2":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremaining string\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tinput:    \"42\",\n\t\t\texpected: \"42\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"-3.14\",\n\t\t\texpected: \"-3.14\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"2.71828\",\n\t\t\texpected: \"2.71828\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"3.0e10\",\n\t\t\texpected: \"3.0e10\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"inf\",\n\t\t\texpected: \"inf\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \"nan\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"invalidNumber\",\n\t\t\texpected: \"\",\n\t\t\tremaining: \"invalidNumber\",\n\t\t\terr:      fmt.Errorf(\"unexpected char: %q\", \"i\"),\n\t\t},\n\t\t{\n\t\t\tinput:    \"12invalid\",\n\t\t\texpected: \"12\",\n\t\t\tremaining: \"invalid\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \".5\",\n\t\t\texpected: \".5\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tinput:    \"-.75\",\n\t\t\texpected: \"-.75\",\n\t\t\tremaining: \"\",\n\t\t\terr:      nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, rem, err := parseRawNumber(test.input)\n\t\tif result != test.expected || rem != test.remaining || (err != nil \u0026\u0026 err.Error() != test.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); want (%q, %q, %v)\", \n\t\t\t\ttest.input, result, rem, err, test.expected, test.remaining, test.err)\n\t\t}\n\t}\n}","eb0bed6b248796ac2aa5e59b1e4f4066":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := test.input.String(); got != test.expected {\n\t\t\tt.Errorf(\"Type.String() = %v, want %v\", got, test.expected)\n\t\t}\n\t}\n\n\t// Testing a panic for an unknown type (Type typeRawString)\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Value type\")\n\t\t}\n\t}()\n\tvar unknownType Type = 7 // an invalid/unknown type\n\tunknownType.String()\n}","eb2f7a09786ed520e3c0026730fb8e56":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tvalue  *Value\n\t\texpected []byte\n\t}{\n\t\t// Test case for a raw string\n\t\t{\u0026Value{t: typeRawString, s: \"example\"}, []byte(`\"example\"`)},\n\n\t\t// Test case for an object\n\t\t{\u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t{k: \"key1\", v: \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t{k: \"key2\", v: \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t}}}, []byte(`{\"key1\":\"value1\",\"key2\":123}`)},\n\n\t\t// Test case for an array\n\t\t{\u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\u0026Value{t: TypeString, s: \"item1\"},\n\t\t\t\u0026Value{t: TypeTrue},\n\t\t\t\u0026Value{t: TypeFalse},\n\t\t}}, []byte(`[\"item1\",true,false]`)},\n\n\t\t// Test case for a boolean true\n\t\t{\u0026Value{t: TypeTrue}, []byte(`true`)},\n\n\t\t// Test case for a boolean false\n\t\t{\u0026Value{t: TypeFalse}, []byte(`false`)},\n\n\t\t// Test case for null\n\t\t{\u0026Value{t: TypeNull}, []byte(`null`)},\n\n\t\t// Test case for a number\n\t\t{\u0026Value{t: TypeNumber, s: \"42\"}, []byte(`42`)},\n\n\t\t// Test case for a complex JSON object\n\t\t{\u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t{k: \"array\", v: \u0026Value{t: TypeArray, a: []*Value{\n\t\t\t\t\u0026Value{t: TypeString, s: \"abc\"},\n\t\t\t\t\u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\t}}},\n\t\t\t{k: \"nested\", v: \u0026Value{t: TypeObject, o: Object{kvs: []kv{\n\t\t\t\t{k: \"innerKey\", v: \u0026Value{t: TypeString, s: \"innerValue\"}},\n\t\t\t}}}},\n\t\t}}}, []byte(`{\"array\":[\"abc\",123],\"nested\":{\"innerKey\":\"innerValue\"}}`)},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(string(test.expected), func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tresult := test.value.MarshalTo(dst)\n\t\t\tif string(result) != string(test.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","eb885289b7d2fd99a584dd8528e7a597":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedKey  string\n\t\texpectedRest string\n\t\texpectedErr  bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"hello\" world`,\n\t\t\texpectedKey:  \"hello\",\n\t\t\texpectedRest: \" world\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\"world\" more text`,\n\t\t\texpectedKey:  \"hello\\\"world\",\n\t\t\texpectedRest: \" more text\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\\\\\\\"world\" anything`,\n\t\t\texpectedKey:  \"hello\\\\\\\"world\",\n\t\t\texpectedRest: \" anything\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello`,\n\t\t\texpectedKey:  \"\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr:  true, // Missing closing quote\n\t\t},\n\t\t{\n\t\t\tinput:         `no quotes here`,\n\t\t\texpectedKey:  \"no quotes here\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"\"`,\n\t\t\texpectedKey:  \"\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"no escape here\" \"next\"`,\n\t\t\texpectedKey:  \"no escape here\",\n\t\t\texpectedRest: \" \\\"next\\\"\",\n\t\t\texpectedErr:  false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tkey, rest, err := parseRawString(test.input)\n\n\t\tif test.expectedErr {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Expected an error for input %q, but got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error for input %q: %v\", test.input, err)\n\t\t\t}\n\t\t\tif key != test.expectedKey {\n\t\t\t\tt.Errorf(\"For input %q, expected key %q, but got %q\", test.input, test.expectedKey, key)\n\t\t\t}\n\t\t\tif rest != test.expectedRest {\n\t\t\t\tt.Errorf(\"For input %q, expected rest %q, but got %q\", test.input, test.expectedRest, rest)\n\t\t\t}\n\t\t}\n\t}\n}","ebf2cbcce69e6375a3f5bae521ef8b70":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\tremains  string\n\t\terr      error\n\t}{\n\t\t{\"12345\", \"12345\", \"\", nil},\n\t\t{\"-123.45\", \"-123.45\", \"\", nil},\n\t\t{\"3.14e10\", \"3.14e10\", \"\", nil},\n\t\t{\"inf something\", \"inf\", \" something\", nil},\n\t\t{\"-inf\", \"-inf\", \"\", nil},\n\t\t{\"nan\", \"nan\", \"\", nil},\n\t\t{\"12.34abc\", \"12.34\", \"abc\", nil},\n\t\t{\"-12.34e+5xyz\", \"-12.34e+5\", \"xyz\", nil},\n\t\t{\"\", \"\", \"\", fmt.Errorf(\"unexpected char: %q\", \"\")},\n\t\t{\"abc123\", \"\", \"abc123\", fmt.Errorf(\"unexpected char: %q\", \"a\")},\n\t\t{\"123-abc\", \"123\", \"-abc\", nil},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot, remains, err := parseRawNumber(tt.input)\n\t\t\n\t\tif got != tt.expected || remains != tt.remains || (err != nil \u0026\u0026 err.Error() != tt.err.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = %q, %q, %v; want %q, %q, %v\",\n\t\t\t\ttt.input, got, remains, err, tt.expected, tt.remains, tt.err)\n\t\t}\n\t}\n}","ebf877e63e90ebbf0504c5ddb8afea58":"// parse_value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue *Value\n\t\texpectedTail  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\":\\\"value\\\"}\",\n\t\t\texpectedValue: /* expected Value for object */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedValue: /* expected Value for array */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"\\\"string\\\"\",\n\t\t\texpectedValue: /* expected Value for raw string */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"3.14\",\n\t\t\texpectedValue: /* expected Value for number */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": [1, 2, 3]\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": 1, \\\"value\\\": true}\",\n\t\t\texpectedValue: /* expected Value for object */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"unclosed string\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t// Add more test cases as needed to cover edge cases or requirements\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresultValue, tail, err := parseValue(tt.input, c, 0)\n\n\t\t\tif (err != nil) != tt.expectedError {\n\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t}\n\t\t\tif resultValue != tt.expectedValue {\n\t\t\t\tt.Errorf(\"expected value: %v, got: %v\", tt.expectedValue, resultValue)\n\t\t\t}\n\t\t\tif tail != tt.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail: %v, got: %v\", tt.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","ec026c231b0d836d21a262081a7a59a0":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetObject(t *testing.T) {\n\t// Prepare some test cases\n\ttests := []struct {\n\t\tjsonInput   string\n\t\tkeys        []string\n\t\texpected    *Object\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\tjsonInput:   `{\"key1\": {\"subkey1\": \"value1\"}}`,\n\t\t\tkeys:        []string{\"key1\"},\n\t\t\texpected:    \u0026Object{kvs: []kv{{k: \"subkey1\", v: \u0026Value{s: \"value1\", t: TypeString}}}},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tjsonInput:   `{\"key1\": \"not an object\"}`,\n\t\t\tkeys:        []string{\"key1\"},\n\t\t\texpected:    nil,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tjsonInput:   `{\"key1\": {\"subkey1\": \"value1\"}}`,\n\t\t\tkeys:        []string{\"key2\"},\n\t\t\texpected:    nil,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tjsonInput:   `{}`,\n\t\t\tkeys:        []string{\"key1\"},\n\t\t\texpected:    nil,\n\t\t\texpectError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Parse the JSON input\n\t\tv, err := Parse(test.jsonInput)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t}\n\n\t\t// Call GetObject\n\t\tgot := v.GetObject(test.keys...)\n\n\t\t// Check result\n\t\tif (got == nil) != (test.expected == nil) {\n\t\t\tt.Errorf(\"For input %s and keys %v: expected %v, got %v\", test.jsonInput, test.keys, test.expected, got)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Further checks can be added as needed for the contents of the Object\n\t\tif test.expected != nil {\n\t\t\t// Check if the actual object returned matches the expected\n\t\t\tif !compareObjects(got, test.expected) {\n\t\t\t\tt.Errorf(\"For input %s and keys %v: expected object not equal to got object\", test.jsonInput, test.keys)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// compareObjects is a utility function to compare two Object instances for equality.\n// You would need to implement this based on the structure of your Object.\nfunc compareObjects(a, b *Object) bool {\n\t// Implement comparison logic here\n\t// Compare lengths and key-value pairs\n\treturn true // Placeholder\n}","ecb9681ec50f26f5fdb26414aabd3121":"// unescape_string_best_effort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Plain string\", \"Plain string\"},\n\t\t{\"String with \\\"quotes\\\"\", \"String with \\\"quotes\\\"\"},\n\t\t{\"Escaped backslash: \\\\\\\\\", \"Escaped backslash: \\\\\"},\n\t\t{\"Newline: \\\\n\", \"Newline: \\n\"},\n\t\t{\"Tab: \\\\t\", \"Tab: \\t\"},\n\t\t{\"Form feed: \\\\f\", \"Form feed: \\f\"},\n\t\t{\"Carriage return: \\\\r\", \"Carriage return: \\r\"},\n\t\t{\"Backspace: \\\\b\", \"Backspace: \\b\"},\n\t\t{\"Forward slash: \\\\/\", \"Forward slash: /\"},\n\t\t{\"Unicode: \\\\u0041\", \"Unicode: A\"},\n\t\t{\"Invalid unicode: \\\\u00\", \"Invalid unicode: \\\\u00\"},\n\t\t{\"Surrogate pairs: \\\\uD83D\\\\uDE00\", \"Surrogate pairs: ðŸ˜€\"},\n\t\t{\"Escaped character: \\\\xF0\\\\x9F\\\\x98\\\\x80\", \"Escaped character: ðŸ˜€\"},\n\t\t{\"Nested escaped: \\\"\\\\\\\\nested\\\"\", \"\\\"\\\\nested\\\"\"},\n\t\t{\"Multiple escapes: \\\\n\\\\t\\\\r\\\\b\\\\f\", \"\\n\\t\\r\\b\\f\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","ed2bbe5d8b0addacee0007eb6c33fdd0":"// file: string_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTypeString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"},\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.expected, func(t *testing.T) {\n\t\t\tresult := tt.input.String()\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Test for panic on unknown Type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"expected panic for unknown Type\")\n\t\t}\n\t}()\n\n\t// Creating an unknown Type (which is out of the defined constants)\n\tvar unknownType Type = 100\n\t_ = unknownType.String()\n}","ed60335579948b7d973b557c9487f30f":"// File: value_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUint64(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected uint64\n\t\terr      bool\n\t}{\n\t\t{\"12345\", 12345, false},\n\t\t{\"0\", 0, false},\n\t\t{\"18446744073709551615\", 18446744073709551615, false}, // Max uint64\n\t\t{\"-1\", 0, true},                                         // Invalid case\n\t\t{\"abc\", 0, true},                                      // Invalid case\n\t}\n\n\tfor _, test := range tests {\n\t\tv := \u0026Value{s: test.input, t: TypeNumber} // Simulate the Value\n\n\t\tresult, err := v.Uint64()\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"For input %s, expected error: %v, got: %v\", test.input, test.err, err)\n\t\t}\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"For input %s, expected: %d, got: %d\", test.input, test.expected, result)\n\t\t}\n\t}\n}","ed7f1f9db9ebf8c730e6dec6ab9e2901":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected Value structure */ },\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": 123}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected Value structure */ },\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": true}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected Value structure */ },\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `[1, 2, 3]`,\n\t\t\texpected: \u0026Value{ /* Initialize expected Value structure */ },\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `invalid json`,\n\t\t\texpected: nil,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": null}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected Value structure */ },\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": [1, 2, 3]}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected Value structure */ },\n\t\t\twantErr:  false,\n\t\t},\n\t}\n\n\tp := \u0026Parser{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tgot, err := p.Parse(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr \u0026\u0026 !valuesEqual(got, tt.expected) {\n\t\t\t\tt.Errorf(\"Parse() = %v, want %v\", got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function to compare Value structs\nfunc valuesEqual(v1, v2 *Value) bool {\n\t// Implement the logic to compare the two Value instances.\n\treturn false // Replace with actual comparison logic\n}","edc73e729f5fb16c77ddb02f2d62c7f4":"// file: marshal_to_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname: \"Marshal raw string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"testString\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"testString\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\"}\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t{t: TypeNumber, s: \"2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: []byte(\"[1,2]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"Hello, World!\",\n\t\t\t},\n\t\t\texpected: []byte(\"\\\"Hello, World!\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNumber,\n\t\t\t\ts: \"123.456\",\n\t\t\t},\n\t\t\texpected: []byte(\"123.456\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Edge case - unexpected type\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: Type(100), // Invalid type for testing.\n\t\t\t},\n\t\t\texpected: nil, // We expect a panic here.\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.expected == nil {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected panic for value: %v\", tt.value)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tdst := make([]byte, 0)\n\t\t\tresult := tt.value.MarshalTo(dst)\n\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"Expected %s, got %s\", string(tt.expected), string(result))\n\t\t\t}\n\t\t})\n\t}\n}","ee281fd673e0e5921d985e16d66274ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"Hello, World!\", \"Hello, World!\"},\n\t\t{\"Hello\\\\nWorld\", \"Hello\\nWorld\"},\n\t\t{\"Quote: \\\\\\\"Hello\\\\\\\"!\", \"Quote: \\\"Hello\\\"!\"},\n\t\t{\"Backslash: \\\\\\\\\", \"Backslash: \\\\\"},\n\t\t{\"Forward slash: \\\\/\", \"Forward slash: /\"},\n\t\t{\"Tab:\\\\tEnd\", \"Tab:\\tEnd\"},\n\t\t{\"Invalid Unicode: \\\\uXYZZ\", \"Invalid Unicode: \\\\uXYZZ\"},\n\t\t{\"Incomplete Unicode: \\\\u123\", \"Incomplete Unicode: \\\\u123\"},\n\t\t{\"Surrogate Pair: \\\\uD83D\\\\uDE00\", \"Surrogate Pair: ðŸ˜„\"},\n\t\t{\"Normal string with backslash: \\\\\\\\B\", \"Normal string with backslash: \\\\B\"},\n\t\t{\"Multiple \\\\u escape sequences: \\\\u0041\\\\u0042\", \"Multiple \\\\u escape sequences: AB\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","efa4903c7248777618b60131d2acc577":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"no escape\", \"no escape\"},\n\t\t{\"escaped quote: \\\\\\\" \", \"escaped quote: \\\" \"},\n\t\t{\"newline\\\\nnewline\", \"newline\\nnewline\"},\n\t\t{\"tab:\\\\t tab\", \"tab:\\t tab\"},\n\t\t{\"backslash\\\\\\\\\", \"backslash\\\\\"},\n\t\t{\"unicode\\\\u0041\", \"unicodeA\"},\n\t\t{\"surrogate\\\\uD83D\\\\uDE00\", \"surrogateðŸ˜€\"},\n\t\t{\"invalid unicode\\\\uXYZ\", \"invalid unicode\\\\uXYZ\"},\n\t\t{\"partial unicode\\\\u123\", \"partial unicode\\\\u123\"},\n\t\t{\"mixed \\\\\\\"escaped\\\\\\\" and non-escaped\", \"mixed \\\"escaped\\\" and non-escaped\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; want %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f05845715af1ed66ea29327c8a4a23ec":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCache_GetValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\t// Initial state: ensure the cache starts empty\n\tif len(c.vs) != 0 {\n\t\tt.Fatalf(\"expected empty cache, got length %d\", len(c.vs))\n\t}\n\n\t// Call getValue multiple times\n\tfor i := 0; i \u003c 10; i++ {\n\t\tvalue := c.getValue()\n\t\tif value == nil {\n\t\t\tt.Fatal(\"expected non-nil value\")\n\t\t}\n\t}\n\n\t// Check if the cache has grown as expected\n\tif len(c.vs) != 10 {\n\t\tt.Fatalf(\"expected cache length to be 10, got %d\", len(c.vs))\n\t}\n\n\t// Check if the values are not reset\n\tfor i := range c.vs {\n\t\tif c.vs[i].o != (Object{}) || c.vs[i].a != nil || c.vs[i].s != \"\" || c.vs[i].t != TypeNull {\n\t\t\tt.Fatalf(\"value at index %d was reset when it shouldn't have been\", i)\n\t\t}\n\t}\n}","f0667afc84cf5da4eedaac8df46a195b":"// parse_object_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedError  string\n\t\texpectedResult *Value\n\t}{\n\t\t{\n\t\t\tinput:         `{}`,\n\t\t\texpectedError: \"\",\n\t\t\texpectedResult: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\":\"value1\", \"key2\":42}`,\n\t\t\texpectedError: \"\",\n\t\t\texpectedResult: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\":}`,\n\t\t\texpectedError: \"missing ':' after object key\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\":value}`,\n\t\t\texpectedError: \"cannot parse object value: unexpected end of object\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedError: \"missing ',' after object value\",\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedError: \"\",\n\t\t\texpectedResult: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tvar c cache\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tresult, _, err := parseObject(tt.input, \u0026c, 0)\n\t\t\tif tt.expectedError != \"\" {\n\t\t\t\tif err == nil || err.Error() != tt.expectedError {\n\t\t\t\t\tt.Errorf(\"expected error: %v, got: %v\", tt.expectedError, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\t// Use the appropriate method to compare the expectedResult with result\n\t\t\tif !compareValues(result, tt.expectedResult) {\n\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expectedResult, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// compareValues would be a helper function to compare two Value types, \n// you may need to implement this based on your Value struct.","f090bde8d09c3c16eb0203495d317a50":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname:     \"empty object\",\n\t\t\tinput:    \"{}\",\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{}}, // Expected empty object\n\t\t\terr:      nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"single key-value pair\",\n\t\t\tinput: `{\"key\":\"value\"}`,\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple key-value pairs\",\n\t\t\tinput: `{\"key1\":\"value1\", \"key2\":42}`,\n\t\t\texpected: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"42\", t: TypeNumber}}, // Assumed to handle numbers as strings in test\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname:  \"missing closing brace\",\n\t\t\tinput: `{\"key\":\"value\"`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing '}'\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"key without quoted string\",\n\t\t\tinput: `{key:value}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(`cannot find opening '\"\" for object key`),\n\t\t},\n\t\t{\n\t\t\tname:  \"missing colon\",\n\t\t\tinput: `{\"key\" \"value\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ':' after object key\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"missing comma\",\n\t\t\tinput: `{\"key1\":\"value1\" \"key2\":\"value2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"missing ',' after object value\"),\n\t\t},\n\t\t{\n\t\t\tname:  \"unexpected end of object\",\n\t\t\tinput: `{\"key1\":\"value1\", \"key2\":`,\n\t\t\texpected: nil,\n\t\t\terr:      fmt.Errorf(\"unexpected end of object\"),\n\t\t},\n\t}\n\n\tc := \u0026cache{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv, rem, err := parseObject(tt.input, c, 0)\n\t\t\tif err != nil \u0026\u0026 err.Error() != tt.err.Error() {\n\t\t\t\tt.Fatalf(\"expected error: %v, got: %v\", tt.err, err)\n\t\t\t}\n\t\t\tif v != nil {\n\t\t\t\t// Add additional checks if needed for the expected Value\n\t\t\t\tif !reflect.DeepEqual(v, tt.expected) {\n\t\t\t\t\tt.Errorf(\"expected: %+v, got: %+v\", tt.expected, v)\n\t\t\t\t}\n\t\t\t} else if tt.expected != nil {\n\t\t\t\tt.Errorf(\"expected value got nil\")\n\t\t\t}\n\t\t})\n\t}\n}","f131920ae34d0848f01ae4cda57a1695":"// fastjson_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Test case when kvs is empty\n\tkv1 := obj.getKV()\n\tif kv1.k != \"\" || kv1.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %+v\", kv1.k, kv1.v)\n\t}\n\n\t// Test case when kvs has a capacity and is half filled\n\tobj.kvs = make([]kv, 1)\n\tobj.kvs[0] = kv{\"key1\", nil}\n\tkv2 := obj.getKV()\n\tif kv2.k != \"\" || kv2.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %+v for second getKV\", kv2.k, kv2.v)\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected kvs length to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Test case when kvs is fully filled\n\tobj.kvs = make([]kv, 2)\n\tobj.kvs[0] = kv{\"key1\", nil}\n\tobj.kvs[1] = kv{\"key2\", nil}\n\tkv3 := obj.getKV()\n\tif kv3.k != \"\" || kv3.v != nil {\n\t\tt.Errorf(\"Expected empty kv, got k: %s, v: %+v for third getKV\", kv3.k, kv3.v)\n\t}\n\tif len(obj.kvs) != 3 {\n\t\tt.Errorf(\"Expected kvs length to be 3, got %d\", len(obj.kvs))\n\t}\n\n\t// Test case that ensures kvs is resized correctly\n\tfor i := 0; i \u003c 10; i++ {\n\t\tkv := obj.getKV()\n\t\tkv.k = \"key\" + string(i)\n\t\tobj.kvs = append(obj.kvs, *kv)\n\t}\n\n\tif len(obj.kvs) != 11 {\n\t\tt.Errorf(\"Expected kvs length to be 11 after multiple getKV calls, got %d\", len(obj.kvs))\n\t}\n}","f1d4a580fbdf8c143281df8713dc7b06":"// parseValue_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue *Value\n\t\texpectedTail  string\n\t\texpectedErr   error\n\t}{\n\t\t{\n\t\t\tinput:         \"\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   fmt.Errorf(\"cannot parse empty string\"),\n\t\t},\n\t\t{\n\t\t\tinput:         \"{}\",\n\t\t\texpectedValue: /* expected value for empty object */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[]\",\n\t\t\texpectedValue: /* expected value for empty array */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"hello\"`,\n\t\t\texpectedValue: /* expected value for string \"hello\" */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"true\",\n\t\t\texpectedValue: valueTrue,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"false\",\n\t\t\texpectedValue: valueFalse,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"null\",\n\t\t\texpectedValue: valueNull,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"123.45\",\n\t\t\texpectedValue: /* expected value for number 123.45 */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"invalid\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"invalid\",\n\t\t\texpectedErr:   fmt.Errorf(\"unexpected value found: %q\", \"invalid\"),\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": \\\"value\\\"}\",\n\t\t\texpectedValue: /* expected value for object with a key-value pair */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"key\\\": [1, 2, 3]}\",\n\t\t\texpectedValue: /* expected value for object with an array */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\\\"nested\\\": {\\\"key\\\": \\\"value\\\"}}\",\n\t\t\texpectedValue: /* expected value for nested object */,\n\t\t\texpectedTail:  \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"{\",\n\t\t\texpectedValue: nil,\n\t\t\texpectedTail:  \"{\",\n\t\t\texpectedErr:   fmt.Errorf(\"cannot parse object: %s\", \"unexpected end of JSON input\"),\n\t\t},\n\t\t// Add more test cases as needed\n\t}\n\n\tc := \u0026cache{}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tvalue, tail, err := parseValue(tt.input, c, 0)\n\t\t\tif value != tt.expectedValue || tail != tt.expectedTail || (err != nil \u0026\u0026 err.Error() != tt.expectedErr.Error()) {\n\t\t\t\tt.Errorf(\"parseValue(%q) = (%v, %q, %v), want (%v, %q, %v)\", tt.input, value, tail, err, tt.expectedValue, tt.expectedTail, tt.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}","f1fe434c7c5c4eee4f1b5f499d63ef52":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\texpectedErr string\n\t}{\n\t\t// Test empty string\n\t\t{\"\", nil, \"cannot parse empty string\"},\n\n\t\t// Test valid object\n\t\t{\"{}\", \u0026Value{t: TypeObject}, \"\"},\n\n\t\t// Test valid array\n\t\t{\"[]\", \u0026Value{t: TypeArray}, \"\"},\n\n\t\t// Test valid string\n\t\t{\"\\\"hello\\\"\", \u0026Value{s: \"hello\", t: typeRawString}, \"\"},\n\n\t\t// Test true boolean\n\t\t{\"true\", valueTrue, \"\"},\n\n\t\t// Test false boolean\n\t\t{\"false\", valueFalse, \"\"},\n\n\t\t// Test null value\n\t\t{\"null\", valueNull, \"\"},\n\n\t\t// Test invalid JSON (unexpected value)\n\t\t{\"unexpected\", nil, \"unexpected value found: \\\"unexpected\\\"\"},\n\n\t\t// Test deeply nested structure\n\t\t{\"{{}}\", \u0026Value{t: TypeObject}, \"\"},\n\t\t{\"{}}\", nil, \"unexpected value found: \\\"}\\\"\"},\n\t\t\n\t\t// Test depth exceeded\n\t\t{\"{}}\", nil, \"too big depth for the nested JSON; it exceeds 100\"},  // Assuming MaxDepth is 100\n\t}\n\n\tfor _, test := range tests {\n\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\tif (err != nil) != (test.expectedErr != \"\") {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, expectedErr %q\", test.input, err, test.expectedErr)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil \u0026\u0026 err.Error() != test.expectedErr {\n\t\t\tt.Errorf(\"parseValue(%q) error = %v, expectedErr %q\", test.input, err, test.expectedErr)\n\t\t}\n\n\t\tif v != nil \u0026\u0026 v.t != test.expected.t {\n\t\t\tt.Errorf(\"parseValue(%q) = %v, want %v\", test.input, v, test.expected)\n\t\t}\n\t}\n}","f23543cc8a2f20450756636e16c7ac84":"// object_test.go\n\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Initial call to getKV should create the first kv element\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected kv not to be nil, got nil\")\n\t}\n\tif len(obj.kvs) != 1 {\n\t\tt.Errorf(\"Expected length of kvs to be 1, got %d\", len(obj.kvs))\n\t}\n\n\t// Second call to getKV should create the second kv element\n\tkv2 := obj.getKV()\n\tif kv2 == nil {\n\t\tt.Errorf(\"Expected kv not to be nil, got nil\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of kvs to be 2, got %d\", len(obj.kvs))\n\t}\n\n\t// Check if the kv elements are distinct\n\tif kv1 == kv2 {\n\t\tt.Errorf(\"Expected kv1 and kv2 to be distinct, got the same reference\")\n\t}\n\n\t// Fill existing capacity and test append\n\tobj.kvs = make([]kv, 1)\n\tkv3 := obj.getKV()\n\tif kv3 == nil {\n\t\tt.Errorf(\"Expected kv not to be nil, got nil\")\n\t}\n\tif len(obj.kvs) != 2 {\n\t\tt.Errorf(\"Expected length of kvs to still be 2 after second call, got %d\", len(obj.kvs))\n\t}\n\n\t// Validate capacity increment and allocation works as expected\n\tif cap(obj.kvs) \u003c= len(obj.kvs) {\n\t\tt.Errorf(\"Expected capacity of kvs to be greater than length, got capacity: %d, length: %d\", cap(obj.kvs), len(obj.kvs))\n\t}\n}","f42b808694ac056f3434ca48d3a97f42":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue *Value\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedValue: \u0026Value{ // expectedValue to be constructed based on your implementation's requirements\n\t\t\t\t// Fill in expected Value object initialization based on the parsed input\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{}`,\n\t\t\texpectedValue: \u0026Value{ // In this case, an empty object.\n\t\t\t\to: Object{},\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedValue: nil,\n\t\t\texpectedError: true, // Error due to missing value after key2\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpectedValue: nil,\n\t\t\texpectedError: true, // Error due to missing colon after key2\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedValue: nil,\n\t\t\texpectedError: true, // Error due to trailing comma\n\t\t},\n\t\t{\n\t\t\tinput:         `{ \"key1\": 123, \"key2\": true, \"key3\": null }`,\n\t\t\texpectedValue: \u0026Value{ // Fill in the expected Value after parsing integers, booleans, and null\n\t\t\t\t// Construct Value object based on integer, boolean, and null handling requirements\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": {\"key3\": \"value3\"}}`,\n\t\t\texpectedValue: \u0026Value{ // Expected nested object\n\t\t\t\t// Fill in expected Value object initialization based on the nested parsed input\n\t\t\t},\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{}\n\t\tdepth := 0\n\t\tvalue, remainder, err := parseObject(test.input, c, depth)\n\t\t\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Fatalf(\"Expected error status %v, got %v: %v\", test.expectedError, err != nil, err)\n\t\t}\n\t\t\n\t\t// Further validation can be performed on 'value' and remainder hereif no error expected\n\t\tif !test.expectedError \u0026\u0026 value == nil {\n\t\t\tt.Fatal(\"Expected non-nil value for valid input\")\n\t\t}\n\t\t\n\t\t// Optionally add comparison of expectedValue and value based on your Value struct's equality logic.\n\t}\n}","f43be1abf4b1b32657a9009cca3aa5f7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t\trest     string\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    `\"hello\" world`,\n\t\t\texpected: \"hello\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello\\\\\" world`,\n\t\t\texpected: \"hello\\\\\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello \\\\\" world`,\n\t\t\texpected: \"hello \\\\\",\n\t\t\trest:     \" world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello \"world`,\n\t\t\texpected: \"hello \",\n\t\t\trest:     \"world\",\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"hello \\\\\" world\"`,\n\t\t\texpected: \"hello \\\\\",\n\t\t\trest:     ` world\"`,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"missing closing quote`,\n\t\t\texpected: \"\",\n\t\t\trest:     \"\",\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"escaped quote \\\\\"this is not escaped quote\"`,\n\t\t\texpected: `escaped quote \\`,\n\t\t\trest:     `this is not escaped quote\"`,\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot, rest, err := parseRawString(test.input)\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"parseRawString(%q) unexpected error: %v\", test.input, err)\n\t\t}\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, got, test.expected)\n\t\t}\n\t\tif rest != test.rest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.rest)\n\t\t}\n\t}\n}","f4bcb92947eb553e92ce8b89aba331e3":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"hello\", \"hello\"},\n\t\t{\"hello\\\\nworld\", \"hello\\nworld\"},\n\t\t{\"hello\\\\tworld\", \"hello\\tworld\"},\n\t\t{\"test\\\\\\\"quote\\\"\", \"test\\\"quote\"},\n\t\t{\"backslash\\\\\\\\\", \"backslash\\\\\"},\n\t\t{\"unicode\\\\u0041\", \"unicodeA\"},\n\t\t{\"surrogate\\\\uD83D\\\\uDE00\", \"surrogateðŸ˜€\"},\n\t\t{\"invalid\\\\uXYZ\", \"invalid\\\\uXYZ\"},\n\t\t{\"valid\\\\uD83D\\\\uDE00missing\", \"validðŸ˜€missing\"},\n\t\t{\"no_escape_sequences_here\", \"no_escape_sequences_here\"},\n\t\t{\"mixed\\\\u0041and\\\\t other chars\", \"mixedAand\\t other chars\"},\n\t\t{\"escape a backslash: \\\\\\\\\", \"escape a backslash: \\\\\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f4ec22d1a5a18bc89b39a41074f20a98":"// parse_raw_number_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRest   string\n\t\texpectedError  bool\n\t}{\n\t\t{\"12345\", \"12345\", \"\", false},\n\t\t{\"-123.45e+6\", \"-123.45e+6\", \"\", false},\n\t\t{\"3.14159 and some text\", \"3.14159\", \" and some text\", false},\n\t\t{\"inf\", \"inf\", \"\", false},\n\t\t{\"nan\", \"nan\", \"\", false},\n\t\t{\"-inf and more text\", \"-inf\", \" and more text\", false},\n\t\t{\"-xyz\", \"\", \"-xyz\", true}, // unexpected character\n\t\t{\"abc\", \"\", \"abc\", true},    // unexpected character\n\t\t{\"\", \"\", \"\", true},           // empty input\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, rest, err := parseRawNumber(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected error: %v, got: %v\", test.input, test.expectedError, err != nil)\n\t\t}\n\t\tif number != test.expectedNumber {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected number: %q, got: %q\", test.input, test.expectedNumber, number)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawNumber(%q) expected rest: %q, got: %q\", test.input, test.expectedRest, rest)\n\t\t}\n\t}\n}","f507afd9a2e710907103163f30938768":"// unescape_string_besteffort_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `\"Hello, \\\"World\\\"!\"`,\n\t\t\texpected: \"Hello, \\\"World\\\"!\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Backslash: \\\\\"`,\n\t\t\texpected: \"Backslash: \\\\\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Newline:\\nTest\"`,\n\t\t\texpected: \"Newline:\\nTest\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Tab:\\tTest\"`,\n\t\t\texpected: \"Tab:\\tTest\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Form Feed:\\f\"`,\n\t\t\texpected: \"Form Feed:\\f\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Carriage Return:\\r\"`,\n\t\t\texpected: \"Carriage Return:\\r\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Unicode:\\u0041\"`, // Represents 'A'\n\t\t\texpected: \"Unicode:A\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Invalid Unicode:\\uXYZ\"`,\n\t\t\texpected: \"Invalid Unicode:\\\\uXYZ\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Surrogate Pair:\\uD83D\\uDE00\"`, // Represents ðŸ˜€\n\t\t\texpected: \"Surrogate Pair:ðŸ˜€\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"\"`, // Empty string\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:    `\"Mixed: \\n\\t\\u003A\"`, // Represents ':'\n\t\t\texpected: \"Mixed: \\n\\t:\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := unescapeStringBestEffort(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","f52a9ba437685c8435afc8b5272bb656":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tjson     string\n\t\tkeys     []string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"valid int\",\n\t\t\tjson:     `{\"key\": 123}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 123,\n\t\t},\n\t\t{\n\t\t\tname:     \"non-existing key\",\n\t\t\tjson:     `{\"key\": 123}`,\n\t\t\tkeys:     []string{\"non_existing_key\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"invalid type (string)\",\n\t\t\tjson:     `{\"key\": \"not_a_number\"}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tname:     \"negative int\",\n\t\t\tjson:     `{\"key\": -42}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: -42,\n\t\t},\n\t\t{\n\t\t\tname:     \"decimal number represented as int\",\n\t\t\tjson:     `{\"key\": 45.67}`,\n\t\t\tkeys:     []string{\"key\"},\n\t\t\texpected: 45,\n\t\t},\n\t\t{\n\t\t\tname:     \"array index\",\n\t\t\tjson:     `{\"array\": [100, 200, 300]}`,\n\t\t\tkeys:     []string{\"array\", \"1\"},\n\t\t\texpected: 200,\n\t\t},\n\t\t{\n\t\t\tname:     \"valid decimal index\",\n\t\t\tjson:     `{\"array\": [100, 200, 300]}`,\n\t\t\tkeys:     []string{\"array\", \"2\"},\n\t\t\texpected: 300,\n\t\t},\n\t\t{\n\t\t\tname:     \"out of bounds array index\",\n\t\t\tjson:     `{\"array\": [100, 200]}`,\n\t\t\tkeys:     []string{\"array\", \"5\"},\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvalue := \u0026Value{}\n\t\t\tif err := value.Parse(tt.json); err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t\t}\n\t\t\tgot := value.GetInt(tt.keys...)\n\t\t\tif got != tt.expected {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %v; want %v\", tt.keys, got, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","f583068e21b7ee06f424a489cd2eb93d":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *Value\n\t\texpectedTail string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tinput:       \"\",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"true\",\n\t\t\texpected:    valueTrue,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"false\",\n\t\t\texpected:    valueFalse,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"null\",\n\t\t\texpected:    valueNull,\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"hello\"`,\n\t\t\texpected:    \u0026Value{s: \"hello\", t: TypeString},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"[1, 2, 3]\",\n\t\t\texpected:    \u0026Value{a: []*Value{{s: \"1\", t: TypeNumber}, {s: \"2\", t: TypeNumber}, {s: \"3\", t: TypeNumber}}, t: TypeArray},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `{\"key\": \"value\"}`,\n\t\t\texpected:    \u0026Value{o: Object{kvs: []kv{{k: \"key\", v: \u0026Value{s: \"value\", t: TypeString}}}}, t: TypeObject},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"1.23\",\n\t\t\texpected:    \u0026Value{s: \"1.23\", t: TypeNumber},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       `\"unescaped string\"`,\n\t\t\texpected:    \u0026Value{s: \"unescaped string\", t: TypeString},\n\t\t\texpectedTail: \"\",\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"    \",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"    \",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"aaaa\", // Invalid JSON\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"aaaa\",\n\t\t\texpectedErr: true,\n\t\t},\n\t\t{\n\t\t\tinput:       \"{invalid json}\",\n\t\t\texpected:    nil,\n\t\t\texpectedTail: \"invalid json}\",\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tv, tail, err := parseValue(test.input, c, 0)\n\n\t\t\tif (err != nil) != test.expectedErr {\n\t\t\t\tt.Errorf(\"unexpected error result: %v, expected error: %v\", err, test.expectedErr)\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\tif v == nil \u0026\u0026 test.expected != nil {\n\t\t\t\t\tt.Errorf(\"expected value but got nil\")\n\t\t\t\t} else if v != nil \u0026\u0026 test.expected == nil {\n\t\t\t\t\tt.Errorf(\"expected nil but got value\")\n\t\t\t\t} else if v != nil \u0026\u0026 test.expected != nil {\n\t\t\t\t\t// You might want to check the content of 'v' against 'test.expected'.\n\t\t\t\t\t// It's a straightforward check for demonstration purposes.\n\t\t\t\t\tif v.s != test.expected.s || v.t != test.expected.t {\n\t\t\t\t\t\tt.Errorf(\"expected value %v but got %v\", test.expected, v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tail != test.expectedTail {\n\t\t\t\tt.Errorf(\"expected tail %q but got %q\", test.expectedTail, tail)\n\t\t\t}\n\t\t})\n\t}\n}","f59ee05c8531a20d9be7e8f6127935d7":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestUnescapeStringBestEffort(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"plain text\", \"plain text\"},\n\t\t{\"\\\\nnew line\", \"\\nnew line\"},\n\t\t{\"hello\\\\tworld\", \"hello\\tworld\"},\n\t\t{\"escaped \\\\\\\"quote\\\\\\\"\", \"escaped \\\"quote\\\"\"},\n\t\t{\"backslash\\\\\\\\\", \"backslash\\\\\"},\n\t\t{\"unicode \\\\u0041\", \"unicode A\"},\n\t\t{\"invalid \\\\u004Z\", \"invalid \\\\u004Z\"},\n\t\t{\"surrogate \\\\uD83D\\\\uDE00\", \"surrogate ðŸ˜€\"},\n\t\t{\"mixed \\\\u0041\\\\b\\\\t\\\\n\", \"mixed A\\b\\t\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := unescapeStringBestEffort(test.input)\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"unescapeStringBestEffort(%q) = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n}","f5e0639406a7ac149ef59ce46b9fd877":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\n// TestGetKV tests the getKV function of the Object type.\nfunc TestGetKV(t *testing.T) {\n\tobj := \u0026Object{}\n\n\t// Call getKV and check the returned kv\n\tkv1 := obj.getKV()\n\tif kv1 == nil {\n\t\tt.Errorf(\"Expected kv to be initialized, but got nil\")\n\t}\n\n\t// Check the initial state of the kv\n\tif kv1.k != \"\" {\n\t\tt.Errorf(\"Expected key to be empty, but got '%s'\", kv1.k)\n\t}\n\tif kv1.v != nil {\n\t\tt.Errorf(\"Expected value to be nil, but got '%v'\", kv1.v)\n\t}\n\n\t// Call getKV again to test the append behavior\n\tkv2 := obj.getKV()\n\n\t// Check that kv2 references the same object\n\tif kv1 != kv2 {\n\t\tt.Errorf(\"Expected kv1 and kv2 to be the same reference, but they are different\")\n\t}\n\n\t// Modify the kv\n\tkv2.k = \"testKey\"\n\tkv2.v = \u0026Value{} // assuming Value is a struct that can be instantiated\n\n\t// Ensure that the modification reflects back on kv1\n\tif kv1.k != \"testKey\" {\n\t\tt.Errorf(\"Expected kv1.k to be 'testKey', but got '%s'\", kv1.k)\n\t}\n\tif kv1.v == nil {\n\t\tt.Errorf(\"Expected kv1.v to not be nil, but got nil\")\n\t}\n}","f61bfa80baef78dd9ee3035bba841ed5":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\t   Hello\", \"Hello\"},\n\t\t{\"\\r\\n  Test\", \"Test\"},\n\t\t{\"   \", \"\"},\n\t\t{\"NoLeadingSpaces\", \"NoLeadingSpaces\"},\n\t\t{\"\\t   \\n   \\r\", \"\"},\n\t\t{\"  Multiple   Spaces  \", \"Multiple   Spaces  \"},\n\t\t{\"\\t\\t\\t\\tTabbed Text\", \"Tabbed Text\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tactual := skipWSSlow(test.input)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"skipWSSlow(%q) = %q; expected %q\", test.input, actual, test.expected)\n\t\t}\n\t}\n}","f625b903fe1f87df3db897c6edb4f6ae":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\tdst      []byte\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tname:     \"TestNull\",\n\t\t\tvalue:    \u0026Value{t: TypeNull},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"null\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TestTrue\",\n\t\t\tvalue:    \u0026Value{t: TypeTrue},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"true\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TestFalse\",\n\t\t\tvalue:    \u0026Value{t: TypeFalse},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"false\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TestNumber\",\n\t\t\tvalue:    \u0026Value{t: TypeNumber, s: \"123\"},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"123\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TestString\",\n\t\t\tvalue:    \u0026Value{t: TypeString, s: \"hello\"},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"\\\"hello\\\"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"TestArray\",\n\t\t\tvalue:    \u0026Value{t: TypeArray, a: []*Value{\u0026Value{t: TypeNumber, s: \"1\"}, \u0026Value{t: TypeNumber, s: \"2\"}}},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"[1,2]\"),\n\t\t},\n\t\t{\n\t\t\tname: \"TestObject\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{\"key1\", \u0026Value{t: TypeString, s: \"value1\"}},\n\t\t\t\t\t\t{\"key2\", \u0026Value{t: TypeNumber, s: \"123\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdst:      []byte{},\n\t\t\texpected: []byte(\"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":123}\"),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := tt.value.MarshalTo(tt.dst)\n\t\t\tif string(result) != string(tt.expected) {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","f6f799d652f95548df1454b0da524481":"package fastjson\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedOutput string\n\t\texpectedRest   string\n\t\texpectedErr    error\n\t}{\n\t\t{\n\t\t\tinput:          `\"test\" more data`,\n\t\t\texpectedOutput: \"test\",\n\t\t\texpectedRest:   \" more data\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"escaped \\\" quote\" rest`,\n\t\t\texpectedOutput: \"escaped \\\" quote\",\n\t\t\texpectedRest:   \" rest\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"unclosed string`,\n\t\t\texpectedOutput: \"\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedErr:    errors.New(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:          `\"complex \\\\\" escape \" sequence\" more text`,\n\t\t\texpectedOutput: \"complex \\\\ escape \",\n\t\t\texpectedRest:   \" sequence\" + \" more text\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `\"double \\\\\"escaped\\\\\" quotes\"`,\n\t\t\texpectedOutput: \"double \\\\escaped\\\\ quotes\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t\t{\n\t\t\tinput:          `no quotes`,\n\t\t\texpectedOutput: \"no quotes\",\n\t\t\texpectedRest:   \"\",\n\t\t\texpectedErr:    nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput, rest, err := parseRawString(test.input)\n\n\t\tif output != test.expectedOutput {\n\t\t\tt.Errorf(\"For input %q, expected output %q, got %q\", test.input, test.expectedOutput, output)\n\t\t}\n\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"For input %q, expected rest %q, got %q\", test.input, test.expectedRest, rest)\n\t\t}\n\n\t\tif (err != nil) != (test.expectedErr != nil) || (err != nil \u0026\u0026 err.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"For input %q, expected error %v, got %v\", test.input, test.expectedErr, err)\n\t\t}\n\t}\n}","f7174365718278f6c246af3c02df800c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected *Value\n\t\texpectErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Valid JSON object\",\n\t\t\tinput: `{\"key1\": \"value1\", \"key2\": 2}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected output here */ },\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid JSON array\",\n\t\t\tinput: `[1, 2, 3, 4]`,\n\t\t\texpected: \u0026Value{ /* Initialize expected output here */ },\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid JSON\",\n\t\t\tinput: `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Empty JSON\",\n\t\t\tinput: `{}`,\n\t\t\texpected: \u0026Value{ /* Initialize expected output here */ },\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid JSON format\",\n\t\t\tinput: `[1, 2, 3, \"invalid JSON`,\n\t\t\texpected: nil,\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tparser := \u0026Parser{}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\toutput, err := parser.Parse(tt.input)\n\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Parse() error = %v, wantErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.expectErr \u0026\u0026 output != nil {\n\t\t\t\t// Compare output to expected. You would need to implement\n\t\t\t\t// a comparison logic for *Value\n\t\t\t\t// if !reflect.DeepEqual(output, tt.expected) {\n\t\t\t\t//     t.Errorf(\"Parse() = %v, want %v\", output, tt.expected)\n\t\t\t\t// }\n\t\t\t}\n\t\t})\n\t}\n}","f7c57cc5d4987c63433126e4c45ef159":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSkipWSSlow(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"   Hello, World!\", \"Hello, World!\"},\n\t\t{\"\\n\\n   Go Lang\", \"Go Lang\"},\n\t\t{\"\\t\\tWhitespace\", \"Whitespace\"},\n\t\t{\"   \\r\\n   Sample Text\", \"Sample Text\"},\n\t\t{\"NoWhitespace\", \"NoWhitespace\"},\n\t\t{\"   \", \"\"},\n\t\t{\"\\n\", \"\"},\n\t\t{\"\\t\", \"\"},\n\t\t{\"\\r\", \"\"},\n\t\t{\"\", \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tresult := skipWSSlow(test.input)\n\t\t\tif result != test.expected {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}","f8928951972e02af89edabbec7377750":"// int_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_Int(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tvalueStr    string\n\t\texpectedInt int\n\t\texpectErr   bool\n\t}{\n\t\t{\n\t\t\tname:         \"valid int\",\n\t\t\tvalueStr:    \"42\",\n\t\t\texpectedInt: 42,\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid negative int\",\n\t\t\tvalueStr:    \"-42\",\n\t\t\texpectedInt: -42,\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid int at limit\",\n\t\t\tvalueStr:    \"2147483647\",\n\t\t\texpectedInt: 2147483647,\n\t\t\texpectErr:   false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid int over limit\",\n\t\t\tvalueStr:    \"2147483648\",\n\t\t\texpectedInt: 0, // since it cannot fit in int, we expect specific error handling\n\t\t\texpectErr:   true,\n\t\t},\n\t\t{\n\t\t\tname:         \"not a number\",\n\t\t\tvalueStr:    `\"not a number\"`,\n\t\t\texpectedInt: 0,\n\t\t\texpectErr:   true,\n\t\t},\n\t\t{\n\t\t\tname:         \"null value\",\n\t\t\tvalueStr:    \"null\",\n\t\t\texpectedInt: 0,\n\t\t\texpectErr:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tv := \u0026Value{s: tt.valueStr, t: TypeNumber} // Simulating the Value structure\n\t\t\tresult, err := v.Int()\n\t\t\tif (err != nil) != tt.expectErr {\n\t\t\t\tt.Errorf(\"Int() error = %v, expectErr %v\", err, tt.expectErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif result != tt.expectedInt {\n\t\t\t\tt.Errorf(\"Int() = %v, expected %v\", result, tt.expectedInt)\n\t\t\t}\n\t\t})\n\t}\n}","f8da9bdf20008c2b106a9e69d349e4ba":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput        string\n\t\texpectedStr string\n\t\texpectedRemainder string\n\t\texpectedErr   error\n\t}{\n\t\t{\n\t\t\tinput:        `\"hello\" world`,\n\t\t\texpectedStr: \"hello\",\n\t\t\texpectedRemainder: \" world\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"hello\\\\\" world\"`,\n\t\t\texpectedStr: \"hello\\\\\",\n\t\t\texpectedRemainder: \" world\\\"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"hello\"world`,\n\t\t\texpectedStr: \"hello\",\n\t\t\texpectedRemainder: \"world\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"hello\\world\"`,\n\t\t\texpectedStr: \"hello\\\\world\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"hello\"\"world\"`,\n\t\t\texpectedStr: \"hello\",\n\t\t\texpectedRemainder: \"\\\"world\\\"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"hello\\\\\\\"world\"`,\n\t\t\texpectedStr: \"hello\\\\\\\"\",\n\t\t\texpectedRemainder: \"world\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t\t{\n\t\t\tinput:        `\"missing closing quote`,\n\t\t\texpectedStr: \"\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:   fmt.Errorf(`missing closing '\"'`),\n\t\t},\n\t\t{\n\t\t\tinput:        `\"escaped\\\"quote\\\" here\"`,\n\t\t\texpectedStr: \"escaped\\\"quote\\\" here\",\n\t\t\texpectedRemainder: \"\",\n\t\t\texpectedErr:   nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresultStr, resultRemainder, resultErr := parseRawString(test.input)\n\n\t\tif resultStr != test.expectedStr || resultRemainder != test.expectedRemainder || (resultErr != nil \u0026\u0026 resultErr.Error() != test.expectedErr.Error()) {\n\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, resultStr, resultRemainder, resultErr, test.expectedStr, test.expectedRemainder, test.expectedErr)\n\t\t}\n\t}\n}","f95819b73bedc0740878a7252e4ef62b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestType_String(t *testing.T) {\n\ttests := []struct {\n\t\tinput    Type\n\t\texpected string\n\t}{\n\t\t{TypeObject, \"object\"},\n\t\t{TypeArray, \"array\"},\n\t\t{TypeString, \"string\"},\n\t\t{TypeNumber, \"number\"}, // You didn't provide a return for TypeNumber, modify if necessary\n\t\t{TypeTrue, \"true\"},\n\t\t{TypeFalse, \"false\"},\n\t\t{TypeNull, \"null\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := test.input.String()\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"Type(%d).String() = %q; expected %q\", test.input, result, test.expected)\n\t\t}\n\t}\n\n\t// Check for panic on unknown type\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"Expected panic for unknown Type, but did not get one.\")\n\t\t}\n\t}()\n\n\tvar unknownType Type = 100 // An intentionally invalid value\n\tunknownType.String()\n}","f9747230c68e23c0a3a3fc2165b2b8a6":"// marshal_to_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    *Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal Raw String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: typeRawString,\n\t\t\t\ts: \"example\",\n\t\t\t},\n\t\t\texpected: `\"example\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Object\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{kvs: []kv{{k: \"key\", v: \u0026Value{t: TypeString, s: \"value\"}}}},\n\t\t\t},\n\t\t\texpected: `{\"key\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Array\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeArray,\n\t\t\t\ta: []*Value{\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"1\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"2\"},\n\t\t\t\t\t\u0026Value{t: TypeNumber, s: \"3\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `[1,2,3]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal String\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeString,\n\t\t\t\ts: \"hello\",\n\t\t\t},\n\t\t\texpected: `\"hello\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal True\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: `true`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal False\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: `false`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Null\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: `null`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal Nested Structure\",\n\t\t\tvalue: \u0026Value{\n\t\t\t\tt: TypeObject,\n\t\t\t\to: Object{kvs: []kv{\n\t\t\t\t\t{k: \"name\", v: \u0026Value{t: TypeString, s: \"Alice\"}},\n\t\t\t\t\t{k: \"age\", v: \u0026Value{t: TypeNumber, s: \"30\"}},\n\t\t\t\t\t{k: \"friends\", v: \u0026Value{\n\t\t\t\t\t\tt: TypeArray,\n\t\t\t\t\t\ta: []*Value{\n\t\t\t\t\t\t\t{t: TypeString, s: \"Bob\"},\n\t\t\t\t\t\t\t{t: TypeString, s: \"Charlie\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t},\n\t\t\texpected: `{\"name\":\"Alice\",\"age\":30,\"friends\":[\"Bob\",\"Charlie\"]}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.value.MarshalTo(nil)\n\t\t\tif string(got) != tt.expected {\n\t\t\t\tt.Errorf(\"expected %s, got %s\", tt.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}","f981bfe9171513de09c0681357443d27":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput         string\n\t\texpectedValue string\n\t\texpectedRest  string\n\t\texpectedError bool\n\t}{\n\t\t{\n\t\t\tinput:         `\"Hello, World!\"`,\n\t\t\texpectedValue: \"Hello, World!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Hello, \\\"World\\\"!\"`,\n\t\t\texpectedValue: \"Hello, \\\"World\\\"!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Hello, World!`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Hello, \\\\\"World\\\\!\"`,\n\t\t\texpectedValue: \"Hello, \\\\\\\"World\\\\!\",\n\t\t\texpectedRest:  \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `\"Escaped \\\\\"String\\\\\" Here\" some more text`,\n\t\t\texpectedValue: \"Escaped \\\\\\\"String\\\\\\\" Here\",\n\t\t\texpectedRest:  \" some more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput: `\"No closing quote`,\n\t\t\texpectedValue: \"\",\n\t\t\texpectedRest: \"\",\n\t\t\texpectedError: true,\n\t\t},\n\t\t{\n\t\t\tinput: `\"Mixed \\\\\\\"escaped\\\\\\\" and normal\" followed by more text`,\n\t\t\texpectedValue: \"Mixed \\\\\\\"escaped\\\\\\\" and normal\",\n\t\t\texpectedRest: \" followed by more text\",\n\t\t\texpectedError: false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, rest, err := parseRawString(test.input)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseRawString(%q) unexpected error status: %v\", test.input, err)\n\t\t}\n\t\tif value != test.expectedValue {\n\t\t\tt.Errorf(\"parseRawString(%q) = %q, want %q\", test.input, value, test.expectedValue)\n\t\t}\n\t\tif rest != test.expectedRest {\n\t\t\tt.Errorf(\"parseRawString(%q) rest = %q, want %q\", test.input, rest, test.expectedRest)\n\t\t}\n\t}\n}","fa1f625cfa6f647e389ef8b2e4a2b0f7":"package fastjson\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedKey   string\n\t\texpectedValue  string\n\t\texpectedError  bool\n\t}{\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\"}`,\n\t\t\texpectedKey:   \"key1\",\n\t\t\texpectedValue: \"value1\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpectedKey:   \"key1\",\n\t\t\texpectedValue: \"value1\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{} `,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedValue: \"\",\n\t\t\texpectedError: false,\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\",}`,\n\t\t\texpectedKey:   \"key1\",\n\t\t\texpectedValue: \"value1\",\n\t\t\texpectedError: true, // Additional comma should raise an error\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\":}`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedValue: \"\",\n\t\t\texpectedError: true, // Missing value\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\" \"key3\": \"value3\"}`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedValue: \"\",\n\t\t\texpectedError: true, // Missing comma\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\", \"key2\": \"value2\",}`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedValue: \"\",\n\t\t\texpectedError: true, // Trailing comma\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\":}`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedValue: \"\",\n\t\t\texpectedError: true, // Missing value\n\t\t},\n\t\t{\n\t\t\tinput:         `{\"key1\": \"value1\" \"key2\": \"value2\"}`,\n\t\t\texpectedKey:   \"\",\n\t\t\texpectedValue: \"\",\n\t\t\texpectedError: true, // Missing comma\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\tdepth := 0\n\t\t\tv, remaining, err := parseObject(test.input, c, depth)\n\n\t\t\tif test.expectedError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tassert.Empty(t, remaining)\n\t\t\t\tassert.Nil(t, v)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.NotNil(t, v)\n\t\t\t\tassert.NotEmpty(t, remaining)\n                \n\t\t\t\t// Further checks may be needed based on the actual implementation of the Value and Object types\n\t\t\t\t// The following is highly dependent on how you're exposing the keys and values\n\t\t\t\tobj, _ := v.Object()\n\t\t\t\tassert.Equal(t, test.expectedKey, obj.kvs[0].k)\n\t\t\t\tassert.Equal(t, test.expectedValue, obj.kvs[0].v.String())\n\t\t\t}\n\t\t})\n\t}\n}","fa43a2f1438e1f409b9dcf9d2fc25dc6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value // Expected output structure\n\t\terr      bool   // Indicates if an error is expected\n\t}{\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{/* expected Value struct here */},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{}`,\n\t\t\texpected: \u0026Value{/* expected Value struct for empty object */},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`,\n\t\t\texpected: \u0026Value{/* expected Value struct here for multiple keys */},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\",}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\"}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\": \"value2\", \"key3\": \"value3\"}`,\n\t\t\texpected: \u0026Value{/* expected Value struct for valid cases */},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\", \"key2\": \"value2\", \"key3\": {\"subkey\": \"subvalue\"}}`,\n\t\t\texpected: \u0026Value{/* expected nested Value struct */},\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tc := \u0026cache{} // Initialize a cache\n\t\tresult, remainder, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.err {\n\t\t\tt.Errorf(\"expected error: %v, got: %v\", test.err, err)\n\t\t}\n\n\t\tif err == nil \u0026\u0026 !compareValues(result, test.expected) {\n\t\t\tt.Errorf(\"expected: %+v, got: %+v\", test.expected, result)\n\t\t}\n\n\t\t// You can add further validation for 'remainder' if needed\n\t}\n}\n\n// A utility function to compare Value structs (implementation needed)\nfunc compareValues(a, b *Value) bool {\n\t// Implement your comparison logic for Value structs\n\treturn true\n}","fad2cd55a1437b3ce0da7feb21a2c28c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestValue_MarshalTo(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tvalue    Value\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"Marshal string\",\n\t\t\tvalue: Value{\n\t\t\t\ts: \"Hello, World!\",\n\t\t\t\tt: TypeString,\n\t\t\t},\n\t\t\texpected: `\"Hello, World!\"`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal number\",\n\t\t\tvalue: Value{\n\t\t\t\ts: []byte(\"42\"),\n\t\t\t\tt: TypeNumber,\n\t\t\t},\n\t\t\texpected: \"42\",\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal true\",\n\t\t\tvalue: Value{\n\t\t\t\tt: TypeTrue,\n\t\t\t},\n\t\t\texpected: \"true\",\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal false\",\n\t\t\tvalue: Value{\n\t\t\t\tt: TypeFalse,\n\t\t\t},\n\t\t\texpected: \"false\",\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal null\",\n\t\t\tvalue: Value{\n\t\t\t\tt: TypeNull,\n\t\t\t},\n\t\t\texpected: \"null\",\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal array\",\n\t\t\tvalue: Value{\n\t\t\t\ta: []*Value{\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"item1\",\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ts: \"item2\",\n\t\t\t\t\t\tt: TypeString,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeArray,\n\t\t\t},\n\t\t\texpected: `[\"item1\",\"item2\"]`,\n\t\t},\n\t\t{\n\t\t\tname: \"Marshal object\",\n\t\t\tvalue: Value{\n\t\t\t\to: Object{\n\t\t\t\t\tkvs: []kv{\n\t\t\t\t\t\t{k: \"key1\", v: \u0026Value{s: \"value1\", t: TypeString}},\n\t\t\t\t\t\t{k: \"key2\", v: \u0026Value{s: \"value2\", t: TypeString}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tt: TypeObject,\n\t\t\t},\n\t\t\texpected: `{\"key1\":\"value1\",\"key2\":\"value2\"}`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdst := []byte{}\n\t\t\tgot := tt.value.MarshalTo(dst)\n\t\t\tif string(got) != tt.expected {\n\t\t\t\tt.Errorf(\"MarshalTo() = %s, want %s\", string(got), tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}","fafe949e40ef0e679a1dce9f0ab14244":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseObject(t *testing.T) {\n\tc := \u0026cache{}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\thasError bool\n\t}{\n\t\t{\n\t\t\tinput:    `{}`, // empty object\n\t\t\texpected: \u0026Value{t: TypeObject, o: Object{}},\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`, // simple key-value pair\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value structure to be filled as per implementation\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key1\": \"value1\", \"key2\": \"value2\"}`, // multiple key-value pairs\n\t\t\texpected: \u0026Value{t: TypeObject}, // Expected value structure to be filled as per implementation\n\t\t\thasError: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\": }`, // invalid object (missing value)\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\": \"value\", \"anotherKey\": \"anotherValue\", }`, // trailing comma\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{ \"key\" \"value\"}`, // missing colon\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\" \"key2\": \"value2\"}`, // missing comma\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `}`, // missing opening brace\n\t\t\texpected: nil,\n\t\t\thasError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseObject(test.input, c, 0)\n\n\t\tif (err != nil) != test.hasError {\n\t\t\tt.Errorf(\"parseObject(%q) error = %v, wantError %v\", test.input, err, test.hasError)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !test.hasError \u0026\u0026 result != nil {\n\t\t\t// Add more specific comparisons to check if `result` matches `test.expected`\n\t\t\t// This depends on how Value and Object are structured\n\t\t}\n\t}\n}","fb729c9e664590824f43d00dd4575e18":"package fastjson\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestParseRawString(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpectedValue string\n\t\texpectedRemaining string\n\t\texpectedError error\n\t}{\n\t\t{`\"hello\"`, \"hello\", \"\", nil},\n\t\t{`\"escape\\\"quote\\\"\"`, \"escape\\\"quote\\\"\", \"\", nil},\n\t\t{`\"unmatched`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t\t{`\"escaped\\\\\\\"quote\\\"\"`, \"escaped\\\\\\\"quote\\\"\", \"\", nil},\n\t\t{`\"hello\" extra`, \"hello\", \" extra\", nil},\n\t\t{`\"quote\\\\\"`, \"quote\\\\\", \"\", nil},\n\t\t{`\"double\\\"quoted\\\"text\"`, \"double\\\"quoted\\\"text\", \"\", nil},\n\t\t{`\"nested\\\"string\\\"structure\\\"`, \"\", \"\", fmt.Errorf(`missing closing '\"'`)},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue, remaining, err := parseRawString(test.input)\n\n\t\tif value != test.expectedValue || remaining != test.expectedRemaining || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawString(%q) = (%q, %q, %v); expected (%q, %q, %v)\",\n\t\t\t\ttest.input, value, remaining, err, test.expectedValue, test.expectedRemaining, test.expectedError)\n\t\t}\n\t}\n}","fb7e9ab90d925bed85b64d15b8032d26":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tvar tests = []struct {\n\t\tinput         string\n\t\texpectedError bool\n\t\texpectedLength int\n\t\texpectedTypes  []Type\n\t}{\n\t\t{\n\t\t\tinput:         \"[]\",\n\t\t\texpectedError: false,\n\t\t\texpectedLength: 0,\n\t\t\texpectedTypes:  []Type{},\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3]\",\n\t\t\texpectedError: false,\n\t\t\texpectedLength: 3,\n\t\t\texpectedTypes:  []Type{TypeNumber, TypeNumber, TypeNumber},\n\t\t},\n\t\t{\n\t\t\tinput:         \"[\\\"string\\\", 123, false]\",\n\t\t\texpectedError: false,\n\t\t\texpectedLength: 3,\n\t\t\texpectedTypes:  []Type{TypeString, TypeNumber, TypeFalse},\n\t\t},\n\t\t{\n\t\t\tinput:         \"[,]\",\n\t\t\texpectedError: true,\n\t\t\texpectedLength: 0,\n\t\t\texpectedTypes:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 3,\",\n\t\t\texpectedError: true,\n\t\t\texpectedLength: 0,\n\t\t\texpectedTypes:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[1, 2, 'string']\",\n\t\t\texpectedError: true,\n\t\t\texpectedLength: 0,\n\t\t\texpectedTypes:  nil,\n\t\t},\n\t\t{\n\t\t\tinput:         \"[]\",\n\t\t\texpectedError: false,\n\t\t\texpectedLength: 0,\n\t\t\texpectedTypes:  []Type{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tcache := \u0026cache{}\n\t\tresult, remaining, err := parseArray(test.input, cache, 0)\n\n\t\tif (err != nil) != test.expectedError {\n\t\t\tt.Errorf(\"parseArray(%q) expected error: %v, got: %v\", test.input, test.expectedError, err)\n\t\t}\n\t\tif result != nil {\n\t\t\tif len(result.a) != test.expectedLength {\n\t\t\t\tt.Errorf(\"parseArray(%q) expected length: %d, got: %d\", test.input, test.expectedLength, len(result.a))\n\t\t\t}\n\n\t\t\tfor i, expectedType := range test.expectedTypes {\n\t\t\t\tif i \u003e= len(result.a) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif result.a[i].t != expectedType {\n\t\t\t\t\tt.Errorf(\"parseArray(%q) expected type at index %d: %v, got: %v\", test.input, i, expectedType, result.a[i].t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","fce70cc9e40ba2c400ed89f3e0ba423b":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetInt(t *testing.T) {\n\t// Create test cases\n\ttests := []struct {\n\t\tname         string\n\t\tinputJSON    string\n\t\tkeys         []string\n\t\texpectedInt  int\n\t}{\n\t\t{\n\t\t\tname:         \"existing_key_with_int_value\",\n\t\t\tinputJSON:    `{\"key1\": 123}`,\n\t\t\tkeys:         []string{\"key1\"},\n\t\t\texpectedInt:  123,\n\t\t},\n\t\t{\n\t\t\tname:         \"existing_key_with_float_value\",\n\t\t\tinputJSON:    `{\"key2\": 123.45}`,\n\t\t\tkeys:         []string{\"key2\"},\n\t\t\texpectedInt:  123,\n\t\t},\n\t\t{\n\t\t\tname:         \"non_existent_key\",\n\t\t\tinputJSON:    `{\"key3\": 456}`,\n\t\t\tkeys:         []string{\"key4\"},\n\t\t\texpectedInt:  0,\n\t\t},\n\t\t{\n\t\t\tname:         \"existing_key_with_string_value\",\n\t\t\tinputJSON:    `{\"key5\": \"not_a_number\"}`,\n\t\t\tkeys:         []string{\"key5\"},\n\t\t\texpectedInt:  0,\n\t\t},\n\t\t{\n\t\t\tname:         \"existing_key_with_invalid_value_type\",\n\t\t\tinputJSON:    `{\"key6\": true}`,\n\t\t\tkeys:         []string{\"key6\"},\n\t\t\texpectedInt:  0,\n\t\t},\n\t\t{\n\t\t\tname:         \"nested_key\",\n\t\t\tinputJSON:    `{\"key7\": {\"nestedKey\": 789}}`,\n\t\t\tkeys:         []string{\"key7\", \"nestedKey\"},\n\t\t\texpectedInt:  789,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Parse the input JSON to create a Value\n\t\t\tparser := \u0026Parser{}\n\t\t\tv, err := parser.Parse(tt.inputJSON)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse JSON: %v\", err)\n\t\t\t}\n\n\t\t\t// Call the GetInt function\n\t\t\tresult := v.GetInt(tt.keys...)\n\n\t\t\t// Check the result\n\t\t\tif result != tt.expectedInt {\n\t\t\t\tt.Errorf(\"GetInt(%v) = %d; want %d\", tt.keys, result, tt.expectedInt)\n\t\t\t}\n\t\t})\n\t}\n}","feacaa5e88202caacf33cb33a02608a6":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: typeRawString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"42\",\n\t\t\texpected: \u0026Value{s: \"42\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{ \\\"key\\\": \\\"value\\\" }\",\n\t\t\texpected: /* expected object value */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: /* expected array value */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{\\\"a\\\": null, \\\"b\\\": [true, false]}\",\n\t\t\texpected: /* expected complex object value */,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"{ \\\"missingBracket\\\"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t}\n\n\tc := \u0026cache{vs: make([]Value, 0)}\n\n\tfor _, test := range tests {\n\t\tresult, _, err := parseValue(test.input, c, 0)\n\t\tif test.err {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error for input %q but got none\", test.input)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error for input %q: %s\", test.input, err)\n\t\t\t} else if !compareValues(result, test.expected) {\n\t\t\t\tt.Errorf(\"expected %v but got %v\", test.expected, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc compareValues(v1, v2 *Value) bool {\n\t// Implement deep comparison of Value objects based on their types and values\n\t// This is a placeholder and should include logic for comparing their values.\n\treturn true // Change this line to reflect actual comparison logic\n}","ff29818ed9c5eb2e04b751c3ad5a474c":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseValue(t *testing.T) {\n\tvar c cache\n\n\ttests := []struct {\n\t\tinput    string\n\t\texpected *Value\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"null\",\n\t\t\texpected: valueNull, // assuming valueNull is a predefined Value for JSON null\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"true\",\n\t\t\texpected: valueTrue, // assuming valueTrue is a predefined Value for JSON true\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"false\",\n\t\t\texpected: valueFalse, // assuming valueFalse is a predefined Value for JSON false\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `\"string\"`,\n\t\t\texpected: \u0026Value{s: \"string\", t: TypeString},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"123\",\n\t\t\texpected: \u0026Value{s: \"123\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"[1, 2, 3]\",\n\t\t\texpected: \u0026Value{}, // Placeholder for expected Value, adjust according to the expected structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\": \"value\"}`,\n\t\t\texpected: \u0026Value{}, // Placeholder for expected Value, adjust according to the expected structure\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"nan\",\n\t\t\texpected: \u0026Value{s: \"nan\", t: TypeNumber},\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tinput:    `{\"key\":}`,\n\t\t\texpected: nil,\n\t\t\terr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:    `[[1, 2], [3, 4]]`,\n\t\t\texpected: \u0026Value{}, // Placeholder for expected Value, adjust according to the expected structure\n\t\t\terr:      false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tresult, _, err := parseValue(tt.input, \u0026c, 0)\n\t\tif (err != nil) != tt.err {\n\t\t\tt.Errorf(\"parseValue(%q) returned error: %v, expected error: %v\", tt.input, err != nil, tt.err)\n\t\t}\n\t\tif !tt.err \u0026\u0026 result != nil {\n\t\t\tif *result != *tt.expected {\n\t\t\t\tt.Errorf(\"parseValue(%q) returned %v, expected %v\", tt.input, result, tt.expected)\n\t\t\t}\n\t\t}\n\t}\n}","ff2e64941735c4b5b5fb0f73d2564232":"// file: get_uint_test.go\npackage fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGetUint(t *testing.T) {\n\t// Test case for a valid JSON value with a valid key path\n\tjsonData := `{\"key\": {\"subkey\": 123}}`\n\tv, err := Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t}\n\tresult := v.GetUint(\"key\", \"subkey\")\n\tif result != 123 {\n\t\tt.Errorf(\"expected 123 but got %d\", result)\n\t}\n\n\t// Test case for non-existing key path\n\tresult = v.GetUint(\"key\", \"nonexistent\")\n\tif result != 0 {\n\t\tt.Errorf(\"expected 0 for non-existing path but got %d\", result)\n\t}\n\n\t// Test case for an invalid value type\n\tjsonData = `{\"key\": {\"subkey\": \"not_a_number\"}}`\n\tv, err = Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t}\n\tresult = v.GetUint(\"key\", \"subkey\")\n\tif result != 0 {\n\t\tt.Errorf(\"expected 0 for invalid type but got %d\", result)\n\t}\n\n\t// Test case for array index\n\tjsonData = `{\"key\": [0, 1, 2]}`\n\tv, err = Parse(jsonData)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse JSON: %v\", err)\n\t}\n\tresult = v.GetUint(\"key\", \"1\")\n\tif result != 1 {\n\t\tt.Errorf(\"expected 1 at index 1 but got %d\", result)\n\t}\n\n\t// Test case for invalid array index\n\tresult = v.GetUint(\"key\", \"10\")\n\tif result != 0 {\n\t\tt.Errorf(\"expected 0 for invalid array index but got %d\", result)\n\t}\n}","ff75975ea5cedab01a573834e62bf964":"package fastjson\n\nimport (\n\t\"testing\"\n)\n\nfunc TestParseRawNumber(t *testing.T) {\n\ttests := []struct {\n\t\tinput          string\n\t\texpectedNumber string\n\t\texpectedRest   string\n\t\texpectedError  error\n\t}{\n\t\t{\"123abc\", \"123\", \"abc\", nil},\n\t\t{\"-456.78xyz\", \"-456.78\", \"xyz\", nil},\n\t\t{\"3.14xyz\", \"3.14\", \"xyz\", nil},\n\t\t{\"nan more text\", \"nan\", \" more text\", nil},\n\t\t{\"inf something\", \"inf\", \" something\", nil},\n\t\t{\"invalidChar123\", \"\", \"invalidChar123\", fmt.Errorf(`unexpected char: \"i\"`)},\n\t\t{\"\", \"\", \"\", fmt.Errorf(`unexpected char: \" \"`)},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumber, rest, err := parseRawNumber(test.input)\n\n\t\tif number != test.expectedNumber || rest != test.expectedRest || (err != nil \u0026\u0026 err.Error() != test.expectedError.Error()) {\n\t\t\tt.Errorf(\"parseRawNumber(%q) = (%q, %q, %v); expected (%q, %q, %v)\", test.input, number, rest, err, test.expectedNumber, test.expectedRest, test.expectedError)\n\t\t}\n\t}\n}"}